{"meta":{"title":"CaseZheng","subtitle":"CaseZheng Blog","description":"CaseZheng的博客网站","author":"CaseZheng","url":"http://www.casezheng.date"},"pages":[{"title":"All tags","date":"2017-12-30T07:51:04.000Z","updated":"2020-04-12T04:56:36.251Z","comments":false,"path":"tags/index.html","permalink":"http://www.casezheng.date/tags/index.html","excerpt":"","text":""},{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-12T04:56:36.248Z","comments":false,"path":"categories/index.html","permalink":"http://www.casezheng.date/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-09-11T15:20:38.000Z","updated":"2020-04-12T04:56:36.242Z","comments":false,"path":"about/index.html","permalink":"http://www.casezheng.date/about/index.html","excerpt":"","text":"自我介绍C++后台开发工程师。专注高性能，高可用的后台开发技术。"}],"posts":[{"title":"服务器负载均衡","slug":"load-balance","date":"2019-07-04T12:03:08.000Z","updated":"2019-07-04T12:03:08.000Z","comments":true,"path":"2019/07/04/load-balance/","link":"","permalink":"http://www.casezheng.date/2019/07/04/load-balance/","excerpt":"负载均衡","text":"负载均衡 负载均衡常见方式基于DNS的负载均衡利用域名转化为IP由DNS服务器完成的特点，将一个域名绑定多个IP，DNS服务器按照特定的算法返回其中一个IP给用户，实现服务器集群的负载均衡。 优点: 配置简单，只需要在DNS服务器配置域名和IP的映射 扩展性强，服务器增加只需要增加域名映射的IP 就近访问，可以根据用户的地理位置，选择一个地理位置近的服务器IP 缺点： DNS有缓存机制，服务器故障时由于DNS服务缓存了故障服务器的IP，用户请求时，DNS任然返回故障的服务器IP 缩短IP缓存时间 自建DNS服务器 只能将所有请求平均分配，无法动态的了解每台服务器的负载情况 动态DNS：通过程序动态修改DNS服务器的域名解析，当监控程序发现某台服务器挂掉后，立即通知DNS将其删掉。 七层负载均衡器基于应用层协议中的信息进行负载均衡。代表为Nginx的反向代理负载均衡，性能大致为5万QPS反向代理服务器是一个位于实际服务器的之前的服务器，所有请求都需要经过反向代理服务器，由反向代理服务器判断直接返回结果，或者再请求后端的服务器进行处理，得到处理结果再返回。反向代理服务器也可以承担后盾服务器集群的负载均衡工作，根据特定策略将请求转发到一台后端服务器，处理完毕后将结果再转发给用户。 优点： 隐藏后端服务器。 故障转移，一台后端服务器出现问题，反向代理服务器可以迅速感知，并将其下线。 合理的负载均衡，反向代理服务器可以设定后台服务器的权重，根据权重进行更合理的负载均衡。 缺点： 调度者压力过大，所有请求都要过反向代理服务器，反向代理服务器成为瓶颈 扩展性不足，反向代理服务器的吞吐制约后台服务器的增加 粘滞会话：如果后台服务器是有状态的，那么一个用户的请求应该始终落到该后台服务器 使用唯一标识进行请求的分配，按策略将相同标识的请求分发到同一台后台服务器 在请求中标注要访问的后台服务器，请求时按照标注的后台服务器进行转发 四层负载均衡器基于IP和端口的负载均衡。代表为LVS的VIP（Virtual IP 虚拟IP技术）一般IP和物理网卡是绑定的，VIP则不然，当外网的请求访问该VIP时，VIP不和任何具体的设备相关，而是动态的映射到不同的机器设备上，起到负载均衡的效果。 负载均衡常见算法 随机 加权随机 轮询 加权轮询 键值范围法：按照键的范围进行负载 Hash法：根据键进行哈希，选定一个后台服务器 最小连接数：将请求分发到连接数最少的服务器 最快响应速度：将请求分发到返回响应时间最少的服务器 观察算法：根据连接数和响应速度计算出机器负载，选负载低的一个服务分发请求 预判算法：在观察算法的基础上增加预判算法，预判负载低的一个服务分发请求 一致性Hash参考文档 浅谈负载均衡 高并发解决方案之一 ——负载均衡 LVS原理介绍 负载均衡的基本算法 一篇读懂分布式架构下的负载均衡 深入浅出一致性Hash原理","categories":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}],"tags":[{"name":"负载均衡","slug":"负载均衡","permalink":"http://www.casezheng.date/tags/负载均衡/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}]},{"title":"单元化（SET）架构","slug":"server-set","date":"2019-07-04T07:43:55.000Z","updated":"2019-07-04T07:43:55.000Z","comments":true,"path":"2019/07/04/server-set/","link":"","permalink":"http://www.casezheng.date/2019/07/04/server-set/","excerpt":"什么是单元化单元化是将一个系统的架构按照某种数据特征纬度进行垂直的划分。例如：有100万用户，按用户纬度进行划分，分为10个单元，每个单元存储10万个用户资料。一个单元就是一个能完成所有业务操作的自包含集合，该集合中包含了业务所需的所有服务，以及分配到该单元的数据。","text":"什么是单元化单元化是将一个系统的架构按照某种数据特征纬度进行垂直的划分。例如：有100万用户，按用户纬度进行划分，分为10个单元，每个单元存储10万个用户资料。一个单元就是一个能完成所有业务操作的自包含集合，该集合中包含了业务所需的所有服务，以及分配到该单元的数据。 单元化的好处 每个单元数据规模可控 计算离存储更近 提高资源利用率 动态可伸缩 异地多活 线蓝绿发和线上灰度 故障隔离 单元化的目标 业务，解决业务遇到的扩展性和容灾等需求，支持业务的高速发展 通用性，架构侧形成统一的解决方案，方便各业务线接入 单元化架构原则 对业务透明，对代码业务透明，业务代码不需要关心单元化规则，单元化的部署等问题 单元化划分的规则需要按照业务层面定制，建议优先选最大的业务纬度进行切分 部署规范 单元化架构设计传统服务化架构（SOA），服务是分层的，每层节点数据不定，上层调用下层时随机选择节点。123456789101112131415161718192021222324252627282930313233 |1 2| |3 | | |---------------------------------------------------------------------- |1 2| |3 \\|/ \\|/\\|/ ------ ------ ------ | W1 | | W2 | | W3 | 接口层 ------ ------ ------ | | |---------------------------------------------------------------------- |1 2| |3 --------- | ------- \\|/ | \\|/ ------ | ------ | S1 | ------&gt;| S2 |-------- 业务层 ------ ------ 2| |1 3| |---------------------------------------------------------------------- |1 | | ----------- | | \\|/ | \\|/ ------ -------- | ------ | C1 | | C2 | &lt;-- | C3 | 核心层 ------ -------- ------ 1| |3 |2---------------------------------------------------------------------- 1| |3 | \\|/ \\|/ | ---------- 2 | | DB |&lt;-------------- 数据层 -------------------------------------------------------------------------------- 单元化架构下，服务仍然分层，但每层的任意一个节点都属于且仅数据同一个单元，上层调用下层时仅选项本单元内的节点1234567891011121314151617181920212223242526272829303132333435363738 |1 |2 |3 ---------------------------------------------------------------- | 流量路由 | ---------------------------------------------------------------- |1 |2 |3 ------------------| --------------------- ------------------- | |1 | | |2 | | |3 |--|-----------------|-----|-------------------|------|-----------------|------------ | |1 | | |2 | | |3 | | \\|/ | | \\|/ | | \\|/ | | ------ | | ------ | | ------ | | | W1 | | | | W2 | | | | W3 | | 接口层 | ------ | | ------ | | ------ | | | | | | | | | |--|-----------------|-----|-------------------|------|-----------------|------------ | |1 | | |2 | | |3 | | \\|/ | | \\|/ | | \\|/ | | ------ | | ------ | | ------ | | | S1 | | | | S2 | | | | S3 | | 业务层 | ------ | | ------ | | ------ | | |1 | | |2 | | |3 |--|-----------------|-----|-------------------|------|-----------------|------------ | |1 | | |2 | | |3 | | \\|/ | | \\|/ | | \\|/ | | ------ | | ------ | | ------ | | | C1 | | | | C2 | | | | C3 | | 核心层 | ------ | | ------ | | ------ | | |1 | | |2 | | |3 |--|-----------------|-----|-------------------|------|-----------------|------------ | |1 | | |2 | | |3 | | \\|/ | | \\|/ | | \\|/ | | ------ | | ------ | | ------ | | | D1 | | | | D2 | | | | D3 | | 数据层 | ------ | | ------ | | ------ | | | | | | |--|-----------------|-----|-------------------|------|-----------------|------------ | SET 1 | | SET 2 | | SET 3 | ------------------- --------------------- ------------------- 单元化的系统很容易部署在N个机房12345678910111213141516 | 100% ---------------------------------------- | 流量路由 | ---------------------------------------- |25% |25% |25% |25% | | | |------------------- -------------------| \\|/ \\|/ | | \\|/ \\|/ || ------ ------ | | ------ ------ || | | | | | | | | | | || |SET1| |SET2| | | |SET3| |SET4| || | | | | | | | | | | || ------ ------ | | ------ ------ || | | || IDC 1 | | IDC 2 |------------------- ------------------- 单元化架构必须具备数据分区的能力，每个数据分区决定了各个单元可承担的业务流量比例。数据分区（Shard）：把全局数据按照某个维度水平划分，每个分区的数据互不重叠，即数据库的水平拆分。单元化结构的必要条件：所有业务数据分区所用的拆分维度和拆分规则必须一致。单元化结构的维度选择很重要，该维度应该粒度合适。某个单元中数据分区占数据总量的比例即为该单元承担业务流量的比例。 单元化架构数据的划分支付宝对于单元称为Zone，数据也分为三类 可分区数据（RZone，Region Zone）按照选择好的维度可以真正被单元化的数据。可分区数据在系统链路中应该处于核心位置，单元化建设最重要的目标就是处理该类数据。 全局数据，不被关键链路业务频繁访问（GZone，Global Zone）不能被分区的数据，全局只有一份，可能被关键链接访问，但访问频率低，例如：配置类数据。该类数据无法被分区，也就无法单元化。 全局数据，需要被关键链路业务频繁访问（CZone，City Zone）不能被分区的数据，全局只有一份，频繁被关键链接访问。该类数据在同机房、同城的时候可以通过调用接口的方式获取，但在异地部署的情况下，从A地访问B地的服务，会有很高的延时，在高频率的情况下，系统性能将大大降低。对该类数据的处理，需要将数据本地化，每个城市的数据双向同步。问题在于异地数据同步的延迟问题。 RZone：最符合理论上单元定义的 zone，每个 RZone 都是自包含的，拥有自己的数据，能完成所有业务。GZone：部署不可拆分的数据和服务，数据或服务可能会被RZone依赖。GZone在全局只有一组，数据仅有一份。GZone的数据或服务被RZone访问的频率低。CZone：部署不可拆分的数据和服务，数据或服务可能会被RZone依赖。CZone中的数据或服务会被RZone频繁访问。 参考资料 单元化与分布式架构的切分问题 一个单元化架构的例子 追前沿，领略SET化架构衍化与设计 蚁金服支付宝系统的单元化","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/tags/高性能服务器/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"libmysqlclient 常用api学习","slug":"study-libmysqlclient","date":"2019-06-20T09:58:32.000Z","updated":"2019-06-20T09:58:32.000Z","comments":true,"path":"2019/06/20/study-libmysqlclient/","link":"","permalink":"http://www.casezheng.date/2019/06/20/study-libmysqlclient/","excerpt":"在开始、提交、回滚事务时推荐使用SQL语句START TRANSACTION、COMMIT、ROLLBACK然后执行进行操作，可以统一断线重连的处理逻辑。","text":"在开始、提交、回滚事务时推荐使用SQL语句START TRANSACTION、COMMIT、ROLLBACK然后执行进行操作，可以统一断线重连的处理逻辑。 api使用流程图 mysql_init原型: MYSQL *mysql_init(MYSQL *mysql)描述: 分配或初始化与mysql_real_connect()相适应的MYSQL对象.如果mysql是NULL指针,该函数将分配、初始化、并返回新对象.否则,将初始化对象,并返回对象的地址. 如果mysql_init()分配了新的对象,当调用mysql_close()来关闭连接时.将释放该对象.返回值: 初始化的MYSQL*句柄.如果无足够内存以分配新的对象,返回NULL.错误: 在内存不足的情况下,返回NULL. mysql_close原型: void mysql_close(MYSQL *mysql)描述: 关闭前面打开的连接.如果句柄是由mysql_init()或mysql_connect()自动分配的,mysql_close()还将解除分配由mysql指向的连接句柄.返回值: 无错误: 无 mysql_optionsmysql_real_connect原型: MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)描述: mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接.在执行需要有效MySQL连接句柄结构的任何其他API函数之前,mysql_real_connect()必须成功完成.参数的指定方式如下: * `mysql`应是已有MYSQL结构的地址.调用`mysql_real_connect()`之前,必须调用`mysql_init()`来初始化MYSQL结构.通过`mysql_options()`调用,可更改多种连接选项. * `host`的值必须是主机名或IP地址 * `user`用户的MySQL登录名 * `passwd`用户的密码 * `db`数据库名称 * `port`端口号 * `unix_socket`表示连接类型 * `client_flag`通常为0 返回值: 1. 如果连接成功,返回MYSQL*连接句柄.如果连接失败,返回NULL.对于成功的连接,返回值与第1个参数的值相同. 2. 错误 1. CR_CONN_HOST_ERROR 无法连接到MySQL服务器 2. CR_CONNECTION_ERROR 无法连接到本地MySQL服务器 3. CR_IPSOCK_ERROR 无法创建IP套接字 4. CR_OUT_OF_MEMORY 内存溢出 5. CR_SOCKET_CREATE_ERROR 无法创建Unix套接字 6. CR_UNKNOWN_HOST 无法找到主机名的IP地址 7. CR_VERSION_ERROR 协议不匹配 8. CR_NAMEDPIPEOPEN_ERROR 无法在Windows平台下创建命名管道 9. CR_NAMEDPIPEWAIT_ERROR 在Windows平台下等待命名管道失败 10. CR_NAMEDPIPESETSTATE_ERROR 在Windows平台下获取管道处理程序失败 11. CR_SERVER_LOST 如果`connect_timeout&gt;0`,而且在连接服务器时所用时间长于`connect_timeout`秒,或在执行init-command时服务器消失. mysql_real_query原型: int mysql_real_query(MYSQL *mysql, const char *query, unsigned long length)描述: 执行由query指向的SQL查询,length是字符串query的长度返回值: 如果查询成功,返回0.如果出现错误,返回非0值.错误: CR_COMMANDS_OUT_OF_SYNC 以不恰当的顺序执行了命令 CR_SERVER_GONE_ERROR MySQL服务器不可用 CR_SERVER_LOST 在查询过程中,与服务器的连接丢失 CR_UNKNOWN_ERROR 出现未知错误 mysql_store_result原型: MYSQL_RES *mysql_store_result(MYSQL *mysql)描述: 对于成功检索了数据的每个查询(SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等),必须调用mysql_store_result()或mysql_use_result()获得返回结果集.mysql_store_result()将查询的全部结果读取到客户端,分配1个MYSQL_RES结构,并将结果置于该结构中.如果未返回行,将返回空的结果集.(空结果集设置不同于作为返回值的空指针)返回值: 具有多个结果的MYSQL_RES结果集合.如果出现错误,返回NULL.错误: 成功,mysql_store_result()将复位mysql_error()和mysql_errno() 错误: CR_COMMANDS_OUT_OF_SYNC 以不恰当的顺序执行了命令 CR_OUT_OF_MEMORY 内存溢出 CR_SERVER_GONE_ERROR MySQL服务器不可用 CR_SERVER_LOST 在查询过程中,与服务器的连接丢失 CR_UNKNOWN_ERROR 出现未知错误 mysql_free_result原型: void mysql_free_result(MYSQL_RES *result)描述: 释放由mysql_store_result()、mysql_use_result()、mysql_list_dbs()等为结果集分配的内存.完成对结果集的操作后,必须调用mysql_free_result()释放结果集使用的内存.释放完成后,不要尝试访问结果集.返回值: 无错误: 无 mysql_field_count原型: unsigned int mysql_field_count(MYSQL *mysql)描述: 返回作用在连接上的最近一次查询结果集的列数.返回值: 表示结果集中列数的无符号整数.错误: 无. mysql_num_fields原型: unsigned int mysql_num_fields(MYSQL_RES *result)描述: 返回结果集中的列数.返回值: 表示结果集中列数的无符号整数.错误: 无 mysql_fetch_fields原型: MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)描述: 对于结果集,返回所有MYSQL_FIELD结构的数组.每个结构提供了结果集中列的字段定义.返回值: 关于结果集所有列的MYSQL_FIELD结构的数组.错误: 无 mysql_num_rows原型: my_ulonglong mysql_num_rows(MYSQL_RES *result)m描述: 返回结果集中的行数.返回值: 结果集中的行数.错误: 无. mysql_data_seek原型: void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)描述: 在查询结果集中寻找任意行.偏移值为行号,范围从0到mysql_num_rows(result)-1.该函数要求结果集结构包含查询的所有结果,因此,mysql_data_seek()仅应与mysql_store_result()联合使用,而不是与mysql_use_result()联合使用.返回值: 无错误: 无 mysql_fetch_row原型: MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)描述: 检索结果集的下一行.在mysql_store_result()之后使用时,如果没有要检索的行,mysql_fetch_row()返回NULL;在mysql_use_result()之后使用时,如果没有要检索的行或出现了错误,mysql_fetch_row()返回NULL.行内值的数目由mysql_num_fields(result)给出.如果行中保存了调用mysql_fetch_row()返回的值,将按照row[0]到row[mysql_num_fields(result)-1],访问这些值的指针.行中的NULL值由NULL指针指明.可以通过调用mysql_fetch_lengths()来获得行中字段值的长度.对于空字段以及包含NULL的字段,长度为0.通过检查字段值的指针,能够区分它们.如果指针为NULL,字段为NULL,否则字段为空.返回值: 下一行的MYSQL_ROW结构.如果没有更多要检索的行或出现了错误,返回NULL.错误: 注意,在对mysql_fetch_row()的两次调用之间,不会复位错误. CR_SERVER_LOST 在查询过程中,与服务器的连接丢失 CR_UNKNOWN_ERROR 出现未知错误 mysql_use_result原型: MYSQL_RES *mysql_use_result(MYSQL *mysql)描述: 对于成功检索数据的每个查询(SELECT、SHOW、DESCRIBE、EXPLAIN),必须调用mysql_store_result()或mysql_use_result().mysql_use_result()将初始化结果集检索,然后必须通过对mysql_fetch_row()的调用,对每一行分别进行检索.将直接从服务器读取结果,而不会将其保存在临时表或本地缓冲区内.使用mysql_use_result()时,必须执行mysql_fetch_row(),直至返回NULL值,否则,未获取的行将作为下一个检索的一部分返回.C API给出命令不同步错误,如果忘记了执行该操作,将不能运行该命令.不应与从mysql_use_result()返回的结果一起使用mysql_data_seek()、mysql_row_seek()、mysql_row_tell()、mysql_num_rows()或mysql_affected_rows(),也不应发出其他查询,直至mysql_use_result()完成为止,当提取了所有行后,mysql_num_rows()将准确返回提取的行数.一旦完成了对结果集的操作,必须调用mysql_free_result()返回值: MYSQL_RES结果结构.如果出现错误,返回NULL.错误: 如果成功,mysql_use_result()将复位mysql_error()和mysql_errno(). 错误: CR_COMMANDS_OUT_OF_SYNC 以不恰当的顺序执行了命令. CR_OUT_OF_MEMORY 内存溢出. CR_SERVER_GONE_ERROR MySQL服务器不可用. CR_SERVER_LOST 在查询过程中,与服务器的连接丢失. CR_UNKNOWN_ERROR 出现未知错误. mysql_fetch_lengths原型: unsigned long *mysql_fetch_lengths(MYSQL_RES *result)描述: 返回结果集内当前行的列的长度(避免strlen()的调用,提高效率; 确定二进制数据长度). 对于空列以及包含NULL值的列,其长度为0.返回值: 无符号长整数的数组表示各列的大小(不包括任何终结NULL字符).如果出现错误,返回NULL.错误: mysql_fetch_lengths()仅对结果集的当前行有效.如果在调用mysql_fetch_row()之前或检索了结果集中的所有行后调用了它,将返回NULL. mysql_affected_rows原型: my_ulonglong mysql_affected_rows(MYSQL *mysql)描述: 返回上次UPDATE更改的行数或上次DELETE删除的行数或上次INSERT语句插入的行数.对于UPDATE、DELETE或INSERT语句,可在mysql_query()后立刻调用.返回值: 大于0的整数表明受影响或检索的行数.”0”表示UPDATE语句未更新记录,在查询中没有与WHERE匹配的行,或未执行查询.错误: 无 mysql_autocommit原型: my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)描述: 如果模式为1,启用autocommit模式;如果模式为0,禁止autocommit模式.返回值: 如果成功,返回0;如果出现错误,返回非0值.错误: 无 mysql_commit原型: my_bool mysql_commit(MYSQL *mysql)描述: 提交当前事务.返回值: 如果成功,返回0;如果出现错误,返回非0值.错误: 无 mysql_rollback原型: my_bool mysql_rollback(MYSQL *mysql)描述: 回滚当前事务返回值: 如果成功,返回0;如果出现错误,返回非0值.错误: 无 mysql_real_escape_string原型: unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)描述: 该函数用于创建可在SQL语句中使用的合法SQL字符串.按照连接的当前字符集,将from中的字符串编码为转义SQL字符串.将结果置于to中,并添加1个终结用Null字符.返回值: 置于to中的值的长度,不包括终结用Null字符.错误: 无. mysql_errno原型: unsigned int mysql_errno(MYSQL *mysql)描述: 对于由mysql指定的连接,mysql_errno()返回最近调用的API函数的错误代码,该函数调用可能成功也可能失败.0返回值表示未出现错误.返回值: 如果失败,返回上次mysql_xxx()调用的错误代码.0表示未出现错误错误: 无 mysql_error原型: const char *mysql_error(MYSQL *mysql)描述: 对于由mysql指定的连接,对于失败的最近调用的API函数,mysql_error()返回包含错误消息的、由Null终结的字符串.如果该函数未失败,mysql_error()的返回值可能是以前的错误,或指明无错误的空字符串.返回值: 返回描述错误的、由Null终结的字符串.如果未出现错误,返回空字符串.错误: 无.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL InnoDB存储引擎学习","slug":"study-mysql-innodb","date":"2019-06-18T15:20:54.000Z","updated":"2019-06-18T15:20:54.000Z","comments":true,"path":"2019/06/18/study-mysql-innodb/","link":"","permalink":"http://www.casezheng.date/2019/06/18/study-mysql-innodb/","excerpt":"数据库:物理操作系统文件或其它形式文件类型的集合.数据库实例:由数据库后台进程/线程以及一个共享内存区组成.数据库实例才是真正用来操作数据库文件的.","text":"数据库:物理操作系统文件或其它形式文件类型的集合.数据库实例:由数据库后台进程/线程以及一个共享内存区组成.数据库实例才是真正用来操作数据库文件的. MySQL数据库架构InnoDB存储引擎介绍MySQL5.5.5后默认的存储引擎 InnoDB内存InnoDB存储引擎内存: 缓冲池(buffer pool) 索引页 数据页 undo页 插入缓存(insert buffer) 自适应哈希索引(adaptive hash index) InnoDB存储的锁信息(lock info) 数据字典信息(data dictionary) 重做日志缓冲池(redo log buffer) 额外内存池(additional memory pool) 缓冲池是占用内存最多的部分,用来存放各种数据的缓存.InnoDB将数据库文件按页读取到缓冲池,再按最近最少使用(LRU)算法保留缓冲区的缓存数据.数据库的修改总是先修改缓冲池中的页,修改完后该页即为脏页,再按一定频率将脏页刷新到文件中.重做日志缓存将重做日志信息放在该缓存区,按照一定频率将其刷新到重做日志文件. 查看内存池配置大小123456789101112131415161718192021mysql&gt; show variables like 'innodb_buffer_pool_size';+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.00 sec)mysql&gt; show variables like 'innodb_log_buffer_size';+------------------------+---------+| Variable_name | Value |+------------------------+---------+| innodb_log_buffer_size | 8388608 |+------------------------+---------+1 row in set (0.00 sec)mysql&gt; show variables like 'innodb_additional_mem_pool_size';+---------------------------------+---------+| Variable_name | Value |+---------------------------------+---------+| innodb_additional_mem_pool_size | 8388608 |+---------------------------------+---------+1 row in set (0.00 sec) 通过show engine innodb status\\G查看缓冲池的使用情况(并不是实时的,而是过去某段时间的)12345678910111213141516171819202122232425mysql&gt; show engine innodb status\\G... ...Per second averages calculated from the last 52 seconds 过去53秒内的数据库状态... ...----------------------BUFFER POOL AND MEMORY----------------------Total memory allocated 137363456; in additional pool allocated 0Dictionary memory allocated 21773263Buffer pool size 8192 缓冲帧(buffer frame) 每个buffer frame为16KFree buffers 0 当前空闲的buffer frameDatabase pages 8151 已经使用的缓冲帧Old database pages 2988Modified db pages 0 脏页的数量Pending reads 0Pending writes: LRU 0, flush list 0, single page 0Pages made young 9725418, not young 00.00 youngs/s, 0.00 non-youngs/sPages read 6612986, created 56449, written 6242950.00 reads/s, 0.00 creates/s, 0.00 writes/sBuffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 8151, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0]... ... InnoDB线程InnoDB采用多线程模型.默认情况下,InnoDB存储引擎的后台线程有四类:若干IO Thread, 一个Master Thread, 一个Lock监控线程, 一个错误监控线程.可以通过show engine innodb status\\G查看InnoDB的线程状态1234567891011121314151617181920212223mysql&gt; show engine innodb status\\G*************************** 1. row ***************************... ...--------FILE I/O--------I/O thread 0 state: waiting for completed aio requests (insert buffer thread)I/O thread 1 state: waiting for completed aio requests (log thread)I/O thread 2 state: waiting for completed aio requests (read thread)I/O thread 3 state: waiting for completed aio requests (read thread)I/O thread 4 state: waiting for completed aio requests (read thread)I/O thread 5 state: waiting for completed aio requests (read thread)I/O thread 6 state: waiting for completed aio requests (write thread)I/O thread 7 state: waiting for completed aio requests (write thread)I/O thread 8 state: waiting for completed aio requests (write thread)I/O thread 9 state: waiting for completed aio requests (write thread)Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] , ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0Pending flushes (fsync) log: 0; buffer pool: 06614275 OS file reads, 661776 OS file writes, 44313 OS fsyncs0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s-------------------------------------... ... IO Thread分为insert buffer thread、log thread、read thread、write thread Master Thread将缓冲池的数据异步刷新到磁盘,保证数据一致性(刷新脏页、合并插入缓存、undo页回收) 123456mysql&gt; show engine innodb status\\G*************************** 1. row ***************************... ...srv_master_thread loops: 2084267 1_second, 2084267 sleeps, 190202 10_second, 182347 background, 182347 flushsrv_master_thread log flush and writes: 2082683... ... IO Thread负责IO请求的回调处理 Purge Thread事物提交后的undo log不再需要,由Purge Thread负责回收已经使用并分配的undo page Page Cleaner Thread在InnoDB 1.2.x版本引入,将脏页的刷新操作放在这个线程中进行处理,减轻Master Thread的工作,减少用户查询线程的阻塞,提高InnoDB的性能 InnoDB关键特性插入缓存提高性能,两次写提高可靠性 插入缓存主键是行唯一的标识符,应用程序中行记录的插入一般是按照主键递增的顺序进行插入,因此,插入聚集索引一般是顺序的,不需要磁盘的随机读取,可以很快完成,但表上可能会同时存在多个非聚集索引非唯一的索引,在插入时数据页的存放按照主键的递增顺序存放,但对于非聚集索引,叶子节点的插入可能不再是顺序的,需要离散的访问非聚集索引页,插入性能降低.InnoDB使用插入缓存的方式,对非聚集索引的插入或更新操作,不是每一次直接插入索引页,而是先判断非聚集索引页是否在缓存池中,如果在,直接插入,如果不在先放入一个插入缓冲区,再以一定频率执行插入缓冲和非聚集索引页子几点的合并操作.插入缓存的使用需满足两个条件: 索引是非聚集索引 索引不是唯一索引 12345678910mysql&gt; show engine innodb status\\G... ...INSERT BUFFER AND ADAPTIVE HASH INDEX-------------------------------------Ibuf: size 1, free list len 5, seg size 7, 201 mergesmerged operations: insert 1846, delete mark 2126, delete 0discarded operations: insert 0, delete mark 0, delete 0... ... 两次写当数据库宕机时,可能发生数据库正在写一个页面,而该页面只写了一部分(比如16K,只写了前4K的情况),称为部分写失效发生写失效时,需要通过这个页的副本来还原该页,再进行重做. 自适应哈希索引当InnoDB注意到索引值使用非常频繁便会自动在内存中再建立一个哈希索引12345mysql&gt; show engine innodb status\\G... ...Hash table size 276707, node heap has 41 buffer(s)0.00 hash searches/s, 0.00 non-hash searches/s... ... 数据库和表的建立1234567891011121314151617181920CREATE DATABASE case_test_db;USE case_test_db;CREATE TABLE t_user( Fid int PRIMARY KEY COMMENT '用户ID', Fname VARCHAR(255) NOT NULL COMMENT '姓名', Famount bigint NOT NULL DEFAULT 0 COMMENT '金额', Fcreate_time DATETIME NOT NULL COMMENT '创建时间', Fmodify_time DATETIME NOT NULL COMMENT '修改时间', INDEX idx_mdftime(Fmodify_time)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表' ;INSERT INTO t_user (Fid, Fname, Famount, Fcreate_time, Fmodify_time)VALUES(10000, \"用户1\", 0, \"2019-06-18 15:55:00\", \"2019-06-18 15:55:00\"), (10001, \"用户2\", 0, \"2019-06-18 15:55:04\", \"2019-06-18 15:55:04\"), (10002, \"用户3\", 0, \"2019-06-18 15:55:05\", \"2019-06-18 15:55:05\");SELECT Fid, Fname, Famount, Fcreate_time, Fmodify_time FROM case_test_db.t_user; 索引索引使用B+树或哈希表建立.InnoDB不能显式的指定哈希索引,InnoDB引擎自适应哈希索引,哈希索引只适用于字典查找,如SELECT Famount FROM t_user WHERE Fid=10001;. 聚集索引InnoDB存储引擎类型的表,表中数据按照主键顺序存放.聚集索引就是按照表的主键构建一颗B+树,并在叶子节点存放行的全部数据.InnoDB存储引起类型的表,有且仅有一个聚齐索引.当使用聚齐索引对表中数据进行检索时,可以直接获得聚集索引所对应的整条行记录数据所在的页. 非聚齐索引(辅助聚集索引)非聚齐索引叶子节点不包含行的全部数据,只包含一个用于查找行数据的书签,在InnoDB中这个标签就是数据行的主键,因此通过非聚齐索引只能查找到数据行的主键,再通过主键查找数据行所在的数据页,比聚集索引多了一次操作. 按功能的索引 普通索引 最基础的索引类型 唯一索引 在普通索引的基础上加入唯一性限制,索引列的所有值只能出现一次 全文索引 MySQL 5.6.24在InnoDB加入全文索引,但对中文支持不友好,MySQL 5.7.6提供支持中文的内置的ngram解析器 空间索引 MySQL 5.7开始支持空间索引 事务事务的属性(ACID) 原子性(Atomic) 一个事务中的SQL,要么全部成功,要么全部失败,不存在部分成功的情况 一致性(Consistency) 一个事务使系统从一个一致状态转移到另外一个一致状态 隔离性(Isolation) 并发事务互相影响的程度 持久性(Durability) 一旦事务提交,对数据的修改是永久的,及时系统故障也不会数据丢失 隔离性事务并发存在的问题数据库测试前,将两个Serssion的隔离级别置为Read Uncommitted1set tx_isolation = 'read-uncommitted'; 更新丢失(Lost Update)同时有两个事务对同一条数据库记录进行操作,事务A读取数据库数据后,数据被事务B进行了更新,事务A基于最初读取的值进行运算并将运算结果写回到数据库,导致事务B的更新被覆盖,导致更新丢失的问题 事务A 事务B START TRANSACTION; START TRANSACTION; SELECT Famount FROM t_user WHERE Fid=10001; 值为0 SELECT Famount FROM t_user WHERE Fid=10001; 值为0 运算 对Famount加100 UPDATE t_user SET Famount=1 WHERE Fid=10001; 对Famount加1 UPDATE t_user SET Famount=100 WHERE Fid=10001; COMMIT; COMMIT; - SELECT Famount FROM t_user WHERE Fid=10001; 值为100 SELECT Famount FROM t_user WHERE Fid=10001; 值为100 脏读(Dirty Reads)事务A在事务的过程中修改了一条记录,在A提交前,该记录处于中间状态,如果事务B访问该记录,读到了这个中间状态,可能出现数据不一致的状态,叫做脏读. 事务A 事务B START TRANSACTION; - SELECT Famount FROM t_user WHERE Fid=10001; 值为100 - 运算 对Famount加100 - UPDATE t_user SET Famount=200 WHERE Fid=10001; START TRANSACTION; 运算 对Famount再加100 SELECT Famount FROM t_user WHERE Fid=10001; 此时读到事务AFamount字段的中间状态200 UPDATE t_user SET Famount=300 WHERE Fid=10001; 运算 对Famount加20 COMMIT; UPDATE t_user SET Famount=220 WHERE Fid=10001; - COMMIT; SELECT Famount FROM t_user WHERE Fid=10001; 值为220 SELECT Famount FROM t_user WHERE Fid=10001; 值为220 使用InnoDB引擎避免脏读 通过共享锁或排他锁避免脏读,对于所有更新操作,在读取数据库记录前都获得该记录的排他锁获取共享锁 通过InnoDB的事务隔离级别避免脏读 不可重复读(Non-Repeatable Reads)事务A读取某条记录后,记录被事务B进行修改,事务A再次读取该记录,该记录的数据和事务A初次读取的记录不一致. 事务A 事务B START TRANSACTION; - SELECT Famount FROM t_user WHERE Fid=10001; 值为220 START TRANSACTION; - UPDATE t_user SET Famount=100 WHERE Fid=10001; - COMMIT; SELECT Famount FROM t_user WHERE Fid=10001; 值为100 - 读取到的数据和初次读取的数据不一致 - ROLLBACK; - 和脏读的区别:脏读是读到事务中间过程的临时数据,可能会被事务再次修改或回滚.不可重复读是由于两个读取时间点的间隙,数据被其它事务修改而导致的数据不一致.可以通过设置InnoDB的事务隔离级别避免不可重复读 幻读(Phantom Reads)幻读发生在多条记录的查询中.当事务A用同样的查询条件读取之间某个时间点查询过的数据时,读取到了被其它事务在其两次读取中间插入的新数据(或者少了被其它事务删除的记录).称为幻读幻读和不可重复读本质一样,都是在两次读取间隙由于其它事务的操作导致的记录数据变更,区别在于不可重复度针对单条记录,幻读针对一个结果集而言. 事务A 事务B START TRANSACTION; - SELECT Fid FROM t_user WHERE Fid&gt;10001; 读到10002 START TRANSACTION; - INSERT INTO t_user (Fid, Fname, Famount, Fcreate_time, Fmodify_time) VALUES(10003, &quot;用户4&quot;, 0, &quot;2019-06-18 15:55:00&quot;, &quot;2019-06-18 15:55:00&quot;); - COMMIT; SELECT Fid FROM t_user WHERE Fid&gt;10001; 读到10002、10003 读取到的结果集和初次读取的结果集不一致 - ROLLBACK; - 隔离级别事务并发问题不能单靠数据库事务控制来解决,需要结合InnoDB的锁机制来解决.防止出现事务并发问题是应用层需要解决的问题,不能单靠事务机制更新丢失需要完全避免,更新丢失会导致严重的数据不一致性,数据库记录表现出随机性、不可预测性脏读、不可重复读、幻读是数据库读一致性问题,需要由数据库提供一定的事务隔离机制解决.数据库实现事务隔离的方式: 读取数据前对数据加锁,阻止其它事务对其进行修改 通过数据库机制生成一个时间点的一致性数据快照,从用户角度看,数据库提供了一个数据的多个版本,数据库多版本并发控制(MultiVersion Concurrency Control)或多版本数据库 隔离级别 读一致性 脏读 不可重复读 幻读 读加锁 未提交读(Read Uncommitted) 最低级别 是 是 是 否 已提交读(Read Committed) 语句级别 否 是 是 否 可重复读(Repeatable Read) 事务级别 否 否 是 否 串行化(Serializable) 最高级别,事务级 否 否 否 是 未提交读(Read Uncommitted)最低的事务隔离级别,事务B可能读取到事务A未提交的中间状态数据 已提交读(Read Committed)事务B可能读取到事务开始时到读取操作点之间被事务A提交的修改可避免脏读的发生 可重复读(Repeatable Read)MySQL InnoDB的默认隔离模式,事务B只能读到事务开始时的数据,及时数据已经被事务A修改可避免脏读和不可重复读 串行化(Serializable)最高的事务隔离级别,避免脏读、不可重复读、幻读. 如下示例演示在不同隔离级别下,事务A读到Famount的值的不同 事务A 事务B 未提交读 已提交读 可重复读 串行化 START TRANSACTION; START TRANSACTION; - - - - SELECT Famount FROM t_user WHERE Fid=10001; - 100 100 100 100 - UPDATE t_user SET Famount=200 WHERE Fid=10001; - - - - SELECT Famount FROM t_user WHERE Fid=10001; - 200 100 100 100 - COMMIT; - - - - SELECT Famount FROM t_user WHERE Fid=10001; - 200 200 100 100 COMMIT; - - - - - SELECT Famount FROM t_user WHERE Fid=10001; - 200 200 200 200 隔离级别为串行化时,事务B执行UPDATE操作的时候,提交事务会被锁住,直到事务A提交后,事务B才可以继续进行. 读未提交:别人改数据的事务尚未提交,我在我的事务中也能读到.读已提交:别人改数据的事务已经提交,我在我的事务中才能读到.可重复读:别人改数据的事务已经提交,我在我的事务中也不去读.串行:我的事务尚未提交,别人就别想改数据.四种隔离级别,并行性能依次降低,安全性依次提高 隔离级别的实现隔离级别是通过视图(read-view)来实现的并发版本控制(MVCC),不同隔离级别创建视图的时间点不同. 未提交读 不创建视图,直接返回记录上的最新值 已提交读 给每条SQL创建视图,在每个SQL语句开始执行时创建视图,隔离作用域仅限该条SQL. 可重复读 每个事务创建一个视图,整个事务存在期间都用该视图 串行化 直接加锁,不创建视图视图可以理解为数据副本,每次创建视图时,将当前已持久化数据创建副本,后续直接从副本读取,达到数据隔离效果. InnoDB隔离级别的查看/修改 隔离级别的查看 1234567mysql&gt; select @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec) 隔离级别的设置 全局 修改配置文件,重启数据库 set global transaction isolation level repeatable read; 当前Session set tx_isolation = &#39;repeatable-read&#39;; set session transaction isolation level repeatable read; 下一个事务set transaction isolation level repeatable read; 事务控制1234START TRANSACTION | BEGIN [WORK]COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]SET AUTOCOMMIT = &#123;0 | 1&#125; 在InnoDB中,任何SQL语句都在一个事务当中. 如果在没有显式的调用开始事务的命令,MySQL会自动加上开始事务命令,再执行SQL语句.MySQL默认使用自动提交模式,即一条SQL语句执行完毕,自动COMMIT.当MySQL显式执行开始事务的命令后,会自动设置为非自动提交模式,ROLLBACK或COMMENT后恢复到START TRANSACTION之前的事务提交模式. 事务的开始当执行START TRANSACTION;或BEGIN;后事务并没有真正的开始,当事务真正的执行操作后才会生成事务ID,事务才真正开始.如果想START TRANSACTION;后就真正开启事务,需要以START TRANSACTION WITH CONSISTENT SNAPSHOT;开始事务 数据库测试前,将两个Serssion的隔离级别置为Repeatable Read, set tx_isolation = &#39;repeatable-read&#39;; 事务A 事务B SELECT Famount FROM t_user WHERE Fid=10001; 值为200 - START TRANSACTION; START TRANSACTION; - UPDATE t_user SET Famount=300 WHERE Fid=10001; - COMMIT; SELECT Famount FROM t_user WHERE Fid=10001; 值为300 - COMMIT; - 复原Famount的值为200UPDATE t_user SET Famount=200 WHERE Fid=10001; 事务A 事务B SELECT Famount FROM t_user WHERE Fid=10001; 值为200 - START TRANSACTION WITH CONSISTENT SNAPSHOT; START TRANSACTION; - UPDATE t_user SET Famount=300 WHERE Fid=10001; - COMMIT; SELECT Famount FROM t_user WHERE Fid=10001; 值为200 - COMMIT; - 事务的实现事务的隔离性由锁和MVCC实现,原子性、一致性、持久性通过数据库的redo和undo来完成. redo在InnoDB存储引擎中,事务日志通过重做(redo)日志文件和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)来实现.当开始一个事务时,会记录该事务的LSN(Log Sequence Number, 日志序列号);当事务执行时,会往InnoDB存储引擎的日志缓冲里插入事务日志;当事务提交时,必须将InnoDB存储引擎的日志缓冲写入磁盘.即写数据前,需要先写日志,称为预写日志方式(Write-Ahead Logging, WAL).InnoDB通过WAL方式保证事务的完整性,导致磁盘存储的数据页和内存缓冲池中的页不同步,对于内存缓冲池中页的修改,先是写入重做日志文件,然后再写入磁盘.12345678910111213mysql&gt; show engine innodb status\\G... ...---LOG---Log sequence number 592623868976 当前LSNLog flushed up to 592623868976 刷新到重做日志文件的LSNLast checkpoint at 592623868976 刷新到磁盘的LSN0 pending log writes, 0 pending chkp writes19876 log i/o's done, 0.00 log i/o's/second----------------------... ... undo事务的撤销使用undo,undo存放在数据库内部的一个特殊段中,称为undo段(undo segment),undo段存放在共享表空间中.数据库undo只是进行逻辑上的恢复,恢复后的数据结构可能可原先不同. 锁乐观锁:总认为没有别人会对资源进行修改,当回写时再对初次拿到的资源和当前资源进行判断,如果没有发生变化就写回,否则进行重试,整个过程并没有对数据加锁.悲观锁:在获取资源前对资源加锁,确保同一时刻只有有限的线程可以访问该资源,其它想获取改资源的操作进入等待状态,直到该进程完成对资源的操作并释放锁,其它线程再重新争夺锁. InnoDB使用的都是悲观锁 锁的种类对数据的操作包括读和写,InnoDB实现锁时,对读和写使用不同的锁.InnoDB实现了标准的行级锁,即共享锁(Shared Lock)和互斥锁(Exclusive Lock). 共享锁(读锁 S Lock):允许事务对一条数据进行读取. 互斥锁(写锁 X Lock):允许事务对一条数据进行删除/更新. 锁的粒度InnoDB除了支持行锁,还支持表锁,称为意向锁(Intention Lock).意向锁针对读和写也分为两种: 意向共享锁(IS Lock):事务想要获得一个表中某几行的共享锁 意向排他锁(IX Lock):事务想要获得一个表中某几行的互斥锁由于InnoDB支持行锁,所以意向锁并不会阻塞除全表扫之外的任何请求,意向锁主要是为了表示有人请求锁定表中的某一行数据. 单单使用行锁,一个请求对全表进行操作时需要判断表中所有行的锁定状态,效率太差.引入意向锁后,当有人使用行锁对表中某行进行修改前,先对表添加意向锁互斥锁(IX),在对记录添加互斥锁(X),当有人对全表进行操作时,不需要再判断表中所有行的锁定状态,只需要等待意向锁被释放即可. 锁的兼容 - IS Lock IX Lock S Lock X Lock IS Lock √ √ √ × IX Lock √ √ × × S Lock √ × √ × X Lock × × × × 锁的算法InnoDB的锁实际上是对索引进行加锁.InnoDB的三种锁的算法设计: Record Lock(记录锁): 单个行记录上的锁 Gap Lock(间隙锁): 锁定一个范围,但不包含记录本身 间隙锁也分为共享锁和互斥锁,但间隙共享锁和间隙互斥锁并不互斥,不同的事务可以同时持有一段相同范围的共享锁和互斥锁,唯一阻止的是其它事务在范围中添加/删除纪录 Next-Key Lock(): Gap Lock + Record Lock,锁定一个范围,并且锁定记录本身 加锁语句 LOCK IN SHARED MODE用于给记录加共享锁 FOR UPDATE用于给记录加互斥锁 不同SQL语句在各种隔离级别下的锁方式 - 条件 未提交读 已提交读 可重复读 串行化 SELECT 唯一索引 不加锁 一致性读 一致性读 共享锁 SELECT 范围索引 不加锁 一致性读 一致性读 间隙共享锁 UPDATE 唯一索引 互斥锁 互斥锁 互斥锁 互斥锁 UPDATE 范围索引 互斥锁 间隙互斥锁 间隙互斥锁 间隙互斥锁 INSERT - 互斥锁 互斥锁 互斥锁 互斥锁 REPLACE 无键冲突 互斥锁 互斥锁 互斥锁 互斥锁 REPLACE 键冲突 间隙互斥锁 间隙互斥锁 间隙互斥锁 间隙互斥锁 DELETE 唯一索引 互斥锁 互斥锁 互斥锁 互斥锁 DELETE 范围索引 间隙互斥锁 间隙互斥锁 间隙互斥锁 间隙互斥锁 SELECT LOCK IN SHARE MODE 唯一索引 共享锁 共享锁 共享锁 共享锁 SELECT LOCK IN SHARE MODE 范围索引 共享锁 共享锁 间隙共享锁 间隙共享锁 SELECT FOR UPDATE 唯一索引 互斥锁 互斥锁 互斥锁 互斥锁 SELECT FOR UPDATE 范围索引 互斥锁 共享锁 间隙互斥锁 间隙互斥锁 死锁两个或多个事务在同一资源上相互占用,并请求锁定对方占用的资源.InnoDB有一个专门的锁监控线程,该线程负责查看可能的死锁问题,并自动告知用户.InnoDB在发现死锁后,会马上回滚一个事务(持有最少行级互斥锁的事务),该事物其占用的资源被释放,另一个事务即可获得该资源,并继续向下执行.死锁的四个必要条件:互斥,不可剥夺,请求和保持,循环等待 事务A 事务B START TRANSACTION; START TRANSACTION; SELECT Famount FROM t_user WHERE Fid=10001 FOR UPDATE; - SELECT Famount FROM t_user WHERE Fid=10002 FOR UPDATE; SELECT Famount FROM t_user WHERE Fid=10002 FOR UPDATE; 阻塞 等待10002的释放 - - SELECT Famount FROM t_user WHERE Fid=10001 FOR UPDATE; 得到10002的锁 执行完毕 发现死锁 自动回滚该事务ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction COMMIT; - 参考资料 MySQL技术内幕InnoDB存储引擎 这一次，带你搞清楚MySQL的事务隔离级别！ 『浅入浅出』MySQL 和 InnoDB MySQL InnoDB 索引原理 第一章、MySQL架构及历史","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"},{"name":"innodb","slug":"innodb","permalink":"http://www.casezheng.date/tags/innodb/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"jsoncpp Reader::parse线程不安全","slug":"thread-unsafe-jsoncpp-reader-parse","date":"2019-06-05T10:00:53.000Z","updated":"2019-06-05T10:00:53.000Z","comments":true,"path":"2019/06/05/thread-unsafe-jsoncpp-reader-parse/","link":"","permalink":"http://www.casezheng.date/2019/06/05/thread-unsafe-jsoncpp-reader-parse/","excerpt":"问题分析线上服务异常终止,通过分析core dump信息,对应用层的数据进行分析,排除了应用层的问题,然后怀疑是json库存在问题","text":"问题分析线上服务异常终止,通过分析core dump信息,对应用层的数据进行分析,排除了应用层的问题,然后怀疑是json库存在问题 部分core日志信息如下:1234567891011121314151617181920212223... ...saveBackTrace|19|CoreTime:2019-06-04 20:05:03 ThreadId:140319607437056 SignalId:6saveBackTrace|24|backtrace rank:37 addr2line -f -C -e 应用名 地址saveBackTrace|32|37: program_name(_Z13saveBackTracei+0x436) [0x579926]saveBackTrace|32|36: /lib64/libc.so.6(+0x32510) [0x7f9f10cfb510]saveBackTrace|32|35: /lib64/libc.so.6(gsignal+0x35) [0x7f9f10cfb495]saveBackTrace|32|34: /lib64/libc.so.6(abort+0x175) [0x7f9f10cfcc75]saveBackTrace|32|33: /usr/lib64/libstdc++.so.6(_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x41) [0x7f9f115b59a1]saveBackTrace|32|32: /usr/lib64/libstdc++.so.6(+0xbcbe6) [0x7f9f115b3be6]saveBackTrace|32|31: /usr/lib64/libstdc++.so.6(+0xbcc13) [0x7f9f115b3c13]saveBackTrace|32|30: /usr/lib64/libstdc++.so.6(+0xbcd32) [0x7f9f115b3d32]saveBackTrace|32|29: program_name(_ZN4Json17throwRuntimeErrorERKSs+0x3a) [0x6cc8ba]saveBackTrace|32|28: program_name(_ZN4Json6Reader9readValueEv+0x2a4) [0x6c3404]saveBackTrace|32|27: program_name(_ZN4Json6Reader9readArrayERNS0_5TokenE+0xb2) [0x6c3532]saveBackTrace|32|26: program_name(_ZN4Json6Reader9readValueEv+0x15b) [0x6c32bb]saveBackTrace|32|25: program_name(_ZN4Json6Reader10readObjectERNS0_5TokenE+0x18a) [0x6c2caa]saveBackTrace|32|24: program_name(_ZN4Json6Reader9readValueEv+0x14b) [0x6c32ab]saveBackTrace|32|23: program_name(_ZN4Json6Reader9readArrayERNS0_5TokenE+0xb2) [0x6c3532]saveBackTrace|32|22: program_name(_ZN4Json6Reader9readValueEv+0x15b) [0x6c32bb]saveBackTrace|32|21: program_name(_ZN4Json6Reader10readObjectERNS0_5TokenE+0x18a) [0x6c2caa]saveBackTrace|32|20: program_name(_ZN4Json6Reader9readValueEv+0x14b) [0x6c32ab]saveBackTrace|32|19: program_name(_ZN4Json6Reader5parseEPKcS2_RNS_5ValueEb+0x291) [0x6c3ae1]... ... 可以看到在调用Json::Reader::parse后经过Json::Reader::readValue等调用,最后再调用Json::Reader::readValue时调用Json::throwRuntimeError抛出异常 在github jsoncpp下载jsoncpp源码 查看函数Reader::readValue()1234567bool Reader::readValue() &#123; if (stackDepth_g &gt;= stackLimit_g) throwRuntimeError(\"Exceeded stackLimit in readValue().\"); ++stackDepth_g; ... ... --stackDepth_g; return successful;&#125; 可以看到只有一个地方会调用Json::throwRuntimeError抛出异常,而stackDepth_g是个坑爹的静态全局变量,线程不安全,而出问题的服务是多线程的12static int const stackLimit_g = 1000;static int stackDepth_g = 0; // see readValue() 解决12345678//stackDepth_是OurReader的成员变量bool OurReader::readValue() &#123; if (stackDepth_ &gt;= features_.stackLimit_) throwRuntimeError(\"Exceeded stackLimit in readValue().\"); ++stackDepth_; ... ... --stackDepth_; return successful;&#125; 分析源码,找到一个线程安全的Json解析类Json::OurReader,但该类在reader.h未声明,通过查看代码可以使用以下方法使用123456789101112131415161718bool Json::FromString(Json::Value &amp;value, const string &amp;data)&#123; if(data.empty()) &#123; return true; &#125; static Json::CharReaderBuilder oBuilder; std::auto_ptr&lt;Json::CharReader&gt; pReader(oBuilder.newCharReader()); if(NULL == pReader.get()) &#123; return false; &#125; const char* begin = data.c_str(); const char* end = begin + data.length(); string strError; bool bRet = pReader-&gt;parse(begin, end, &amp;value, &amp;strError); return bRet;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"fastcgi","slug":"fastcgi","date":"2019-05-03T17:23:08.000Z","updated":"2019-05-03T17:23:08.000Z","comments":true,"path":"2019/05/04/fastcgi/","link":"","permalink":"http://www.casezheng.date/2019/05/04/fastcgi/","excerpt":"CGICGI(Common Gateway Interface)通用网关接口,是Web服务器与Server进行数据传递的一种标准协议.Server每次接收到Web服务器的一个CGI请求后fork一个子进程去exec特定的CGI程序,Server收到的参数通过环境变量传递,在fork后对子进程的标准输入/标准输出/标准错误输出进行重定向,重定向到父进程生成的IPC文件描述符.exec特定的CGI程序,替换成功后等待子进程的运算结果,受到结果将其返回给浏览器.其中Web服务器和Server的通信通过标准输入/标准输出/标准错误输出进行,Server从标准输入读取参数,向标准输出输出数据即可.1234567891011121314151617Web浏览器 --&gt; Web服务器 --&gt; Server 1.Http Request 2.stdin | 子进程的创建 | CGI协议解析 | CGI程序exec | 环境变量读取 | 标准输入标准输出标准错误输出重定向 | CGI协议解析 |Web浏览器 &lt;-- Web服务器 &lt;-- 逻辑处理 4.Http Response 3.stdout/stderr | 退出 CGI程序每处理一个请求都需要创建子进程,然后exec特定的CGI程序,处理完请求子进程自动退出,消耗大量系统资源,性能太差","text":"CGICGI(Common Gateway Interface)通用网关接口,是Web服务器与Server进行数据传递的一种标准协议.Server每次接收到Web服务器的一个CGI请求后fork一个子进程去exec特定的CGI程序,Server收到的参数通过环境变量传递,在fork后对子进程的标准输入/标准输出/标准错误输出进行重定向,重定向到父进程生成的IPC文件描述符.exec特定的CGI程序,替换成功后等待子进程的运算结果,受到结果将其返回给浏览器.其中Web服务器和Server的通信通过标准输入/标准输出/标准错误输出进行,Server从标准输入读取参数,向标准输出输出数据即可.1234567891011121314151617Web浏览器 --&gt; Web服务器 --&gt; Server 1.Http Request 2.stdin | 子进程的创建 | CGI协议解析 | CGI程序exec | 环境变量读取 | 标准输入标准输出标准错误输出重定向 | CGI协议解析 |Web浏览器 &lt;-- Web服务器 &lt;-- 逻辑处理 4.Http Response 3.stdout/stderr | 退出 CGI程序每处理一个请求都需要创建子进程,然后exec特定的CGI程序,处理完请求子进程自动退出,消耗大量系统资源,性能太差 FastCGIFastCGI是CGI的优化版本,FastCGI再程序启动之初就fork多个子进程,阻塞等待Web服务器的请求,处理完一个请求后不退出,继续阻塞等待下一个请求,通信方式可以使用TCP连接,跨服务器 spawn-fcgispawn-fcgi是一个开源的小程序,用来管理fast-cgi进程,简单小巧.spawn-fcgi的github地址github.com/lighttpd/spawn-fcgi123456789101112131415161718192021222324252627$ spawn-fcgiUsage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]spawn-fcgi v1.6.3 (ipv6) - spawns FastCGI processesOptions: -f &lt;path&gt; filename of the fcgi-application (deprecated; ignored if &lt;fcgiapp&gt; is given; needs /bin/sh) -d &lt;directory&gt; chdir to directory before spawning -a &lt;address&gt; bind to IPv4/IPv6 address (defaults to 0.0.0.0) -p &lt;port&gt; bind to TCP-port -s &lt;path&gt; bind to Unix domain socket -M &lt;mode&gt; change Unix domain socket mode -C &lt;children&gt; (PHP only) numbers of childs to spawn (default: not setting the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0) -F &lt;children&gt; number of children to fork (default 1) -P &lt;path&gt; name of PID-file for spawned process (ignored in no-fork mode) -n no fork (for daemontools) -v show version -?, -h show this help(root only) -c &lt;directory&gt; chroot to directory -S create socket before chroot() (default is to create the socket in the chroot) -u &lt;user&gt; change to user-id -g &lt;group&gt; change to group-id (default: primary group of user if -u is given) -U &lt;user&gt; change Unix domain socket owner to user-id -G &lt;group&gt; change Unix domain socket group to group-id spawn-fcgi.c注释 fastcgifastcgi的阉割版本,只保留Linux环境下的代码,加入注释缺点:所有操作都是阻塞的,一个进程同时只能处理一个请求,和web服务器之间的通信只能使用短链接 协程FastCGI从fastcgi-async-or-coroutine修改而来的cocgi和腾讯的libco相结合,单进程可同时处理多个请求,增加了协程动态新增和销毁的功能 异步FastCGI从fastcgi-async-or-coroutine修改而来的mucgi借助muduo库,使用I/O复用技术,单进程可以处理多个请求,缺点在于对后端的访问还是同步方式的话会阻塞整个进程","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"数值计算溢出判断","slug":"overflow-detection-value","date":"2019-04-01T13:00:00.000Z","updated":"2019-04-01T13:00:00.000Z","comments":true,"path":"2019/04/01/overflow-detection-value/","link":"","permalink":"http://www.casezheng.date/2019/04/01/overflow-detection-value/","excerpt":"数值计算溢出在进行数值计算时可能会导致计算后的结果过大或过小,超出数值类型的范围,此处封装数据计算类,在计算前先对计算后的结果进行判断,防止溢出,并给出错误提醒","text":"数值计算溢出在进行数值计算时可能会导致计算后的结果过大或过小,超出数值类型的范围,此处封装数据计算类,在计算前先对计算后的结果进行判断,防止溢出,并给出错误提醒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#ifndef _Overflow_Detection_Value_H_#define _Overflow_Detection_Value_H_#include &lt;string&gt;#include &lt;limits&gt;enum OverflowErrorCode&#123; NoError = 0, AdditionOverflow, SubtractionOverflow, MultiplicationOverflow, DivisionOverflow&#125;;template&lt;class T&gt;class TOverflowDetectionValue&#123;public: explicit TOverflowDetectionValue(T tValue) : m_tValue(tValue) &#123; &#125; virtual ~TOverflowDetectionValue() &#123; &#125; TOverflowDetectionValue(const TOverflowDetectionValue &amp;tR) &#123; m_tValue = tR.m_tValue; &#125; TOverflowDetectionValue&amp; operator =(const TOverflowDetectionValue &amp;tR) &#123; m_tValue = tR.m_tValue; return *this; &#125; inline TOverflowDetectionValue&amp; operator =(const T &amp;tR) &#123; m_tValue = tR; return *this; &#125; inline TOverflowDetectionValue operator +(const TOverflowDetectionValue &amp;tR) &#123; if(m_tValue&gt;0 &amp;&amp; tR.m_tValue&gt;0 &amp;&amp; m_tValue &gt; std::numeric_limits&lt;T&gt;::max()-tR.m_tValue) &#123; m_eError = AdditionOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::max()); &#125; else if(m_tValue&lt;0 &amp;&amp; tR.m_tValue&lt;0 &amp;&amp; m_tValue &lt; std::numeric_limits&lt;T&gt;::min()-tR.m_tValue) &#123; m_eError = AdditionOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::min()); &#125; else &#123; TOverflowDetectionValue tTmp; tTmp.m_tValue = m_tValue + tR.m_tValue; return tTmp; &#125; &#125; inline TOverflowDetectionValue operator +(const T &amp;tR) &#123; return (*this) + TOverflowDetectionValue(tR); &#125; inline TOverflowDetectionValue operator -(const TOverflowDetectionValue &amp;tR) &#123; if(m_tValue&gt;0 &amp;&amp; tR.m_tValue&lt;0 &amp;&amp; m_tValue &gt; std::numeric_limits&lt;T&gt;::max()+tR.m_tValue) &#123; m_eError = SubtractionOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::max()); &#125; else if(m_tValue&lt;0 &amp;&amp; tR.m_tValue&gt;0 &amp;&amp; m_tValue &lt; std::numeric_limits&lt;T&gt;::min()+tR.m_tValue) &#123; m_eError = SubtractionOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::min()); &#125; else &#123; TOverflowDetectionValue tTmp; tTmp.m_tValue = m_tValue - tR.m_tValue; return tTmp; &#125; &#125; inline TOverflowDetectionValue operator -(const T &amp;tR) &#123; return (*this) - TOverflowDetectionValue(tR); &#125; inline TOverflowDetectionValue operator *(const TOverflowDetectionValue &amp;tR) &#123; if((m_tValue&gt;0 &amp;&amp; tR.m_tValue&gt;0 &amp;&amp; std::numeric_limits&lt;T&gt;::max()/m_tValue &lt; tR.m_tValue) || (m_tValue&lt;0 &amp;&amp; tR.m_tValue&lt;0 &amp;&amp; std::numeric_limits&lt;T&gt;::max()/m_tValue &gt; tR.m_tValue)) // MAX &gt; a * b &#123; m_eError = MultiplicationOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::max()); &#125; else if((m_tValue&gt;0 &amp;&amp; tR.m_tValue&lt;0 &amp;&amp; std::numeric_limits&lt;T&gt;::min()/m_tValue &gt; tR.m_tValue) || (m_tValue&lt;0 &amp;&amp; tR.m_tValue&gt;0 &amp;&amp; std::numeric_limits&lt;T&gt;::min()/m_tValue &lt; tR.m_tValue)) // MIN &lt; a * b &#123; m_eError = MultiplicationOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::min()); &#125; else &#123; TOverflowDetectionValue tTmp; tTmp.m_tValue = m_tValue * tR.m_tValue; return tTmp; &#125; &#125; inline TOverflowDetectionValue operator *(const T &amp;tR) &#123; return (*this) * TOverflowDetectionValue(tR); &#125; inline TOverflowDetectionValue operator /(const TOverflowDetectionValue &amp;tR) &#123; if(tR.m_tValue == 0) &#123; m_eError = DivisionOverflow; return TOverflowDetectionValue(std::numeric_limits&lt;T&gt;::max()); &#125; TOverflowDetectionValue tTmp; tTmp.m_tValue = m_tValue / tR.m_tValue; return tTmp; &#125; inline TOverflowDetectionValue operator /(const T &amp;tR) &#123; return (*this) / TOverflowDetectionValue(tR); &#125; static inline void ResetErrorCode() &#123; m_eError = NoError; &#125; inline T get() &#123; return m_tValue; &#125; static inline OverflowErrorCode GetErrorCode() &#123; OverflowErrorCode eRet = m_eError; m_eError = NoError; return eRet; &#125; static inline std::string GetErrorMsgByErrorCode(OverflowErrorCode eCode) &#123; if(eCode == NoError) &#123; return \"No error\"; &#125; else if (eCode == AdditionOverflow) &#123; return \"Addition overflow\"; &#125; else if (eCode == SubtractionOverflow) &#123; return \"Subtraction overflow\"; &#125; else if (eCode == MultiplicationOverflow) &#123; return \"Multiplication overflow\"; &#125; else if (eCode == DivisionOverflow) &#123; return \"Division overflowNoError\"; &#125; else &#123; return \"Undefined error code\"; &#125; &#125;private: TOverflowDetectionValue()&#123; &#125;private: T m_tValue; static __thread OverflowErrorCode m_eError;&#125;;template&lt;typename T&gt;__thread OverflowErrorCode TOverflowDetectionValue&lt;T&gt;::m_eError = NoError;#endif","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"服务器开发-框架与架构概述","slug":"server-framework","date":"2019-03-23T13:58:54.000Z","updated":"2019-03-23T13:58:54.000Z","comments":true,"path":"2019/03/23/server-framework/","link":"","permalink":"http://www.casezheng.date/2019/03/23/server-framework/","excerpt":"","text":"框架1. 网络通信 客户端连接检测 接受客户端连接 客户端数据检测 客户端数据接收 发送数据给客户端 连接异常检测 连接的关闭 客户端连接的发起 2. I/O复用select/poll/epoll 3. 检测网络事件4. 连接关闭(主动/被动)被动关闭连接:检测到连接异常事件(例如:EPOLLERR)或对端关闭连接(send或recv返回0)主动关闭连接:主动调用close或shutdown 5. 发送缓冲区/接收缓冲区发送缓冲区和接收缓冲区每一个socket连接都存在一个,应该可以动态增长,按需分配 6. 协议设计 Json 优点 跨语言 文本协议 可读性好 简单易用,开发成本低 缺点 体积大 无版本检查,自己做兼容 数据解析复杂 文本格式,安全性差 Protobuf 二进制协议 可读性差 优点 跨语言,自定义数据结构 字段被编号,新添加字段不影响老结构,向后兼容 简单易用,自动生成代码 二进制消息,效率高,性能好,安全性高 缺点 二进制格式,可读性差 对象冗余,字段很多,生成类较大,占用空间 7. 服务器程序结构组织8. 多进程/多线程/协程9. 内存管理 内存分片和内存碎片 gcc默认内存管理器ptmalloc 更好的内存管理器tcmalloc tcmalloc在链接时替代标准libc中的malloc和free,不改动代码的情况下解决内存碎片问题 tcmalloc的malloc和free函数速度快 tcmalloc优化了小对象存储 tcmalloc对多线程做了优化 内存池(自己管理内存)10. 连接池11. 线程池 架构1. 接入层2. 负载均衡 求余法 一致性哈希 3. 缓存4. 数据库5. 日志上报6. 名字服务7. 配置服务8. 队列(解耦合)开源组件zookeeperzooKeeper是一个分布式的，开放源码的分布式应用程序协调服务,是hadoop和hbase的重要组件,为分布式应用提供一致性服务.提供java和c的客户端. etcdetcd是一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现。etcd相比zookeeper是轻量级的.etcd基于HTTP+JSON的API易于使用raft算法,保证数据一致性,协议简单,容易实现 rabbitmqkafkamysqlredisnginxtcmalloc","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"服务器开发-网络通信API和注意事项","slug":"server-network-api","date":"2019-03-23T13:41:39.000Z","updated":"2019-03-23T13:41:39.000Z","comments":true,"path":"2019/03/23/server-network-api/","link":"","permalink":"http://www.casezheng.date/2019/03/23/server-network-api/","excerpt":"","text":"Linux下网络编程常用函数需要包含头文件12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; socketsocket函数建立协议簇为aomain 协议类型为type 协议类型的某个特定类型为protocol的套接字文件描述符成功返回标识套接字的文件描述符 失败返回-1,错误原因通过查看errno获得常用协议簇 domain AF_UNIX 本机通信 AF_INET IPV4 AF_INET6 IPV6 常用协议类型 type SOCK_STREAM TCP套接字 SOCK_DGRAM UDP套接字 SOCK_RAM 原始套接字 协议类型的特定类型 protocol 一般置为0即可1int socket(int domain, int type, int protocol); fcntlfcntl函数针对文件描述符提供各种操作控制以改变已打开文件的各种属性网络编程中主要使用其设置为阻塞和设置为非阻塞功能1234567891011#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, long arg);//设置为非阻塞int flags = fcntl(sockfd, F_GETFL, 0);fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);//设置为阻塞int flags = fcntl(sockfd, F_GETFL, 0);fcntl(sockfd, F_SETFL, flags &amp; ~O_NONBLOCK); getsockopt和setsockoptgetsockoptgetsockopt()函数用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optvalsockfd 套接字文件描述符level 选项定义的层次optname 需获取的套接字选项optval 指向存放所得选项值的缓冲区optlen 指向optval缓冲区的长度值1int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen); setsockoptsetsockopt()函数用于任意类型、任意状态套接口的设置选项值。sockfd 套接字文件描述符level 选项定义的层次optname 需获取的套接字选项optval 指向存放所得选项值的缓冲区optlen 指向optval缓冲区的长度值1int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 常用level和选项 level级别 optname选项名 选项值数据类型 适用函数 说明 SOL_SOCKET SO_ERROR int getsockopt 获取并清除套接字错误 SOL_SOCKET SO_REUSEADDR int setsockopt SOL_SOCKET SO_REUSEPORT int setsockopt SOL_SOCKET SO_KEEPALIVE int setsockopt SOL_SOCKET SO_LINGER struct linger setsockopt IPPROTO_TCP TCP_DEFER_ACCEPT int setsockopt IPPROTO_TCP TCP_NODELAY int setsockopt 禁用Nagle算法 bindbind函数绑定套接字和地址, 成功返回0, 失败返回-1, 错误原因可以通过errno获得 地址为32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口的组合sockfd 套接字文件描述符 通过socket函数获得addr 指向特定协议的地址结构的指针 绑定0.0.0.0则绑定该机器上任意网卡地址,绑定127.0.0.1则只会绑定本地回环地址127.0.0.1addrlen 该地址结构的长度1234567891011121314struct sockaddr &#123; sa_family_t sa_family; char sa_data[14];&#125;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);//示例struct sockaddr_in addr;/*设置sockaddr结构*/addr.sin_family=AF_INET;addr.sin_port=htons(SERVPORT);addr.sin_addr.s_addr=INADDR_ANY;bzero(&amp;(addr.sin_zero), 8);bind(sockfd,(struct sockaddr*)&amp;addr, sizeof(struct sockaddr)) listenlisten监听函数,将一个套接字转化为监听套接字sockfd 套接字文件描述符backlog 连接建立完成的队列的长度1int listen(int sockfd, int backlog); acceptaccept接受连接 成功则返回建立了连接的套接字文件描述符 失败返回-1 错误原因通过查看errno获得当监听的sockfd被设置为非阻塞而errno为EWOULDBLOCK、ECONNABORTED、EPROTO、EINTR时需要忽略错误sockfd 套接字文件描述符addr 用来保存发起连接的主机的IP和端口号addrlen addr指向的长度1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); connectconnect用于主动建立一个连接 成功返回0 失败返回-1 错误原因可以通过errno获得当发起连接的sockfd被设置为非阻塞而errno为EINPROGRESS表示连接操作正在进行中,但是仍未完成.然后将sockfd的加入到I/O复用中,监听sockfd是否可读或者可写,如果只可写说明连接成功,如果即可读又可写分为两种情况: sockfd连接错误 sockfd连接成功,socket读缓冲区得到了远程主机发送的数据 通过getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void*)&amp;e, &amp;elen)获取sockfd错误信息 如果e为0表示连接成功 否则连接失败sockfd 套接字文件描述符addr 指向特定协议的地址结构的指针addrlen 该地址结构的长度1int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 如何将一个sockfd设为非阻塞 调用socket函数时设置 1int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP); accept改为调用accept4设置最后的标记位为SOCK_NONBLOCK 12int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags); 调用fcntl或ioctl函数(常用fcntl) 12fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);ioctl(sockfd, FIONBIO, 1); //1:非阻塞 0:阻塞 connect非阻塞代码编写connect能立即连接成功,则返回0;如果连接操作正在进行中或连接出错,则返回-1,连接操作正在进行中可通过errno为EINPROGRESS或EINTR(中断)判断.然后将该sockfd放入I/O复用中进行,监听sockfd可读 非阻塞socket正确收发数据非阻塞情况下recv数据 返回值大于0表示接收数据的大小 返回值等于0表示对端关闭连接 返回值为-1,errno为EWOULDBLOCK或EINTR时接收完毕 在epoll的ET(边缘触发)模式下,一定要循环收取数据,直到收取干净为止. 非阻塞情况下send数据 返回值大于0表示发送数据的大小 返回值等于0表示对端关闭连接 返回值为-1,errno为EWOULDBLOCK表示TCP窗口容量不足,errno为EINTR表示中断,继续发送数据 丢包/粘包/包不完整丢包:TCP是可靠的,不会丢包,也不存在包顺序错乱的问题粘包:收取一个固定大小的包头信息,根据包头里面指定的包体大小收取包体大小包不完整:循环接受数据,当发现包头或包体大小不够,数目数据不完整,继续等待新的数据到来 Nagle算法nagle是操作系统网络通信层的一种发送数据包的机制.开启nagle算法后,一次放入网卡缓冲区的数据较小时,可能不会立即发出,只有当多次send或write之后,网卡缓冲区数据足够多时,才一次性发出.操作系统利用nagle算法减少网络通信次数,提供网络利用率,对于实时性要求比较高的应用,可以禁用nagle算法.12long noDelay = 1;setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY,(LPSTR)&amp;noDelay, sizeof(long)); //noDelay为1禁用nagle算法，为0启用nagle算法 SO_REUSEADDR和SO_REUSEPORT套接字由相关五元组组成:协议、本地地址、本地端口、远程地址、远程端口解决一个socket被系统回收以后,在一个最大存活期(MSL，大约2分钟)内,该socket绑定的地址和端口号不能被重复利用的情况 心跳包TCP协议的keepalive机制(开启SO_KEEPALIVE选项)应用层心跳: 定时发送心跳包(只在两端没有数据往来的N秒后才需要发送,减轻服务器压力,减少网络通信流量) 由客户端发给服务端 重连错误码EINTRLinux网络函数(connect/send/recv/epoll_wait等)在出错时一定要检查错误是不是EINTR,如果是EINTR,操作其实只是被信号中断了,函数调用并没有出错. 减少系统调用系统调用伴随着从用户空间到内核空间的切换. 忽略SIGPIPE信息对一个已经收到FIN包的socket调用read方法,如果接收缓冲已空,则返回0,即连接已关闭.对一个已经收到FIN包的socket第一次调用write方法时,如果发送缓冲没问题,则write调用会返回写入的数据量,同时进行数据发送.但是发送出去的报文会导致对端发回RST报文.因为对端的socket已经调用了close进行了完全关闭,已经处于既不发送,也不接收数据的状态.所以第二次调用write方法时(假设在收到RST之后)会生成SIGPIPE信号,导致进程退出.通俗点:对一个对端已经关闭的socket调用两次write,第二次将生成SIGPIPE信号.在写管道时,读进程已经终止,也将产生SIGPIPE信号1signal(SIGPIPE, SIG_IGN); //屏蔽SIGPIPE信号后,第二次调用write方法时,会返回-1,并设置errno为EPIPE.","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"网络","slug":"网络","permalink":"http://www.casezheng.date/tags/网络/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"数据结构","slug":"data-structure","date":"2019-03-15T14:51:38.000Z","updated":"2019-03-15T14:51:38.000Z","comments":true,"path":"2019/03/15/data-structure/","link":"","permalink":"http://www.casezheng.date/2019/03/15/data-structure/","excerpt":"","text":"堆STL中的堆 优先级队列的底层算法 二叉排序树二叉树是指任何节点最多只允许两个子节点的树。两个子节点称为左子节点和右子节点。二叉排序树提供对数时间的元素插入和访问，二叉排序树的节点放置规则：任何检点的键值一定大于其左子树的每个节点的键值，并小于其右子树的每一个节点的键值。因此，从根节点一直向左走，直至左路可走，即得最小元素；从根节点一直向右走，直至无右路可走，即得最大元素。 二叉排序树的搜索时间复杂度为$O(log_2n)$到$O(n)$ AVL树AVL树是”加上额外平衡条件”的二叉搜索树。平衡条件的建立是为了确保整棵树的深度为$O(logN)$。AVL-tree要求任何节点的左右子树高度相差最多1。AVL树的搜索时间复杂度为$O(log_2n)$ 红黑树RB-tree不仅是二叉搜索树，而且必须满足以下规则： 每个节点不是红色就是黑色。 根节点为黑色。 如果节点为红色，其子节点必须为黑色。 任一节点到NULL(树尾端)的任何路径，所含黑节点数目必须相同。 红黑树的搜索时间复杂度为$O(log_2n)$STL中的红黑树是map、set、multiset、multimap的底层epoll底层内核事件表对文件描述符的管理使用红黑树 B树(B-树)一个m阶的B树具有如下几个特征： 根结点至少有两个子女。 每个中间节点都包含k-1个元素和k个孩子,其中 $m/2 \\le k \\le m$ 每一个叶子节点都包含k-1个元素,其中 $m/2 \\le k \\le m$ 所有的叶子结点都位于同一层。 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B+树一个m阶的B+树具有如下几个特征： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素 MySQL索引就是使用B+树B+树相比B树的优势: I/O次数更少(单一节点存储更多元素) 查找性能更稳定(搜索查找都要查找到叶子节点) 范围查找简便(所有叶子节点形成有序链表) B*树哈希表哈希表查找、插入、删除只需要接近$O(1)$的时间复杂度.SGI STL提供的hashset、hashmap、hashmultiset、hashmultimap使用的底层结构即为哈希表缺点: 哈希表基于数组,创建后扩展困难,hash表表基本填满时,性能下降严重. 一个关键字可能对应多个散列地址 需要范围查找时,效果不好 跳表跳表具有如下性质： 由很多层结构组成 每一层都是一个有序的链表 最底层(Level 1)的链表包含所有元素 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素 跳表的搜索时间复杂度为$O(log_2n)$到$O(n)$,其搜索时间复杂度大部分情况下与红黑树相当,但实现难度比红黑树低 1234567 Top |Level 3 2-----------&gt;21-------&gt;37------------------&gt; | | |Level 2 2--&gt;7-------&gt;21-------&gt;37--&gt;71-------------&gt; | | | | |Level l 2--&gt;7--&gt;14--&gt;21--&gt;32--&gt;37--&gt;71--&gt;85--&gt;117--&gt; Redis底层使用跳表 倒排表参考资料 SkipList跳表基本原理","categories":[],"tags":[],"keywords":[]},{"title":"协程库学习","slug":"coroutine","date":"2019-03-01T10:49:52.000Z","updated":"2019-03-01T10:49:52.000Z","comments":true,"path":"2019/03/01/coroutine/","link":"","permalink":"http://www.casezheng.date/2019/03/01/coroutine/","excerpt":"","text":"协程简介进程、线程、协程 libco简介libco是腾讯开源的一个协程库.主要结构和方法介绍:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// co_routine.h//1.structstruct stCoRoutine_t;struct stShareStack_t;struct stCoRoutineAttr_t&#123; int stack_size; stShareStack_t* share_stack; stCoRoutineAttr_t() &#123; stack_size = 128 * 1024; share_stack = NULL; &#125;&#125;__attribute__ ((packed));struct stCoEpoll_t;typedef int (*pfn_co_eventloop_t)(void *);typedef void *(*pfn_co_routine_t)( void * );//2.co_routine//创建一个新协程int co_create( stCoRoutine_t **co,const stCoRoutineAttr_t *attr,void *(*routine)(void*),void *arg );//执行一个协程void co_resume( stCoRoutine_t *co );//让某个协程yield(让出时间片)void co_yield( stCoRoutine_t *co );//让当前协程yieldvoid co_yield_ct(); //ct = current threadvoid co_release( stCoRoutine_t *co );stCoRoutine_t *co_self();int co_poll( stCoEpoll_t *ctx,struct pollfd fds[], nfds_t nfds, int timeout_ms );void co_eventloop( stCoEpoll_t *ctx,pfn_co_eventloop_t pfn,void *arg );//3.specificint co_setspecific( pthread_key_t key, const void *value );void * co_getspecific( pthread_key_t key );//4.eventstCoEpoll_t * co_get_epoll_ct(); //ct = current thread//5.hook syscall ( poll/read/write/recv/send/recvfrom/sendto )void co_enable_hook_sys(); void co_disable_hook_sys(); bool co_is_enable_sys_hook();//6.syncstruct stCoCond_t;stCoCond_t *co_cond_alloc();int co_cond_free( stCoCond_t * cc );int co_cond_signal( stCoCond_t * );int co_cond_broadcast( stCoCond_t * );int co_cond_timedwait( stCoCond_t *,int timeout_ms );//7.share stackstShareStack_t* co_alloc_sharestack(int iCount, int iStackSize);//8.init envlist for hook get/set envvoid co_set_env_list( const char *name[],size_t cnt);void co_log_err( const char *fmt,... ); 参考资料 libco github仓库 libco简介 C/C++协程学习笔记 Why c++ coroutine？Why libgo？","categories":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}],"tags":[{"name":"协程","slug":"协程","permalink":"http://www.casezheng.date/tags/协程/"}],"keywords":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}]},{"title":"Linux进程/线程间同步与通信","slug":"process-thread-communication-synchronize","date":"2019-02-27T14:29:19.000Z","updated":"2019-02-27T14:29:19.000Z","comments":true,"path":"2019/02/27/process-thread-communication-synchronize/","link":"","permalink":"http://www.casezheng.date/2019/02/27/process-thread-communication-synchronize/","excerpt":"","text":"进程/线程间通信方式 管道 (进程和线程) 基于流,半双工,数据只能向一个方向流动,双方通信时需要建立两个管道,管道缓存区有限 无名管道 可用于具有亲缘关系的进程间通信 1int pipe(int fildes[2]); 有名管道 可用于无血缘关系的进程间通信 信号 (进程) 123#include &lt;signal.h&gt;void (*signal(int sig, void (*func)(int)))(int);int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact); 消息队列 (进程和线程) 消息的链表,存放在内核,有消息队列标识符标识.不需要同步机制. 12345#include &lt;sys/msg.h&gt;int msgget(key_t key, int msgflg);int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);int msgctl(int msqid, int cmd, struct msqid_ds *buf); 共享内存 (进程和线程) 多个进程可以访问同一块内存空间,和其它通信机制结合使用,达到进程间的同步和互斥 速度快 123456#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); //用来创建共享内存void *shmat(int shmid, const void *shmaddr, int shmflg); //将共享内存段连接到进程地址空间int shmdt(const void *shmaddr); //将共享内存段与当前进程脱离int shmctl(int shmid, int cmd, struct shmid_ds *buf); //用于控制共享内存 信号量 (进程和线程) 进程间或线程间同步 一个计数器,每次调用wait将使信号量值减一,如果信号量值为0,则wait将阻塞.每次调用post操作将使信号量值加1 12345678910#include &lt;semaphore.h&gt;sem_t *sem_open(const char *name, int oflag, ...);int sem_init(sem_t *sem, int pshared, unsigned value);int sem_close(sem_t *sem);int sem_destroy(sem_t *sem);int sem_wait(sem_t *sem);int sem_trywait(sem_t *sem);int semctl(int semid, int semnum, int cmd, ...);int semget(key_t key, int nsems, int semflg);int semop(int semid, struct sembuf *sops, size_t nsops); socket套接字 (进程和线程) 基于流 跨服务器 12345int socket(int family, int type, int protocol);int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);int listen(int sockfd, int backlog);int accept(int sockfd, struct sockaddr *client_addr, socklen_t *len);int connect(int sock_fd, struct sockaddr *serv_addr,int addrlen); 互斥量 (线程) 线程同步方式 互斥锁,访问共享资源前加锁,访问完后释放互斥量,一次只能由一个线程运行 需要注意死锁 123456789101112#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); //互斥量初始化int pthread_mutex_destroy(pthread_mutex_t *restrict mutex); //互斥量销毁int pthread_mutex_lock(pthread_mutex_t *mutex); //加锁int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); //解锁PTHREAD_MUTEX_NORMAL 一种标准互斥量类型，不做任何特殊的错误检查或死锁检测。PTHREAD_MUTEX_ERRORCHECK 此互斥量类型提供错误检查。PTHREAD_MUTEX_RECURSIVE 此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。PTHREAD_MUTEX_DEFAULT 此互斥量类型可以提供默认特性和行为。int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type); //得到互斥量类型属性int pthread_mutexattr_settype(const pthread_mutexattr_t *attr, int type); //设置互斥量类型属性 预防死锁:破环死锁产生的四个必要条件:互斥条件,不可剥夺条件,请求和保持条件,循环等待条件 避免死锁:每次资源分配前,应该计算此次分配资源的安全性,如果此次资源分配不会导致系统进入不安全状态,则分配资源,否则等待.算法:银行家算法 检查死锁:检测到死锁后通过资源剥夺,撤销进程,进程回退等方法解除死锁. 自旋锁 (线程) 线程同步方式 自旋锁不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等待阻塞状态(占用CPU),用于锁持有时间短,并且线程不希望在重新调度上花费大量成本的情况下 123456#include &lt;pthread.h&gt;int pthread_spin_init(pthread_spinlock_t *lock, int pshared); //初始化锁int pthread_spin_destroy(pthread_spinlock_t *lock); //销毁锁int pthread_spin_unlock(pthread_spinlock_t *lock); //解锁int pthread_spin_lock(pthread_spinlock_t *lock); //加锁int pthread_spin_trylock(pthread_spinlock_t *lock); 条件变量 (线程) 常和互斥锁一起使用,使用时,条件变量被用来阻塞一个线程,当条件不满足时,线程解开相应的互斥锁并等待条件发生变化,一旦其它线程改变了条件变量,条件变量将唤醒一个或多个被此条件变量阻塞的线程,这些线程重新锁定互斥锁并重新测试条件是否满足. 1234567#include &lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *cv,const pthread_condattr_t *cattr); //初始化条件变量int pthread_cond_wait(pthread_cond_t *cv,pthread_mutex_t *mutex); //等待条件变量int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mp, const structtimespec * abstime); //等待条件变量到某个时间int pthread_cond_signal(pthread_cond_t *cv); //通知条件变量的单个线程int pthread_cond_broadcast(pthread_cond_t *cv); //通知条件变量的多个线程int pthread_cond_destroy(pthread_cond_t *cv); //销毁条件变量 读写锁 (线程) 线程同步方式 三种状态 1.读模式加锁 2.写模式加锁 3.不加锁 一次只能有一个线程占用写模式的读写锁 但可以有多个线程同时占有读模式的读写锁 12345678910#include &lt;pthread.h&gt;int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //销毁锁int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); //初始化锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //解锁int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); //读加锁int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); //写加锁int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict abstime);int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict abstime); 线程信号量 (线程) 全局变量 (线程) 管道 消息队列 信号量 共享内存","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"进程、线程、协程","slug":"process-thread-coroutine","date":"2019-02-27T13:34:22.000Z","updated":"2019-02-27T13:34:22.000Z","comments":true,"path":"2019/02/27/process-thread-coroutine/","link":"","permalink":"http://www.casezheng.date/2019/02/27/process-thread-coroutine/","excerpt":"","text":"进程进程是系统进行资源分配和资源调度的基本单位.进程有独立的资源.不同进程通过进程间通信来通信.进程的上下文切换开销大.新进程由父进程fork而来,fork结束后并不立即复制父进程的内容,等真正使用的时候再复制,即写时拷贝(copy-on-write COW).为了效率,子进程一般会先父进程一步进行调用.孤儿进程:父进程先退出,子进程还没退出,那么子进程将被托孤给init进程,此时的子进程就是孤儿进程.僵死进程:在每个进程退出的时候,内核释放该进程所有的资源(包括打开的文件、占用的内存等),但是仍然为其保留一定的信息(包括进程号,退出状态,运行时间等),直到父进程通过外wait/waitpid来取时才释放.此时该进程处于僵死状态.守护进程:守护进程是后台常驻内存的一种特殊进程,不和任何终端关联.守护进程是一个孤儿进程.守护进程的标准输入输出和错误输出都会被丢到/dev/null中.守护进程一般用作服务器进程. 123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;//获取进程自身PIDpid_t getpid(void);//获取进程自身父进程的ID PPIDpid_t getppid(void);//创建一个子进程//返回值有两次 1.子进程返回0 2.父进程返回子进程的PIDpid_t fork(void);//创建一个子进程,但子进程共享父进程的空间.返回值有两次,子进程返回0,父进程返回子进程的进程号.vfork创建子进程后,父进程阻塞,直到子进程执行exec()或exit().//vfork最初因为fork没有COW机制,而很多情况下fork后会紧接着执行exec,而exec的执行相当于之前fork复制的空间做了无用功,所以设计了vfork.//fork有了COW机制后,唯一的代价仅仅是复制父进程页表的代价,所以vfork渐渐被废弃pid_t vfork(void);#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *status);pid_t waitpid(pid_t pid, int *status, int options); 进程的销毁 主动 main函数的自然返回 注意:main返回return不是结束,只是main函数结束,main函数结束后还需要调用全局变量、静态局部变量和main函数的局部变量的析构函数. 调用exit函数,标准函数 退出时会检查文件的打开情况,把文件缓冲区内容写回文件 调用_exit函数,系统调用函数 不会检测文件打开情况,直接退出 调用abort函数,产生SIGABRT信号 被动 收到信号 vfork创建的子进程中在main函数中return会导致进程异常结束,而调用exit则不会正是由于子进程和父进程公用栈空间,子进程return后导致栈空间被释放,而exit不会释放栈空间. 进程替换12345678#include &lt;unistd.h&gt;extern char **environ;int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char * const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]); 进程间通信进程间通信方式: 共享内存 消息队列 信号量 有名管道 无名管道 信号 socket 文件 守护进程的创建Linux有一个daemon函数用来创建守护进程.1234#include &lt;unistd.h&gt;int daemon(int nochdir, int noclose);nochdir 如果为0,将当前工作目录切换到根目录/,否则工作目录不改变noclose 如果为0,将0,1,2重定向到/dev/null,否则不变 守护进程的创建过程 屏蔽控制终端操作信号 处理SIGCHLD信号 后台运行(调用fork函数,然后让父进程退出运行,子进程继续在后台运行) 脱离控制终端,登陆会话和进程组setsid() 禁止会话重新打开控制终端(子进程调用fork函数,然后让子进程退出运行孙进程继续在后台运行) 重设文件创建掩码umask(0) 关闭打开的文件描述符 改变当前工作目录chdir(&quot;/&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;iostream&gt;#include &lt;signal.h&gt;void daemon()&#123; //屏蔽控制终端操作信号 signal(SIGTTOU, SIG_IGN); signal(SIGTTIN, SIG_IGN); signal(SIGTSTP, SIG_IGN); signal(SIGHUP, SIG_IGN); signal(SIGCHLD, SIG_IGN); //忽略子进程结束信号，避免僵死进程产生 pid_t pid = fork(); //创建子进程 if(-1 == pid) &#123; exit(-1); &#125; if(0 != pid) &#123; std::cout &lt;&lt; __LINE__ &lt;&lt; \"父进程:\" &lt;&lt; getpid() &lt;&lt; \"退出\" &lt;&lt; std::endl; std::fflush(stdout); exit(0); //父进程退出,子进程继续运行 &#125; setsid(); //子进程脱离控制终端,登陆会话和进程组,成为无终端的会话组长 pid = fork(); //创建孙进程 if(-1 == pid) &#123; exit(-1); &#125; if(0 != pid) &#123; std::cout &lt;&lt; __LINE__ &lt;&lt; \"子进程:\" &lt;&lt; getpid() &lt;&lt; \"退出\" &lt;&lt; std::endl; std::fflush(stdout); exit(0); //让子进程退出,孙进程继续运行,孙进程不再是会话组长,禁止程序重新打开控制终端 &#125; std::cout &lt;&lt; __LINE__ &lt;&lt; \"孙进程:\" &lt;&lt; getpid() &lt;&lt; \"继续运行\" &lt;&lt; \" PPID:\" &lt;&lt; getppid() &lt;&lt; std::endl; std::fflush(stdout); chdir(\"/\"); //改变工作目录 umask(0); //重设文件创建掩码 for(unsigned i=0; i&lt;3; ++i) &#123; close(i); //关闭标准输入,标准输出,标准错误输出 &#125; std::cout &lt;&lt; __LINE__ &lt;&lt; \"关闭标准输入,标准输出,标准错误输出\" &lt;&lt; std::endl; std::fflush(stdout); return;&#125; 线程(轻量级进程)线程是CPU调度和分派的基本单位.一个进程中可以有多个线程(最少一个线程).它们共享代码空间和数据空间(全局变量和静态变量),文件描述符,信号,malloc分配的内存.每个线程有自己独立的栈空间和程序计数器.同进程内线程上下文切换快,资源消耗少.线程的实现调用clone系统调用. 线程相关函数12345678910111213#include&lt;pthread.h&gt;//线程的创建int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);//等待线程结束 返回等待线程的返回值int pthread_join(pthread_t thread, void **retval);//终止线程void pthread_exit(void *retval);//获取线程自身idpthread_t pthread_self(void);//将指定线程转变为detach状态//1. 线程缺省情况下是joinable,其线程ID和退出状态将留给另一个线程对它调用pthread_join//2. detach线程在终止时,所有资源将自动释放int pthread_detach(pthread_t thread); linux下获取线程Id有两种方式 gettid pthread_selfgettid获取的是内核中线程Id,pthread_self获取的是posix描述的线程Id 对于单线程的进程,内核中tid和pid相等,对于多线程的进程,它们的pid相等,tid则不相同.tid用于描述内核中真实的pid和tid信息.pthread_self返回的是posix定义的线程Id,只是用来区分某个进程中不同的线程,当一个线程退出后,新创建的线程可以复用原来的id.pthread_self返回的线程控制块TCB首地址相对于进程数据段的偏移(pthread_create也是返回该值),只是用来描述同一进程中的不同线程. 线程间通信和同步方式 共享内存 消息队列 信号量 有名管道 无名管道 socket 文件 互斥量 自旋锁 条件变量 读写锁 线程信号 全局变量 协程(微线程)协程是用户态的轻量级线程.协程调度完全由用户控制,上下文切换比线程快,占用资源少.协程不需要多线程的锁机制,执行效率比多线程高. 进程学习代码代码Git地址123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; cout &lt;&lt; \"start fork\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; pid_t iPid = fork(); if(iPid &lt; 0) &#123; cout &lt;&lt; \"fork error\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; &#125; else if (iPid == 0) &#123; cout &lt;&lt; \"child process\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; \" PPID:\" &lt;&lt; getppid() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"parent process\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; &#125; sleep(300); return 0;&#125; 运行情况1234567891011121314$ ./process_studystart fork PID:12128parent process PID:12128child process PID:12129 PPID:12128$ pstree -p -a... ... ├─sshd,724 -D │ ├─sshd,609 │ │ └─sshd,611 │ │ └─bash,620 │ │ └─process_study,12128 │ │ └─process_study,12129... ... 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; cout &lt;&lt; \"start fork\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; for(int i=0; i&lt;3; ++i) &#123; pid_t iPid = fork(); if(iPid &lt; 0) &#123; cout &lt;&lt; \"fork error\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; &#125; else if (iPid == 0) &#123; cout &lt;&lt; \"child process\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; \" PPID:\" &lt;&lt; getppid() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"parent process\" &lt;&lt; \" PID:\" &lt;&lt; getpid() &lt;&lt; endl; &#125; &#125; sleep(300); return 0;&#125; 运行情况12345678910111213141516171819202122232425262728$ ./process_study start fork PID:16030parent process PID:16030parent process PID:16030parent process PID:16030child process PID:16033 PPID:16030child process PID:16032 PPID:16030parent process PID:16032child process PID:16031 PPID:16030parent process PID:16031parent process PID:16031child process PID:16034 PPID:16032child process PID:16036 PPID:16031child process PID:16035 PPID:16031parent process PID:16035child process PID:16037 PPID:16035$ pstree -p -a... ... │ │ └─process_study,16030 │ │ ├─process_study,16031 │ │ │ ├─process_study,16035 │ │ │ │ └─process_study,16037 │ │ │ └─process_study,16036 │ │ ├─process_study,16032 │ │ │ └─process_study,16034 │ │ └─process_study,16033... ... 分析流程12345678PID:16030 --fork--&gt; PID:16030 --fork--&gt; PID:16030 --fork--&gt; PID:16030 PID:16033 PID:16032 --fork--&gt; PID:16032 PID:16034 PID:16031 --fork--&gt; PID:16031 --fork--&gt; PID:16031 PID:16036 PID:16035 --fork--&gt; PID:16035 PID:16037 线程学习代码代码Git地址1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/types.h&gt;using namespace std;void *Print(void *pArg)&#123; int *pCount = (int*)pArg; for(;*pCount&lt;10;++(*pCount)) &#123; cout &lt;&lt; \"PID:\" &lt;&lt; getpid() &lt;&lt; \" TID:\" &lt;&lt; pthread_self() &lt;&lt; \" \" &lt;&lt; *pCount &lt;&lt; endl; sleep(1); &#125;&#125;int main()&#123; pthread_t t1; pthread_t t2; int iCount = 0; if(pthread_create(&amp;t1, NULL, Print, &amp;iCount) == -1) &#123; cout &lt;&lt; \"thread create error\" &lt;&lt; endl; return 1; &#125; if(pthread_create(&amp;t2, NULL, Print, &amp;iCount) == -1) &#123; cout &lt;&lt; \"thread create error\" &lt;&lt; endl; return 1; &#125; pthread_join(t1, NULL); pthread_join(t2, NULL); return 0;&#125; 运行结果123456789101112$ ./thread_study PID:31384 TID:140122741049088 0PID:31384 TID:140122749441792 0PID:31384 TID:140122741049088 1PID:31384 TID:140122749441792 2PID:31384 TID:140122741049088 3PID:31384 TID:140122749441792 4PID:31384 TID:140122741049088 5PID:31384 TID:140122749441792 6PID:31384 TID:140122741049088 7PID:31384 TID:140122749441792 8PID:31384 TID:140122741049088 9 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;boost/chrono.hpp&gt;#include &lt;boost/ref.hpp&gt;using namespace std;void Print1(int *pCount)&#123; for(;(*pCount)&lt;10;++(*pCount)) &#123; cout &lt;&lt; \"PID:\" &lt;&lt; getpid() &lt;&lt; \" TID:\" &lt;&lt; pthread_self() &lt;&lt; \" \" &lt;&lt; *pCount &lt;&lt; endl; boost::this_thread::sleep_for(boost::chrono::seconds(1)); &#125;&#125;void Print2(int &amp;count)&#123; for(;count&lt;10;++count) &#123; cout &lt;&lt; \"PID:\" &lt;&lt; getpid() &lt;&lt; \" TID:\" &lt;&lt; pthread_self() &lt;&lt; \" \" &lt;&lt; count &lt;&lt; endl; boost::this_thread::sleep_for(boost::chrono::seconds(1)); &#125;&#125;int main()&#123; int count = 1; boost::thread t1(Print1, &amp;count); boost::thread t2(Print2, boost::ref(count)); t1.join(); t2.join(); return 0;&#125; 运行结果1234567891011$ ./thread_study PID:11311 TID:140043269957376 1PID:11311 TID:140043278350080 1PID:11311 TID:140043269957376 2PID:11311 TID:140043278350080 3PID:11311 TID:140043269957376 4PID:11311 TID:140043278350080 5PID:11311 TID:140043269957376 6PID:11311 TID:140043278350080 7PID:11311 TID:140043269957376 8PID:11311 TID:140043278350080 9 协程学习代码C++协程库基于两种方案: 利用汇编代码控制协程的上下文切换 (libco, Boost.context) 利用操作系统提供的API来实现协程上下文切换 参考文档 linux进程、调度、线程、进程上下文等几点理解 进程、线程和协程之间的区别和联系 关于进程，线程，协程，一点心得 linux进程-线程-协程上下文环境的切换与实现 fork和vfork fork()、vfork()、clone()的区别 pthread_detach linux进程相关函数(获取、销毁、切换···) gettid和pthread_self区别","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Linux内存","slug":"linux-ram","date":"2019-02-23T17:54:42.000Z","updated":"2019-02-23T17:54:42.000Z","comments":true,"path":"2019/02/24/linux-ram/","link":"","permalink":"http://www.casezheng.date/2019/02/24/linux-ram/","excerpt":"","text":"内存映射只有内核可以访问物理内存内核给每个进程提供独立虚拟地址空间,虚拟地址空间连续,进程通过访问虚拟地址空间访问内存虚拟地址空间分为内核空间和用户空间进程在用户态只能访问用户空间内存,只有进入内核态后,才能访问内核空间内存.每个进程的地址空间都包含内核空间,但各个进程的内核空间其实关联的是相同的物理内存,当进程切换到内核态后,可以很方便地访问内核空间内存.虚拟内存通过内存映射来管理,只有实际使用的虚拟内存才会分配物理内存.内存映射将虚拟内存地址映射到物理内存地址,内核为每个进程维护一张页表,记录虚拟内存与物理地址的映射关系页面实际存储在CPU的内存管理单元MMU中当进程直接访问的虚拟内存在页表中查不到时,系统产生缺页异常,进入内核空间分配物理内存,更新进程页表,最后返回用户空间,恢复进程运行.TLB是MMU中页表的高速缓存,由于进程的虚拟内存地址独立,TLB的访问速度比MMU快,通过减少进程的上下文切换,减少TLB的刷新次数,提供TLB缓存的使用率,提高CPU访问内存的性能.MMU以页(通常为4K)为内存映射的最小单位,每次内存映射都需要关联4KB或4KB整数倍的内存空间.页的大小只有4K,导致页表非常大,Linux使用多级页表和大页解决这个问题.多级页表:把内存分为区块来管理,将原来的映射关系改为区块索引和区块的偏移.Linux使用四级页表管理内存页.虚拟内存分为5个部分大页:比普通页更大的内存块,常见大小2MB和1GB.大页使用在大量内存的进程上,比如Oracle,DPDK等. 虚拟内存空间分布虚拟内存空间用户空间内存,从低到高分别是五种不同的内存段 只读段,包括代码和常量等 数据段,包括全局变量等 堆,包括动态分配的内存,从低地址开始向上增长 文件映射段,包括动态库,共享内存等,从高地址向低地址向下增长 栈,包括局部变量和函数调用上下文等.栈的大小是固定的,一般为8MB,从高地址向低地址向下增长 堆和文件映射段的内存是动态分配的. 内存分配与回收malloc()是C标准库提供的内存分配函数,对应系统调用brk()和mmap().小块内存(小于128K)用brk()分配,通过移动堆顶的位置来分配内存,内存释放后不立即归还系统,先缓存起来,重复利用.大块内存(大于128K)用mmap()分配,直接用内存映射mmap()来分配,在文件映射段找一块空闲分配出来.brk()方式缓存可以减少缺页异常的发生,提高内存访问效率.由于内存未归还系统,在内存工作繁忙时,频繁的内存分配和释放会造成内存碎片.mmap()方式释放直接归还系统,但mmap()都会发生缺页异常,内存工作繁忙时,频繁的内存分配会导致大量的缺页异常,使内核的管理负担增大.当brk()和mmap()被调用时,其实并没有分配内存,只有首次访问这些内存时才分配,即通过缺页异常进入内核,再有内核来分配内存.Linux使用伙伴系统管理内存.伙伴系统以页为单位管理内存,并通过相邻页的合并减少内存碎片.Linux内核通过slab分配器管理小内存,主要作用是分配和释放内核中的小对象.内存只分配不释放会造成内存泄漏,甚至耗尽系统内存,在应用程序使用完内存后,需要调用free()或unmap()释放不用的内存. 系统在发现内存紧张时会通过一系列机制回收内存: 回收缓存 回收不常使用内存,把不常使用的内存通过交换分区(Swap)写到磁盘.Swap是把一块磁盘当作内存使用,把进程暂时不用的数据写入磁盘(换出),当进程访问这些内存时,再从磁盘读取数据到内存(换入).Swap使系统可用内存变大了,只有内存不足时才会发生Swap交换,由于磁盘读写速度远慢于内存,Swap会导致严重内存性能问题. 杀死进程,内存紧张时系统通过OOM(Out of Memory)直接杀死占用大量内存的进程.OOM是一种内核保护机制,监控进程内存使用情况,使用oom_soure为每个进程内存使用情况评分. 1. 进程消耗内存越大,oom_soure越大 2. 进程运行占用CPU越多,oom_soure就越小. oom_soure越大表示占用内存越多,越容易被OOM杀死.进程的oom_soure可以在/proc/PID/oom_soure进行查看,可以手动修改/proc/PId/oom_adj进行调整,oom_adj范围为[-17,15],-17表示禁用OOM.12345678$ ll /proc/15571/oom_*-rw-r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_adj-r--r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_score-rw-r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_score_adj$ cat /proc/15571/oom_*0160 参考资料 Linux内核OOM机制的详细分析","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"firefox配置","slug":"firefox-addons","date":"2019-02-18T13:59:14.000Z","updated":"2019-02-18T13:59:14.000Z","comments":true,"path":"2019/02/18/firefox-addons/","link":"","permalink":"http://www.casezheng.date/2019/02/18/firefox-addons/","excerpt":"","text":"AutoCopy LastPass New Tab Override uBlock Origin Hoxx VPN Proxy Saka Key 网页截图 HTTPS证书检查禁用进入 about:config更改security.enterprise_roots.enabled的值为true","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/tags/other/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"Hadoop概述","slug":"hadoop","date":"2019-01-24T05:03:28.000Z","updated":"2019-01-24T05:03:28.000Z","comments":true,"path":"2019/01/24/hadoop/","link":"","permalink":"http://www.casezheng.date/2019/01/24/hadoop/","excerpt":"Hadoop是一个能够对大量数据进行分布式处理的软件框架，具有可靠，高效，可伸缩的特点","text":"Hadoop是一个能够对大量数据进行分布式处理的软件框架，具有可靠，高效，可伸缩的特点 Hadoop组件 Common一组分布式文件系统和通用I/O的组件和接口(序列化、Java RPC和持久化数据结构) HDFS(Hadoop Distributed File System)分布式文件系统 MapReduce分布式并行编程模型 Hive分布式、按列存储数据库。Hive管理HDFS中存储的数据，并提供基于SQL的查询语言(由运行时引擎翻译为MapReduce作业)用以查询数据库 HBase一个分布式、按列存储数据库。HBase使用HDFS作为底层存储，支持MapReduce的批量式计算和点查询(随机读取) Sqoop在数据库和HDFS之间高效传输数据的工具(可以将一个关系型数据库（MySQL ，Oracle ，Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。) Pig一种数据流语言和运行环境，用以检索非常大的数据集.Pig运行在MapReduce和HDFS的集群上 Avro一种支持高效、跨语言的RPC以及永久存储数据的序列化系统 ZooKeeper分布式、高可用的协调服务，提供分布式锁之类的基础服务，用于构建分布式应用 Flume一个分布式、可靠的、高可用的海量日志聚合系统，可用于日志收集，日志数据处理，日志数据传输 Ambari一个基于Web的攻击，用来创建、管理、监视 Hadoop 的集群 Hodoop安装搭建本地源准备工作 安装nginxyum install nginx 禁用防火墙或打开ambari/hadoop集群所需要使用端口 禁用SELinux 重启服务器 编辑/etc/selinux/config修改SELINUX为SELINUX=disabled 在Ambari Server和Hadoop集群所有机器配置hosts IP地址根据实际的IP设置1127.0.0.1 ambari.casezhegn.date 压缩包下载12345# Ambariwget http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.2/ambari-2.6.2.2-centos7.tar.gz# Hadoopwget http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gzwget http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0/HDP-2.6.5.0-centos7-rpm.tar.gz 配置Nginx12345678910$cat ambari.casezheng.date.conf server &#123; listen 8088; server_name ambari.casezheng.date 127.0.0.1; root /data/hadoop/repo/; location / &#123; autoindex on; &#125;&#125; 重新加载nginx配置 拷贝文件到配置的nginx根目录下 解压文件 123tar zxvf ambari-2.6.2.2-centos7.tar.gztar zxvf HDP-2.6.5.0-centos7-rpm.tar.gztar zxvf HDP-UTILS-1.1.0.22-centos7.tar.gz 将解压文件放置在配置的nginx根目录下,目录层次结构如下 1234567891011121314151617181920212223242526$ pwd/data/hadoop/repo$ tree --filelimit 5.|-- ambari| `-- centos7| `-- 2.6.2.2-1 [9 entries exceeds filelimit, not opening dir]`-- HDP |-- HDP | `-- centos7 | `-- 2.6.5.0-292 [48 entries exceeds filelimit, not opening dir] `-- HDP-UTILS `-- centos7 `-- 1.1.0.22 |-- hdp-utils.repo |-- openblas [12 entries exceeds filelimit, not opening dir] |-- repodata [7 entries exceeds filelimit, not opening dir] |-- RPM-GPG-KEY | `-- RPM-GPG-KEY-Jenkins `-- snappy |-- snappy-1.1.0-3.el7.i686.rpm |-- snappy-1.1.0-3.el7.x86_64.rpm |-- snappy-devel-1.1.0-3.el7.i686.rpm `-- snappy-devel-1.1.0-3.el7.x86_64.rpm14 directories, 6 files 确保本地源可用访问,确保可以看到应有的repo内容(域名访问不通,可通过ip:端口号的方式访问)12http://ambari.casezheng.date:8088/ambari/centos7/http://ambari.casezheng.date:8088/hdp/ 添加ambari yum repo123456789$ cat /etc/yum.repos.d/ambari.repo#VERSION_NUMBER=2.6.2.2-1[ambari-2.6.2.2]name=ambari Version - ambari-2.6.2.2baseurl=http://ambari.huishoubao.com:8088/Ambari/centos7/2.6.2.2-1gpgcheck=1gpgkey=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.2/RPM-GPG-KEY/RPM-GPG-KEY-Jenkinsenabled=1priority=1 确保ambari yum repo可用1234$ yum repolist | grep ambariambari-2.6.2.2 ambari Version - ambari-2.6.2.2 12$ yum search ambari-serverambari-server.x86_64 : Ambari Server Ambari安装1yum install ambari-server 集群授权在ambari server上生成ssh key,并在其它所有节点将pub key设为信任key123$ ssh-keygen -b 4096cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keys 然后将~/.ssh/id_rsa.pub加入到集群所有机器的~/.ssh/authorized_keys并确保权限为600 配置和启动 mysql-connector 12345$ yum install mysql-connector-java*$ cd /var/lib/ambari-server/resources/$ ln -s /usr/share/java/mysql-connector-java.jar mysql-connector-java.jar $ ll mysql-connector-java.jar lrwxrwxrwx 1 root root 40 Jan 31 15:18 mysql-connector-java.jar -&gt; /usr/share/java/mysql-connector-java.jar 配置 一路回车 选错了先ambari-server reset再重新执行setup 1ambari-server setup 监听端口号修改 12$ cat /etc/ambari-server/conf/ambari.properties | grep &apos;client.api.port&apos;client.api.port=8081 命令 123456#启动ambari-server start#停止ambari-server stop#重启ambari-server restart ambari初始帐号/密码为admin,admin Hadoop安装 登录ambari 进入安装流程 Welcome to Apache Ambari -&gt; Launch install Wizard 输入集群名称 使用本地HDP源 选择Use Local Repository os选择redhat7 填入本地源地址 12http://ambari.casezheng.date:8088/HDP/HDP/centos7/2.6.5.0-292/http://ambari.casezheng.date:8088/HDP/HDP-UTILS/centos7/1.1.0.22/ 指定要安装Hadoop的机器 提供ambari server的ssh private key(~/.ssh/id_rsa) 安装会报错 给要安装Hadoop的机器安装ambari agent 1234567$ yum install ambari-agent#给 /etc/ambari-agent/conf/ambari-agent.ini 在[security]下面添加 force_https_protocol=PROTOCOL_TLSv1_2#修改 /etc/python/cert-verification.cfg 中verify的值verify=disable#重启ambari-agentambari-agent restart 重试安装失败的安装任务 根据需要安装Hadoop组件 指定hadoop集群所有服务各自的master节点 指定hadoop集群所有服务各自的slave以及client 配置(后期可以修改,主要指定目录,设置帐号,密码,设置MySQL) 安装&amp;启动 参数调整 参考资料 Hadoop生态圈介绍 走进hadoop生态圈 大数据技术原理与应用：大数据处理架构Hadoop生态圈 Hadoop家族学习路线图 Hadoop生态圈初识 Hortworks Hadoop生态圈简介 hadoop生态圈各个组件简介 Hadoop初探之Hadoop生态圈 一文看懂大数据的技术生态圈，Hadoop，hive，spark都有了","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://www.casezheng.date/tags/hadoop/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"数据仓库","slug":"data-warehouse","date":"2019-01-21T14:48:42.000Z","updated":"2019-01-21T14:48:42.000Z","comments":true,"path":"2019/01/21/data-warehouse/","link":"","permalink":"http://www.casezheng.date/2019/01/21/data-warehouse/","excerpt":"数据仓库数据仓库(Data Warehouse)是一个面向主题的、集成的、随时间变化的、但信息本身相对稳定的数据存储集合，用于对企业管理决策过程的支持。 面向主题:数据仓库针对某个主题来进行组织 集成:需要整合多个数据源的数据 稳定:数据一般只进行查询操作 随时间变化:定期接收新的集成数据,反应最新的数据变化 面向分析的存储系统","text":"数据仓库数据仓库(Data Warehouse)是一个面向主题的、集成的、随时间变化的、但信息本身相对稳定的数据存储集合，用于对企业管理决策过程的支持。 面向主题:数据仓库针对某个主题来进行组织 集成:需要整合多个数据源的数据 稳定:数据一般只进行查询操作 随时间变化:定期接收新的集成数据,反应最新的数据变化 面向分析的存储系统 数据仓库和操作型数据库区别面向主题是数据仓库和操作型数据库的根本区别,操作型数据库是为了支持各个业务而建立,分析型数据为了从各种繁杂业务中抽象出来的分析主题进行分析而建立 差异项 数据库 数据仓库 特征 操作处理 信息处理 面向 事务 分析 用户 DBA、开发 经理、主管、分析人员 功能 日常操作 长期信息需求、决策支持 DB设计 基于ER模型，面向应用 星形/雪花模型，面向主题 数据 当前的、最新的 历史的、跨时间维护 汇总 原始的、高度详细 汇总的、统一的 视图 详细、一般关系 汇总的、多维的 工作单元 短的、简单事务 复杂查询 访问 读/写 大多为读 关注 数据进入 信息输出 操作 主键索引操作 大量的磁盘扫描 用户数 数百到数亿 数百 DB规模 GB到TB &gt;=TB 优先 高性能、高可用性 高灵活性 度量 事务吞吐量 查询吞吐量、响应时间 数据仓库组件数据仓库核心组件有4个:源数据库,ETL,数据仓库,前端应用 源数据库:业务系统数据,外部数据 ETL:提取extraction、转换transformation、加载load。提取过程表示操作型数据库搜集指定数据，转换过程表示将数据转化为指定格式并进行数据清洗保证数据质量，加载过程表示将转换过后满足指定格式的数据加载进数据仓库。数据仓库会周期不断地从源数据库提取清洗好了的数据 前端应用:数据查询,展示 数据集市包含单个主题的小型数据仓库,关注范围小(不关注全局) 独立数据集市:有自己的源数据库和ETL架构 非独立数据集市:没有自己的源数据库,数据来自数据仓库(是数据仓库的一个子集) 数据仓库建模纬度建模是专门用于分析型数据库,数据仓库,数据集市建模的方法,属于关系建模方法,比操作型数据库的建模方法多了两个概念(维度表和事实表) 维度表:表示对分析主题所属类型的描述,通常维度表比较固定且数据量小 事实表:表示对主题分析的量度,事实表通常是数值类型,且记录数会不断增加,表规模迅速增长 纬度建模三种模式 星形模式(一个事实表和多个维度表) 雪花模式(对星形模式的扩展,每个维度表可向外连接多个子维度表) 星座模式(对星形模式的扩展,每个多个事实表) 12345678 星形模式 | --------------- | |规范化设计 多个事实表 | | | |雪花模式 星座模式 数据仓库建模体系 规范化数据仓库 维度建模数据仓库 独立数据集市 数据仓库建模体系对比 数据仓库系统实现与使用ETL(抽取,转换,加载)ETL工作本质:从各个工作源抽取数据,对数据进行转化,并最终加载到数据仓库维度建模后的表中 抽取(Extract) 根据数据仓库主题从应用数据库抽取数据 转换(Transform) 对抽取的数据的结构进行转换,满足目标数据仓库模型的过程(数据清洗) 加载(Load) 将提前好的数据在确保数据质量后加载到目标数据仓库(首次加载和刷新加载) OLAP/BI工具OLAP:在线分析处理(On-line Analytical Processing)OLAP专门用于纬度建模数据分析BI工具将OLAP的结果以图表的方式展现出来 数据立方体数据立方体是N维的数据立方体五大操作:切片,切块,旋转,上卷,下钻 OLAP架构模式ROLAP(Relational Online Analytical Processing)关系式OLAP使用星形模式以及多个关系表对数据立方体进行模拟,所有查询都被转化为SQL语句执行,SQL语句涉及多个表之间的JOIN操作,速度慢基于RDBMS技术,通过并行化/内存加速计算 Hive/Presto/Spark SQL/Dirll优点: 1. 支持任意的SQL表达式 2. 无数据冗余和预处理 不足: 1. 大量数据/复杂查询下分钟/小时级响应 2. 低并发 3. 不支持实时数据 适用场景: 对灵活性要求不高的即席查询场景 MOLAP(Multidimensional Online Analytical Processing)多维度OLAP生成一个多维数据集,构建一个实际数据立方体,常用查询被预先计算,每次查询都非常快速,但立方体更新比较慢预先聚合明细数据,系统中存储汇总数据 Kylin/Druid优势: 1. 支持超大原始数据集 2. 高性能高并发 不足: 1. 不支持明细数据查询 2. 需要预先定义维度和指标(度量) 适用场景: 1. 对性能要求非常高的OLAP场景 2. 交互式分析 搜索引擎Search Engines基于搜索引擎技术,通过索引加速计算(Elasticsearch / Solr)优势: 1. 强大的明细检索功能 2. 同时支持实时与离线数据 不足: 1. 大量数据/复杂查询下分钟/小时级响应 2. 复杂聚合计算下低并发 3. 不支持JOIN/子查询 适合场景:中小数据规模(~亿级)的简单OLAP分析 HOLAP(Hybrid Online Analytical Processing)参考MOLAP和ROLAP的混合解决方案,将需要特别提速的查询放在MOLAP引擎,其他查询则调用ROLAP引擎 ROLAP MOALP HOLAP的对比| 名称 | 描述 | 细节数据存储位置 | 聚合后的数据存储位置 || :—: | :—: | :—: | :—: || ROLAP(Relational OLAP) | 基于关系数据库的OLAP实现 | 关系型数据库 | 关系型数据库 || MOLAP(Multidimensional OLAP) | 基于多维数据组织的OLAP实现 | 数据立方体 | 数据立方体 || HOLAP(Hybrid OLAP) | 基于混合数据组织的OLAP实现 | 关系型数据库 | 数据立方体 | OLAP引擎比较 OLAP引擎简介HiveElasticSearchKylin参考资料 数据仓库概述 数据仓库与数据集市建模 数据仓库系统的实现与使用(含OLAP重点讲解) 数据仓库(Data Warehouse)介绍及设计原则 数据仓库的架构与设计 数据库需求与ER建模 Meetup-Druid和Kylin在美团点评的选型与实践 浅谈ROLAP、MOLAP和HOLAP区别","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"数据库建模","slug":"database-modeing","date":"2019-01-20T10:57:04.000Z","updated":"2019-01-20T10:57:04.000Z","comments":true,"path":"2019/01/20/database-modeing/","link":"","permalink":"http://www.casezheng.date/2019/01/20/database-modeing/","excerpt":"","text":"ER建模数据库建设最重要的一步:需求分析阶段(ER建模阶段)ER建模阶段:数据库开发人员协同需求方以ER图的方式对业务需求进行可视化展现 实体(entity):表示客观世界中的众多概念 ER图中矩形表示 属性(attribute):每个实体都有属性 ER图中椭圆表示 联系(relation):实体和实体之间通常具有某种联系 ER图中菱形表示 一对一 一对多 多对多 ER模型到关系表的映射(逻辑模型建模或者关系建模)数据库设计三大范式有效避免数据冗余导致的更新异常 第一范式(1NF) 每个列都是不可再分的属性值,确保每一列的原子性(确保每列保持原子性) 第二范式(2NF) 在满足第一范式的基础上,必须有主键,没有包含在主键中的列必须完全依赖于主键,而不能只依赖主键的一部分(确保表中的每列都和主键相关) 第三范式(3NF) 在满足第二范式的基础上,非主键必须直接依赖于主键(确保每列都和主键列直接相关，而不是间接相关) 参考资料 数据库设计入门经典 数据库三大范式详解（通俗易懂） 数据库设计三大范式（简单易懂） 数据库关系建模 数据库需求与ER建模 更新异常与规范化设计","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"linux性能优化","slug":"linux-performance-optimization","date":"2018-12-07T16:11:35.000Z","updated":"2019-12-23T15:45:35.000Z","comments":true,"path":"2018/12/08/linux-performance-optimization/","link":"","permalink":"http://www.casezheng.date/2018/12/08/linux-performance-optimization/","excerpt":"","text":"linux性能优化学习 性能指标高并发和响应快 两个核心指标:吞吐和延时,从应用负载视角考察性能,直接影响产品终端的用户体验,相对应的从系统资源出发的指标(资源使用率,饱和度等)性能问题的本质:系统资源到达瓶颈,请求处理不够快,无法支撑更多请求性能分析:找出应用或系统的瓶颈,并设法避免或缓解,更高效的利用系统资源处理更多请求 平均负载使用uptime可以查看系统负载12$ uptime 00:38:27 up 62 days, 14 min, 2 users, load average: 0.00, 0.04, 0.07 显示内容说明:123400:38:27 系统当前时间up 62 days, 14 min 主机已运行时间2 users 用户连接数load average: 0.00, 0.04, 0.07 系统平均负载,统计最近1,5,15分钟的系统平均负载 系统平均负载:指单位时间内，系统处于可运行状态和不可中断状态的平均进程数, 即平均活跃进程数可运行状态:正在使用CPU和正在等待CPU的进程(使用ps命令看到的处于R状态的进程)不可中断状态:正处于内核态不可被打断的关键流程中的进程(不可中断状态是系统对进程和硬件设备的一种保护机制)平均活跃进程不仅包括正在使用CPU的进程也包括等待CPU和等待I/O的进程,因此平均负载高不一定是CPU使用率高,也可能是I/O更繁忙了 系统逻辑CPU核心数可以使用top命令或者从文件/proc/cpuinfo中读取12$ grep &apos;model name&apos; /proc/cpuinfo | wc -l1 uptime命令会显示1分钟,5分钟,15分钟的平均负载,可以用来分析系统负载趋势系统负载异常需要结合历史数据,判断负载的变化趋势,当负载有明显升高趋势时再分析调查 stress命令是Linux系统压力测试工具 —cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，—timeout 执行时间 123stress --cpu 1 --timeout 600 CPU密集型进程 模拟一个CPU使用率100%的场景 持续600sstress -i 1 --timeout 600 I/O密集型进程 模拟I/O压力 持续600sstress -c 8 --timeout 600 大量进程的场景 模拟8个进程 持续600s sysstat包,包含了常用的Linux性能工具,用来监控和分析系统性能 mpstat多核CPU性能分析工具,用来实时查看每个CPU的性能指标和所有CPU的平均指标 123456789101112131415161718$ mpstat -P ALL 5 3 显示所有CPU的指标,并每间隔5s输出一组数据,一共输出3组Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 01/03/2019 _x86_64_ (1 CPU)01:41:06 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle01:41:11 PM all 0.20 0.00 0.20 0.20 0.00 0.00 0.00 0.00 0.00 99.4001:41:11 PM 0 0.20 0.00 0.20 0.20 0.00 0.00 0.00 0.00 0.00 99.4001:41:11 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle01:41:16 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.0001:41:16 PM 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.0001:41:16 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle01:41:21 PM all 0.20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 99.8001:41:21 PM 0 0.20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 99.80Average: CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idleAverage: all 0.13 0.00 0.07 0.07 0.00 0.00 0.00 0.00 0.00 99.73Average: 0 0.13 0.00 0.07 0.07 0.00 0.00 0.00 0.00 0.00 99.73 pidstat进程性能分析工具,用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标 123456789101112$ pidstat -u 5 1 每5s输出一组数据Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 01/03/2019 _x86_64_ (1 CPU)01:46:19 PM UID PID %usr %system %guest %CPU CPU Command01:46:24 PM 1000 21765 0.20 0.00 0.00 0.20 0 vim01:46:24 PM 1000 22625 0.00 0.20 0.00 0.20 0 pidstat01:46:24 PM 994 28861 0.00 0.20 0.00 0.20 0 redis-serverAverage: UID PID %usr %system %guest %CPU CPU CommandAverage: 1000 21765 0.20 0.00 0.00 0.20 - vimAverage: 1000 22625 0.00 0.20 0.00 0.20 - pidstatAverage: 994 28861 0.00 0.20 0.00 0.20 - redis-server watch以周期性的方式执行给定的指令，指令输出以全屏方式显示 1watch -d uptime CPU上下文切换CPU上下文切换的工作原理CPU寄存器是CPU内置的容量小,但速度极快的内存. 程序计数器(PC)是用来存储CPU正在执行的指令位置,或者即将执行的下一条指令位置. CPU寄存器和程序计数器都是CPU在运行任何任务之前,必须的依赖环境.CPU寄存器和程序计数器被称为CPU上下文.CPU上下文切换:把前一个任务的CPU上下文保存起来,然后加载新任务的上下文到CPU寄存器和程序计数器中,最后再跳转到程序计数器所指的新位置,运行新任务.保存下来的上下文,存储在系统内核中,在系统再次调度执行时再次加载进来,保证任务原先的状态不受影响,让任务看起来还是连续运行的. CPU上下文切换根据任务不同,分为3个不同场景:进程上下文切换,线程上下文切换,中断上下文切换 进程上下文切换Linux按照特权等级把进程的运行空间分为内核空间和用户空间. 内核空间具有最高权限,可以访问所有资源 用户空间只能访问受限资源,不能直接访问内存等硬件设备,必须通过系统调用陷入到内核中,才能访问这些资源 即:进程既可以在用户空间运行,又可以在内核空间运行,进程在用户空间运行称为进程的用户态,陷入到内核空间的时候,称为进程的内核态从用户态到内核态的转变,需要通过系统调用完成.系统调用会发生2次CPU上下文的切换,从用户态到内核态,CPU寄存器里用户态的指令位置需要先保存起来,CPU寄存器再更新为内核态指令的新位置,最后跳到内核态运行内核任务.系统调用后,CPU寄存器需要恢复原来保存用户态,然后再切换到用户空间,继续运行程序.系统调用过程不涉及虚拟内存等进程用户态的资源,也不切换进程 进程上下文切换是指从一个进程切换到另一个进程运行 系统调用过程一直在同一个进程运行 进程是由内核来管理和调度,进程的切换只能发生在内核态,进程的上下文包括虚拟内存,栈,全局变量等用户空间的资源和内核堆栈,寄存器等内核空间的状态进程的上下文切换:在保存当前进程的内核状态和CPU寄存器之前,需要将该进程的虚拟内存,栈等保存下来,加载了下一个进程的内核态后,需要刷下进程的虚拟内存和用户栈进程上下文切换频繁,很容易导致CPU将大量时间耗费在寄存器,内核栈以及虚拟内存等资源的保存和恢复上,缩短了真正运行进程的时间,导致平均负载升高Linux通过TLB(快表,虚拟地址到物理地址的转换表)管理虚拟内存到物理内存的映射关系,当虚拟内存更新后,TLB也需要更新,内存访问也会随之变慢.多处理器系统,缓存被多个处理器共享,刷新缓存不仅影响当前处理器的进程,也影响共享缓存其它处理器的进程.进程上下文切换的时机: 进程时间片耗尽 系统资源不足,进程被挂起,先执行其他进程,等资源满足时再运行 进程sleep主动挂起 有更高优先级进程时 有硬件中断时,CPU上进程被挂起,转而执行内核中的中断服务程序 线程上下文切换线程和进程的最大区别:线程是调度的基本单位,进程是资源拥有的基本单位 当进程只有一个线程时,可以认为进程就等于线程 当进程拥有多个线程时,这些线程共享相同的虚拟内存和全局变量资源,这些资源在上下文切换中不需要修改 线程也有自己的私有数据(例如栈和寄存器等),在上下文切换时需要保存 线程上下文切换: 两个线程数据不同进程,资源不共享,上下文切换过程与进程上下文切换一样 两个线程属于同一个进程,有许多共享资源,切换时,虚拟内存等共享资源保持不动,只切换线程的私有数据,寄存器等不共享资源. 中断上下文切换中断处理会打断进程的正常调度和执行,转而调用中断处理程序,响应设备事件中断上下文切换不涉及进程的用户态,中断上下文只包括内核态中断服务程序处理所必须的状态,包括CPU寄存器,内核堆栈,硬件中断参数等 系统上下文切换情况的查看vmstat主要用来分析系统内存使用情况,也可分析CPU上下文切换和中断次数123456#每隔5s输出一次数据$ vmstat 5procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 2 0 520 894220 230456 519308 0 0 2 29 33 53 0 0 99 0 0 0 0 520 893940 230460 519348 0 0 0 13 46 66 0 0 99 0 0 cs(context switch)是每秒上下文切换次数 in(interrupt)是每秒中断次数 r(Running or Runnable)是就绪队列长度(正在运行或等待CPU的进程数) b(Blocked)是处于不可中断睡眠状态的进程数 vmstat给出系统总体的上下文切换情况,每个进程的详细情况,需要使用pisstat查看12345678910111213141516171819#每隔5s输出一组数据 -w参数报告任务切换情况$ pidstat -w 5Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 01/15/2019 _x86_64_ (1 CPU)11:55:15 PM UID PID cswch/s nvcswch/s Command11:55:20 PM 0 3 0.80 0.00 ksoftirqd/011:55:20 PM 0 9 9.38 0.00 rcu_sched11:55:20 PM 0 11 0.20 0.00 watchdog/011:55:20 PM 0 31 0.20 0.00 khugepaged11:55:20 PM 0 219 0.80 0.00 kworker/0:1H11:55:20 PM 0 221 0.20 0.00 kworker/u2:211:55:20 PM 0 249 0.80 0.00 jbd2/vda1-811:55:20 PM 0 698 1.20 0.00 smbd11:55:20 PM 0 1306 0.40 0.00 cleanupd11:55:20 PM 1000 25163 1.00 0.00 python3611:55:20 PM 1000 25355 0.40 0.00 sshd11:55:20 PM 1000 25634 0.20 0.00 sshd11:55:20 PM 0 26461 1.20 0.00 kworker/0:011:55:20 PM 1000 26575 0.20 0.00 pidstat cswch 每秒自愿上下文切换的次数 指进程无法获取所需资源,导致的上下文切换 nvcswch 每秒非自愿上下文切换的次数 指进程由于时间片已到等原因,被系统强制调度,进而发生的上下文切换 1234567891011121314151617181920212223242526272829303132333435#-wt参数输出线程的上下文切换指标$ pidstat -wt 5Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 01/16/2019 _x86_64_ (1 CPU)12:10:12 AM UID TGID TID cswch/s nvcswch/s Command12:10:17 AM 0 3 - 0.40 0.00 ksoftirqd/012:10:17 AM 0 - 3 0.40 0.00 |__ksoftirqd/012:10:17 AM 0 9 - 0.80 0.00 rcu_sched12:10:17 AM 0 - 9 0.80 0.00 |__rcu_sched12:10:17 AM 0 11 - 0.40 0.00 watchdog/012:10:17 AM 0 - 11 0.40 0.00 |__watchdog/012:10:17 AM 0 31 - 0.20 0.00 khugepaged12:10:17 AM 0 - 31 0.20 0.00 |__khugepaged12:10:17 AM 0 219 - 0.80 0.00 kworker/0:1H12:10:17 AM 0 - 219 0.80 0.00 |__kworker/0:1H12:10:17 AM 0 221 - 0.20 0.00 kworker/u2:212:10:17 AM 0 - 221 0.20 0.00 |__kworker/u2:212:10:17 AM 0 249 - 0.60 0.00 jbd2/vda1-812:10:17 AM 0 - 249 0.60 0.00 |__jbd2/vda1-812:10:17 AM 0 - 1308 1.00 0.00 |__tuned12:10:17 AM 0 - 901 1.20 0.00 |__in:imjournal12:10:17 AM 27 - 1278 1.99 0.00 |__mysqld12:10:17 AM 27 - 1279 1.99 0.00 |__mysqld12:10:17 AM 27 - 1280 1.99 0.00 |__mysqld12:10:17 AM 27 - 1281 1.99 0.00 |__mysqld12:10:17 AM 27 - 1282 1.99 0.00 |__mysqld12:10:17 AM 27 - 1283 1.99 0.00 |__mysqld12:10:17 AM 27 - 1284 1.99 0.00 |__mysqld12:10:17 AM 27 - 1285 1.99 0.00 |__mysqld12:10:17 AM 27 - 1286 1.99 0.00 |__mysqld12:10:17 AM 27 - 1287 1.99 0.00 |__mysqld12:10:17 AM 27 - 1289 1.00 0.00 |__mysqld12:10:17 AM 27 - 1290 1.00 0.00 |__mysqld12:10:17 AM 27 - 1291 0.20 0.00 |__mysqld12:10:17 AM 27 - 1292 0.20 0.00 |__mysqld CPU使用率 user(us),用户态CPU时间,不包含nice时间,包括了guest时间 nice(ni),低优先级用户态时间,即进程优先级被调整为1-19(nice取值范围为-20到19,数值越大优先级反而越低)之间时的CPU时间 system(sys),内核态CPU时间 idle(id),空闲时间,不包括等待I/O的时间(iowait) iowait(wa),等待I/O的CPU时间 irq(hi),处理硬中断的CPU时间 softirq(si),处理软中断的CPU时间 steal(st),当系统运行在虚拟机中的时候,被其他虚拟机占用的CPU时间 guest(guest),代表通过虚拟化运行其他操作系统的时间(运行虚拟机的CPU时间) guest_nice(gnice),代表以低优先级运行虚拟机的时间 CPU使用率:除了空闲时间外的其他时间占总CPU时间的百分比性能工具计算CPU使用率取一段时间的两次值,做差后,再计算这段时间内的平均CPU使用率1平均CPU使用率=1-((空闲时间new-空间时间old)/(总CPU时间new-总CPU时间old)) 由于性能工具给出的都是一段时间平均CPU使用率,所以要注意间隔时间的设置.(多个性能工具对比分析时,要保证它们用的相同的间隔) CPU使用率查看 top显示系统总体的CPU和内存使用情况,以及各个进程的资源使用情况 ps只显示各个进程的资源使用情况 pidstat专门分析每个进程占用系统资源的工具 CPU使用过高使用perf分析perf是Linux下的性能分析工具,能够进行函数与指令级的热点查找 perf top实时显示占用CPU时钟最多的函数或指令,用来查找热点函数或者指令 perf record提供保存数据功能 perf report解析展示record的数据 perf top和perf record添加-g参数开启调用关系采样,方便根据调用链分析性能问题 常规方法无法找到CPU使用率问题 应用直接调用了其他二进制程序,运行时间较短,通过top等工具不易发现 应用本身不断崩溃重启,启动过程资源初始化,很可能占用相当多的CPU 可以通过pstree找到进程的父进程,再从父进程所在应用入手,排查问题根源 进程进程状态 R(Running或Runnable)表示进程在CPU的就绪队列中,正在运行或正在等待运行 D(Disk Sleep)不可中断睡眠状态,一般表示进程正在跟硬件交互,并且交互过程不允许被其他进程或中断打断 Z(Zombie)僵尸进程,进程实际已经结束了,但父进程还没有回收它的资源 S(Interruptible Sleep)可中断睡眠状态,表示进程因为等待某个事件而被系统挂起.当进程等待的事件发生时,它将被唤醒并进入R状态 I(Idle)空闲状态,用在不可中断睡眠的内核线程上. T或t(Stopped或Traced),表示进程处于暂停或者跟踪状态 X(Dead)表示进程已经消亡(top或者ps命令中不会看到它) dstat是一个全能系统信息统计工具12345678910$ dstat You did not select any stats, using -cdngy by default.----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--usr sys idl wai hiq siq| read writ| recv send| in out | int csw 9 2 72 17 0 0|6902k 88k| 0 0 |1550B 22k| 501 500 96 4 0 0 0 0| 0 0 | 54B 154B| 0 0 |1120 450 96 4 0 0 0 0| 0 0 | 164B 1188B| 0 0 |1163 462 88 12 0 0 0 0| 0 0 | 164B 456B| 0 0 |1156 579 23 4 70 3 0 0| 12k 192k| 164B 456B| 0 0 | 503 631 1 2 95 2 0 0| 116k 0 |1090B 1300B| 0 0 | 267 353 僵尸进程使用pstree找出其父进程,在父进程中解决 软中断中断是一种异步的事件处理机制,可以提高系统的并发处理能力中断处理程序会打断其他进程的进行,所以,中断处理程序需要尽可能快的运行,减少对正常进程运行调度的影响Linux将中断过程分为两个阶段,解决中断处理程序执行过长和中断丢失的问题 上半部:快速处理中断,在中断禁止模式运行,主要处理跟硬件紧密相关的或时间敏感的工作,直接处理硬件请求,硬中断,快速执行 下半部:延迟处理上半部未完成的工作,通常以内核线程的方式运行,由内核触发,软中断,延迟执行 软中断和内核线程查看/proc/softirqs 软中断运行情况/proc/interrupts 硬中断运行情况 软中断内核线程 ksoftirqd/CPU 编号12$ ps aux | grep ksoftirqd | grep -v greproot 3 0.0 0.0 0 0 ? S Feb19 0:08 [ksoftirqd/0] CPU性能CPU性能指标 CPU性能工具根据指标找工具 性能指标 工具 说明 平均负载 uptime top uptime最简单; top提供更全的指标 系统整体CPU使用率 vmstat mpstat top sar /proc/stat top vmstat mpstat只可以动态查看,sar可以记录历史数据 /proc/stat是其它性能工具的数据来源 进程CPU使用率 top pidstat ps htop atop top和ps可以按CPU使用率给进程排序,而pidstat只显示实际用了CPU的进程 htop和atop以不同颜色显示更直观 系统上下文切换 vmstat 除了系统上下文切换数,还提供运行状态和不可中断状态进程数量 进程上下文切换 pidstat -w参数 软中断 top /proc/softirqs mpstat top提供软中断CPU使用率 /proc/softirqs和mpstat提供各种软中断在每个CPU上的运行次数 硬中断 vmstat /proc/interrupts vmstat提供总的中断次数 /proc/interrupts提供各个中断在每个CPU上运行的基类次数 网络 dstat sar tcpdump dstat sar提供总的网络接收和发送情况 tcpdump动态抓取正在进行的网络通信 I/O dstat sar dstat和sar都提供了I/O的整体情况 CPU个数 /proc/cpuinfo lscpu lscpu更直观 事件剖析 perf execsnoop perf可以用来分析CPU的缓存以及内核调用链,execsnoop用来监控短时进程 根据工具查指标 性能指标 CPU性能指标 uptime 平均负载 top 平均负载、运行队列、整体的CPU使用率以及每个进程的状态和CPU使用率 htop top增强版,以不同颜色区分不同类型的进程,更直观 atop CPU/内存/磁盘/网络等各种资源的全面监控 vmstat 系统整体的CPU使用率/上下文切换次数/中断次数,包括处于运行和不可中断状态的进程数量 mpstat 每个CPU的使用率和软中断次数 pidstat 进程和线程的CPU使用率/中断上下文切换次数 /proc/softirqs 软中断类型和在每个CPU上的累计中断次数 /proc/interrupts 硬中断类型和在每个CPU上的累计中断次数 ps 每个进程的状态和CPU使用率 pstree 进程的父子关系 dstat 系统整体的CPU使用率 sar 系统整体CPU使用率,包括可配置的历史数据 strace 进程的系统调用 perf CPU性能事件剖析,调用链/CPU缓存/CPU调度等 execsnoop 监控短时进程 性能分析 CPU性能优化CPU优化 应用程序优化 编译器优化,编译器优化选项 例如:gcc优化选项-O2 算法优化 异步处理 多线程代替多进程 善用缓存 系统优化 CPU绑定 CPU独占 优先级调整 为进程设置资源限制 NUMA(Non-Uniform Memory Access)优化 中断负载均衡 Linux内存Linux内存原理Linux内存简介 Linux内存使用情况查看free命令可以查看系统内存使用情况12345678$ free total used free shared buff/cache availableMem: 1882860 589828 387196 112 905836 1090592Swap: 2047996 105736 1942260$ free -m total used free shared buff/cache availableMem: 1838 576 377 0 885 1064Swap: 1999 103 1896 Mem物理内存使用情况,Swap交换分区使用情况 total总内存大小 used已使用内存大小,包含共享内存 free未使用内存大小 shared共享内存大小 buff/cache缓存和缓冲区大小 available新进程可用内存大小,不仅包含未使用内存,也包括可回收的缓存,一般会比未使用内存大,但并不是所有缓存都可以被回收. free显示整个系统内存使用情况,进程内存使用情况用top或ps等工具查看.123456789Tasks: 88 total, 1 running, 87 sleeping, 0 stopped, 0 zombie%Cpu(s): 1.7 us, 0.7 sy, 0.0 ni, 97.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882860 total, 384436 free, 590704 used, 907720 buff/cacheKiB Swap: 2047996 total, 1942260 free, 105736 used. 1089708 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND22272 root 20 0 3438356 326068 6172 S 0.3 17.3 27:45.68 java16200 root 20 0 2488224 55908 6636 S 0.3 3.0 8:51.48 java 538 CaseZhe+ 20 0 945436 52264 7216 S 0.3 2.8 1:31.74 vim 547 CaseZhe+ 20 0 1113148 51592 25008 S 0.0 2.7 0:00.80 python36 VIRT进程虚拟内存大小,只要是进程申请过的内存,即使还没有真正分配物理内存,也计算在内 RES常驻进程内存大小,进程实际使用的物理内存大小,但不包括Swap和共享内存 SHR共享内存大小(和其他进程共同使用的共享内存/加载的动态链接库/程序代码段等) %MEM进程使用物理内存占系统总内存的百分比 参考 Linux性能优化实战 Linux命令大全 Linux命令手册","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"nginx学习笔记","slug":"nginx","date":"2018-11-20T01:50:37.000Z","updated":"2018-11-20T01:50:37.000Z","comments":true,"path":"2018/11/20/nginx/","link":"","permalink":"http://www.casezheng.date/2018/11/20/nginx/","excerpt":"","text":"nginx介绍轻量级,高性能,跨平台Web服务器,基于REST架构风格,以统一资源描述符(URI)或统一资源定位符(URL)作为沟通依据,通过HTTP为浏览器等客户端程序提供各种网络服务. nginx特性 更快 单次请求得到更快的响应 高并发下比其它web服务器更快地响应请求 高扩展性 高可靠性 低内存消耗 高并发 热部署 不停服升级nginx,不停服更新配置,不停服更快日志文件等 开源(BSD许可) 核心:支持高并发的同时保持高效的服务 nginx编译安装源码获取nginx官网123wget http://nginx.org/download/nginx-1.15.6.tar.gztar zxvf nginx-1.15.6.tar.gzcd nginx-1.15.6 编译安装123./configuremakemake install configure命令检测操作系统内核,检测已安装软件,参数解析,中间目录生成,根据参数生成C源码文件和Makefile文件make执行configure命令生成的Makefile文件编译nginx工程,并生成目标文件和最终的二进制文件make install根据configure执行时的参数将nginx部署到指定的安装目录,包括相关目录的建立和二进制文件,配置文件的复制 nginx命令启动默认配置文件/usr/local/nginx/conf/nginx.conf1/usr/local/nginx/sbin/nginx 可以通过-c参数指定配置文件1/usr/local/nginx/sbin/nginx -c /etc/nginx.conf 测试配置文件信息是否有错误1/usr/local/nginx/sbin/nginx -t 停止服务stop强制停止nginx服务quit处理完所有当前请求再停止服务12/usr/local/nginx/sbin/nginx -s stop/usr/local/nginx/sbin/nginx -s quit 重读配置并生效1/usr/local/nginx/sbin/nginx -s reload 日志文件回滚先将当前日志文件改名或转移到别的地址,再执行下面命令生成新的日志文件1/usr/local/nginx/sbin/nginx -s reopen nginx配置nginx进程在生产环境部署nginx都是采用一个master进程管理多个worker进程的模式.一般情况下,woker进程的数量和服务器上的CPU核心数相等即可(最好每个worker进程都绑定特定的CPU核心,让进程间切换的代价最小).woker进程提供正在的互联网服务,master进程负责监控woker进程(当worker进程意外退出立即启动新的worker进程继续提供服务),为管理员提供命令行服务(启动服务,停止服务,重新载入配置,平滑升级程序等)123456789 |--&gt; worker进程 ------HTTP请求---- Client | |--&gt; worker进程 ------HTTP请求---- Client | |master进程 ---管理---- |---HTTP请求---- Client | |--&gt; worker进程 ------HTTP请求---- Client | |--&gt; worker进程 ------HTTP请求---- Client nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#块配置项由一个块配置项名和一对大括号组成 events http server location upstream等都是块配置项#块配置项一定会用大括号把所属的一系列所属的配置项包含进来,表示大括号内的配置项同时生效#块配置项可以嵌套,内层块直接继承外层块#配置项单位 空间: K或者k千字节 M或m兆字节 时间:ms(毫秒),s(秒),m(分钟),h(小时),d(天),w(周),M(月),y(年)#以守护进程方式运行Nginx 默认ondaemon on;#以mater/worker(一个master进程管理多个worker进程)方式工作,如果关闭就不会fork出worker子进程,而是master进程自身来处理请求 默认onmaster_process on;#error日志设置 语法: error_log /path/file level;#/path/file是一个具体文件, /path/file也可以设置为/dev/null,不再输出任何日志(关闭error日志的唯一手段)#level是日志等级 debug info notice warn error crit alert emerg 从左到右等级依次增大 如果想把日志等级设置为debug,必须在configure时加入--with-debug配置项error_log /var/log/nginx/error.log error;#error_log logs/error.log notice;#error_log logs/error.log info;#限制coredump核心转储文件的大小,防止core文件过大占满了磁盘 语法: worker_rlimit_core size;worker_rlimit_core 1024M;#指定coredump文件生成目录,worker进程的工作目录,该配置的唯一用途是设置coredump文件防止的目录,协助定位问题,需要确保worke进程有权限向working_directory指定目录写入文件 语法: working_directory path;working_directory /data/nginx;#定义环境变量 语法: env VAR|VAR=VALUE; 该配置让用户直接操作操作系统上的环境变量#嵌入其他配置文件 语法: inclue /path/file; 将其它配置文件嵌入到当前的nginx.conf文件中,参数可以是绝对路径也可以是相对路径(相对nginx配置目录)#include nginx.d/http/server.casezheng.com.conf#include nginx.d/*.conf#pid文件路径 保存master进程ID的pid文件存储路径.默认和configure设置的--pid-path所指定位置相同,需要确认nginx有权在相应目录中建立pid文件pid /run/nginx.pid;#ningx worker进程运行的用户及用户组user nginx;#设置一个nginx worker进程可以打开的最大文件描述符个数worker_rlimit_nofile 65535;#限制信号队列 设置每个用户发往nginx的信号队列的大小,当某个用户的信号队列满了,该用户发送的信号量将被丢弃#worker_rlimit_sigpending limit;#nginx worker进程个数 在master/worker运行方式下,定义worker进程的个数worker_processes auto;#绑定nginx worker进程到指定的CPU内核 语法: worker_cpu_affinity cpumask [cpumask...]; 该配置仅针对Linux操作系统有效#SSL硬件加速 如果服务器上有SSL硬件加速设备,可以进行配置加快SSL协议的处理速度.用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备: openssl engine -t#ssl_engine device;#nginx worker进程的优先级设置, 优先级有静态优先级和进程执行情况共同决定.这里设置的是静态优先级. 语法: worker_priority nice; nice -20 ~ +19, -20最高优先级 +19最低优先级 希望nginx占用更多系统资源可以将其设置小点,但不建议比内核进程的nice(-5)小.#worker_priority 0;include /usr/share/nginx/modules/*.conf;events &#123; #对指定的客户端输出debug级别的日志 语法: debug_connection [IP|CIDR]; 该配置属于事件类配置,必须放在events配置块中才有效,值可以是IP地址或CIDR地址 可以用于高并发请求下定位问题 debug_connection 127.0.0.1; debug_connection 127.0.0.0/24; #accept锁 accept_mutex是Nginx的负载均衡锁,让多个worker进程轮流的,序列化地与新的客户端建立TCP连接,当一个worker进程建立的连接达到worker_connections配置的最大连接数的7/8时,大大减少该worker进程试图建立新TCP连接的机会,以此实现所有worker进程上处理的客户端请求数尽量接近. accept锁默认打开,关闭后建立TCP连接的耗时会更短,但worker进程间的负载会不均衡,因此不建议关闭它 accept_mutex on; #使用accept锁后真正建立连接的延迟时间 语法: accept_mutext_delay Nms; 在使用accept锁后,同一时间只有一个worker进程可以获取到accept锁,accept锁不是阻塞锁,如果获取不到会立即返回.如果有一个worker进程试图获取accept锁而没有获取到,至少要等accept_mutex_delay定义的时间间隔后才能再次试图获取锁. #批量建立新连接 当事件模型通知有新连接时,尽可能对本次调度中客户端发起的所有TCP请求都建立连接. 语法: multi_accept [on|off]; multi_accept off; #选择事件模型 语法: use [kququ | rtsig | epoll | /dev/poll | select | poll | eventport]; nginx默认会选择最合适的事件模型 use epoll; #每个worker可以处理的最大连接数 worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #gzip on; #内存和磁盘资源的分配 #client_body_in_file_only HTTP包体只存储在磁盘空间中 语法:client_body_in_file_only on|clean|off; 默认off; 适用于配置块:http,server,location 当非off值时,用户请求中的HTTP包体一律存储到磁盘文件中,即使只有0字节也会存储为文件.当请求结束时如果配置为on,则该文件不会被删除(一般用于调试定位问题),若配置为clean,则会删除该文件 client_body_in_file_only off; #client_body_in_single_buffer on|off; HTTP包体尽量写到一个内存buffer中.如果HTTP包体的大小超过了client_body_buffer_size设置的值,包体还是会写入到磁盘文件中 适用于配置块:http,server,location client_body_in_single_buffer off; #client_header_buffer_size size; 存储HTTP头部的内存buffer大小 配置块:http,server 存储HTTP头部的内存buffer大小 定义了正常情况下Nginx接收用户请求中HTTP header部分(包括HTTP行和HTTP头部)时分配的内存buffer大小.如果请求中的HTTP header部分超过client_header_buffer_size,large_client_header_buffers将会生效 client_header_buffer_size 1K; #large_client_header_buffers number size; 配置块:http,server large_client_header_buffers定义了nginx接收超大HTTP头部请求的buffer个数和每个buffer的大小.如果HTTP请求行的大小超过单个buffer,则返回&quot;Request URI toolager&quot;(414).请求中一般有多个header,每个header的大小也不能超过单个buffer的大小.否则返回&quot;Bad request&quot;(400).请求行和请求头部的总和也不可以超过buffer个数和*buffer大小 large_client_header_buffers 4 8K; #client_body_buffer_size size; 配置块:http,server,location 存储HTTP包体的内存buffer大小 定义了nginx接收HTTP包体的内存缓冲区大小 即HTTP包体会先接收到指定的这块内存中,之后才决定是否写入磁盘. #如果用户请求中包含HTTP头部Content-Length,并且其标识长度小于定义的buffer长度,nginx会自动降低本次请求所使用的内存buffer,降低内存消耗. client_body_buffer_size 16k; #client_body_temp_path dir-path [level1[level2[level3]]]; 配置块:http,server,location 定义HTTP包体存放的临时目录.在请求HTTP包体时,如果包体大小大于client_body_buffer_size,则会以一个递增的整数命名并存放到client_body_temp_path所指定的目录中.其后跟随的level1,level2,level3是为了防止一个目录下文件太多导致性能下降,因此使用level参数,按照临时文件名最多再加三层目录. client_body_temp_path client_body_temp 1 2; #connection_pool_size size; 配置块:http,server nginx对每个建立的TCP连接会预先分配一个内存池,size指定该内存池的初始大小,用于减少内核对小块内存的分配次数,需谨慎设置.过大的size会使服务器消耗内存增多,更小的size会引发更多的内存分配次数. connection_pool_size 256; #request_pool_size size; 配置块:http,server nginx开始处理HTTP请求时,会为每个请求分配一个内存池,size配置项指定该内存池的初始大小,用于减少内核对小块内存的分配次数.TCP连接关闭时会销毁connection_pool_size指定的连接池,HTTP请求结束时会销毁request_pool_size指定的HTTP请求内存池.但TCP连接内存池和HTTP请求内存池的创建和销毁时间并不一致,因为一个TCP连接可能被复用于多个HTTP请求. request_pool_size 4k; #网络连接的设置 #client_header_timeout time(默认单位s); 配置块:http,server,location 读取HTTP头部的超时时间 客户端和服务器建立连接后开始接收HTTP头部,如果在一个时间间隔内没有读取到客户端发来的字节,则认为超时,并向客户端返回408(&quot;Request timed out&quot;)响应. client_header_timeout 60; #client_body_timeout time(默认单位s); 配置块:http,server,location 读取HTTP包体的超时时间 client_body_timeout 60; #send_timeout time; 配置块:http,server,location 发送响应的超时时间 nginx服务器向客户端发送数据包,但客户端一直没有去接收这个数据包.如果某个连接超过send_timeout定义的超时时间,nginx将关闭这个连接 send_timeout 60; #reset_timedout_connection on|off; 配置块:http,server,location 连接超时后将通过向客户端发送RST包来直接重置连接.该选项打开后,nginx会在某个连接超时后,不是使用正常情况下的四次挥手关闭TCP连接,而是直接向用户发送RST重置包,不在等待用户的应答,直接使用nginx服务器上关于该套接字的所有缓存,与正常关闭方式相比,使得服务器避免了产生更多处于FIN_WAIT_1,FIN_WAIT_2,TIME_WAIT状态的TCP连接. 但是,使用RST重置包关闭连接会带来一些问题,默认情况下不会开启. reset_timedout_connection off; #lingering_close off|on|always; 配置块:http,server,location 控制nginx关闭用户连接的方式.always表示关闭用户连接前必须无条件地处理连接上所有用户发送的请求.off表示关闭连接时完全不管连接上是否有已经准备就绪的来自用户的数据.on是中间值,一般情况下在关闭前都会处理l连接上用户发送的数据,除了有些情况下在业务上认定之后的数据是不必要的. lingering_close on; #lingering_time time; 配置块:http,server,location lingering_close启用后,对上传大文件很有用,当用户上传的Content-Length大于max_client_body_size时,nginx服务器向用户发送413(Request entity too large)响应,如果客户端不管413返回值继续上传HTTP body,经过lingering_time设置的时间后,nginx将不管用户是否仍在上传,都将连接关闭掉 lingering_time 30s; #lingering_timeout time; 配置块:http,server,location lingering_close生效后,在关闭连接前,会检测是否有用户发送的数据到达服务器,如果超过了lingering_timeout还没有数据可读,就直接关闭连接,否则,必须在读取完连接缓冲区上的数据并丢弃后才能关闭连接 lingering_timeout 5s; #keepalive_disable [msie6|safari|none...]; 配置块:http,server,location HTTP请求的keepalive功能让多个请求复用一个HTTP长连接,对服务器的性能提高很有帮助,但有的浏览器对keepalive功能的POST请求有功能项问题,因此可以对特定浏览器禁用keepalive功能 keepalive_disable msie6 safari; #keepalive_timeout time(秒); 配置块:http,server,location 一个httpalive在闲置一定时间后,服务器和浏览器都会去关闭这个连接,keepalive_timeout配置项用来约束nginx服务器,nginx会按照规范将keepalive_timeout传给浏览器,但每个浏览器对keepalive的策略有可能不同 keepalive_timeout 65; #keepalive_requests n; 配置块:http,server,location 一个keepalive长连接上允许的请求最大数 即一个keepalive连接上最多只能发送n个请求 keepalive_requests 100; #tcp_nodelay on|off; 配置块:http,server,location 确定对keepalive连接是否使用TCP_NODELAY选项 tcp_nodelay on; #tcp_nopush on|off; 配置块:http,server,location 在打开sendfile选项时,确认是否开启FreeBSD系统的TCP_NOPUSH或Linux系统上的TCP_CORK功能,打开tcp_nopush后,将在发送响应时把真个响应头放在一个TCP包中发送. tcp_nopush on; #MIME类型的设置 #MIME type与文件扩展的映射 语法: type &#123;...&#125;; 配置块:http,server,location 定义MIME type到文件拓展名的映射.多个拓展名可映射到同一个MIME type. #默认MIME type 语法:default_type MIME-type; 配置块:http,server,location 当找不到相应的MIME type与文件扩展名之间的映射时使用默认的MIME type作为HTTP header中的Content-Type. default_type application/octet-stream; #types_hash_bucket_size size; 默认type_hash_bucket_size 32|64|128; 配置块:http,server,location 为了快速查找相应MIME type,nginx使用散列表来存储MIME type与文件扩展名.types_hash_bucket_size设置了每个散列桶占用内存大小 types_hash_bucket_size 64; #types_hash_max_size size; 配置块:http,server,location 影响散列表的冲突率,types_hash_max_size越大,消耗内存越大,打散列表的冲突率会降低,检索速度会更快,types_hash_max_size越小,消耗内存越少,但散列表冲突率会上升. types_hash_max_size 2048; #文件操作的优化 #sendfile系统调用 sendfile on|off; 配置块:http,server,location 启用Linux上的sendfile系统调用来发送文件,减少系统内核和用户态之间的两次内存复制,从磁盘中直接读取文件后直接在内核态发送到网卡设备.提高发送文件的效率. #sendfile off; #AIO系统调用 aio on|off; 配置块:http,server,location 表示是否在FreeBSD或Linux系统上启用内核级别的异步文件I/O功能.该配置和sendfile功能互斥 aio on; #directio size|off; 配置块:http,server,location 在FreeBSD和Linux系统上使用O_DIRECT选项来读文件,缓冲区大小为size,通常对大文件的读取速度有优化功能,与sendfile功能相斥. directio off; #directio_alignment size; 配置块:http,server,location 与directio配合使用,指定以directio方式读取文件时的对齐方式. directio_alignment 512; #打开文件缓存 open_file_cache max=N[inactive=time]|off; 配置块:http,server,location 文件缓存会在内存中存储3种信息:1.文件句柄,文件大小和上次修改时间 2.已经打开过的目录结构 3.没有找到的或者没有操作权限的文件信息 #open_file_cache 后面跟3个参数.max表示在内存中存储元素的最大个数,当达到最大值后,将采用LRU算法从缓存中淘汰最近最少使用的元素.inactive表示在inactive指定的时间段内没有被访问过的元素将被淘汰.默认时间为60秒.off关闭缓存功能 open_file_cache off; #open_file_cache max=100 inactive=20s; #缓存打开文件错误的信息 open_file_cache_errors on|off; 配置块:http,server,location open_file_cache_errors off; #不被淘汰的最小访问次数 open_file_cache_min_uses number; 配置块:http,server,location 与open_file_cache中的inactive参数配合使用.如果在inactive指定时间段内,访问次数超过了open_file_cache_min_uses指定的最小次数,那么将不会被淘汰出缓存. open_file_cache_min_uses 1; #检查缓存中元素有效性的频率. open_file_cache_valid time; 配置块:http,server,location open_file_cache_valid 60s; include /etc/nginx/mime.types; include /etc/nginx/default.d/*.conf; include /etc/nginx/conf.d/*.conf; #server_names_hash_bucket_size设置nginx存储server_name的散列表每个散列桶占用的内存大小 适用于配置块:http,server,location 取值32,64,128 server_names_hash_bucket_size 128; #server_names_hash_max_size影响散列表的冲突率,值越大消耗内存越多,散列key的冲突率约低,检索速度越快 适用于配置块:http,server,location server_names_hash_max_size 512; #对客户端请求的特殊处理 #忽略不合法的HTTP头部 ignore_invalid_headers on|off; 配置块:http,server 如果将其设置为off,当出现不合法的HTTP头部时,ngin将拒绝服务,并直接想用户发送400(Bad Request)错误,如果设置为on,则将忽略此HTTP头部. ignore_invalid_headers on; #HTTP头部允许下划线 underscores_in_headers on|off; 配置块:http,server 默认off,表示HTTP头部名称中不允许带&quot;_&quot; underscores_in_headers off; #If-Modified-Since头部的处理策略 if_modified_since [off|exact|before]; 配置块:http,server,location Web浏览器一般会缓存文件到本地,并存储当时获取的时间,下次向Web服务器获取缓存过的资源时,使用If-Modified-Since头部把上次获取的时间捎带上,而if_modified_since将根据后面的参数决定如何处理If-Modified-Since头部. #off: 直接忽略用户请求中的If-Modified-Since头部,如果获取一个文件,会正常返回文件内容,HTTP响应吗通常为200 #exact: 将If-Modified-Since头部包含的时间和将要返回的文件上次修改时间做精准比较,如果没有匹配上则返回200和文件实际内容,如果匹配上了,则表示浏览器缓存的已经是最新的啦,没有必要再返回文件浪费时间和宽带,返回304 Not Modified,浏览器收到后会直接读取自己的本地缓存 #before: 比exact更宽松,只要文件上次修改时间等于或早于用户请求中的If-Modified-Since头部的时间,会向客户端返回304Not Modified. if_modified_since exact; #文件未找到时记录到error日志 log_not_found on|off; 配置块:http,server,location 表示当处理用户请求且需要访问文件时,如果未找到文件,是否将错误记录到error.log日志.可用于定位问题. log_not_found on; #merge_slashes on|off; 配置块:http,server,location 合并相邻的&quot;/&quot;. merge_slashes on; #DNS解析地址 resolver address ...; 配置块:http,server,location 设置DNS名字解析服务器地址. #DNS解析超时时间 resolver_timeout time; 配置块:http,server,location resolver_timeout 30s; #server_tokens on|off; 返回错误页面时是否在Server中注明nginx版本 配置块:http,server,location 方便定位问题 server_tokens on; #server块 虚拟主机定义 server &#123; #监听端口 默认监听80端口 listen决定nginx服务如何监听端口.在listen后面可以只加IP地址,端口或主机名 #listen 127.0.0.1:8080; #listen 127.0.0.1; #不写端口时,默认监听80端口 #listen *:80; #listen localhost:80; #listen后面也可以加其他参数 #1. default/default_server: 将这个server块作为整个Web服务的默认server块.未设置则将nginx解析配置时找到的第一个server块作为默认块,当一个请求无法匹配配置文件中所有主机域名时,选择默认的虚拟主机. #2. backlog=num: 表示TCP中backlog队列的大小,默认为-1,表示不予设置.在TCP三次握手的工程中,进程还没有开始处理监听句柄,这时backlog队列会放置这些新连接.如果backlog队列已满,新的客户端试图建立新连接将会失败. #3. rcvbuf=size: 设置监听句柄的SO_RCVBUF参数 #4. sndbuf=size: 设置监听句柄的SO_SNDBUF参数 #5. accept_filter: 设置accept过滤器,只对FreeBSD操作系统有效 #6. deferred: 设置该参数,若用户发起建立连接请求,并且完成TCP的三次握手,内核也不会调度worker进程来处理这个连接,当用户真的发送请求数据时,内核才会调度worker进程处理这个连接,这个参数适合大并发的情况下,减轻worker进程的负担 #7. bind: 绑定当前端口/地址对, 只有同时对一个端口监听多个地址才会生效 #8. ssl: 在当前监听的端口上建立的连接必须基于SSL协议 listen 80 default_server; listen [::]:80 default_server; #主机名称 server_name可以跟多个主机名称 #server_name localhost test.casezheng.date; #server_name localhost 127.0.0.1; #当nginx处理一个HTTP请求时,nginx取出header头中的host,与每个server中的server_name匹配.匹配规则如下: #1. 完全匹配server_name #2. 通配符在前面的server_name #3. 通配符在后面的server_name #4. 正则表达式才匹配的server_name #5. 前面都未匹配到,找listen配置项后加了default或default_server的server块 #6. 前面都未匹配到,找匹配listen端口的第一个server块 #server_name后面跟空字符串表示匹配没有host这个HTTP头部的请求 server_name localhost test.casezheng.date; #server_name_in_redirect 重定向主机名称 配合server_name使用,当打开时表示重定向请求时会使用server_name里配置的第一个主机名代替原先请求中的Host头部,关闭时表示在重定向请求时使用请求本身的Host头部. 适用于配置块:http,server,location 默认on server_name_in_redirect on; #charset koi8-r; #location 语法: location [=|~|~*|^~|@]/uri/ &#123; ... &#125; 适用于配置块:server location尝试根据用户请求中的URI来匹配/uri表达式,如果可以匹配,就选择location块中的配置处理用户请求, 匹配规则如下: #1. =表示把URI作为字符串,以便与参数中的uri做完全匹配 #2. ~表示匹配URI时是大小写敏感的 #3. ~*表示匹配URI时忽略字母大小写问题 #4. ^~表示匹配URI时只需要其前半部分与uri参数匹配即可 #5. @表示仅用于nginx服务内部请求之间的重定向 #在uri参数中可以使用正则表达式进行匹配 #location存在顺序,当一个请求有可能匹配多个location时,该请求将被第一个location处 root /data/nginx/; #对客户端请求的限制 #对HTTP方法名限制用户请求 limit_except method ... &#123; ... &#125; 配置块:location nginx通过limit_except后面指定的方法名来限制用户请求.方法名取值包括:GET,HEAD,POST,PUT,DELETE,MKCOL,COPY,MOVE,OPTIONS,PROPFIND,PROPPATCH,LOCK,UNLOCK或者PATCH. #请求包体的最大值 client_max_body_size size; 配置块:http,server,location 浏览器发送含较大HTTP包体的请求时,其头部有Content-Length字段,client_max_body_size是用来限制Content-Length所示值的大小的.nginx在接受到包头后,发现Content-Length的值大于client_max_body_size,直接发送403(&quot;Request Entity Too Large&quot;)响应给客户端 client_max_body_size 1m; #对请求的限制 limit_rate speed; 配置块:http,server,location,if 对客户端请求限制每秒传输的字节数. 0表示不限速. limit_rate 0; #limit_rate_after length; 表示nginx向客户端发送的请求长度超过limit_rate_after后才开始限速. limit_rate_after 100m; location = /test_root &#123; #以root方式设置资源路径 适用于配置块:http,server,location,if root根据完整的URI请求来映射 #root /data/nginx/; limit_except GET &#123; allow 192.168.1.0/32; deny all; &#125; &#125; location = /test_alias &#123; #以alias方式设置资源路径 适用于配置块:location alias在URI向实际文件路径的映射过程中,会丢弃掉location后面配置的那部分uri alias /data/nginx/test_alias/; &#125; location / &#123; #访问首页 语法: index file ...; 用ngx_http_index_module模块提供的index配置实现返回网站首页,nginx按照配置的顺序访问index后配置的文件 root /data/nginx; index index.html index.htm; &#125; #error_page code [code...][=|=answer-code]uri|@named_location 适用于配置块:http,server,location,if #当某个请求返回错误码时,如果匹配上了erro_page中设置的code,则重定向到新的URI中. #error_page 404 /404.html; #error_page 404 =200 /404.html; #重定向后返回的错误码还是原来的,可以通过=更改返回的错误码 #error_page 404 = /404.html; #也可以不指定确切的返回码,由重定向后实际处理的真实结果决定 #如果不行修改URI,只是将错误请求重定向到另一个location处理,可以如下配置,将错误请求代理到http://test.casezheng.date/test_root上游服务器处理 location /test_error_fallback &#123; error_page 404 @fallback; &#125; location @fallback &#123; proxy_pass http://test.casezheng.date; &#125; #递归使用error_page recursive_error_pages [on|off] recursive_error_pages off; #默认不允许递归定义error_page # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /data/nginx; &#125; location ^~ /test_try_files &#123; #try_files后跟若干路径,最后必须有uri参数. nginx尝试按顺序访问每个路径,如果可以有效访问则返回,否则继续读取下一个.如果所有路径都读取不到则重定向到最后的参数uri上.因此最后的uri参数必须存在而且是可以重定向的. #try_files适用于server,location配置块 try_files /test_try1 /test_try2 /test_try3 @fallback; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; nginx配置反向代理服务器反向代理(reverse proxy)方式指用代理服务器接受Internet上的连接请求,然后将请求转发给内部网络中的上游服务器,并将从上游服务器得到的结果返回给Internet上请求连接的客户端.反向代理服务器必须能够能支持大量并发请求 12345678 Nginx ---静态文件请求---&gt; 静态Web服务器 &lt;---文件内容------- Web浏览器 ---静态文件请求---&gt; ---转发动态请求---&gt; 反向代理服务器 处理复杂业务的动态Web服务器 &lt;---转发动态应答--- &lt;----动态应答------ nginx的反向代理特点 2 用户发来的请求将会完整地缓存到nginx代理服务器,之后才会向后端服务器转发 3 nginx反向代理服务器可以按照多种方案从上游服务器的集群中选择一台.负载均衡方案包括按IP地址做散列等 5 如果上游服务器返回内容,则不会先完整缓存到nginx代理服务器再发给客户端,而是边接收边转发到客户端 1234567 2----&gt; 缓存的HTTP包体 上游服务器 | --------1------&gt; | ---------3---------&gt; 客户端 nginx反向代理服务器 上游服务器 &lt;-------5------- &lt;--------4---------- 上游服务器 nginx的反向代理方案主要是为了降低上游服务器的并发压力.缺点是:延长了一个请求的处理时间,并增加了用于缓存请求内容的内存和磁盘空间,增加了nginx的压力. 负载均衡和反向代理的基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546... ...http &#123; ... ... #upstream name &#123;...&#125; 配置块:http upstream块定义一个上游服务器的集群,便于反向代理中proxy_pass使用. #server name [parameters]; 配置块:upstream server配置项指定了一个上游服务器的名字,可以是域名,IP地址端口,UNIX句柄等,其后可跟如下参数 #1. weight=number:设置向这台上游服务器转发的权重,默认为1 #2. max_fails=number:与fail_timeout配合使用,指在fail_timeout时间段内,如果向当前的上游服务器转发失败次数超过number,则认为在当前的fail_timeout时间段内这台上游服务器不可用,max_fails默认为1,设置为0表示不检查失败次数 #3. fail_timeout:表示该时间段内转发失败多少次后就认为上游服务器暂时不可用,用于优化反向代理功能.该值与向上游服务器建立连接的超时时间,读取上游服务器的响应超时时间等完全无关.fail_timeout默认为10s #4. down:表示所在的上游服务器永久下线,只在使用ip_hash配置项时才有用 #5. backup:在使用ip_hash配置时无效,表示所在的上游服务器只是备份服务器,当所有非备份上游服务器都失效后,才会向所在的上游服务器转发请求 #ip_hash; 配置块:upstream 按ip hash转发,确保同一个客户端的请求只转发到指定的上游服务器, ip_hash不可与weight配置同时使用. 当upstream集群有一台上游服务器不可用时不可直接删除该配置,而是用down参数标识,确保转发的一致性. upstream backend1 &#123; server example1.casezheng.date weight=5; server example2.casezheng.date max_fails=2 fail_timeout=30s; server example3.casezheng.date down; server example4.casezheng.date; &#125; upstream backend2 &#123; ip_hash; server example1.casezheng.date; server example2.casezheng.date; server example3.casezheng.date down; server example4.casezheng.date; &#125; #proxy_pass URL; 配置块:location, if 将当前请求反向代理到URL参数指定的服务器上,URL可以是主机名或IP加端口或直接使用upstream块 默认情况下反向代理不转发请求中的Host头部,如果需要转发,需要加上 proxy_set_header Host $host; #proxy_method method; 配置块:http,server,location 表示转发时的协议方法名 #proxy_hide_header the_header; 配置块:http,server,location nginx将上游服务器的响应转发给客户端,但默认不转发以下HTTP头部字段:Data,Server,X-Pad和X-Accel-*.使用proxy_hide_header后k而已任意指定哪些HTTP头部字段不能被转发 #proxy_pass_header the_header; 配置块:http,server,location 与proxy_hide_header相反,将原本被禁止的header设置为允许转发. #proxy_pass_request_body on|off; 配置块:http,server,location 向上游服务器发送HTTP包体 #proxy_pass_request_headers on|off; 配置块:http,server,location 向上游服务器发送HTTP包头 #proxy_redirect [default|off|redirect reqlacement]; 配置块:http,server,location #proxy_next_upstream [error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off]; 配置块:http,server,location 表示当向一台上游服务器转发请求错误时,继续换一台上游服务器处理这个请求 server &#123; listen 80; server_name exampel.casezheng.date; proxy_method POST; proxy_pass_request_body on; proxy_pass_request_headers on; #proxy_redirect default; proxy_next_upstream error timeout; location / &#123; proxy_pass http://backend2; &#125; &#125;&#125; nginx http模块调用的简化流程 nginx基础架构nginx数据结构ngx_list_t nginx源码阅读nginx-1.15.6源码阅读注释 参考资料 深入理解Nginx模块开发与架构解析第2版","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"http://www.casezheng.date/tags/nginx/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"centos安装多个gcc版本","slug":"centos-multiple-gcc-version","date":"2018-11-16T04:57:27.000Z","updated":"2018-11-16T04:57:27.000Z","comments":true,"path":"2018/11/16/centos-multiple-gcc-version/","link":"","permalink":"http://www.casezheng.date/2018/11/16/centos-multiple-gcc-version/","excerpt":"","text":"centos下多个gcc版本的安装方法和切换安装scl发布源1sudo yum install centos-release-scl-rh 安装gcc和gcc-c++devtoolset中有多个gcc版本123[CaseZheng@Test ~]$ yum search devtoolset- | grep gcc-c++devtoolset-6-gcc-c++.x86_64 : C++ support for GCC version 6devtoolset-7-gcc-c++.x86_64 : C++ support for GCC version 7 安装devtoolset-6-*如下1sudo yum install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-gdb devtoolset-6-libstdc++-devel devtoolset-*中还有别的工具,可以根据需要安装 启用安装的gcc版本12[CaseZheng@Test ~]$ gcc --version | grep GCCgcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-23) 使用source /opt/rh/devtoolset-6/enable启用, 如果安装的devtoolset-7-*则使用source /opt/rh/devtoolset-7/enable,依次类推12[CaseZheng@Test ~]$ gcc --version | grep GCCgcc (GCC) 6.3.1 20170216 (Red Hat 6.3.1-3) 使用这种方法只对当前会话有效,如果想每次新开会话都生效可以将source /opt/rh/devtoolset-6/enable加入到~/.bashrc,加入后source ~/.bashrc生效如果想全局生效可以将source /opt/rh/devtoolset-6/enable加入到/etc/bashrc,加入后执行下source /etc/bashrc生效 Software Collections介绍Software Collections 是 Red Hat 唯一支持的新软件包源. Software Collections 为 CentOS 设立了专门的仓库,安装和管理都和其它第三方仓库一样. centos-release-scl 里有一些由社区维护的额外的软件包 安装 Software Collections1sudo yum install centos-release-scl centos-release-scl-rh SCL的默认关闭,启用使用source /opt/rh/devtoolset-7/enable,参考启用安装的gcc版本 参考资料 CentOS 6&amp;7 安装使用多个GCC版本（GCC4.9，GCC5.3，GCC6.2）","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"http://www.casezheng.date/tags/gcc/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"Kafka介绍与实践","slug":"kafka","date":"2018-10-26T13:43:10.000Z","updated":"2018-10-26T13:43:10.000Z","comments":true,"path":"2018/10/26/kafka/","link":"","permalink":"http://www.casezheng.date/2018/10/26/kafka/","excerpt":"","text":"kafka安装安装java12yum install java-1.8.0-openjdkjava -version 安装zookeeper 获取zookeeperwget http://mirror.bit.edu.cn/apache/zookeeper/current/zookeeper-3.4.12.tar.gz 解压tar zxvf zookeeper-3.4.12.tar.gz 移动解压文件到安装路径下 123mkdir /data/zookeeper -pmv zookeeper-3.4.12 /data/zookeeper/cd /date/zookeeper/zookeeper-3.4.12 创建配置文件 1234567[root@VM_187_252_centos zookeeper-3.4.12]# vim conf/zoo.cfg[root@VM_187_252_centos zookeeper-3.4.12]# cat conf/zoo.cfgtickTime = 2000dataDir = /data/zookeeper/dataclientPort = 2181initLimit = 5syncLimit = 2 启动zookeeper服务 1234[root@VM_187_252_centos zookeeper-3.4.12]# bin/zkServer.sh startZooKeeper JMX enabled by defaultUsing config: /data/zookeeper/zookeeper-3.4.12/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 使用客户端连接 123[root@VM_187_252_centos zookeeper-3.4.12]# bin/zkCli.sh... ...[zk: localhost:2181(CONNECTED) 0] 安装kafka 获取kafkawget http://mirrors.hust.edu.cn/apache/kafka/2.0.0/kafka_2.12-2.0.0.tgz 解压tar zxf kafka_2.12-2.0.0.tgz 移动解压文件到安装路径下 123mkdir /data/kafka -pmv kafka_2.12-2.0.0 /data/kafka/cd /data/kafka/kafka_2.12-2.0.0/ 启动kafka 1[root@VM_187_252_centos kafka_2.12-2.0.0]# nohup bin/kafka-server-start.sh config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp; kafka manager安装1234cd ~mkdir .sbtcd .sbtvim repositories 在repositories中加入如下内容,使用国内阿里云资源加快下载速度1234[repositories]localaliyun: http://maven.aliyun.com/nexus/content/groups/publictypesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly 返回安装目录123git clone https://github.com/yahoo/kafka-manager.gitcd kafka-manager./sbt clean dist 这个过程比较慢,需要耐心等待,完成之后在target/universal目录下会生产一个zip压缩包kafka-manager-*.zip,将其拷贝到要部署的目录下解压。12345cd target/universalcp kafka-manager-1.3.3.21.zip /data/kafka/cd /data/kafka/unzip kafka-manager-1.3.3.21.zipcd kafka-manager-1.3.3.21/ 修改 conf/application.conf 中kafka-manager.zkhosts为正确的zookeeper地址1bin/kafka-manager -Dconfig.file=./conf/application.conf -Dhttp.port=9000 正常启动后即可登陆进行相关操作 kafka概述kafka专为分布式高吞吐量系统而设计,kafka相比其它消息传递系统具有更好的吞吐量,内置分区,复制和固有的容错能力,非常适合大规模消息处理应用程序.kafka是一个分布式发布-订阅消息系统和一个强大的队列,可以处理大量的数据,并使您能够将消息从一个端点传递到另一个端点.kafka适合离线和在线消息消费.Kafka消息保留在磁盘上,并在群集内复制以防止数据丢失.Kafka构建在ZooKeeper同步服务之上.它与Apache Storm和Spark非常好地集成,用于实时流式数据分析. kafka的好处 可靠性 kafka是分布式,分区,复制和容错的 可扩展性 kafka消息传递系统轻松缩放,无需停机 耐用性 kafka使用分布式提交日志,消息尽可能快的保存在磁盘上 性能 kafka对于发布和订阅都具有高吞吐量 kafka非常快,并保证零停机和零数据丢失 kafka的用例 指标 kafka通常用来操作监控数据,涉及聚合来自分布式应用程序的统计信息,以产生操作数据和集中馈送 日志聚合解决方案 kafka用于跨组织来从多个服务收集日志,并提供标准格式给多个服务器 流处理 流行的框架从主题中读取数据,对其处理,并将处理后的数据写入新主题,供用户和应用程序使用.kafka的强耐久性在流处理的上下文中非常有用 kafka基础 Topics 主题 属于特定类别的消息流称为主题.数据存储在主题中.主题被拆分成分区.对于每个主题,Kafka保存一个分区的数据.每个这样的分区包含不可变有序序列的消息.分区被实现为具有相等大小的一组分段文件 Partition分区 主题可能有许多分区,因此它可以处理任意数量的数据. Partition offset 分区偏移 每个分区消息具有称为offset的唯一序列标识. Replicas of partition 分区备份 副本只是一个分区的备份.副本从不读取或写入数据.它们用于防止数据丢失. Brokers 经纪人 代理是负责维护发布数据的简单系统.每个代理中的每个主题可以具有零个或多个分区 假设,如果在一个主题和N个代理中有N个分区，每个代理将有一个分区. 假设在一个主题中有N个分区并且多于N个代理(n+m)，则第一个N代理将具有一个分区，并且下一个M代理将不具有用于该特定主题的任何分区。 假设在一个主题中有N个分区并且小于N个代理(n-m)，每个代理将在它们之间具有一个或多个分区共享。 由于代理之间的负载分布不相等，不推荐使用此方案。 Kafka Cluster Kafka集群 Kafka有多个代理被称为Kafka集群.可以扩展Kafka集群,无需停机.集群用于管理消息数据的持久性和复制. Producers 生产者 生产者是发送给一个或多个Kafka主题的消息的发布者.生产者向Kafka经纪人发送数据.每当生产者将消息发布给代理时,代理只需将消息附加到最后一个段文件.实际上,该消息将被附加到分区.生产者还可以向他们选择的分区发送消息. Consumers 消费者 Consumers从经纪人处读取数据.消费者订阅一个或多个主题,并通过从代理中提取数据来使用已发布的消息. Leader 领导者 Leader是负责给定分区的所有读取和写入的节点. 每个分区都有一个服务器充当Leader Follower 追随者跟随领导者指令的节点被称为Follower.如果领导失败,一个追随者将自动成为新的领导者.跟随者作为正常消费者,拉取消息并更新其自己的数据存储. kafka集群架构 Broker代理 Kafka集群通常由多个代理组成以保持负载平衡.Kafka代理是无状态的,使用ZooKeeper来维护它们的集群状态.一个Kafka代理实例可以每秒处理数十万次读取和写入,每个Broker可以处理TB的消息,而没有性能影响.Kafka经纪人领导选举可以由ZooKeeper完成. ZooKeeper ZooKeeper用于管理和协调Kafka代理.ZooKeeper服务主要用于通知生产者和消费者Kafka系统中存在任何新代理或Kafka系统中代理失败.根据Zookeeper接收到关于代理的存在或失败的通知,然后产品和消费者采取决定并开始与某些其他代理协调他们的任务. Producers 生产者 生产者将数据推送给经纪人.当新代理启动时,所有生产者搜索它并自动向该新代理发送消息.Kafka生产者不等待来自代理的确认,并且发送消息的速度与代理可以处理的一样快. Consumers 消费者 因为Kafka代理是无状态的,这意味着消费者必须通过使用分区偏移来维护已经消耗了多少消息.如果消费者确认特定的消息偏移,则意味着消费者已经消费了所有先前的消息.消费者向代理发出异步拉取请求,以具有准备好消耗的字节缓冲区.消费者可以简单地通过提供偏移值来快退或跳到分区中的任何点.消费者偏移值由ZooKeeper通知. Kafka工作流程Kafka只是分为一个或多个分区的主题的集合.Kafka分区是消息的线性有序序列,其中每个消息由它们的偏移来标识.Kafka集群中的所有数据都是不相连的分区联合.传入消息写在分区的末尾,消息由消费者顺序读取.通过将消息复制到不同的代理提供持久性.Kafka以快速,可靠,持久,容错和零停机的方式提供基于pub-sub和队列的消息系统.生产者只需将消息发送到主题，消费者可以根据自己的需要选择任何一种类型的消息传递系统 发布订阅工作流程 生产者向主题发送消息。 Kafka代理存储为该特定主题配置的分区中的所有消息.它确保消息在分区之间平等共享.如果生产者发送两个消息并且有两个分区,Kafka将在第一分区中存储一个消息,在第二分区中存储第二消息. 消费者订阅特定主题. 一旦消费者订阅主题,Kafka将向消费者提供主题的当前偏移,并且还将偏移保存在Zookeeper中. 消费者将定期请求Kafka新消息. 一旦Kafka收到来自生产者的消息,它将这些消息转发给消费者. 消费者将收到消息并进行处理. 一旦消息被处理,消费者将向Kafka代理发送确认. 一旦Kafka收到确认,它将偏移更改为新值,并在Zookeeper中更新它.由于偏移在Zookeeper中维护,消费者可以正确地读取下一封邮件,即使在服务器暴力期间. 以上流程将重复,直到消费者停止请求. 消费者可以随时回退/跳到所需的主题偏移量,并阅读所有后续消息. 队列消息/用户组的工作流在队列消息传递系统而不是单个消费者中，具有相同”组ID “的一组消费者将订阅主题。 简单来说，订阅具有相同” Group ID “的主题的消费者被认为是单个组，并且消息在它们之间共享。 让我们检查这个系统的实际工作流程。 生产者以固定间隔向某个主题发送消息. Kafka存储在为该特定主题配置的分区中的所有消息. 单个消费者订阅特定主题，假设Topic-01的Group ID为Group-1。 Kafka以与发布-订阅消息相同的方式与消费者交互,直到新消费者以相同的组ID订阅相同主题Topic-01 一旦新消费者到达,Kafka将其操作切换到共享模式,并在两个消费者之间共享数据.此共享将继续,直到用户数达到为该特定主题配置的分区数。 一旦消费者的数量超过分区的数量,新消费者将不会接收任何进一步的消息,直到现有消费者取消订阅任何一个消费者.出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区,并且一旦所有分区被分配给现有消费者,新消费者将必须等待 此功能也称为”使用者组”。 同样，Kafka将以非常简单和高效的方式提供两个系统中最好的 ZooKeeper的作用Apache Kafka的一个关键依赖是Apache Zookeeper, Zookeeper是一个分布式配置和同步服务.Zookeeper是Kafka代理和消费者之间的协调接口.Kafka服务器通过Zookeeper集群共享信息.Kafka在Zookeeper中存储基本元数据,例如关于主题,代理,消费者偏移(队列读取器)等的信息. 由于所有关键信息存储在Zookeeper中,并且它通常在其整体上复制此数据,因此Kafka代理/Zookeeper的故障不会影响Kafka集群的状态.Kafka将恢复状态,一旦Zookeeper重新启动.这为Kafka带来了零停机时间.Kafka代理之间的领导者选举也通过使用Zookeeper在领导者失败的情况下完成. Kafka Leader的选举Kafka Partition的Leader选举是在所有Broker中选出一个Controller(管理员),所有Partition的Leader选举都由Controller决定,Controller会将Leader的改变直接通过RPC的方式(比Zookeeper Queue的方式更高效)通知需要为此做出响应的Broker.Kafka Controller的选举过程: 每个Broker都会在Zookeeper中Controller Path上注册一个Watch(监听者) 当前Controller由于某些原因和Zookeeper断开时,对应的Controller Path会自动消失,此时会触发Watch,所有活着的Broker都回去竞争成为新的Controller(创建新的Controller Path),但只有一个会竞争成功(Zookeeper保证). 竞争成功的Broker会成功新的Controller,竞争失败的Broker会重新在新的Controller Path上注册Watch. Kafka Partition Leader的选举由Controller执行: 从Zookeeper中读取当前分区的所有ISR集合 调用配置的分区选择算法选择分区的Leader Kafka C++实践librdkafka安装123456wget https://github.com/edenhill/librdkafka/archive/v0.11.6.tar.gztar zxvf v0.11.6.tar.gzcd librdkafka-0.11.6./configuremakemake install 参考文献 Kafka中文文档 Apache Kafka 教程 Kafka权威指南 librdkafka github","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://www.casezheng.date/tags/kafka/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"Linux常用命令","slug":"linux-common-commands","date":"2018-10-15T14:43:57.000Z","updated":"2018-10-15T14:43:57.000Z","comments":true,"path":"2018/10/15/linux-common-commands/","link":"","permalink":"http://www.casezheng.date/2018/10/15/linux-common-commands/","excerpt":"","text":"Linux常用命令Linux批量查找和替换语法格式1sed -i &quot;s/原字符串/新字符串/g&quot; `grep 原字符串 -rl 所在目录` 实例查找./post/目录下包含c++字符串的文档,并将文档中c++字符串替换为c1sed -i \"s/c++/c/g\" `grep c++ -rl ./post/` yumyum在误操作后的回滚,通过yum history查看yum的历史操作记录,然后通过yum history undo ID的方式回滚123456789# yum historyID | 命令行 | 日期和时间 | 操作 | 更改------------------------------------------------------------------------------- 41 | autoremove | 2019-05-04 02:26 | Removed | 4 40 | install ibus-libpinyin | 2019-05-04 02:15 | Install | 1 39 | remove ibus-libpinyin | 2019-05-04 02:12 | Removed | 1... ...# yum history undo 41 参考 Linux命令大全","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"C++ boost库源码编译安装","slug":"boost-install","date":"2018-09-28T15:20:39.000Z","updated":"2018-09-28T15:20:39.000Z","comments":true,"path":"2018/09/28/boost-install/","link":"","permalink":"http://www.casezheng.date/2018/09/28/boost-install/","excerpt":"","text":"boost库的安装获取boost源码boost官网获取最新版本123wget https://dl.bintray.com/boostorg/release/1.68.0/source/boost_1_68_0.tar.gztar zxvf boost_1_68_0.tar.gzcd boost_1_68_0 booststrap.shboost库有两种类型 1.需要编译才可使用 2.直接包含文件即可使用booststrap.sh设置编译参数 如下设置库的安装目录为/usr/lib/boost 编译thread date_time 如果安装全部组件则不需要指定—with-libraries1./bootstrap.sh --prefix=/usr/lib/boost --with-libraries=thread,date_time 再运行b2编译安装12./b2./b2 install boost库瘦身boost库很是庞大,只需要部分功能的话可以使用bcp工具瘦身 编译bcp工具1./b2 tools/bcp 使用bcp工具如下创建boost_lib目录 提取smart_ptr thread组件到boost_lib目录12mkdir boost_lib./dist/bin/bcp smart_ptr thread ./boost_lib 注意此处提取只是头文件","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"MySQL主从复制与异地容灾","slug":"mysql-slave","date":"2018-09-18T11:12:57.000Z","updated":"2019-05-06T11:12:57.000Z","comments":true,"path":"2018/09/18/mysql-slave/","link":"","permalink":"http://www.casezheng.date/2018/09/18/mysql-slave/","excerpt":"","text":"MySQL主从复制用途、条件和问题用途 实时灾备，用于故障切换 读写分离，提供查询服务 主从复制的必要条件 主库开启binlog日志(设置log-bin参数) 主库和从库的server-id不同 从库能连接到主库，并且有权限 主从复制原理MySQL最基本的主从复制是异步复制（Asynchronous replication）Master事务的提交不需要经过Slave的确认，Master对Slave接收Master binlog成功与否并不关心。Slave接收到Master的binlog后先写relay log，然后异步执行relay log的SQL。从库有两个线程 I/O线程，请求主库的binlog，并将得到的binlog日志写入到relay log(中继日志)文件中。 SQL线程，读取中继日志，并解析成具体的操作执行，保证主从一致12345678910Slave1 --------------------------------&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; /|\\ Commit | End ------ | -----&gt; \\|/ | | 不用等待直接返回成功Master -----&gt; execute ---&gt; binlog -----&gt; commit ---------------------------------------------------&gt; | | \\|/Slave2 --------------------------------&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; 主库生成log dump线程，给从库的I/O线程传递binlog 问题 主库和从库的同步会出现延时，主库宕机可能导致数据丢失 主库和从库的同步因为网络延迟等各种问题，导致主库和从库的差距过大 主库和从库的由于配置问题、权限问题等，导致主从同步失败 主库只负责把binlog日志发送到从库，当从库故障时，导致主从数据库数据不一致 单一的主从复制并不能保证数据的安全可靠，也不能做到异地容灾 解决方案 基于GTID的半同步复制 解决数据丢失问题(GTID) 解决从库故障时主库无感知的问题(半同步) 并行复制，解决从库复制延迟的问题 MySQL基于GTID的半同步复制GTIDGTID(Global Transaction ID 全局事物标记)是对于一个已提交事务的编号，并且是一个全局唯一的编号.GTID实际上是由UUID+TID组成的.其中UUID是一个MySQL实例的唯一标识.server_uuid在MySQl启动时，使用当前时间，随机数等拼接成一个128bit位的uuid.然后该server_uuid被写入到auto.conf文件，当MySQL再次重启时不再随即生成，直接使用保存的这个server_uuid.TID代表了该实例上已经提交的事务数量，并且随着事务提交单调递增.MySQL数据库从5.6.5开始新增一种基于GDIT的复制方式.通过GDIT保证每个主库上提交的事务在集群中有一个唯一的ID.这种方式强化了数据库的主备一致性，故障恢复以及容错能力. 全同步复制（Fully synchronous replication）主库完成一个事务，所有从库都需要返回事务执行成功才返回给客户端。由于要所有从库都返回Ack成功才能返回，所有全同步复制的性能会受到严重影响 半同步复制（Semisynchronous replication）半同步复制的效率介于异步复制和半同步复制之间，主库完成一个事务不直接返回给客户端，而是等待至少一个从库接收到并写到relay log中然后给主库返回Ack，才返回客户端。123456789101112Slave1 ------------------------------&gt; relay log ----------&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; /|\\ | | Ack 至少等待一个从库的Ack才给客户端返回成功 | | Commit | | Commit End ------ | | -----&gt; \\|/ | \\|/ |Master -----&gt; execute ---&gt; binlog -----&gt; engine commit -------------------------------------------------&gt; | /|\\ | Ack \\|/ |Slave2 ------------------------------&gt; relay log ----------&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; 半同步复制Slave对relay log的应用仍然是异步的 开启基于GTID的主从复制，在从库和主库都需要在配置文件加入如下配置:123gtid-mode=ONenforce-gtid-consistency=ONlog-slave-updates=ON 半同步复制的增强MySQL5.7增强半同步复制，两种方式：AFTER SYNC和AFTER COMMIT AFTER COMMIT5.6版本MySQL半同步的方式，现在引擎层做提交后再等待Ack确认。如果一个事务在该模式下，如果在接收Ack的阶段Master实例故障，数据库切到从库,有两种请求： binlog未发送到从库，但主库已经提交了，主从数据不同步 binlog已发送到从库，但Client未收到提交成功的消息，但该事务实际已执行成功，如果业务不判断则会将该事务执行两次 AFTER SYNC官方推荐方式，客户端发出Commit请求后，在主库上写入binlog并推送给Slave，Slave接收到binlog并写入relay log，再发送Ack到Master，Master收到Ack后再在引擎层提交。123456789101112Slave1 ------------------------------&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; /|\\ | | Ack 至少等待一个从库的Ack才给客户端返回成功 | | Commit | | End ------ | | -----&gt; \\|/ | \\|/ |Master -----&gt; execute ---&gt; binlog ------------------&gt;----engine commit --------------------------&gt; | /|\\ | Ack \\|/ |Slave2 ------------------------------&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; 该模式下，现将binlog发送到从库，然后再在引擎层提交 基于GTID的主从复制实例配置单机启动3306和3307两个MySQL实例，配置以3306作为主库，3307为从库 同步主库的test.t_test1和test.t_test2两个实例的server-id不能相同123456789101112131415161718192021222324252627282930313233343536373839404142[mysqld3306]user = mysqlport = 3306socket = /data/mysql/3306/mysql.sockpid-file = /data/mysql/3306/mysqld.pidlog-error = /data/mysql/3306/mysqld.logdatadir = /data/mysql/3306/datamax_connections = 200default-storage-engine = innodbcharacter_set_server = utf8log-bin=mysql-bin #开启二进制日志server-id=1 #服务器IDbinlog-do-db=test #需要同步的数据库名binlog-ignore-db=mysql #禁止同步的数据库名gtid-mode=ONenforce-gtid-consistency=ONlog-slave-updates=ON[mysqld3307]user = mysqlport = 3307socket = /data/mysql/3307/mysql.sockpid-file = /data/mysql/3307/mysqld.pidlog-error = /data/mysql/3307/mysqld.logdatadir = /data/mysql/3307/datamax_connections = 200default-storage-engine = innodbcharacter_set_server = utf8log-bin=mysql-binserver-id=2relay_log=relay-binreplicate-wild-do-table=test.t_test1replicate-wild-do-table=test.t_test2slave-skip-errors=allgtid-mode=ONenforce-gtid-consistency=ONlog-slave-updates=ON 3307同步3306的test.t_test1和test.t_test2 在3306上创建同步所用的帐号 grant replication slave on *.* to rep@&#39;%&#39; identified by &#39;123456&#39;; 在3307上设置同步配置 change master to master_host=&#39;127.0.0.1&#39;,master_user=&#39;rep&#39;,master_password=&#39;123456&#39;,master_port=3306; 开启同步 start slave; 关闭同步 stop slave; 查看同步状态 show slave status\\G1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556MariaDB [(none)]&gt; show slave status\\G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 127.0.0.1 Master_User: root Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 502 Relay_Log_File: relay-bin.000002 Relay_Log_Pos: 801 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: test.t_test1,test.t_test2 Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 502 Relay_Log_Space: 1104 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_SSL_Crl: Master_SSL_Crlpath: Using_Gtid: No Gtid_IO_Pos: Replicate_Do_Domain_Ids: Replicate_Ignore_Domain_Ids: Parallel_Mode: conservative SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it Slave_DDL_Groups: 0Slave_Non_Transactional_Groups: 0 Slave_Transactional_Groups: 11 row in set (0.000 sec) MySQL组复制（MySQL Group Replication，简称MGR）传统异步复制和半同步复制的缺陷（数据的一致性问题无法保证）由若干个节点共同组成一个复制组，一个事物的提交，必须经过组内大多数节点（N/2+1）决议并通过才能进行提交。组复制主要是解决传统异步复制和半同步复制可能产生的数据不一致的问题。组复制依靠分布式一致性协议（Paxos协议的变体），实现分布式下数据的一致性。 MGR原理1234567891011121314 -------------------- | |Slave1 --------------|---------&gt;------&gt; certify ---&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; | /|\\ | Commit | | | End ------ | | | -----&gt; \\|/ | | | |Master -----&gt; execute|----------------&gt; certify ---&gt; binlog ------------------&gt;-----------&gt; commit ------------&gt; | | | | \\|/ |Slave2 --------------|---------&gt;------&gt; certify ---&gt; relay log ---&gt; apply ---&gt; binlog ---&gt; commit -------------&gt; | | | Consensus | -------------------- 一个复制组由若干个节点（数据库实例）组成，组内各个节点维护各自的数据副本，通过一致性协议实现原子消息和全局有序消息，来实现组内实例数据的一致。 MGR特性 数据一致性保障：确保集群中大部分节点收到日志 多节点写入支持：多写模式下支持集群中的所有节点都可以写入 容错：确保系统发生故障（包括脑裂）依然可用 MGR的性能比Semi-sync（半同步复制）好 MGR能极大的简化业务逻辑架构 碰到问题mysqld_multi启动实例会默认读取mysql默认配置mysqld_multi启动实例会读取默认mysql配置，导致配置有问题，尝试给mysqld_multi使用--defaults-file设置默认配置，但仍未解决，最后解决方法先移除mysql默认配置，启动mysqld_multi实例后再恢复回去 参考资料 mysql的主从复制和半同步复制 MySQL 5.7半同步复制技术 MySQL5.7新特性—官方高可用方案MGR介绍 【MySQL】5.7增强半同步AFTER SYNC&amp;AFTER COMMIT MySQL5.7新特性半同步复制之AFTER_SYNC/AFTER_COMMIT的过程分析和总结","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL单机多实例","slug":"mysqld-multi","date":"2018-09-17T10:48:08.000Z","updated":"2019-05-06T17:12:08.000Z","comments":true,"path":"2018/09/17/mysqld-multi/","link":"","permalink":"http://www.casezheng.date/2018/09/17/mysqld-multi/","excerpt":"","text":"这里演示在单台机器上利用mysqld_multi运行两个MySQL实例,MySQL版本5.1.73 配置文件创建mysql_multi所需的配置文件touch /etc/mysql_multi.cnf 编辑配置文件如下vim /etc/mysql_multi.cnf1234567891011121314151617181920212223242526[mysqld_multi]mysqld = /usr/bin/mysqld_safemysqladmin = /usr/bin/mysqladminlog = /data/mysql/log/mysqld_multi.log[mysqld3306]user = mysqlport = 3306socket = /data/mysql/3306/mysql.sockpid-file = /data/mysql/3306/mysqld.pidlog-error = /data/mysql/3306/mysqld.logdatadir = /data/mysql/3306/datamax_connections = 200default-storage-engine = innodbcharacter_set_server = utf8[mysqld3307]user = mysqlport = 3307socket = /data/mysql/3307/mysql.sockpid-file = /data/mysql/3307/mysqld.pidlog-error = /data/mysql/3307/mysqld.logdatadir = /data/mysql/3307/datamax_connections = 200default-storage-engine = innodbcharacter_set_server = utf8 初始化DBmysql_install_db —datadir=/data/mysql/3306/data —user=mysqlmysql_install_db —datadir=/data/mysql/3307/data —user=mysql 查看mysql用户组 不存在则创建一个查看grep mysql /etc/group 创建groupadd mysql 查看mysql用户 不存在则创建一个查看grep mysql /etc/passwd 创建useradd mysql -g mysql -M -s /sbin/nologin 1234增加一个名为CentOS Mysql的用户。-g：指定新用户所属的用户组(group)-M：不建立根目录-s：定义其使用的shell，/sbin/nologin代表用户不能登录系统。 给mysql用户添加权限chown -R mysql.mysql /data/mysql 启用MySQL实例mysqld_multi --defaults-extra-file=/etc/mysql_multi.cnf start 查看启用的MySQL实例状态12345678910[root@HSB-DEV-001 log]mysqld_multi --defaults-extra-file=/etc/mysql_multi.cnf reportReporting MySQL serversMySQL server from group: mysqld3306 is runningMySQL server from group: mysqld3307 is running[root@HSB-DEV-001 mysql]ps -aef | grep mysqlroot 28064 1 0 19:08 pts/7 00:00:00 /bin/sh /usr/bin/mysqld_safe --user=mysql --port=3306 --socket=/data/mysql/3306/mysql.sock --pid-file=/data/mysql/3306/mysqld.pid --log-error=/data/mysql/3306/mysqld.log --datadir=/data/mysql/3306/data --max_connections=200 --default-storage-engine=innodb --character_set_server=utf8root 28072 1 0 19:08 pts/7 00:00:00 /bin/sh /usr/bin/mysqld_safe --user=mysql --port=3307 --socket=/data/mysql/3307/mysql.sock --pid-file=/data/mysql/3307/mysqld.pid --log-error=/data/mysql/3307/mysqld.log --datadir=/data/mysql/3307/data --max_connections=200 --default-storage-engine=innodb --character_set_server=utf8mysql 28304 28064 0 19:08 pts/7 00:00:00 /usr/libexec/mysqld --basedir=/usr --datadir=/data/mysql/3306/data --user=mysql --max_connections=200 --default-storage-engine=innodb --character_set_server=utf8 --log-error=/data/mysql/3306/mysqld.log --pid-file=/data/mysql/3306/mysqld.pid --socket=/data/mysql/3306/mysql.sock --port=3306mysql 28308 28072 0 19:08 pts/7 00:00:00 /usr/libexec/mysqld --basedir=/usr --datadir=/data/mysql/3307/data --user=mysql --max_connections=200 --default-storage-engine=innodb --character_set_server=utf8 --log-error=/data/mysql/3307/mysqld.log --pid-file=/data/mysql/3307/mysqld.pid --socket=/data/mysql/3307/mysql.sock --port=3307 设置密码和权限登录MySQLmysql -h 127.0.0.1 -P3306 -uroot -p 修改密码SET PASSWORD=password(&#39;123456&#39;); 设置权限GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; 查看权限SHOW GRANTS FOR &#39;root&#39;@&#39;%&#39;; 设置mysqld_multi为开机自启动 sudo vim /etc/rc.d/rc.local 12#!/bin/bashmysqld_multi --defaults-extra-file=/etc/mysql_multi.cnf start 赋予rc.local可执行权限chmod +x /etc/rc.d/rc.local sudo vim /usr/lib/systemd/system/rc-local.service 12[Install]WantedBy=multi-user.target 设置rc-local.service服务开机运行systemctl enable rc-local.service 问题解决Warning: World-writable config file ‘/etc/mysql_multi.cnf’ is ignored123456[root@HSB-DEV-001 ~]# /usr/local/mysql/bin/mysqld_multi --defaults-extra-file=/etc/mysql_multi.cnf reportWarning: World-writable config file &apos;/etc/mysql_multi.cnf&apos; is ignoredWarning: World-writable config file &apos;/etc/mysql_multi.cnf&apos; is ignoredReporting MySQL serversWarning: World-writable config file &apos;/etc/mysql_multi.cnf&apos; is ignoredMySQL server from group: mysqld3307 is running 当配置文件的权限为任何人都可访问时,MySQL任务不安全会忽略配置文件,改为644即可1[root@HSB-DEV-001 ~]# chmod 644 /etc/mysql_multi.cnf doesn’t have a default value重启MySQL实例后执行SQL命令报如下错误,经查是开启了MySQL严格模式导致的,使用select @@sql_mode;语句查看MySQL实例的模式,发现确实是开启了严格模式,查看MySQL配置配置,发现已经设置不使用严格模式,最后发现是MySQL读取了多个配置文件导致的,MySQL在读取了首选配置文件后又读取了别的配置文件导致设置的默认被覆盖. 查看MySQL模式1234567MariaDB [(none)]&gt; select @@sql_mode;+--------------------------------------------+| @@sql_mode |+--------------------------------------------+| STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION |+--------------------------------------------+1 row in set (0.00 sec) 在sql_mode中有STRICT_TRANS_TABLES则表示开启严格模式, 使用mysql严格模式可以使数据更加安全严格，缺点是减少了对空数据入库的兼容性, 严格模式功能说明: 不支持对not null字段插入null值 不支持对自增长字段插入值 不支持text字段有默认值 查看MySQL默认配置文件和优先顺序12[CaseZheng@VM_187_252_centos ~]$ mysql --help|grep &apos;my.cnf&apos;/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"RabbitMQ","slug":"rabbitmq","date":"2018-07-13T07:02:50.000Z","updated":"2018-08-28T15:03:00.000Z","comments":true,"path":"2018/07/13/rabbitmq/","link":"","permalink":"http://www.casezheng.date/2018/07/13/rabbitmq/","excerpt":"","text":"RabbitMQ的安装RabbitMQ官网系统版本12345CaseZheng@VM_187_252_centos ~]$ uname -aLinux VM_187_252_centos 3.10.0-693.17.1.el7.x86_64 #1 SMP Thu Jan 25 20:13:58 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux[CaseZheng@VM_187_252_centos ~]$ cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core) RabbitMQ基于Erlang,需要先安装Erlang环境 Erlang安装Erlang的版本需要看下RabbitMQ的对应版本的要求Erlang的下载页面 下载Erlang到本地1wget http://erlang.org/download/otp_src_21.0.tar.gz 解压并安装1234tar zxvf otp_src_21.0.tar.gzcd otp_src_21.0/./configuremake &amp;&amp; sudo make install 默认使用默认路径 如需更改需要在 ./configure 时指定 如:1./configure --prefix=/opt/erlang 输入erl有以下提示则为安装成功1234[CaseZheng@VM_187_252_centos ~]$ erlErlang/OTP 21 [erts-10.0] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1] [hipe]Eshell V10.0 (abort with ^G)1&gt; RabbitMQ安装下载RabbitMQ 这里安装rabbitmq的generic版本1wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.7/rabbitmq-server-generic-unix-3.7.7.tar.xz 解压1tar xvJf rabbitmq-server-generic-unix-3.7.7.tar.xz 移动 rabbitmq_server-3.7.7 到 /usr/local/ 并重命名为rabbitmq1sudo mv rabbitmq_server-3.7.7 /usr/local/rabbitmq 给/etc/profile加入环境变量如下:1export PATH=$PATH:/usr/local/rabbitmq/sbin 使环境变量生效1source /etc/profile 启用rabbitmq网页管理插件(该插件实际已随rabbitmq安装,启用即可)1rabbitmq-plugins enable rabbitmq_management 启动rabbitmq12rabbitmq-server -detachedERROR: epmd error for host bogon: timeout (timed out) 出现此报错信息是因为解析不了主机名 修改hosts 将主机名解析到127.0.0.1或者当前机器的内网地址 查看启动成功12345[CaseZheng@VM_187_252_centos ~]$ netstat -tunlp | grep beam tcp 0 0 0.0.0.0:15672 0.0.0.0:* LISTEN 31942/beam.smp tcp 0 0 0.0.0.0:25672 0.0.0.0:* LISTEN 31942/beam.smp tcp6 0 0 :::5672 :::* LISTEN 31942/beam.smp udp 0 0 0.0.0.0:46173 0.0.0.0:* 31942/beam.smp 添加用户 设置用户组 授权123rabbitmqctl add_user root 123456rabbitmqctl set_user_tags root administratorrabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 可通过外网地址+15672端口号的形式访问web管理界面,需要开放15672端口 RabbitMQ介绍RabbitMQ是由Erlang语言开发的AMQP的开源实现AMQP(Advanced Message Queuing Protocol 高级消息队列协议)是一个开放的应用层协议,为面对消息的中间件而设计,基于此协议的客户端和消息中间件可传递消息. AMQP模型简介12345 |---------------------------------| | |生产者 ---publish--|-&gt; Exchange ---Routes---&gt; Queue -|--consumes---&gt; 消费者 | | |-------- Brokers(消息代理) ------| 生产者发布消息到交换机,交换机根据路由规则将消息转发到消息队列,消息队列从消息队列取数据消费.生产者可以在发布消息时给消息指定各种消息属性.消息的属性有的会被消息代理(brokers)使用,有的则完全不透明,只能由被接收消息的应用所使用.由于网络是不可靠的,而且消费者处理消息也可能失败,为了保证消息可靠的被处理掉,AMQP包含了消息确认机制,当消息从队列投递到消费者后,消费者需通知消息代理,进行确认,这个确认操作可以是自动的,也可以由处理消息的消费者执行.当消息确认机制启用时,消息代理不会完全将消息从队列中删除,直到它收到来自消费者的确认信息. 交换机和交换机类型交换机负责消息的路由,使用的路由算法由交换机和绑定规则决定. 交换机类型(Exchange Type) 预声明的默认名称 Direct exchange (Empty string) 或 amq.direct Fanout exchange amq.fanout Topic exchange amq.topic Headers exchange amq.match 交换机除类型外,在申明交换机时还有许多其它属性,主要的有: Name Durability 消息代理重启后,交换机是否存在 Auto-delete 在所有与之绑定的消息队列都完成对此交换机的使用后,删除它 交换机有两个状态:持久(durable)和暂存(transient),持久化的交换机在消息代理重启后依然存在,而暂存的交换机则不会. 默认交换机默认交换机是一个由消息代理预先声明的名字为空字符串的amq.direct交换机 Direct exchange(直连交换器 路由键完全匹配)direct exchange是根据消息携带的路由键将消息投递给对应队列的.direct exchange用来处理消息的单播路由 将一个队列绑定在某个交换机上,同时绑定一个路由键 当一个携带路由键R的消息被发送到直连交换机时,交换机会将该消息路由给绑定值同样为R的队列direct交换器当路由键完全匹配队列绑定键才路由消息到绑定的队列 Fanout exchange(扇形交换器 不理会路由键)fanout exchange将消息路由给绑定在它身上的所有队列,不理会绑定的路由键.如果N个队列绑定在某个扇形交换机上,当有消息发送到此扇形交换机时,交换机将消息的拷贝发送给所有的N个队列.funout exchange用来处理消息的广播路由. Topic exchange(路由键部分匹配)topic exchange通过对消息的路由键和队列到交换机的绑定模式之间的匹配,将消息路由给一个或多个队列.topic exchange经常用来实现各种分发/订阅模式及其变种.topic exchange用来实现消息的多播路由.路由键部分匹配,路由键的约定如下: 路由键为一个句点号”.”分隔的字符串(被”.”分割的每一段独立的字符串称为一个单词),例如:”product.conf.del”, “price.conf.add” 绑定键和路由键都是”.”分隔的字符串 绑定键可以存在两种特殊字符”“和”#”,用于模糊匹配,”“用于匹配一个单词,”#”用于匹配多个单词(可以匹配零个) Headers exchange消息的路由操作如果涉及到多个属性,使用消息头比用路由键更容易表达,headers exchange使用多个消息属性代替路由键建立路由规则.通过判断消息头的值能否与指定的绑定相匹配来确定路由规则. 队列队列(queue)存储着即将被应用消费掉的消息.队列属性: Name Durable(消息代理重启后,队列依旧存在) Exclusive(只被一个连接使用,当连接关闭后队列即被删除) Auto-delete(当最后一个消费者退订后即被删除) Arguments 队列在声明(declare)后才能被使用.如果一个队列尚不存在,声明一个队列会创建它.如果声明的队列已经存在,并且属性完全相同.那么此次声明不会对原有队列产生任何影响.如果声明中的属性与已存在队列的属性有差异,那么一个错误代码为406的通道级异常就会被抛出 队列名称队列名称可以指定,也可以由消息代理生成,队列名称是最多255字节的一个utf-8字符串.如果想让消息代理生成队列名,需要给消息队列的name参数赋值一个空字符串(在统一个通道的后续方法中可以使用空字符串表示之前生成的队列名称,因为通道可以默默记住消息代理最后一次生成的队列名称).以”amq.”开始的队列名称被预留给消息代理内部使用. 队列持久化持久化队列(Durable queues)会被存储在磁盘上,当消息代理重启时它依然存在,没有被持久话的队列被称为暂存队列(Transient queues).持久化队列并不会使得路由到它的消息也持久化,只有持久化的消息才能在消息代理重启后重新恢复. 绑定绑定是交换机将消息路由给队列所需遵循的规则.AMQP的消息无法路由到队列,消息会被就地销毁或者返还给发布者.如何处理取决于发布者设置的消息属性 消费者消费者有两种方式消费数据: 消息代理主动将消息投递给消费者(push API) 消费者根据需要主动获取消息(pull API) 消息确认消息代理删除消息的时机: 当消息代理将消息发送给应用后立即删除(自动确认) 待应用发送一个确认回执后再删除(显式确认) 拒绝消息消费者可以在处理某条消息后向消息代理表明如何处理该消息,销毁它或者重新放入队列. 消息属性 Content type(内容类型) Content encoding(内容编码) Routing key(路由键) Delivery mode(persistent or not)投递模式(持久化或非持久化) Message priority(消息优先权) Message publishing timestamp(消息发布的时间戳) Expiration period(消息有效期) Publisher application id(发布应用ID) 连接AMQP连接通常为长连接,AMQP是一个使用TCP提供可靠投递的应用层协议.AMQP使用认证机制并且提供TLS(SSL)保护.当一个应用不再需要连接到AMQP代理时,需要优雅的释放AMQP连接,而不是直接关闭TCP连接. 通道一个应用可能会和AMQP代理建立多个连接,此时同时开启多个TCP连接不合适,会消耗过多的系统资源,AMQP提供通道来处理多连接,可以将通道理解为共享一个TCP的多个轻量化连接.在多线程/多进程应用中可为每个线程/进程开启一个通道,这些通道不能被线程/进程共享.一个特定通道上的通讯和其它通道上的通信是完全隔离的,因此每个AMQP方法都需要携带一个通道号. 虚拟主机为了在一个单独的AMQP代理上实现多个隔离环境(用户、用户组、交换机、队列等),AMPQ提供虚拟主机概念(vhosts),为AMQP实体提供完全隔离的环境.当连接建立时,AMQP客户端指定使用的虚拟主机. AMQP可扩展RabbitMQ c客户端的使用c客户端编译安装编译安装看git说明即可rabbitmq-c git网址 api说明api可查看官方文档或头文件注释rabbitmq-c 官方文档 原始c接口的封装rabbitmq-c 原始c接口的简单封装 参考文档 RabbitMQ基础知识","categories":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://www.casezheng.date/tags/rabbitmq/"}],"keywords":[{"name":"高性能服务器","slug":"高性能服务器","permalink":"http://www.casezheng.date/categories/高性能服务器/"}]},{"title":"服务器框架设计与编码","slug":"simple-server-framework","date":"2018-07-12T10:16:50.000Z","updated":"2018-07-12T10:16:50.000Z","comments":true,"path":"2018/07/12/simple-server-framework/","link":"","permalink":"http://www.casezheng.date/2018/07/12/simple-server-framework/","excerpt":"","text":"一个libevent和boost库写的轻量级服务器框架 总体服务器框架先看下总体的服务器框架设计图服务器启动,根据不同服务实例化出对应的CLibeventFrame实例,例如Http服务器实例化CLibeventHttpFrame,Rpc服务实例化CLibeventRpcFrame,Tcp服务实例化CLibeventTcpFrame,Timer定时器服务实例化CLibeventTimerFrame.然后运行初始化函数Init(初始化日志,拉取配置文件等操作),然后运行Run函数启动反应堆. Http服务器Http服务器代码 Http服务器类图如下:在调用CLibeventHttpFrame的Init函数时,除了初始化框架的日志,配置等模块外,还会生成CHttpServer实例,并运行HttpServer的初始化Init函数,给evhttp设置相应uri对应的回调函数,最后返回.等框架启动反应堆后,当有请求到来,会调用CPacket的DealPacket函数,解析请求,并通过uri分发请求,如果为默认的请求则分发到CPacketModel,并根据Interface分发到不同的CDealModel,自定义URI则分发到别的具体的CPacket实例,例如示例CExamplePacket. Timer服务器Timer服务器代码 Timer服务器类图如下:在调用CLibeventTimerFrame的Init函数时,除了初始化框架的日志,配置等模块外,还会生成CTimerServer实例,并运行CTimerServer的初始化Init函数,生成定时器,最后启动定时器,当定时器激活后根据注册的ItimerServer执行相应的应用代码 Tcp服务器Tcp服务器代码 Tcp服务器类图如下:在调用CLibeventTcpFrame的Init函数时,除了初始化框架的日志,配置等模块外,还会生成CTcpServer实例,并运行CTcpServer的初始化Init函数,生成具体的IDealModel实例化对象和IProtocol实例化对象,返回后框架启动反应堆,当有请求到来时生成一个CSocketHandle对象,并记录到CTcpServer中,对发过来的信息,通过IProtocol实例解析报文,并将解析后的信息存放在生成的IPacketModel实例中,将IPacketModel实例传递给IDealModel实例进行业务逻辑的处理. Rpc服务器Rpc服务器代码 Rpc服务器类图如下: 在调用CLibevenRpcFrame的Init函数时,除了初始化框架的日志,配置等模块外,还会生成CRpcServer实例,并运行CTcpServer的初始化Init函数,将InterfaceInfo信息通过evrpc_register_generic注册到libevent中,然后返回,框架启动反应堆,如果收到rpc请求则会调用注册的各个回调函数,包括生成请求参数结构体,将请求信息解码到请求信息结构体中,生成返回信息结构体,业务处理回调函数,将返回信息结构体重新编码为字节流的回调函数等.libevent的rpc框架中存在一个问题,如果请求参数为空会core掉,经查是libevent的一个bug.已经提了Issues.","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"libevent","slug":"libevent","permalink":"http://www.casezheng.date/tags/libevent/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"elasticsearch入门学习","slug":"elasticsearch","date":"2018-06-08T02:54:14.000Z","updated":"2018-10-13T02:54:14.000Z","comments":true,"path":"2018/06/08/elasticsearch/","link":"","permalink":"http://www.casezheng.date/2018/06/08/elasticsearch/","excerpt":"","text":"简介Elasticsearch是一个分布式、可扩展、实时的搜索和数据分析引擎。支持全文索引、结构化搜索、数据分析。 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 Elasticsearch和Lucene关系Elasticsearch基于Lucene开发而来,Lucene是一个搜索引擎框架,基于Lucene开发需要做大量工作,调用各种API接口.Elasticsearch隐藏了Lucene的复杂性,提供了分布式方案. 安装从官网下载最新版本安装,步骤看官网文档即可 运行1./bin/elasticsearch 可以在后面添加参数 -d, 使Elasticsearch作为一个守护进程在后台运行1234567891011121314curl &apos;http://localhost:9200/?pretty&apos;&#123; &quot;name&quot; : &quot;YZ_zxCT&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;BKMvoXKrTW-4mj2OyOfibw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;5.6.3&quot;, &quot;build_hash&quot; : &quot;1a2f265&quot;, &quot;build_date&quot; : &quot;2017-10-06T20:33:39.012Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;6.6.1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 使用具体可查看Elasticsearch官方文档 Elasticsearch中文资料 Elasticsearch: 权威指南 Elasticsearch教程","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.casezheng.date/tags/elasticsearch/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"linux信号","slug":"linux-signal","date":"2018-06-03T14:18:14.000Z","updated":"2018-06-03T14:18:14.000Z","comments":true,"path":"2018/06/03/linux-signal/","link":"","permalink":"http://www.casezheng.date/2018/06/03/linux-signal/","excerpt":"","text":"不可忽略或捕获的信号SIGSTOP和SIGKILL一般的信号可以使用signal函数忽略或捕获做进一步处理,而SIGSTOP和SIGKILL信号不可捕获,自然也没有办法忽略了. 在命令行使用kill -l命令可以列出所有linux信号1234567891011121314[CaseZheng@VM_187_252_centos example]$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX Linux信号的捕获signal123#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); signum信号值handler信号处理函数,有两个特殊值 SIG_IGN屏蔽该函数 SIG_DFL恢复默认行为返回值为之前的信号处理函数 sigaction123456789#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);struct sigaction &#123; void (*sa_handler)(int); //信号处理函数 void (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数 第二个参数可指向一个siginfo_t结构体 sigset_t sa_mask; //屏蔽信号集 int sa_flags; // void (*sa_restorer)(void); //&#125;; 用于改变进程接收到特定信号后的行为signum信号值act指向sigaction的一个实例指针,在sigaction中制定了对特定信号的处理方式,为空表示使用默认方式对信号进行处理oldact保存原来对信号的处理方式,可以为NULL成功返回0,失败返回-1","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"boost-log日志组件","slug":"boost-log","date":"2018-04-27T15:25:30.000Z","updated":"2018-04-27T15:25:30.000Z","comments":true,"path":"2018/04/27/boost-log/","link":"","permalink":"http://www.casezheng.date/2018/04/27/boost-log/","excerpt":"","text":"boost-log常用简写123456namespace logging = boost::log;namespace src = boost::log::sources;namespace expr = boost::log::expressions;namespace sinks = boost::log::sinks;namespace attrs = boost::log::attributes;namespace keywords = boost::log::keywords; boost-log的结构图boost::log 的设计主要有日志器(Logger)、日志核心(Logging core)、Sink 前后端(frontend, backend)组成.日志文本以及日志环境由日志器(Logger)负责搜集，日志核心负责处理日志数据(例如全局过滤、将日志记录传递给 Sink ),Sink前端分为同步、异步以及不考虑线程同步问题的版本,它们负责将日志记录传递给 Sink 后端处理.Sink后端负责把日志记录格式化并输出到不同的介质中(例如日志文件、报警以及统计源中). Logging core的获取12#include &lt;boost/log/core.hpp&gt;boost::shared_ptr&lt;logging::core&gt; core = logging::core::get(); sink对象创建需要先创建一个backend对象，然后在创建sink对象的时候，将backend对象传递给它12345678typedef sinks::synchronous_sink&lt;sinks::text_file_backend&gt; TextSink;// init sinkboost::shared_ptr&lt;sinks::text_file_backend&gt; backend = boost::make_shared&lt;sinks::text_file_backend&gt;( keywords::file_name = \"sign_%Y-%m-%d_%H-%M-%S.%N.log\", keywords::rotation_size = 10 * 1024 * 1024, keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0), keywords::min_free_space = 30 * 1024 * 1024);boost::shared_ptr&lt;TextSink&gt; sink(new TextSink(backend)); backend创建指定frontend类型backend的类型需要一个frontend类型作为其模版类,当创建一个backend对象时,已经确定了frontend.frontend模版可以使用synchronous_sink类或者asynchronous_sink类,后者不会阻塞调用程序,会创建额外线程处理log,不过会慢点,内存消耗大点.一般推荐使用后者. 用keywords构造参数boost/log/keywords目录下hpp文件1234[CaseZheng@VM_187_252_centos keywords]$ lsauto_flush.hpp channel.hpp empty_marker.hpp file_name.hpp ident.hpp iteration.hpp max_files.hpp min_free_space.hpp order.hpp permissions.hpp scan_method.hpp target.hppblock_size.hpp delimiter.hpp enable_final_rotation.hpp filter.hpp incomplete_marker.hpp log_name.hpp max_size.hpp name.hpp ordering_window.hpp registration.hpp severity.hpp time_based_rotation.hppcapacity.hpp depth.hpp facility.hpp format.hpp ip_version.hpp log_source.hpp message_file.hpp open_mode.hpp overflow_policy.hpp rotation_size.hpp start_thread.hpp use_impl.hpp keywords是boost库的基本概念，设计到一个宏BOOST_PARAMETER_KEYWORD，定义在boost/parameter/keywords.hpp文件中， 主要作用就是在指定的namespace中创建一个singleton的对象。1keywords::file_name = \"sign_%Y-%m-%d_%H-%M-%S.%N.log\", 上述代码:给keywords namespace下的singleton对象file_name赋值.text_file_backend的构造函数语法上支持变参，但是语义上只支持有限的keywords sink指定格式指定日志格式,在sink中指定1234567sink-&gt;set_formatter ( expr::format(\"[%1%]&lt;%2%&gt;(%3%): %4%\") % expr::format_date_time&lt; boost::posix_time::ptime&gt;(\"TimeStamp\", \"%Y-%m-%d %H:%M:%S\") % expr::attr&lt;sign_severity_level&gt;(\"Severity\") % expr::attr&lt;attrs::current_thread_id::value_type&gt;(\"ThreadID\") % expr::smessage ); Boost::Format风格12345678logging::formatter fmt = expr::stream &lt;&lt; std::setw(6) &lt;&lt; std::setfill('0') &lt;&lt; line_id &lt;&lt; std::setfill(' ') &lt;&lt; \": &lt;\" &lt;&lt; severity &lt;&lt; \"&gt;\\t\" &lt;&lt; expr::if_(expr::has_attr(tag_attr)) [ expr::stream &lt;&lt; \"[\" &lt;&lt; tag_attr &lt;&lt; \"] \" ] &lt;&lt; expr::smessage; sink对象安装1core-&gt;add_sink(sink); attributes根据设计，日志记录是由attributes组成的，所以打印内容必须以attribute的方式传给sink对象12345678sink-&gt;set_formatter ( expr::format(\"[%1%]&lt;%2%&gt;(%3%)(%4%): %5%\") % expr::attr&lt;unsigned int&gt;(\"LineID\") % expr::format_date_time&lt; boost::posix_time::ptime &gt;(\"TimeStamp\", \"%Y-%m-%d %H:%M:%S\") % expr::attr&lt;sign_severity_level&gt;(\"Severity\") % expr::attr&lt;attrs::current_thread_id::value_type &gt;(\"ThreadID\") % expr::smessage); 不要忘记添加commont attributes1logging::add_common_attributes(); 示例代码boost log封装示例代码 log.cppboost log封装示例代码 log.h","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"MySQL数据导出、导入","slug":"mysql-10","date":"2018-04-09T13:14:17.000Z","updated":"2018-04-09T13:14:17.000Z","comments":true,"path":"2018/04/09/mysql-10/","link":"","permalink":"http://www.casezheng.date/2018/04/09/mysql-10/","excerpt":"","text":"MySQL数据导出工具mysqldumpmysqldump客户端工具是MySQL最常用的备份工具.123mysqldump [option] db_name [tables] # 备份单个数据库或者库中部分数据表mysqldump [option] --database DB1 [DB2 DB3] # 备份指定的一个或者多个数据库mysqldump [option] --all --database # 备份所有数据库 连接选项1234-u, --user=name 指定用户名-p, --password[=name] 指定密码-h, --host=name 指定服务器IP或者域名-p, --port=# 指定连接端口 数据内容选项12--add-drop-database 每个数据库创建语句前加上DROP DATABASE语句--add-drop-table 在每个表创建语句前加上DROP TABLE语句 默认情况下这两个选项自动添加 123-n, --no-create-db 不包含数据库的创建语句-t, --no-create-info 不包含数据表的创建语句-d, --no-data 不包含数据 输出格式选项123--compact 选项使数据结果更简洁,不包括默认选项中的各种注释-c, --complete-insert 使输出文件的insert语句包括字段名称-T 将指定数据表中的数据备份为单纯的数据文本和建表SQL两个文件 字符集选项1--default-character-set=name 选型设置导出的客户端字符集 其它常用选项1234-F, --flush-logs 备份前刷新日志-l, --lock-tables 给所有表加读锁 默认开启--where=condition 导出数据的条件--skip-lock-table 导出数据时不锁表 MySQL数据导入工具mysqlimport1mysqlimport [options] db_name textfile1 [textfile2...] 也可以进入数据库使用sourece命令直接执行sql文件","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 优化","slug":"mysql-9","date":"2018-03-31T16:01:39.000Z","updated":"2018-03-31T16:01:39.000Z","comments":true,"path":"2018/04/01/mysql-9/","link":"","permalink":"http://www.casezheng.date/2018/04/01/mysql-9/","excerpt":"","text":"优化SQL步骤了解SQL的执行频率1show [session|global] status; 执行命令提供服务器状态信息，session表示显示session(当前连接)级别的统计结果，global表示显示global(从服务器启动至今)级别的统计结果，默认为session级别。1234567891011MariaDB [(none)]&gt; show global status like 'Com_%';+----------------------------+-------+| Variable_name | Value |+----------------------------+-------+| Com_admin_commands | 1 || Com_alter_db | 0 || Com_alter_db_upgrade | 0 || Com_alter_event | 0 || Com_alter_function | 0 || Com_alter_procedure | 0 |... ... Com_xxx表示每个xxx语句执行的次数： Com_select:执行select操作的次数，一次查询只累加1 Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累计一次 Com_update:执行update操作的次数 Com_delete:执行delete操作的次数 Com_select、Com_insert、Com_update、Com_delete对所有存储引擎都进行累计。 只准对InnoDB存储引擎： Innodb_rows_read:select查询返回的行数 Innodb_rows_inserted:执行insert操作插入的行数 Innodb_rows_updated:执行update操作插入的行数 Innodb_rows_deleted:执行delete操作删除的行数 对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累计 Com_commit和Com_rollback可以了解事物提交和回滚的情况，对于回滚操作非常频繁的数据库，意味着程序编写存在问题。 了解数据库基本情况: Connections:试图连接MySQL服务器的次数 Uptime:服务器工作时间 Slow_queries:慢查询的次数 定位执行效率较低的SQL语句 通过慢查询日志定位 show processlist命令查看当前MySQL在进行的线程,包括线程的状态、是否锁表等,可以实时地查看SQL的执行情况,通过对一些锁表操作优化 通过EXPLAIN分析低效SQL的执行计划查询到低效的SQL语句后,通过EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息,包括在SELECT语句执行过程中表如何连接和连接的顺序.123456789101112131415MariaDB [test]&gt; desc select * from test_int;+------+-------------+----------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+------+-------------+----------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | test_int | ALL | NULL | NULL | NULL | NULL | 4 | |+------+-------------+----------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec)MariaDB [test]&gt; explain select * from test_int;+------+-------------+----------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+------+-------------+----------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | test_int | ALL | NULL | NULL | NULL | NULL | 4 | |+------+-------------+----------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec) select_type:表示select查询的类型,常见的取值有SIMPLE(简单表,即不使用表连接或子查询)、PRIMARY(主查询,即外层的查询)、UNION(UNION中的第二个或后面的查询语句)、SUBQUERY(子查询中的第一个SELECT)等 table:数据结果集的表 type:表示MySQL在表中找到所需行的方式,或者叫访问类型. possible_keys:表示查询时可能使用的索引 key:表示实际使用的索引 key_len:使用到索引字段的长度 rows:扫描行的数量 Extra:执行情况的说明和描述,包括不适合在其他列中显示但是对执行计划非常重要的额外信息 type类型,从左至右,性能由最差到最好123+-----+-------+-------+-----+--------+--------------+------+| ALL | index | range | ref | eq_ref | const,system | NULL |+-----+-------+-------+-----+--------+--------------+------+ ALL 全表扫描,MySQL遍历全表来找到匹配的行 index 索引全扫描,MySQL遍历整个索引来查询匹配的行 range 索引范围扫描,常见于\\&lt;、\\&lt;=、&gt;、&gt;=、between等操作符 ref 使用非唯一索引扫描或唯一索引的前缀扫描,返回匹配某个单独值的记录行 eq_ref 类似ref,区别就在使用的索引是唯一索引,对于每个索引键值,表中只有一条记录记录匹配;简单说,多表连接中使用primary key或者unique index作为关联条件 const/system 单表中最多有一个匹配行,查询起来非常迅速,所以这个匹配行中的其他列的值可以被优化器在当前查询中当错常量来处理 NULL MySQL不用访问表或索引,直接就能够得到结果 通过explain extended命令和show warnings可以看到SQL真正被执行之前优化器做了哪些SQL改写.1234567891011121314MariaDB [test]&gt; explain extended select * from test_int;+------+-------------+----------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+------+-------------+----------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | test_int | ALL | NULL | NULL | NULL | NULL | 4 | 100.00 | |+------+-------------+----------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)MariaDB [test]&gt; show warnings;+-------+------+-----------------------------------------------------------------------------------------+| Level | Code | Message |+-------+------+-----------------------------------------------------------------------------------------+| Note | 1003 | select `test`.`test_int`.`a` AS `a`,`test`.`test_int`.`b` AS `b` from `test`.`test_int` |+-------+------+-----------------------------------------------------------------------------------------+ filtered通过warning的message字段可以看到优化器优化后的SQL. 碰到复杂SQL时,可以利用explain extended的结果迅速获取更清晰易读的SQL 通过show profile分析SQL通过have_profiling参数可以看到当前MySQL是否支持profile:1234567MariaDB [(none)]&gt; select @@have_profiling;+------------------+| @@have_profiling |+------------------+| YES |+------------------+1 row in set (0.00 sec) 通过profiling参数可以看到当前profiling是否打开1234567MariaDB [(none)]&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 0 |+-------------+1 row in set (0.00 sec) 通过set语句在session级别开启profiling12MariaDB [(none)]&gt; set profiling=1;Query OK, 0 rows affected (0.04 sec) 通过profile可以清楚地了解SQL执行的过程.在执行完SQL后,使用show profiles.查看执行SQL的Query_ID,再使用show profile for query查看执行过程中线程的每个状态和消耗时间.12345678910111213141516171819202122232425262728293031323334353637MariaDB [test]&gt; show profiles;+----------+------------+------------------------+| Query_ID | Duration | Query |+----------+------------+------------------------+| 1 | 0.00007221 | select * from test_int || 2 | 0.00012501 | SELECT DATABASE() || 3 | 0.00029614 | show databases || 4 | 0.00014315 | show tables || 5 | 0.00038331 | select * from test_int |+----------+------------+------------------------+5 rows in set (0.00 sec)MariaDB [test]&gt; show profile for query 5;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000058 || checking permissions | 0.000011 || Opening tables | 0.000026 || After opening tables | 0.000023 || System lock | 0.000006 || Table lock | 0.000043 || After table lock | 0.000009 || init | 0.000021 || optimizing | 0.000011 || statistics | 0.000025 || preparing | 0.000015 || executing | 0.000005 || Sending data | 0.000083 || end | 0.000006 || query end | 0.000007 || closing tables | 0.000010 || freeing items | 0.000012 || updating status | 0.000010 || cleaning up | 0.000005 |+----------------------+----------+19 rows in set (0.00 sec) Sending data状态表示MySQL线程开始访问数据行并把结果返回给客户端,而不仅仅是返回结果给客户端.在Sending data状态下,MySQL线程往往需要做大量的磁盘读取操作,所以经常是整个查询中耗时最长的状态.可以使用show profile查看更加详细的资源消耗情况,可选择all、cpu、block io、context switch、page faults等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051MariaDB [test]&gt; show profile all for query 5;+----------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-----------------------+---------------+-------------+| Status | Duration | CPU_user | CPU_system | Context_voluntary | Context_involuntary | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Page_faults_major | Page_faults_minor | Swaps | Source_function | Source_file | Source_line |+----------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-----------------------+---------------+-------------+| starting | 0.000058 | 0.000034 | 0.000018 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | NULL | NULL | NULL || checking permissions | 0.000011 | 0.000006 | 0.000003 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | check_access | sql_parse.cc | 4911 || Opening tables | 0.000026 | 0.000017 | 0.000009 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | open_tables | sql_base.cc | 5048 || After opening tables | 0.000023 | 0.000015 | 0.000008 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | open_tables | sql_base.cc | 5240 || System lock | 0.000006 | 0.000004 | 0.000002 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_lock_tables | lock.cc | 307 || Table lock | 0.000043 | 0.000028 | 0.000015 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_lock_tables | lock.cc | 312 || After table lock | 0.000009 | 0.000006 | 0.000003 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_lock_tables | lock.cc | 326 || init | 0.000021 | 0.000014 | 0.000007 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_select | sql_select.cc | 3075 || optimizing | 0.000011 | 0.000007 | 0.000004 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | optimize | sql_select.cc | 990 || statistics | 0.000025 | 0.000016 | 0.000008 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | optimize | sql_select.cc | 1233 || preparing | 0.000015 | 0.000010 | 0.000005 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | optimize | sql_select.cc | 1258 || executing | 0.000005 | 0.000003 | 0.000002 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | exec | sql_select.cc | 2242 || Sending data | 0.000083 | 0.000054 | 0.000029 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | exec | sql_select.cc | 2873 || end | 0.000006 | 0.000004 | 0.000002 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_select | sql_select.cc | 3110 || query end | 0.000007 | 0.000004 | 0.000002 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_execute_command | sql_parse.cc | 4520 || closing tables | 0.000010 | 0.000007 | 0.000003 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | close_thread_tables | sql_base.cc | 1466 || freeing items | 0.000012 | 0.000008 | 0.000004 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | mysql_parse | sql_parse.cc | 5944 || updating status | 0.000010 | 0.000006 | 0.000004 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | dispatch_command | sql_parse.cc | 1469 || cleaning up | 0.000005 | 0.000003 | 0.000001 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | dispatch_command | sql_parse.cc | 1486 |+----------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-----------------------+---------------+-------------+19 rows in set (0.00 sec)MariaDB [test]&gt; show profile cpu for query 5;+----------------------+----------+----------+------------+| Status | Duration | CPU_user | CPU_system |+----------------------+----------+----------+------------+| starting | 0.000058 | 0.000034 | 0.000018 || checking permissions | 0.000011 | 0.000006 | 0.000003 || Opening tables | 0.000026 | 0.000017 | 0.000009 || After opening tables | 0.000023 | 0.000015 | 0.000008 || System lock | 0.000006 | 0.000004 | 0.000002 || Table lock | 0.000043 | 0.000028 | 0.000015 || After table lock | 0.000009 | 0.000006 | 0.000003 || init | 0.000021 | 0.000014 | 0.000007 || optimizing | 0.000011 | 0.000007 | 0.000004 || statistics | 0.000025 | 0.000016 | 0.000008 || preparing | 0.000015 | 0.000010 | 0.000005 || executing | 0.000005 | 0.000003 | 0.000002 || Sending data | 0.000083 | 0.000054 | 0.000029 || end | 0.000006 | 0.000004 | 0.000002 || query end | 0.000007 | 0.000004 | 0.000002 || closing tables | 0.000010 | 0.000007 | 0.000003 || freeing items | 0.000012 | 0.000008 | 0.000004 || updating status | 0.000010 | 0.000006 | 0.000004 || cleaning up | 0.000005 | 0.000003 | 0.000001 |+----------------------+----------+----------+------------+19 rows in set (0.00 sec) 通过trace分析优化器如何选择执行计划 打开trace,设置格式为JSON,设置trace最大能够使用的内存大小,避免解析过程中因为默认内存过小而不能完整显示. 执行想要trace的SQL语句 检查INFORMATION_SCHEMA.OPTIMIZER_TRACE123SET OPTIMIZER_TRACE=&quot;enabled=on&quot;,END_MARKERS_IN_JSON=on;SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE\\G 确认问题并采取相应的优化措施简单使用的优化方法定期分析表和检查表分析表1ANALYZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tbl_name[, tbl_name]... 本语句用于分析和存储表的关键字分布,分析的结果将可以使得系统得到准确的统计信息,使得SQL能够生成正确的执行计划 检查表1CHECK TABLE tbl_name[, tbl_name]...[option]...option=&#123;QUICK|FAST|MEDIUM|EXTENDED|CHANGED&#125; 检查表的作用是检查一个或多个表是否有错误.CHECK TABLE也可以检查是否是否有错误. 定期优化表1OPTIONMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tbl_name [,tbl_name]... 优化表可以对表中的空间碎片进行合并.InnoDB引擎的表可以设置innodb_file_per_table参数,设置InnoDB为独立表空间模式,每个数据库的每个表都会生成单独的ibd文件,用于存储表的数据和索引,减轻InnoDB表的控件回收问题.删除大量数据后,InnoDB表可以通过alter table但不修改引擎的方式回收不用的空间1alter table tbl_name engine=innodb; ANLYZE、CHECK、OPTIMIZE、ALTER TABLE执行期间将对表进行锁定,因此一定注意在数据库不繁忙时执行相关操作 常用SQL的优化大批量插入数据使用load命令导入数据,可以通过适当的设置提高导入速度.对于MyISAM存储引擎的表,可以使用DISABLE KEYS关闭MyISAM表非唯一索引的更新,读入完成后,使用ENABLE KEYS打开MyISAM表非唯一索引的更新.123alter table tbl_name disable keys;load data infole '/filepath';alter table tbl_name enable keys; 对于InnoDB存储引擎的表: 将导入的数据按照主键的顺序排序 导入数据前执行SET UNIQUE_CHECKS=0关闭唯一性校验,导入结束再执行SET UNIQUE_CHECKS=1,恢复唯一性校验 关闭自动提交,等导入完成再打开(SET AUTOCOMMINT=0) 优化INSERT语句 同一客户端同时插入很多行,应尽量使用一条语句,减少客户端与数据库之间的连接、关闭等消耗 不同客户端插入很多行,使用INSERT DELAYED语句让INSERT语句马上执行,实际数据都被放在内存队列中,并没有真正写入磁盘 将索引文件和数据文件分在不同的磁盘上存放 批量插入可以通过增加bulk_insert_buffer_size变量值的方法提高速度,只对MyISAM表有用 当从文本文件装载一个表时,使用LOAD DATA INFILE,比使用INSERT语句快 优化ORDER BY语句MySQL两种排序方式 通过使用有序索引顺序扫描直接返回有序数据,在使用explain分析查询语句时显示为Using Index,不需要额外排序操作效率较高 通过对返回数据进行排序(Filesort排序),所有不是通过索引直接返回排序结果的排序都叫Filesort排序. ORDER BY语句优化目标:尽量减少额外的排序,通过索引直接返回有序数据. Filesort优化通过建立合适的索引能减少Filesort的出现.如果条件限制导致Filesort不能消失,则需要加快Filesort的操作对Filesort,MySQL的两种排序算法: 两次扫描算法:根据条件取出排序字段和行指针信息,然后在排序区sort buffer中排序,如果sort buffer不足,则在临时表Temporary Table中存储排序结果.完成排序后再根据行指针回表读取记录.优点是排序的时候内存开销少,缺点是第二次读取记录会有大量随机I/O操作,MySQL4.1以前使用此方法 一次扫描算法:一次性取出所有满足条件行的所有字段,然后排序,优点是速度快,缺点是内存开销大 MySQL通过比较系统变量max_length_for_sort_data的大小和Query语句取出的字段总大小判断使用那种排序算法.如果max_length_for_sort_data更大,则使用一次扫描算法,否则使用二次扫描算法适当加大max_length_for_sort_data可以让MySQL选择一次扫描算法,提高效率,设置max_length_for_sort_data过大,会造成CPU利用率过低和磁盘I/O过高,CPU和I/O利用平衡即可.尽量使用必要的字段,SELECT具体的字段名称,减少排序区的使用,提高SQL性能. 优化GROUP BY语句如果查询包括GROUP BY但用户想避免排序结果的消耗,则可以指定ORDER BY NULL禁止排序. 优化嵌套查询使用连接JOIN替代子查询,因为JOIN不需要在内存中创建临时表 MySQL优化OR条件对于含有OR条件的查询子句,如果想利用索引,则OR之间的每个条件列都必须使用索引,如果没有索引则应该考虑增加索引. 分页查询优化 在索引上完成排序分页操作,最后根据主键关联回原表查询所需额其他列内容 将LIMIT查询转化为某个位置的查询(将LIMIT m,n转化为LIMIT n的查询) 使用SQL提示USE INDEX在查询语句中表名的后面,添加USE INDEX来提供希望MySQL去参考的索引列表,让MySQL不再考虑其它可以索引 IGNORE INDEX让MySQL忽略一个或多个索引 FORCE INDEX强制MySQL使用一个特定的索引 常用SQL技巧正则表达式的使用MySQL利用REGEXP命令提供给用户扩展的正则表达式功能.REGEXP在进行模式匹配时区分大小写. 序列 序列说明 ^ 在字符串的开始处进行匹配 $ 在字符串的末尾处进行匹配 . 匹配任意单个字符，包括换行符 […] 匹配出括号内的任意字符 ... 匹配不出括号内的任意字符 a* 匹配零个或多个a（包括空串） a+ 匹配1个或多个a（不包括空串） a？ 匹配1个或零个a a1 &#124; a2 匹配a1或a2 a(m) 匹配m个a a(m,) 匹配m个或更多个a a(m,n) 匹配m到n个a a(,n) 匹配0到n个a (…) 将模式元素组成单一元素","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 存储过程和函数 触发器","slug":"mysql-8","date":"2018-03-30T12:18:02.000Z","updated":"2020-04-12T04:56:36.166Z","comments":true,"path":"2018/03/30/mysql-8/","link":"","permalink":"http://www.casezheng.date/2018/03/30/mysql-8/","excerpt":"","text":"存储过程和函数存储过程和函数是事先经过编译并存储在数据库的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的工作，减少数据在数据库和应用服务器之间的传输，对提高数据处理的效率有好处。存储过程和函数的区别： 函数必须有返回值，存储过程没有。 存储过程的参数使用IN、OUT、INOUT类型，而函数参数只能是IN类型。 存储过程和函数的相关操作创建、修改存储过程或函数1234567891011121314151617181920212223242526272829303132CREATE PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_bodyCREATE FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_body proc_parameter: [ IN | OUT | INOUT ] param_name type func_parameter: param_name typetype: Any valid MySQL data typecharacteristic: LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; | COMMENT 'string'routine_body: Valid SQL procedure statement or statementsALTER &#123;PROCEDURE | FUNCTION&#125; sp_name [characteristic ...]characteristic: &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; | COMMENT 'string 调用过程：1CALL sp_name([parameter[,......]]) MySQL存储过程和函数允许包含DDL语句，允许在存储过程中执行提交或回滚，但存储过程和函数中不允许执行LOAD DATA INFILE语句。存储过程和函数可以调用其他的过程或函数。在执行创建过程和函数之前，通过DELIMITER语句将语句的结束符从”;”修改成其他符号。在创建过程和函数后通过”DELIMITER ;”语句再将结束符改回”;”存储过程的好处在于处理逻辑封装在数据库端，调用者不需要了解中间的处理逻辑，一旦处理逻辑发生变化，只需要修改存储过程即可，而对调用者的程序完全没有影响。 存储过程和函数的 CREATE 语法不支持使用 CREATE OR REPLACE 对存储过程和函数进行修改，如果需要对已有的存储过程或者函数进行修改，需要执行 ALTER 语法。 characteristic特征值部分： LANGUAGE SQL：说明下面过程的 BODY 是使用 SQL 语言编写，这条是系统默认的，为今后 MySQL 会支持的除 SQL 外的其他语言支持的存储过程而准备。 [NOT] DETERMINISTIC：DETERMINISTIC 确定的，即每次输入一样输出也一样的程序，NOT DETERMINISTIC 非确定的，默认是非确定的。当前，这个特征值还没有被优化程序使用。 { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：这些特征值提供子程序使用数据的内在信息，这些特征值目前只是提供给服务器，并没有根据这些特征值来约束过程实际使用数据的情况。如果这些特征没有明确给定，默认使用的值是 CONTAINS SQL。 CONTAINS SQL 表示子程序不包含读或写数据的语句。 NO SQL 表示子程序不包含 SQL 语句。 READS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句。 MODIFIES SQL DATA 表示子程序包含写数据的语句。 SQL SECURITY { DEFINER | INVOKER }：可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是 DEFINER。 COMMENT ‘string’：存储过程或者函数的注释信息 删除存储过程或者函数1DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] sp_name 查看存储过程或函数查看存储过程或函数的状态SHOW {PROCEDURE|FUNCTION} STATUS [LIKE ‘pattern’]; 查看存储过程或函数的定义SHOW CREATE {PROCEDURE|FUNCTION} sp_name; 通过系统表查看存储过程或函数信息查看information_schema.routines表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145MariaDB [test]&gt; DELIMITER $$MariaDB [test]&gt; CREATE PROCEDURE select_test_int (IN p_a INT, IN p_b INT) -&gt; READS SQL DATA -&gt; BEGIN -&gt; SELECT a, b from test_int -&gt; WHERE a&lt;p_a or b&gt;p_b; -&gt; END $$Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; DELIMITER ;MariaDB [test]&gt; call select_test_int(1, 10);+----------+-------------+| a | b |+----------+-------------+| 56457789 | 04294967295 || 56457789 | 04294967295 |+----------+-------------+2 rows in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; call select_test_int(10, 10);+----------+-------------+| a | b |+----------+-------------+| 00001 | 00000000001 || 56457789 | 04294967295 || 00001 | 00000000001 || 56457789 | 04294967295 |+----------+-------------+4 rows in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; SHOW PROCEDURE STATUS;+------+-----------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| Db | Name | Type | Definer | Modified | Created | Security_type | Comment | character_set_client | collation_connection | Database Collation |+------+-----------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| test | select_test_int | PROCEDURE | root@localhost | 2018-03-30 22:58:38 | 2018-03-30 22:58:38 | DEFINER | | utf8 | utf8_general_ci | latin1_swedish_ci |+------+-----------------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+MariaDB [test]&gt; SHOW CREATE PROCEDURE select_test_int\\G*************************** 1. row *************************** Procedure: select_test_int sql_mode: Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `select_test_int`(IN p_a INT, IN p_b INT) READS SQL DATABEGIN SELECT a, b from test_int WHERE a&lt;p_a or b&gt;p_b;ENDcharacter_set_client: utf8collation_connection: utf8_general_ci Database Collation: latin1_swedish_ci1 row in set (0.00 sec)MariaDB [test]&gt; DROP PROCEDURE IF EXISTS select_test_int\\GQuery OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; DELIMITER $$MariaDB [test]&gt; CREATE FUNCTION select_test_int_f (p_a INT, p_b INT) -&gt; RETURNS INT -&gt; BEGIN -&gt; DECLARE p_c INT; -&gt; SELECT count(1) INTO p_c from test_int -&gt; WHERE a&lt;p_a or b&gt;p_b; -&gt; RETURN(p_c); -&gt; END $$Query OK, 0 rows affected (0.05 sec)MariaDB [test]&gt; DELIMITER ;MariaDB [test]&gt; select select_test_int_f(1, 2);+-------------------------+| select_test_int_f(1, 2) |+-------------------------+| 2 |+-------------------------+1 row in set (0.00 sec)MariaDB [test]&gt; SHOW FUNCTION STATUS;+------+-------------------+----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| Db | Name | Type | Definer | Modified | Created | Security_type | Comment | character_set_client | collation_connection | Database Collation |+------+-------------------+----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| test | select_test_int_f | FUNCTION | root@localhost | 2018-03-30 23:14:19 | 2018-03-30 23:14:19 | DEFINER | | utf8 | utf8_general_ci | latin1_swedish_ci |+------+-------------------+----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+1 row in set (0.00 sec)MariaDB [test]&gt; SHOW CREATE FUNCTION select_test_int_f\\G*************************** 1. row ***************************Function: select_test_int_f sql_mode: Create Function: CREATE DEFINER=`root`@`localhost` FUNCTION `select_test_int_f`(p_a INT, p_b INT) RETURNS int(11) BEGIN DECLARE p_c INT; SELECT count(1) INTO p_c from test_int WHERE a&lt;p_a or b&gt;p_b; RETURN(p_c); ENDcharacter_set_client: utf8collation_connection: utf8_general_ciDatabase Collation: latin1_swedish_ci1 row in set (0.00 sec)MariaDB [test]&gt; select * from information_schema.routines where SPECIFIC_NAME='select_test_int_f'\\G*************************** 1. row *************************** SPECIFIC_NAME: select_test_int_f ROUTINE_CATALOG: def ROUTINE_SCHEMA: test ROUTINE_NAME: select_test_int_f ROUTINE_TYPE: FUNCTION DATA_TYPE: intCHARACTER_MAXIMUM_LENGTH: NULL CHARACTER_OCTET_LENGTH: NULL NUMERIC_PRECISION: 10 NUMERIC_SCALE: 0 DATETIME_PRECISION: NULL CHARACTER_SET_NAME: NULL COLLATION_NAME: NULL DTD_IDENTIFIER: int(11) ROUTINE_BODY: SQL ROUTINE_DEFINITION: BEGIN DECLARE p_c INT; SELECT count(1) INTO p_c from test_int WHERE a&lt;p_a or b&gt;p_b; RETURN(p_c);END EXTERNAL_NAME: NULL EXTERNAL_LANGUAGE: NULL PARAMETER_STYLE: SQL IS_DETERMINISTIC: NO SQL_DATA_ACCESS: CONTAINS SQL SQL_PATH: NULL SECURITY_TYPE: DEFINER CREATED: 2018-03-30 23:14:19 LAST_ALTERED: 2018-03-30 23:14:19 SQL_MODE: ROUTINE_COMMENT: DEFINER: root@localhost CHARACTER_SET_CLIENT: utf8 COLLATION_CONNECTION: utf8_general_ci DATABASE_COLLATION: latin1_swedish_ci1 row in set (0.01 sec)MariaDB [test]&gt; drop function if exists select_test_int_f;Query OK, 0 rows affected (0.00 sec) 变量存储过程和函数都可以使用变量，变量不区分大小写。 变量定义通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN……END 块中，可以用在嵌套的块中。变量的定义必须写在复合语句的开头，并且在任何其他语句的前面。可以一次声明多个相同类型的变量。如果需要，可以使用 DEFAULT 赋默认值。定义一个变量的语法如下：1DECLARE var_name[,...] type [DEFAULT value] 变量赋值变量可以直接赋值，或者通过查询赋值。直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：1SET var_name = expr [, var_name = expr] ... 通过查询赋值：1SELECT col_name[,...] INTO var_name[,...] table_expr 定义条件和处理条件定义12345DECLARE condition_name CONDITION FOR condition_valuecondition_value: SQLSTATE [VALUE] sqlstate_value | mysql_error_code 条件处理1234567891011121314DECLARE handler_type HANDLER FOR condition_value[,...] sp_statementhandler_type: CONTINUE | EXIT | UNDOcondition_value: SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION | mysql_error_code 光标的使用在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标：1DECLARE cursor_name CURSOR FOR select_statement OPEN 光标：1OPEN cursor_name FETCH 光标：1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标：1CLOSE cursor_name 变量、条件、处理程序、光标都是通过 DECLARE 定义的，它们之间是有先后顺序的要求的。变量和条件必须在最前面声明，然后才能是光标的声明，最后才可以是处理程序的声明 流程控制IF语句IF 实现条件判断，满足不同的条件执行不同的语句列表，具体语法如下：1234IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list]END IF CASE语句CASE 实现比 IF 更复杂一些的条件构造，具体语法如下：1234567891011CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list]END CASEOr:CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list]END CASE LOOP语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：123[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环 LEAVE语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。 INTRATE语句ITERATE 语句必须用在循环中，作用是跳过当前循环的剩下的语句，直接进入下一轮循环 REPEAT语句有条件的循环控制语句，当满足条件的时候退出循环，具体语法如下：1234[begin_label:] REPEAT statement_listUNTIL search_conditionEND REPEAT [end_label] WHERE 语句WHILE 语句实现的也是有条件的循环控制语句，即当满足条件时执行循环的内容，具体语法如下：123[begin_label:] WHILE search_condition DO statement_listEND WHILE [end_label] WHILE 循环和 REPEAT 循环的区别在于：WHILE 是满足条件才执行循环，REPEAT 是满足条件退出循环；WHILE 在首次循环执行之前就判断条件，所以循环最少执行 0 次，而 REPEAT 是在首次执行循环之后才判断条件，所以循环最少执行 1 次。 存储过程和函数的优势是可以将数据的处理放在数据库服务器上进行，避免将大量的结果集传输给客户端，减少数据的传输，但是在数据库服务器上进行大量的复杂运算也会占用服务器的 CPU，造成数据库服务器的压力，所以不要在存储过程和函数中进行大量的复杂运算，应尽量将这些运算操作分摊到应用服务器上执行 触发器触发器创建1CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 触发器只能创建在永久表上，不能对临时表创建触发器。trigger_time触发器的触发时间，可以是BEFORE或AFTER，BEFORE的含义指在检查约束前出发，而AFTER在检查约束后触发。trigger_event触发器触发的事件，INSERT、UPDATE或者DELETE。对同一个表相同触发时间的相同触发事件，只能定义一个触发器。使用别名OLD和NEW来引用触发器中发生变化的记录内容。 删除触发器1DROP TRIGGER [schema_name.]trigger_name; 查看触发器SHOW TRIGGERS1SHOW TRIGGERS; 系统triggers表1select * from information_schema.triggers; 触发器使用触发器执行的语句的限制： 触发程序不能调用将数据返回客户端的存储程序，也不能使用采用 CALL 语句的动态 SQL 语句，但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或者函数通过 OUT 或者 INOUT 类型的参数将数据返回触发器是可以的，但是不能调用直接返回数据的过程。 不能在触发器中使用以显式或隐式方式开始或结束事务的语句，如 START TRANSACTION、COMMIT 或 ROLLBACK。 MySQL 的触发器是按照 BEFORE 触发器、行操作、AFTER 触发器的顺序执行的，其中任何一步操作发生错误都不会继续执行剩下的操作。如果是对事务表进行的操作，那么会整个作为一个事务被回滚（Rollback），但是如果是对非事务表进行的操作，那么已经更新的记录将无法回滚，这也是设计触发器的时候需要注意的问题.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 字符集、索引、视图","slug":"mysql-7","date":"2018-03-27T15:54:51.000Z","updated":"2020-04-12T04:56:36.164Z","comments":true,"path":"2018/03/27/mysql-7/","link":"","permalink":"http://www.casezheng.date/2018/03/27/mysql-7/","excerpt":"","text":"字符集查看MySQL支持的字符集 show character set; 查看information_schema.character_set 123456789101112131415161718192021MariaDB [information_schema]&gt; show character set;+----------+-----------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+-----------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 |... ...MariaDB [information_schema]&gt; select * from information_schema.character_sets;+--------------------+----------------------+-----------------------------+--------+| CHARACTER_SET_NAME | DEFAULT_COLLATE_NAME | DESCRIPTION | MAXLEN |+--------------------+----------------------+-----------------------------+--------+| big5 | big5_chinese_ci | Big5 Traditional Chinese | 2 || dec8 | dec8_swedish_ci | DEC West European | 1 || cp850 | cp850_general_ci | DOS West European | 1 || hp8 | hp8_english_ci | HP West European | 1 || koi8r | koi8r_general_ci | KOI8-R Relcom Russian | 1 |... ... MySQL字符集包括字符集(CHARACTER)和校对规则(COLLATION)两个概念。 字符集定义MySQL存储字符串的方式。 校对规则定义比较字符串的方式。字符串和校对规则一对多，每个字符集至少对应一个校对规则。使用SHOW COLLATION; 或查看那information_schema.COLLATIONS表查看所有校对规则123456789101112131415161718192021MariaDB [information_schema]&gt; show COLLATION;+--------------------------+----------+-----+---------+----------+---------+| Collation | Charset | Id | Default | Compiled | Sortlen |+--------------------------+----------+-----+---------+----------+---------+| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 || big5_bin | big5 | 84 | | Yes | 1 || dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 || dec8_bin | dec8 | 69 | | Yes | 1 |... ...MariaDB [information_schema]&gt; select * from information_schema.COLLATIONS;+--------------------------+--------------------+-----+------------+-------------+---------+| COLLATION_NAME | CHARACTER_SET_NAME | ID | IS_DEFAULT | IS_COMPILED | SORTLEN |+--------------------------+--------------------+-----+------------+-------------+---------+| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 || big5_bin | big5 | 84 | | Yes | 1 || dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 || dec8_bin | dec8 | 69 | | Yes | 1 || cp850_general_ci | cp850 | 4 | Yes | Yes | 1 || cp850_bin | cp850 | 80 | | Yes | 1 |... ... 校对规则命名约定:以与其相关的字符集名开始，包含语言名，并且以_ci(大小写不敏感)、_cs(大小写敏感)或_bin(二元，即比较基于字符编码的值而与language无关)结束。 字符集设置MySQL的字符集和校对规则有4个默认级别：服务器级、数据库级、表级、字段级。 服务器字符集和校对规则服务器字符集和校对规则在MySQL服务启动的时候确定。 my.cnf中设置 12[mysqld]default-character-set=gbk 启动选项中指定 1mysqld --default-character_set=gdk 编译时指定 1./configure --with-charset=gbk 如果没有特别指定服务器字符集，默认使用latin1作为服务器字符集。如未指定校对规则，则使用字符集默认的校对规则。使用show variables like ‘character_set_server’查看服务器字符集使用show variables like ‘collation_server’查看服务器校对规则123456789101112131415MariaDB [(none)]&gt; show variables like 'character_set_server';+----------------------+--------+| Variable_name | Value |+----------------------+--------+| character_set_server | latin1 |+----------------------+--------+1 row in set (0.00 sec)MariaDB [(none)]&gt; show variables like 'collation_server';+------------------+-------------------+| Variable_name | Value |+------------------+-------------------+| collation_server | latin1_swedish_ci |+------------------+-------------------+1 row in set (0.00 sec) 数据库字符集和校对规则数据库字符集和校对规则在创建数据库时指定，也可通过alter database命令修改。如果数据库中已存在数据，修改字符集并不能将已有数据按照新的字符集存储设置数据库字符集的规则： 如果指定了字符集和校对规则，则使用指定的字符集和校对规则； 如果指定了字符集没有指定校对规则，则使用指定字符集的默认校对规则； 如果没有指定字符集和校对规则，则使用服务器字符集和校对规则作为数据库的字符集和校对规则使用show variables like ‘character_set_database’查看数据库字符集使用show variables like ‘collation_database’查看数据库校对规则1234567891011121314MariaDB [test]&gt; show variables like 'character_set_database';+------------------------+--------+| Variable_name | Value |+------------------------+--------+| character_set_database | latin1 |+------------------------+--------+1 row in set (0.00 sec)MariaDB [test]&gt; show variables like 'collation_database';+--------------------+-------------------+| Variable_name | Value |+--------------------+-------------------+| collation_database | latin1_swedish_ci |+--------------------+-------------------+ 表字符集和校对规则表的字符集和校对规则在创建表的时候指定，可以通过 alter table 命令进行修改。如果表中已有记录，修改字符集对原有的记录并没有影响，不会按照新的字符集进行存放。表的字段仍然使用原来的字符集。设置表字符集的规则： 如果指定了字符集和校对规则，使用指定的字符集和校对规则； 如果指定了字符集没有指定校对规则，使用指定字符集的默认校对规则； 如果没有指定字符集和校对规则，使用数据库字符集和校对规则作为表的字符集和校对规则。推荐在创建表的时候明确指定字符集和校对规则，避免受到默认值的影响。要显示表的字符集和校对规则，可以使用 show create table 命令查看 列字符集和校对规则列字符集和校对规则的定义可以在创建表时指定，或者在修改表时调整，如果在创建表的时候没有特别指定字符集和校对规则，则默认使用表的字符集和校对规则。 连接字符集和校对规则MySQL提供三个参数：character_set_client、character_set_connection 和 character_set_results，分别代表客户端、连接和返回结果的字符集。通常3个字符集都是相同的，保证用户写入数据正确读出。 字符集修改步骤 导出表结构。mysqldump 修改表结构中字符集。 确保数据不再更新，导出所有记录。mysqlduump 修改导入SQL文件中的字符集。SET NAMES。 使用新字符集创建数据库。 创建表。 导入数据。 索引索引是数据库中用来提高性能的最常用工具。 索引概述所用MySQL列类型都可以被索引, 对相关列使用索引是提高select操作性能的最佳途径。 索引创建 直接创建索引 12345678910111213141516CREATE [ONLINE|OFFLINE] [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [index_type] ON tbl_name (index_col_name,...) [index_option] ...index_col_name: col_name [(length)] [ASC | DESC]index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string'index_type: USING &#123;BTREE | HASH&#125; 创建/修改表创建索引 删除索引DROP INDEX index_name on tbl_name; 显示索引 show create table tbl_name查看表结构，查看概况 show index from tbl_name只查看索引，查看详情 12345678910111213141516171819202122232425262728293031MariaDB [test]&gt; show create table student\\G*************************** 1. row *************************** Table: studentCreate Table: CREATE TABLE `student` ( `name` varchar(64) DEFAULT NULL, `age` int(4) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin11 row in set (0.00 sec)MariaDB [test]&gt; create index name_index on student (name(20)) comment \"名称索引\";Query OK, 0 rows affected (0.11 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; show create table student\\G*************************** 1. row *************************** Table: studentCreate Table: CREATE TABLE `student` ( `name` varchar(64) DEFAULT NULL, `age` int(4) DEFAULT NULL, KEY `name_index` (`name`(20)) COMMENT '名称索引' ) ENGINE=InnoDB DEFAULT CHARSET=latin1 1 row in set (0.00 sec)MariaDB [test]&gt; show index from student;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| student | 1 | name_index | 1 | name | A | 7 | 20 | NULL | YES | BTREE | | 名称索引 |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec) 设计索引原则 搜索的列不一定是所要选择的列。(对where子语句或连接子句中指定的列添加索引，而不是select关键字后的列添加索引) 使用唯一索引。(考虑某列中值的分布。索引的列的基数越大，索引的效果越好。) 使用短索引。对字符串索引，应指定前缀长度。 利用最左前缀。 不要过度使用索引。(索引占用额外空间、降低写操作性能) 对于InnoDB存储引擎的表，系统会按照一定顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以 InnoDB 表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果。 索引存储分类索引在MySQL的存储引擎层实现,而不是在服务器层实现,所以每种存储引擎的索引不一定完全相同,也不是所有的存储引擎支持所有的索引类型.MySQL支持的索引: B-Tree索引:最常见的索引类型,大部分引擎都支持B数索引 HASH索引:只有Memory/Heap引擎支持,使用场景简单 R-Tree索引(空间索引):空间索引是MyISAM的一个特殊索引类型,主要用于地理空间数据类型,通常使用较少 Full-text(全文索引):全文索引也是MyISAM的一个特殊索引类型,主要用于全文索引,InnoDB从MySQL5.6版本开始提供对全文索引的支持 MySQL目前不支持函数索引,但能对列的前面某一部分进行索引,可以大大缩小索引文件的大小,但在排序和分组操作的时候无法使用 HASH 索引有一些重要的特征需要在使用的时候特别注意: 只用于使用=或&lt;=&gt;操作符的等式比较。 优化器不能使用 HASH 索引来加速 ORDER BY 操作。 MySQL 不能确定在两个值之间大约有多少行。如果将一个 MyISAM 表改为 HASH 索引的 MEMORY 表，会影响一些查询的执行效率。 只能使用整个关键字来搜索一行。 对于 BTREE 索引，当使用&gt;、&lt;、>=、&lt;=、BETWEEN、!=或者&lt;>，或者 LIKE ‘pattern’(其中’pattern’不以通配符开始)操作符时，都可以使用相关列上的索引当对索引字段进行范围查询的时候，只有BTREE索引可以通过索引访问，而HASH索引实际上是全表扫描的。 MySQL如何使用索引MySQL中能够使用索引的经典场景 匹配全值,对索引中所有列都指定具体值,即是对索引中的所有列都有等值匹配的条件 匹配值的范围查询,对索引的值能够进行范围查找 匹配最左前缀,仅仅使用索引中的最左边列进行查找 仅仅对索引进行查询,当查询的列都在索引的字段中时,查询的效率更高 匹配列前缀,仅仅使用索引中的第一列,并且只包含索引第一列的开头一部分进行查询 能够实现索引匹配部分精确而其他部分进行范围索引 如果列名是索引,使用column_name is null就会使用索引 MySQL5.6引入Index Condition Pushdown(ICP)特性,进一步优化查询,Pushdown表示操作下放,某些情况下的条件过滤操作下放到存储引擎 MySQL存在索引但不能使用索引的经典场景 以%开头的LIKE查询不能够利用B-Tree索引,执行计划中key的值为NULL表示没有使用索引 数据类型中出现隐式转换的时候也不能使用索引,特别是当列类型是字符串 复合索引的情况下,假如查询条件不包含索引列最左部分,即不满足最左原则Leftmost,是不会使用复合索引的 如果MySQL估计使用索引比全表扫描慢,则不使用索引 用or分割的条件,如果or前面的条件中的列有索引,而后面的列中没有索引,则涉及的列都不会被使用(因为or后面的条件列中没有索引,那么后面的查询走全表扫描,在存在全表扫描的情况下,没必要多一次索引扫描增加I/O访问,一次全表扫描过滤条件就足够了) 查看索引使用情况1234567891011121314MariaDB [(none)]&gt; show status like 'Handler_read%';+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| Handler_read_first | 0 || Handler_read_key | 0 || Handler_read_last | 0 || Handler_read_next | 0 || Handler_read_prev | 0 || Handler_read_rnd | 0 || Handler_read_rnd_deleted | 0 || Handler_read_rnd_next | 0 |+--------------------------+-------+8 rows in set (0.00 sec) 索引正在工作则Handler_read_key的值将很高,该值表示一个行被索引值读的次数,值很低表明增加索引得到的性能改善不高,因为索引并不经常使用.Handler_read_rnd_next的值很高则意味着查询运行进行低效,并且应该建立索引补救. 视图视图简介视图是虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。视图相对普通表优势： 简单，使用视图的用户完全不用关心后面对应的表的结构、关联条件和筛选条件，对用户来说是已经是过滤好的符合条件的结果集。 安全，使用视图的用户只能访问被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单地实现。 数据独立，视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图无影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 视图操作创建、修改视图创建视图需要有CREATE VIEW的权限，对查询涉及的列有SELECT权限。使用CREATE OR REPLACE 或 ALTER修改视图，需要该视图的DROP权限。 12345678910111213141516CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] [DEFINER = &#123; user | CURRENT_USER &#125;] [SQL SECURITY &#123; DEFINER | INVOKER &#125;] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] [DEFINER = &#123; user | CURRENT_USER &#125;] [SQL SECURITY &#123; DEFINER | INVOKER &#125;] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 视图的可更新性和视图的定义有关系，以下类型视图是不可更新的： 包含一下关键字的SQL语句：聚合函数(SUM、MIN、MAX、COUNT等)、DISTINCT、GROUP BY、HAVING、UNION或者UNION NULL 常量视图 SELECT中包含子查询 JION FROM一个不能更新的视图 WHERE子句的子查询引用了FROM子句中的表 [WITH [CASCADED | LOCAL] CHECK OPTION] 决定是否允许更新数据使记录不再满足视图的条件。LOCAL只要满足本视图的条件就可更新。CASCADED必须满足所有针对该视图的所有视图的条件才尅更新。如果没有明确指定LOCAL或者CASCADED则默认为CASCADED 删除视图有视图的DROP权限可一次删除一个或多个视图1DROP VIEW [IF EXISTS] view_name [, view_name] ... [RESTRICT|CASCADE]; 查看视图定义 show tables; 查看表名也会展示视图名 show table status [from db_name][like ‘pattern’]; 查看表状态也会展示视图状态 show create iew view_name; 查看视图定义 select * from information_schema.views where table_name=view_name; 通过系统表information_schema.views查看视图相关信息","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 存储引擎","slug":"mysql-6","date":"2018-03-26T13:45:55.000Z","updated":"2020-04-12T04:56:36.161Z","comments":true,"path":"2018/03/26/mysql-6/","link":"","permalink":"http://www.casezheng.date/2018/03/26/mysql-6/","excerpt":"","text":"MySQL存储引擎概述插入式存储引擎是MySQL数据库最重要的特性之一，用户可根据应用的需要选择如何存储和索引数据、是否使用事物等。MySQL支持的引擎包括：MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等。InnoDB和BDB提供事物安全表，其它引擎都是非事物安全的。 默认存储引擎默认情况下创建新表不指定表的存储引擎，则新表是默认存储引擎，设置默认存储引擎在配置文件中设置default-storage-engine12[mysqld]default-storage-engine=INNODB 查看当前默认存储引擎12345678MariaDB [test]&gt; show variables like '%storage_engine%';+------------------------+--------+| Variable_name | Value |+------------------------+--------+| default_storage_engine | InnoDB || storage_engine | InnoDB |+------------------------+--------+2 rows in set (0.00 sec) 查看支持的存储引擎12345678910111213141516ariaDB [test]&gt; show engines;+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+| CSV | YES | CSV storage engine | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || InnoDB | DEFAULT | Percona-XtraDB, Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || FEDERATED | YES | FederatedX pluggable storage engine | YES | NO | YES || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || Aria | YES | Crash-safe tables with MyISAM heritage | NO | NO | NO |+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+10 rows in set (0.00 sec) 指定存储引擎创建表使用engine关键字设置新表存储引擎使用alter table可以修改表的存储结构123456789101112131415161718192021222324252627282930313233343536373839MariaDB [test]&gt; create table test1(a int(10), b varchar(10));Query OK, 0 rows affected (0.05 sec)MariaDB [test]&gt; show create table test1\\G*************************** 1. row *************************** Table: test1Create Table: CREATE TABLE `test1` ( `a` int(10) DEFAULT NULL, `b` varchar(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin11 row in set (0.00 sec)MariaDB [test]&gt; drop table test1;Query OK, 0 rows affected (0.02 sec)MariaDB [test]&gt; create table test1(a int(10), b varchar(10))engine=MyISAM;Query OK, 0 rows affected (0.02 sec)MariaDB [test]&gt; show create table test1\\G*************************** 1. row *************************** Table: test1Create Table: CREATE TABLE `test1` ( `a` int(10) DEFAULT NULL, `b` varchar(10) DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=latin11 row in set (0.00 sec)MariaDB [test]&gt; alter table test1 engine=innodb;Query OK, 0 rows affected (0.06 sec) Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; show create table test1\\G*************************** 1. row *************************** Table: test1Create Table: CREATE TABLE `test1` ( `a` int(10) DEFAULT NULL, `b` varchar(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin11 row in set (0.00 sec) 各种存储引擎特性 特点 MyISAM InnoDB MEMORY MERGE NDB 存储限制 有 64TB 有 没有 有 事务安全 支持 锁机制 表锁 行锁 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 集群索引 支持 数据缓存 支持 支持 支持 索引缓存 支持 支持 支持 支持 支持 数据可压缩 支持 空间使用 低 高 N/A 低 低 内存使用 低 高 中等 低 高 批量插入的速度 高 低 高 高 高 支持外键 支持 MyISAM不支持事物、不支持外键,访问速度快，对事物完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用MyISAM引擎。每个MyISAM在磁盘上存储为3个文件，文件名与表名相同，扩展名不同： .frm(存储表定义) .MYD(MyData,存储数据) .MYI(MYIndex,存储索引)123456[root@VM_187_252_centos test]# cat /etc/my.cnf | grep datadirdatadir=/var/lib/mysql[root@VM_187_252_centos test]# ls /var/lib/mysql/test/ | grep test_myisamtest_myisam.frmtest_myisam.MYDtest_myisam.MYI 数据文件和索引文件可以放置在不同目录，平均分布IO，获得更快速度。创建表时可通过DATA DIRECTORY和INDEX DIRECTORY指定数据文件路径和索引文件路径，文件路径使用绝对路径，且有访问权限。MyISAM类型的表可能会损坏，损坏后的表可能不能访问，会提示修复或返回错误数据。使用CHECK TABLE语句可以检查MyISAM表的健康，使用REPAIR TABLE可以修复损坏的MyISAM表。MyISAM表支持三种不同存储格式： 静态(固定长度)表 默认存储格式。静态表字段非变长字段，每个记录固定长度，存储迅速，容易缓存，出现故障容易恢复，占用空间比动态表多。静态表数据存储时按列宽补总空格，但应用访问时并不返回空格，会自动去掉。 动态表 包含变长字段，记录不是固定长度。占用空间少，频繁更新删除字段会产生碎片，需要定期执行OPTIMIZE TABLE或myisamchk -r命令改善性能，出现故障恢复比较困难。 压缩表 压缩表用myisampack工具创建，占用非常小的磁盘空间。每个记录都被单独压缩，只有非常小的访问开支。123456789101112131415MariaDB [test]&gt; create table test_myisam(a char(64), b varchar(64)) engine=myisam;Query OK, 0 rows affected (0.01 sec)MariaDB [test]&gt; insert into test_myisam values(\" abc\", \" abc\"), (\"abc \", \"abc \");Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0MariaDB [test]&gt; select concat(a, \"+\"), concat(b, \"+\") from test_myisam;+----------------+----------------+| concat(a, \"+\") | concat(b, \"+\") |+----------------+----------------+| abc+ | abc+ || abc+ | abc + |+----------------+----------------+2 rows in set (0.00 sec) InnoDBInnoDB存储引擎提供具有提交、回滚、崩溃恢复能力的事物安全。对比MyISAM，InnoDB写的处理效率差一点，并且会占用更多的磁盘控件保存数据和索引。 自动增长列 自动增长列不论插入0或NULL实际插入的都是自动增长的值。 可以使用ALTER TABLE ** AUTO_INCREMENT=n语句强制设置自动增长列的初始值（该强制值保存在内存中，若使用前数据库重启，该强制值会丢失，需重新设置）。 可使用LAST_INSERT_ID()查看当前线程最后插入记录使用的值，一次插入多条，返回第一条记录使用的自动增长列。 InnoDB自动增长列必须是索引。如果是组合索引，必须是组合索引第一列，对MyISAM，自动增长列可以是组合索引的其它列。 外键约束MySQL只有InnoDB支持外键约束，在创建外键时，要求父表必须有对应的索引，子表在创建外键时也会自动创建对应的索引。在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、 CASCADE、SET NULL 和 NO ACTION。RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择CASCADE和SET NULL两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。在导入多个表的数据时，如果需要忽略表之前的导入顺序，可以暂时关闭外键的检查； 同样，在执行 LOAD DATA 和 ALTER TABLE 操作的时候，可以通过暂时关闭外键约束来加快处理的速度，关闭的命令是“SET FOREIGN_KEY_CHECKS = 0;”，执行完成之后，通过执行“SET FOREIGN_KEY_CHECKS = 1;”语句改回原状态。对于 InnoDB 类型的表，外键的信息通过使用 show create table 或者 show table status 命令都可以显示。 存储方式InnoDB 存储表和索引有以下两种方式。 使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。 多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。 MEMORYMEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。给 MEMORY 表创建索引的时候，可以指定使用 HASH 索引还是 BTREE 索引。 MERGEMERGE 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，MERGE 表本身并没有数据，对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的实际的 MyISAM 表进行的。对于 MERGE 类型表的插入操作，是通过 INSERT_METHOD 子句定义插入的表，可以有 3 个不同的值，使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或最后一个表上，不定义这个子句或者定义为 NO，表示不能对这个 MERGE 表执行插入操作。可以对 MERGE 表进行 DROP 操作，这个操作只是删除 MERGE 的定义，对内部的表没有任何的影响。MERGE 表在磁盘上保留两个文件，文件名以表的名字开始，一个.frm 文件存储表定义，另一个.MRG 文件包含组合表的信息，包括 MERGE 表由哪些表组成、插入新的数据时的依据。可以通过修改.MRG 文件来修改 MERGE 表，但是修改后要通过 FLUSH TABLES 刷新。 合适存储引擎的选择 MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。 InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。 MEMORY：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果。 MERGE：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。这对于诸如数据仓储等VLDB环境十分适合。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"markdown小知识","slug":"markdown","date":"2018-03-24T09:24:03.000Z","updated":"2020-04-12T04:56:36.157Z","comments":true,"path":"2018/03/24/markdown/","link":"","permalink":"http://www.casezheng.date/2018/03/24/markdown/","excerpt":"","text":"markdown表格中显示|可以使用&amp;#124;代替，注意某些markdown渲染器可能不支持","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/tags/other/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"MySQL 运算符 常用函数","slug":"mysql-5","date":"2018-03-24T08:48:05.000Z","updated":"2020-04-12T04:56:36.159Z","comments":true,"path":"2018/03/24/mysql-5/","link":"","permalink":"http://www.casezheng.date/2018/03/24/mysql-5/","excerpt":"","text":"运算符算数运算符 运算符 作用 + 加法 - 减法 * 乘法 /，DIV 除法，返回商 %，MOD 除法，返回余数 1234567MariaDB [test]&gt; select 1/0, 100%0, 1 div 0, MOD(100, 0), 3/2, 3 DIV 2, 3%2, mod(3, 2), 5.3/2, 5.3 DIV 2, 5.3%2, mod(5.3, 2), 5.3 mod 2;+------+-------+---------+-------------+--------+---------+------+-----------+---------+-----------+-------+-------------+-----------+| 1/0 | 100%0 | 1 div 0 | MOD(100, 0) | 3/2 | 3 DIV 2 | 3%2 | mod(3, 2) | 5.3/2 | 5.3 DIV 2 | 5.3%2 | mod(5.3, 2) | 5.3 mod 2 |+------+-------+---------+-------------+--------+---------+------+-----------+---------+-----------+-------+-------------+-----------+| NULL | NULL | NULL | NULL | 1.5000 | 1 | 1 | 1 | 2.65000 | 2 | 1.3 | 1.3 | 1.3 |+------+-------+---------+-------------+--------+---------+------+-----------+---------+-----------+-------+-------------+-----------+1 row in set (0.00 sec) 比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; NULL 安全的等于(NULL-safe) &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 存在与指定范围 IN 存在于指定集合 IS NULL 为 NULL IS NOT NULL 不为 NULL LIKE 通配符匹配 REGEXP 或 RLIKE 正则表达式 =、&lt;&gt;、!=不能用于NULL比较 &lt;=&gt;安全的等于运算符，即使操作数为NULL也可以正确比较 BETWEEN运算符的使用格式为”a BETWEEN min AND max”，当 a 大于等于 min 并且小于等于 max，则返回值为 1，否则返回 0;当操作数 a、min、max 类型相同时，此表达式等价于（a&gt;=min and a&lt;=max），当操作数类型不同时，比较时会遵循类型转换原则进行转换后，再进行比较运算。 “IN”运算符的使用格式为”a IN (value1, value2, … …)”,当 a 的值存在于列表中时，则整个比较表达式返回的值为 1，否则返回 0。 “IS NULL”运算符的使用格式为”a IS NULL”,当 a 的值为 NULL，则返回值为 1，否则返回 0。 “IS NOT NULL”运算符的使用格式为”a IS NOT NULL”。和”IS NULL”相反，当 a 的值不为 NULL，则返回值为 1，否则返回 0。 “LIKE”运算符的使用格式为”a LIKE %123%”,当 a 中含有字符串”123”时，则返回值为 1，否则返回 0。 “REGEXP”运算符的使用格式为”str REGEXP str-pat”,当 str 字符串中含有 str-pat 相匹配的字符串时，则返回值为 1，否则返回 0。 1234567891011121314151617181920212223MariaDB [test]&gt; select 1=0, 1=1, NULL=NULL, 1&lt;&gt;0, 1&lt;&gt;1, NULL&lt;&gt;NULL, 1&lt;=&gt;1, 2&lt;=&gt;0, NULL&lt;=&gt;NULL;+-----+-----+-----------+------+------+------------+-------+-------+-------------+| 1=0 | 1=1 | NULL=NULL | 1&lt;&gt;0 | 1&lt;&gt;1 | NULL&lt;&gt;NULL | 1&lt;=&gt;1 | 2&lt;=&gt;0 | NULL&lt;=&gt;NULL |+-----+-----+-----------+------+------+------------+-------+-------+-------------+| 0 | 1 | NULL | 1 | 0 | NULL | 1 | 0 | 1 |+-----+-----+-----------+------+------+------------+-------+-------+-------------+1 row in set (0.00 sec)MariaDB [test]&gt; select '123' like '%123%', '123456' like '%123%', '0123123' like '%123%', '01 23' like '%123%';+--------------------+-----------------------+------------------------+----------------------+| '123' like '%123%' | '123456' like '%123%' | '0123123' like '%123%' | '01 23' like '%123%' |+--------------------+-----------------------+------------------------+----------------------+| 1 | 1 | 1 | 0 |+--------------------+-----------------------+------------------------+----------------------+1 row in set (0.00 sec)MariaDB [test]&gt; select 'abcdef' regexp 'ab', 'abcdef' regexp 'k', 'a bcdef' regexp 'ab';+----------------------+---------------------+-----------------------+| 'abcdef' regexp 'ab' | 'abcdef' regexp 'k' | 'a bcdef' regexp 'ab' |+----------------------+---------------------+-----------------------+| 1 | 0 | 0 |+----------------------+---------------------+-----------------------+1 row in set (0.00 sec) 逻辑运算符 运算符 作用 NOT 或 ! 逻辑非 AND 或 &amp;&amp; 逻辑与 OR 或 &#124;&#124; 逻辑或 XOR 逻辑异或 位运算符 运算符 作用 &amp; 位与（位 AND） &#124; 位或 （位 OR ） ^ 位异或（位 XOR） ~ 位取反 &gt;&gt; 位右移 &lt;&lt; 位左移 运算符优先级 优先级顺序 运算符 1 := 2 &#124;&#124; , OR, XOR 3 &amp;&amp;, AND 4 NOT 5 BETWEEN, CASE, WHEN, THEN, ELSE 6 =, &lt;=&gt;, &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN 7 &#124; 8 &amp; 9 &lt;&lt;, &gt;&gt; 10 -, + 11 *, /, DIV, %, MOD 12 ^ 13 - (一元减号), ~ (一元比特反转) 14 ! 常用函数字符串函数 函数 功能 CONCAT(S1,S2,…Sn) 连接S1,S2,…Sn为一个字符串 INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr LOWER(str) 将字符串str中所有字符变为小写 UPPER(str) 将字符串str中所有字符变为大写 LEFT(str,x) 返回字符串str最左边的x个字符 RIGHT(str,x) 返回字符串str最右边的x个字符 LPAD(str,n,pad) 用字符串pad对str最左边进行填充，直到长度为n个字符长度 RPAD(str,n,pad) 用字符串pad对str最右边进行填充，直到长度为n个字符长度 LTRIM(str) 去掉字符串str左侧的空格 RTRIM(str) 去掉字符串str行尾的空格 REPEAT(str,x) 返回str重复x次的结果 REPLACE(str,a,b) 用字符串b替换字符串str中所有出现的字符串a STRCMP(s1,s2) 比较字符串s1和s2 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串strx位置起y个字符长度的字串 数值函数 函数 功能 ABS(x) 返回x的绝对值 CEIL(x) 返回大于x的最大整数值 FLOOR(x) 返回小于x的最大整数值 MOD(x，y) 返回x/y的模 RAND() 返回0到1内的随机值 ROUND(x,y) 返回参数x的四舍五入的有y位小数的值 TRUNCATE(x,y) 返回数字x截断为y位小数的结果 日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期date的UNIX时间戳 FROM_UNIXTIME 返回UNIX时间戳的日期值 WEEK(date) 返回日期date为一年中的第几周 YEAR(date) 返回日期date的年份 HOUR(time) 返回time的小时值 MINUTE(time) 返回time的分钟值 MONTHNAME(date) 返回date的月份名 DATE_FORMAT(date,fmt) 返回按字符串fmt格式化日期date值 DATE_ADD(date,INTERVALexprtype) 返回一个日期或时间值加上一个时间间隔的时间值 DATEDIFF(expr,expr2) 返回起始时间expr和结束时间expr2之间的天数 1234567891011121314151617181920212223242526272829MariaDB [test]&gt; select CURDATE(), CURTIME(), NOW(), UNIX_TIMESTAMP(now()), FROM_UNIXTIME(1521907408), -&gt; WEEK(now()), YEAR(now()), HOUR(CURTIME()), MINUTE(CURTIME()), MONTHNAME(now())\\G*************************** 1. row *************************** CURDATE(): 2018-03-25 CURTIME(): 00:13:13 NOW(): 2018-03-25 00:13:13 UNIX_TIMESTAMP(now()): 1521907993FROM_UNIXTIME(1521907408): 2018-03-25 00:03:28 WEEK(now()): 12 YEAR(now()): 2018 HOUR(CURTIME()): 0 MINUTE(CURTIME()): 13 MONTHNAME(now()): March1 row in set (0.00 sec)MariaDB [test]&gt; select DATE_FORMAT(now(),&apos;%M,%D,%Y&apos;), -&gt; now() current, -&gt; date_add(now(),INTERVAL 31 day) after31days, -&gt; date_add(now(),INTERVAL &apos;1_2&apos; year_month) after_oneyear_twomonth, -&gt; date_add(now(),INTERVAL -31 day) before31days, -&gt; date_add(now(),INTERVAL &apos;-1_-2&apos; year_month) before_oneyear_twomonth\\G*************************** 1. row ***************************DATE_FORMAT(now(),&apos;%M,%D,%Y&apos;): March,25th,2018 current: 2018-03-25 00:36:15 after31days: 2018-04-25 00:36:15 after_oneyear_twomonth: 2019-05-25 00:36:15 before31days: 2018-02-22 00:36:15 before_oneyear_twomonth: 2017-01-25 00:36:151 row in set (0.00 sec) DATE_FORMATDATE_FORMAT(date,fmt)函数：按字符串fmt格式化日期date值，此函数能够按指定的格式显示日期 格式符 格式说明 %S,%s 两位数字形式的秒（00,01,…,59） %i 两位数字形式的分（00,01,…,59） %H 两位数字形式的小时，24 小时（00,01,…,23） %h,%I 两位数字形式的小时，12 小时（01,02,…,12） %k 数字形式的小时，24 小时（0,1,…,23） %l 数字形式的小时，12 小时（1,2,…,12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ssAM 或 hh:mm:ssPM） %p AM 或 PM %W 一周中每一天的名称（Sunday,Monday,…,Saturday） %a 一周中每一天名称的缩写（Sun,Mon,…,Sat） %d 两位数字表示月中的天数（00,01,…,31） %e 数字形式表示月中的天数（1,2，…,31） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %w 以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday） %j 以 3 位数字表示年中的天数（001,002,…,366） %U 周（0,1,52），其中 Sunday 为周中的第一天 %u 周（0,1,52），其中 Monday 为周中的第一天 %M 月名（January,February,…,December） %b 缩写的月名（January,February,…,December） %m 两位数字表示的月份（01,02,…,12） %c 数字表示的月份（1,2,…,12） %Y 4 位数字表示的年份 %y 两位数字表示的年份 %% 直接值“% DATE_ADDDATE_ADD(date,INTERVAL expr type)函数：返回与所给日期date相差INTERVAL时间段的日期其中INTERVAL是间隔类型关键字，expr是一个表达式，这个表达式对应后面的类型，type是间隔类型 表达式类型 描述 格式 HOUR 小时 hh MINUTE 分 mm SECOND 秒 ss YEAR 年 YY MONTH 月 MM DAY 日 DD YEAR_MONTH 年和月 YY-MM DAY_HOUR 日和小时 DD hh DAY_MINUTE 日和分钟 DD hh:mm DAY_SECOND 日和秒 DD hh:mm:ss HOUR_MINUTE 小时和分 hh:mm HOUR_SECOND 小时和秒 hh:ss MINUTE_SECOND 分钟和秒 mm:ss 流程函数 函数 功能 IF(value,t f) 如果 value 是真，返回 t；否则返回 f IFNULL(value1,value2) 如果 value1 不为空返回 value1，否则返回 value2 CASE WHEN [value1] THEN[result1]…ELSE[default]END 如果 value1 是真，返回 result1，否则返回 default CASE [expr] WHEN [value1] THEN[result1]…ELSE[default]END 如果 expr 等于 value1，返回 result1，否则返回 default 其他常用函数 函数 功能 DATABASE() 返回当前数据库名 VERSION() 返回当前数据库版本 USER() 返回当前登录用户名 INET_ATON(IP) 返回IP地址的数字表示 INET_NTOA(num) 返回数字代表的IP地址 PASSWORD(str) 返回字符串str的加密版本 MD5() 返回字符串str的MD5值","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 数据类型","slug":"mysql-4","date":"2018-03-22T14:32:57.000Z","updated":"2020-04-12T04:56:36.156Z","comments":true,"path":"2018/03/22/mysql-4/","link":"","permalink":"http://www.casezheng.date/2018/03/22/mysql-4/","excerpt":"","text":"MySQL支持的数据类型MySQL数据类型：数值型、字符串类型、日期和时间类型。 数值类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号 -128 &lt;/br&gt; 无符号 0 有符号 127 &lt;/br&gt; 无符号 255 SMALLINT 2 有符号 -32768 &lt;/br&gt; 无符号 0 有符号 32767 &lt;/br&gt; 无符号 65535 MEDIUMINT 3 有符号 -8388608 &lt;/br&gt; 无符号 0 有符号 8388607 &lt;/br&gt; 无符号 1677215 INT、INTEGER 4 有符号 -2147483648 &lt;/br&gt; 无符号 0 有符号 2147483647 &lt;/br&gt; 无符号 4294967295 BIGINT 8 有符号 -9223372036854775808 &lt;/br&gt; 无符号 0 有符号 9223372036854775807 &lt;/br&gt; 无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 定点数类型 字节 描述 DEC(M,D) DECIMAL(M,D) M+2 最大取值范围与 DOUBLE 相同，给定 DECIMAL 的有效取值范围由M和D决定 位类型 字节 最小值 最大值 BIT(M) 1~8 BIT(1) BIT(64) 整数MySQL支持在类型后面的小括号内指定显示宽度,而不是占用的字节数。使用zerofill关键字在数字位数不够的控件用”0”填充。所有整型类型有一个可选属性UNSIGNED(无符号),在字段中保存非负数或者较大上限值时可以使用此选项，其取值范围是正常值的下限取0，上限取原值的两倍。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MariaDB [test]&gt; create table test_int(a int(5), b int(11));Query OK, 0 rows affected (0.09 sec)MariaDB [test]&gt; insert into test_int values(1,1), (567789, 134567897531);Query OK, 2 rows affected, 1 warning (0.01 sec)Records: 2 Duplicates: 0 Warnings: 1MariaDB [test]&gt; select * from test_int;+--------+------------+| a | b |+--------+------------+| 1 | 1 || 567789 | 2147483647 |+--------+------------+2 rows in set (0.00 sec)MariaDB [test]&gt; alter table test_int modify a int(5) zerofill;Query OK, 2 rows affected (0.18 sec) Records: 2 Duplicates: 0 Warnings: 0MariaDB [test]&gt; alter table test_int modify b int zerofill;Query OK, 2 rows affected (0.08 sec) Records: 2 Duplicates: 0 Warnings: 0MariaDB [test]&gt; select * from test_int;+----------+------------+| a | b |+----------+------------+| 00001 | 0000000001 || 567789 | 2147483647 |+----------+------------+2 rows in set (0.01 sec)MariaDB [test]&gt; alter table test_int modify a int(5) unsigned zerofill;Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; alter table test_int modify b int(11) unsigned zerofill;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; insert into test_int values(1,1), (56457789, 1345678972531);Query OK, 2 rows affected, 1 warning (0.01 sec)Records: 2 Duplicates: 0 Warnings: 1MariaDB [test]&gt; select * from test_int;+----------+-------------+| a | b |+----------+-------------+| 00001 | 00000000001 || 56457789 | 04294967295 |+----------+-------------+2 rows in set (0.01 sec) AUTO_INCREMENT属性，可以产生唯一标识符或顺序值, 只能用于整数类型。AUTO_INCREMENT值一般从1开始，每行增加1。一个表中最多只能有一个AUTO_INCREMENT列。对于任何想要使用AUTO_INCREMENT的列，应该定义为NOT NULL，并定义为PRIMARY KEY或定义为UNIQUE键。123CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,PRIMARY KEY(ID));CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL ,UNIQUE(ID)); 浮点数、定点数、BIT小数的表示：浮点数和定点数。浮点数：float、double。定点数：decimal定点数在MySQL内部以字符串形式存放，比浮点数更精确，适合用来存放货比等精度高的数据。浮点数和定点数都可以用类型名称后加”(M,D)”的方式来进行表示，”(M,D)”表示该值一共显示M位数字(整数位+小数位)，其中D位位于小数点后面，M和D又称为精度和标度。浮点数后跟”(M,D)”的方法是非标准用法，如果要用于数据库的迁移，最好不要使用。float和double不指定精度按照实际精度(由实际的硬件和操作系统决定)来表示，而decimal在不指定精度时，默认整数位为10，默认小数位为0。 浮点数存在误差 对货币等敏感数据应该采用定点数表示或存储。 编程中，如果用到浮点数，注意误差问题，避免浮点数做比较，浮点数的比较最好使用范围比较，而不使用”=”比较 注意浮点数中一些特殊值的处理 1234567891011121314151617181920212223242526272829303132333435MariaDB [test]&gt; show create table test_xiaoshu\\G*************************** 1. row *************************** Table: test_xiaoshuCreate Table: CREATE TABLE `test_xiaoshu` ( `a` float(5,2) DEFAULT NULL, `b` double(5,2) DEFAULT NULL, `c` decimal(5,2) DEFAULT NULL, `d` float DEFAULT NULL, `e` double DEFAULT NULL, `f` decimal(10,0) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin11 row in set (0.00 sec)MariaDB [test]&gt; insert into test_xiaoshu value(1.23, 1.23, 1.23, 1.23, 1.23, 1.23);Query OK, 1 row affected, 1 warning (0.00 sec)MariaDB [test]&gt; select * from test_xiaoshu;+------+------+------+------+------+------+| a | b | c | d | e | f |+------+------+------+------+------+------+| 1.23 | 1.23 | 1.23 | 1.23 | 1.23 | 1 |+------+------+------+------+------+------+1 row in set (0.00 sec)MariaDB [test]&gt; insert into test_xiaoshu value(1.234, 1.234, 1.234, 1.234, 1.234, 1.234);Query OK, 1 row affected, 2 warnings (0.00 sec)MariaDB [test]&gt; select * from test_xiaoshu;+------+------+------+-------+-------+------+| a | b | c | d | e | f |+------+------+------+-------+-------+------+| 1.23 | 1.23 | 1.23 | 1.23 | 1.23 | 1 || 1.23 | 1.23 | 1.23 | 1.234 | 1.234 | 1 |+------+------+------+-------+-------+------+2 rows in set (0.00 sec) BIT(位类型)，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M范围从1~64，如果不写默认1位。对于位类型，直接使用select命令无法看到结果，可以用bin()(二进制格式)或者hex()(十六进制格式)函数进行读取。123456789101112131415161718192021222324MariaDB [test]&gt; desc test_bit;+-------+--------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------+------+-----+---------+-------+| a | bit(1) | YES | | NULL | || b | bit(2) | YES | | NULL | || c | bit(3) | YES | | NULL | |+-------+--------+------+-----+---------+-------+3 rows in set (0.00 sec)MariaDB [test]&gt; insert into test_bit values(1, 1, 1), (2, 2, 2), (8, 8, 8);Query OK, 3 rows affected, 4 warnings (0.01 sec)Records: 3 Duplicates: 0 Warnings: 4MariaDB [test]&gt; select bin(a), bin(b), bin(c), hex(a), hex(b), hex(c) from test_bit;+--------+--------+--------+--------+--------+--------+| bin(a) | bin(b) | bin(c) | hex(a) | hex(b) | hex(c) |+--------+--------+--------+--------+--------+--------+| 1 | 1 | 1 | 1 | 1 | 1 || 1 | 10 | 10 | 1 | 2 | 2 || 1 | 11 | 111 | 1 | 3 | 7 |+--------+--------+--------+--------+--------+--------+3 rows in set (0.00 sec) 日期时间类型 日期和时间类型 字节 最小值 最大值 零值表示 DATE 4 1000-01-01 9999-12-31 0000-00-00 DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 TIMESTAMP 4 19700101080001 2038年某个时刻 00000000000000 TIME 3 -838:59:59 838:59:59 00:00:00 YEAR 1 1901 2155 0000 如果表示年月日，通常用DATE来表示 如果表示年月日时分秒，通常用DATETIME来表示 如果表示时分秒，通常用TIME来表示 如果需要经常插入或者更新日期位当前系统时间，则通常使用TIMESTAMP来表示 如果只表示年份，可以用YEAR来表示。 字符串类型 字符串类型 字节 描述及存储需求 CHAR（M） M M 为 0～255 之间的整数 VARCHAR（M） M 为 0～65535 之间的整数，值的长度+1 个字节 TINYBLOB 允许长度 0～255 字节，值的长度+1 个字节 BLOB 允许长度 0～65535 字节，值的长度+2 个字节 MEDIUMBLOB 允许长度 0～167772150 字节，值的长度+3 个字节 LONGBLOB 允许长度 0～4294967295 字节，值的长度+4 个字节 TINYTEXT 允许长度 0～255 字节，值的长度+2 个字节 TEXT 允许长度 0～65535 字节，值的长度+2 个字节 MEDIUMTEXT 允许长度 0～167772150 字节，值的长度+3 个字节 LONGTEXT 允许长度 0～4294967295 字节，值的长度+4 个字节 VARBINARY（M） 允许长度 0～M 个字节的变长字节字符串，值的长度+1 个字节 BINARY（M） M 允许长度 0～M 个字节的定长字节字符串 char和varcharchar和varchar都用来存储较短的字符串。主要区别是存储方式的不同：char列的长度固定为创建表时声明的长度，长度可以为从0~255的任意值；varchar列中的值为可变长字符串。检索时char列删除末尾的空格，而varchar则保留空格。对于长度变化不大并且对查询速度要求较高的数据可以考虑使用char类型存储。不同存储引擎对char和varchar使用原则不同： MyISAM：建议使用固定长度的数据列代替可变长度的数据列 MEMORY：目前都使用固定长度的数据行处理，因为无论使用char或varchar列都没有关系，两者都是作为char类型处理 InnoDB：建议使用varchar。InnoDB内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针）。因此，使用cahr和varchar的性能差别不大，主要看空间占用大小。 123456789101112131415161718192021222324252627282930313233343536MariaDB [test]&gt; desc test_char;+-------+------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------+------+-----+---------+-------+| a | varchar(4) | YES | | NULL | || b | char(4) | YES | | NULL | |+-------+------------+------+-----+---------+-------+2 rows in set (0.00 sec)MariaDB [test]&gt; insert into test_char values(&quot;nnnn&quot;, &quot;nnnn&quot;), (&quot;mm&quot;, &quot;mm&quot;), (&quot;kkkkkk&quot;, &quot;kkkkk&quot;), (&quot;ee &quot;,&quot;ee &quot;), (&quot; tt&quot;, &quot; tt&quot;);Query OK, 5 rows affected, 2 warnings (0.03 sec)Records: 5 Duplicates: 0 Warnings: 2MariaDB [test]&gt; select * from test_char;+------+------+| a | b |+------+------+| nnnn | nnnn || mm | mm || kkkk | kkkk || ee | ee || tt | tt |+------+------+5 rows in set (0.00 sec)MariaDB [test]&gt; select concat(a, &apos;+&apos;), concat(b, &apos;+&apos;), length(a), length(b) from test_char;+----------------+----------------+-----------+-----------+| concat(a, &apos;+&apos;) | concat(b, &apos;+&apos;) | length(a) | length(b) |+----------------+----------------+-----------+-----------+| nnnn+ | nnnn+ | 4 | 4 || mm+ | mm+ | 2 | 2 || kkkk+ | kkkk+ | 4 | 4 || ee + | ee+ | 3 | 2 || tt+ | tt+ | 3 | 3 |+----------------+----------------+-----------+-----------+5 rows in set (0.00 sec) binary和varbinary类型binary和varbinary包含二进制字符串，而不包含非二进制字符串。1234567891011121314151617181920212223MariaDB [test]&gt; desc test_binary;+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| a | binary(4) | YES | | NULL | || b | varbinary(4) | YES | | NULL | |+-------+--------------+------+-----+---------+-------+2 rows in set (0.00 sec)MariaDB [test]&gt; insert into test_binary values(&quot;a&quot;, &quot;a&quot;), (&quot;bbbb&quot;, &quot;bbbb&quot;), (&quot;cc &quot;, &quot;cc &quot;), (&quot;dddddd&quot;, &quot;ddddd&quot;);Query OK, 4 rows affected, 2 warnings (0.02 sec)Records: 4 Duplicates: 0 Warnings: 2MariaDB [test]&gt; select *, hex(a), hex(b), concat(a, &quot;+&quot;), concat(b, &quot;+&quot;), length(a), length(b) from test_binary;+------+------+----------+----------+----------------+----------------+-----------+-----------+| a | b | hex(a) | hex(b) | concat(a, &quot;+&quot;) | concat(b, &quot;+&quot;) | length(a) | length(b) |+------+------+----------+----------+----------------+----------------+-----------+-----------+| a | a | 61000000 | 61 | a + | a+ | 4 | 1 || bbbb | bbbb | 62626262 | 62626262 | bbbb+ | bbbb+ | 4 | 4 || cc | cc | 63632020 | 63632020 | cc + | cc + | 4 | 4 || dddd | dddd | 64646464 | 64646464 | dddd+ | dddd+ | 4 | 4 |+------+------+----------+----------+----------------+----------------+-----------+-----------+4 rows in set (0.00 sec) text和blob保存较大文本时使用text或blob，blob能用来存储二进制数据，text只能保存字符数据。 blob和text会引起性能问题，特别是执行大量的删除操作时。删除操作会在数据表中留下很大的”空洞”，后续插入数据插入”空洞”时，性能会有影响。可以定期使用OPTIMIZE和TABLE功能进行碎片整理，避免因为”空洞”导致性能问题。 可以使用合成(Synthetic)索引来提高大文本字段的查询性能。即生成散列值，然后保存在单独列中，在通过散列值查找数据(只能用于精确查找)。对大文本的模糊索引可以使用前缀索引来解决。 在不必要的情况下避免索引大型的blob或者text值。 把blob或text列分离到单独的表中。 ENUM类型emum枚举类型，取值范围在创建表是通过枚举方式显示指定，对1~255个成员的枚举需要1个字节存储，对于255~65535个成员需要2个字节存储。最多允许65535个成员。123456789101112131415161718192021222324252627282930MariaDB [test]&gt; desc test_enum;+-------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------------+------+-----+---------+-------+| a | enum('A','B') | YES | | NULL | |+-------+---------------+------+-----+---------+-------+1 row in set (0.00 sec)MariaDB [test]&gt; insert into test_enum values(\"A\"), (\"b\"), (\"W\"), (NULL);Query OK, 4 rows affected, 1 warning (0.00 sec)Records: 4 Duplicates: 0 Warnings: 1MariaDB [test]&gt; show warnings;+---------+------+----------------------------------------+| Level | Code | Message |+---------+------+----------------------------------------+| Warning | 1265 | Data truncated for column 'a' at row 3 |+---------+------+----------------------------------------+1 row in set (0.00 sec)MariaDB [test]&gt; select * from test_enum;+------+| a |+------+| A || B || || NULL |+------+4 rows in set (0.00 sec) 枚举类型忽略大小写。 SET类型set类型也是字符串对象，里面包含0~64个成员。根据成员不同，存储上也有所不同。1~8个成员的集合，占1个字节9~16个成员的集合，占2个字节17~24成员的集合，占3个字节25~32成员的集合，占4个字节33~64成员的集合，占8个字节set和enum，存储不同，而且set一次可以取多个成员，enum只能选一个。123456789101112131415161718192021222324MariaDB [test]&gt; desc test_set;+-------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------------------+------+-----+---------+-------+| a | set('a','b','c','d') | YES | | NULL | |+-------+----------------------+------+-----+---------+-------+1 row in set (0.00 sec)MariaDB [test]&gt; insert into test_set values('a,b'), ('a,b,a'), ('a,c'), ('a'), ('f'), ('a, b');Query OK, 6 rows affected, 2 warnings (0.03 sec)Records: 6 Duplicates: 0 Warnings: 2MariaDB [test]&gt; select * from test_set;+------+| a |+------+| a,b || a,b || a,c || a || || a |+------+6 rows in set (0.00 sec) set所取成员中间不能有空格set取成员中不存在的值会自动过滤掉set取重复的成员只取一个","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"linux编译链接","slug":"linux-2-gcc-make","date":"2018-03-14T05:31:43.000Z","updated":"2018-03-14T05:31:43.000Z","comments":true,"path":"2018/03/14/linux-2-gcc-make/","link":"","permalink":"http://www.casezheng.date/2018/03/14/linux-2-gcc-make/","excerpt":"","text":"GCC简介GCC是Linux下的编译工具集，是GNU Compiler Collection的缩写，包括gcc、g++等编译器和其它工具集。GCC的C编译器为gcc，命令格式为：1gcc [options] files ... 文件扩展名含义 文件扩展名 含义 .c C语言的源文件 .h C/C++语言的头文件 .hpp C++语言的头文件 .i 预处理后的C文件 .C .cc .cxx C++语言的源文件 .s 汇编语言的源文件 .o 会变后的目标文件 .a 静态库 .so 动态库 GCC编译命令 含义 cpp 预处理器编译器 cc C语言编译器 gcc C语言编译器 cc1 C语言编译器 cc1plus C++语言编译器 g++ C++语言编译器 as 汇编器 ld 链接器 默认搜索路径 头文件 /usr/local/include /usr/lib/gcc/ /usr/include 库文件 /usr/lib/gcc /lib/ 编译程序基础GCC编译器对程序的编译分为4个阶段：预处理、编译和优化、汇编、链接。12 预处理(cpp) 编译和优化(gcc/cc) 汇编(as) 链接(ld)*.c *.h ------------&gt; *.i -------------------------&gt; *.s -------------&gt; *.o -----------------&gt; 可执行文件 gcc选项 选项 说明 -o 指定生成文件名 -c 生成目标文件 -E 预编译操作 -S 生成汇编代码 -g 加上调试信息 预编译主要处理源代码文件中以”#”开始的预编译指令。生成.i文件。编译后的.i文件不包含任何宏定义。12345[CaseZheng@VM_187_252_centos Tmp]$ lsmain.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -E -o main.i main.c [CaseZheng@VM_187_252_centos Tmp]$ lsmain.c main.i 编译和优化词法分析、语法分析、语义分析、优化、生成汇编代码文件。12345[CaseZheng@VM_187_252_centos Tmp]$ lsmain.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -S main.c [CaseZheng@VM_187_252_centos Tmp]$ lsmain.c main.s 词法分析词法分析使用类似于有限状态机的算法，将源代码的字符序列分割成一系列的记号。词法分析产生的记号一般可以分为：关键词、标识符、字面量、特殊符号等。程序lex可以实现词法扫描，按用户定义的词法规则将字符串分割为一个个记号。 语法分析语法分析将词法分析产生的记号进行语法分析，产生语法树。程序yacc可以完成语法分析。 语义分析语义分析是对表达式的含义进行分析，编译器所能分析的时静态语义（编译期可以确定的语义），动态语义是只在运行期才能确定的语义。静态语义通常包括声明和类型的匹配，类型的转换。 源码级优化及中间代码生成源代码级优化器会在源代码级别进行优化。优化器将整个语法树转换成中间代码（三地址码、P-代码） 生成汇编代码及优化源代码级优化器产生中间代码后的过程属于编译器后端。编译器后端主要包括代码生成器和目标代码优化器。代码生成器将中间代码转换成目标机器代码（汇编代码）。目标代码优化器对汇编代码进行优化。 预编译和编译可以合并成一个步骤，对C语言预编译和编译的程序是cc1，对C++是cc1plus。123[CaseZheng@VM_187_252_centos /]$ locate cc1/usr/libexec/gcc/x86_64-redhat-linux/4.8.2/cc1/usr/libexec/gcc/x86_64-redhat-linux/4.8.2/cc1plus 汇编将汇编代码转变成机器可执行的指令，每一个汇编语句几乎对应一条机器指令。 12345[CaseZheng@VM_187_252_centos Tmp]$ lsmain.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -c main.c [CaseZheng@VM_187_252_centos Tmp]$ lsmain.c main.o 目标文件编译器编译源代码后的生成的文件叫做目标文件。目标文件从结构上讲，是已经编译后的可执行文件格式，只是还没经过链接的过程。 目标文件格式PC平台流行的可执行文件格式主要是Windows下的PE和Linux下的ELF，都是COFF格式的变种。目标文件、可执行文件、动态链接库、静态链接库都是按照可执行文件格式存储。1234567891011[CaseZheng@VM_187_252_centos Tmp]$ file hello.ohello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped[CaseZheng@VM_187_252_centos Tmp]$ gcc -o run main.c hello.c[CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o main.c run[CaseZheng@VM_187_252_centos Tmp]$ file runrun: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=92d675d4aed8cea8d1aeee31f3d4e901f8c57022, not stripped[CaseZheng@VM_187_252_centos Tmp]$ file /lib/libc-2.17.so /lib/libc-2.17.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked (uses shared libs), BuildID[sha1]=efcb4322c3353d41309c104563110b0c238bbc51, for GNU/Linux 2.6.32, not stripped 目标文件内容目标文件将指令代码、数据、链接所需信息以”节”(“段”)的形式存储。ELF文件开头是文件头，描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接等信息，文件头还包括一个段表，段表时一个描述文件中各个段的数据。段表描述了文件中的偏移位置及段的属性等，从段表中可以得到段的所有信息。文件头后面就是各个段的内容。程序源代码编译后的机器指令经常放在代码段(.code/.text)已初始化的全局变量和局部静态变量放在.data段。未初始化的全局变量和局部静态变量放在.bss段。因为未初始化的全局变量和局部静态变量默认值都是0，在.data段分配空间存储0是没有必要的。.bss段只是为未初始化的全局变量和局部静态变量预留位置而已，并没有内容，在文件中不占据空间。.rodata段存放只读数据，一般是程序里面的只读变量和字符串常量。.comment段存放编译器版本信息.debug段调试信息.hash段符号哈希表.line段调试时的行号表，即源代码行号与编译后指令的对应表.strtab段字符串表，存储ELF文件用到的各种字符串.symtab段符号表.shstrtab段段名表.plt .got动态链接的跳转表和全局入口表.init .fini程序初始化与终结代码段总体来说，程序源代码被编译后主要分两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。程序指令和程序数据分开存储的好处： 安全，程序加载后程序指令只读、程序数据读写 利于缓存，提高CPU的缓存命中率 共享指令，节省内存 目标文件结构 文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。 段表是保存各个段的基本属性的结构，描述各个段的信息。ELF文件的段结构由段表决定、编译器、连接器和装载器都是依靠段表来定位和访问各个段的属性的。 重定位表(.rel.text/.rel.data)链接器在处理目标文件时需要对某些部位进行重定位，这些重定位信息都记录在ELF文件的重定位表中。 字符串表.strtab保存普通字符串。 段名字符串表.shstrtab保存短表中用到的字符串。 符号表.symtab记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值。对变量和函数，符号值就是它们的地址。 特殊符号 __executable_start 程序起始地址，不是入口地址，是程序最开始的地址 __extext或_extext或extext代码段结束地址，即代码段最末尾的地址 _edata或edata数据段结束地址，即数据段最末尾的地址 _end或end程序结束地址 符号修饰与函数签名函数签名包含了一个函数的信息，包括函数名、参数类型、所在类、所在名字空间等信息编译器及链接器处理符号时，使用某种那个名称修饰方法，使每个函数签名对应一个修饰后的名称C++编译器会将在extern “C”的大括号内部的代码当作C语言处理。 静态链接链接的主要内容是将各个目标代码之间相互引用的部分都处理好，使各个模块之间能够正确的衔接。链接过程包括地址和空间分配、符号决议、重定位等步骤。运行时库是支持程序运行的基本函数的集合。库其实是一组目标文件的包。各个目标文件独立编译，变量及函数地址不能独立确定，需要在链接过程中修正，使其指向正确的地址，这个过程叫重定位，每个要修正的地方叫重定位入口。 12345[CaseZheng@VM_187_252_centos Tmp]$ lsmain.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -o run main.c [CaseZheng@VM_187_252_centos Tmp]$ lsmain.c run 相似段合并链接器为目标文件分配地址和空间，其中地址和空间有两个含义：1.输出的可执行文件中的空间；2.装载的虚拟地址中的虚拟地址空间。虚拟地址空间分配关系到链接器关于地址的计算，而可执行文件本身的空间分配与链接过程关系并不大。 空间与地址分配 扫描所有输入目标文件，获取各个段长度、属性、位置，将目标文件符号表中符号定义和符号引用收集起来，统一放在全局符号表。链接器根据收集的信息合并各个段，计算文件文件中各个段合并后的长度与位置，并建立映射关系。 符号解析与重定位 使用空间与地址分配收集的信息，读取文件中段的数据、重定位信息，并进行符号解析和重定位、调整代码中的地址。 动态链接静态链接缺点 浪费内存和磁盘空间 模块更新困难 动态链接：不对组成程序的目标文件进行链接，等程序运行时才进行链接，即将链接过程推迟到运行时再进行。Linux系统中，ELF动态连接文件被称为动态共享对象（共享对象），一般都以”.so”为扩展名。Windos中称为动态链接库，一般以”.dll”为扩展名。共享对象在编译时不能假设自己在进程虚拟地址控件中的位置。 装载时重定位Linux和GCC支持装载时重定位的方法，在产生共享对象是不使用’-fPIC’，只使用’-shared’参数，输出的共享对象就是使用装载时重定位的方法。 地址无关代码装载时重定位是解决动态模块中的办法之一，但其指令部分不能在多个进程间共享，失去了动态连接节省内存的一大优势。 模块内部调用或跳转 模块内相对位置固定，通过相对地址调用 模块内部数据访问 相对寻址 模块间数据访问 ELF在数据段建立一个指向其它模块变量的指针数组（全局偏移表GOT），当代码需要引用该全局变量时，通过GOT中的相对应的项间接引用。 模块间调用、跳转 建立全局偏移表GOT，保存目标函数的地址。 指令跳转、调用 数据访问 模块内部 1.相对跳转和调用 2.相对地址访问 模块外部 3.间接跳转和调用 4.间接访问 ‘-fpic’和’-fPIC’功能相同都是生成地址无关代码，但’-fPIC’生成的代码要大一点，’-fpic’生成代码小，不过’-fpic’在某些平台上会有一些限制，而’-fPIC’则不存在。 延迟绑定延迟绑定：函数第一次被使用时才进行绑定。 “.interp”段动态链接器的位置不是由系统配置指定，也不是由环境参数决定，而是由ELF可执行文件决定。“.interp”段保存的一个字符串就是可执行文件所需要的动态链接器的路径。 “.dynamic”段“.dynamic”段保存了动态链接器所需要的基本信息（依赖的共享库、动态链接符号表位置、动态连接重定向表的位置、共享对象初始化代码的地址等）。ldd命令可以查看一个程序或共享库依赖哪些共享库。 动态符号表“.dynsym” 动态链接重定向表静态链接中”.rel.text”代码段重定位表 “.rel.data”数据段重定位表动态链接中”.rel.dyn”对数据引用的修正 “.rel.plt”对函数引用的修正，它所修正的位置位于”.got.plt” 静态链接库静态链接库通常以”.a”为后缀，由程序ar生成。静态链接库优点 不需要重新编译程序库代码，就可进行程序的重新链接，节省编译时间。 提供库文件给使用人员，不需要开放源代码。 静态库执行速度比共享库和动态库要快。 静态链接库生成 生成目标文件 用ar工具对目标文件归档。 ar的-r选项，可以创建库，并把目标文件插入指定库中。12345678[CaseZheng@VM_187_252_centos Tmp]$ lshello.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -c hello.c [CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o[CaseZheng@VM_187_252_centos Tmp]$ ar -rcs libhello.a hello.o[CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o libhello.a 使用静态链接库 和使用目标文件一致 使用”-l库名”使用，库名是不包含函数库和扩展名的字符串。 使用”-L”显式指定搜索库的路径。 1234567891011121314151617[CaseZheng@VM_187_252_centos Tmp]$ rm run [CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o libhello.a main.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -o run main.c libhello.a [CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o libhello.a main.c run[CaseZheng@VM_187_252_centos Tmp]$ ./run hello[CaseZheng@VM_187_252_centos Tmp]$ rm run [CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o libhello.a main.c[CaseZheng@VM_187_252_centos Tmp]$ gcc -o run main.c -L./ -lhello[CaseZheng@VM_187_252_centos Tmp]$ lshello.c hello.o libhello.a main.c run[CaseZheng@VM_187_252_centos Tmp]$ ./run hello 检查包的正确性如果碰到error adding symbols: Archive has no index; run ranlib to add one可以使用ar -t检查打包的正确性12[CaseZheng@VM_187_252_centos Tmp]$ ar -t libhello.ahello.o 确认无误的话在使用file查看被打包文件类型12[CaseZheng@VM_187_252_centos Tmp]$ file hello.ohello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 文件类型没问题再使用nm导出符号检查123[CaseZheng@VM_187_252_centos Tmp]$ nm hello.o U puts0000000000000000 T _Z11print_hellov 动态链接库生成动态链接库使用-fPIC或-fpic选项使gcc生成动态链接库。12345678910111213141516171819202122232425262728293031323334353637383940414243444546[CaseZheng@VM_187_252_centos Tmp]$ cat hello.h#ifndef _HELLO_H_#define _HELLO_H_void print_hello();#endif[CaseZheng@VM_187_252_centos Tmp]$ cat hello.cpp #include &lt;stdio.h&gt;#include &quot;hello.h&quot;void print_hello()&#123; printf(&quot;hello\\n&quot;);&#125;[CaseZheng@VM_187_252_centos Tmp]$ g++ -fPIC -shared -o libhello.so.1.0.0 hello.cpp hello.h[CaseZheng@VM_187_252_centos Tmp]$ ln -s libhello.so.1.0.0 libhello.so[CaseZheng@VM_187_252_centos Tmp]$ lshello.cpp hello.h libhello.so libhello.so.1.0.0 main.cpp[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -L./ -lhello[CaseZheng@VM_187_252_centos Tmp]$ ./run ./run: error while loading shared libraries: libhello.so: cannot open shared object file: No such file or directory[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffc6fb99000) libhello.so =&gt; not found libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f35af31c000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f35af01a000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f35aee04000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f35aea37000) /lib64/ld-linux-x86-64.so.2 (0x00007f35af623000)[CaseZheng@VM_187_252_centos Tmp]$ sudo vim /etc/ld.so.conf[CaseZheng@VM_187_252_centos Tmp]$ cat /etc/ld.so.confinclude ld.so.conf.d/*.conf/usr/local/lib.[CaseZheng@VM_187_252_centos Tmp]$ sudo ldconfig[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffc251b6000) libhello.so =&gt; ./libhello.so (0x00007fcc32399000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fcc32092000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fcc31d90000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fcc31b7a000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fcc317ad000) /lib64/ld-linux-x86-64.so.2 (0x00007fcc3259b000)[CaseZheng@VM_187_252_centos Tmp]$ ./run hello -Wl,-soname编译选项-Wl选项告知编译器将后面的参数传递给链接器.-soname指定动态库的soname(简单共享名,Short for shared object name) 利用soname可以提供动态库的兼容性,当升级一个库时新库和旧库兼容,则可以直接使用相同的soname,如果不兼容换个新的soname则不会影响旧库链接生成的程序.使得升级动态库变的容易. 可以通过readelf -d查看动态库的soname1234[CaseZheng@VM_187_252_centos ~]$ readelf -d /usr/lib/libz.so.1.2.7 ...... 0x0000000e (SONAME) Library soname: [libz.so.1]...... 可以看到前面的动态库链接后libhello.so链接到libhello.so,当新的动态库不兼容旧的动态库时就会影响到旧库链接生成的程序,而指定soname后链接到libhello.so.1.0.0,动态库升级后不会影响到旧库链接生成的程序12345678910111213141516171819202122232425262728[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffee638a000) libhello.so =&gt; ./libhello.so (0x00007fa8c214f000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fa8c1e48000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fa8c1b46000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fa8c1930000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa8c1563000) /lib64/ld-linux-x86-64.so.2 (0x00007fa8c2351000)[CaseZheng@VM_187_252_centos Tmp]$ g++ -fPIC -shared -Wl,-soname,libhello.so.1.0.0 -o libhello.so.1.0.0 hello.cpp hello.h[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -L./ -lhello[CaseZheng@VM_187_252_centos Tmp]$ ./run hello[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffc921b7000) libhello.so.1.0.0 =&gt; ./libhello.so.1.0.0 (0x00007fc55f726000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fc55f41f000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fc55f11d000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fc55ef07000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fc55eb3a000) /lib64/ld-linux-x86-64.so.2 (0x00007fc55f928000)[CaseZheng@VM_187_252_centos Tmp]$ readelf -d libhello.so.1.0.0 ...... 0x000000000000000e (SONAME) Library soname: [libhello.so.1.0.0]......[CaseZheng@VM_187_252_centos Tmp]$ readelf -d libhello.so...... 0x000000000000000e (SONAME) Library soname: [libhello.so.1.0.0]...... 还可以兼容版本使用同一个soname,当有新的不兼容版本时再更换soname 优先使用静态链接的方法使用动态库的不便之处在于服务部署环境必须安装了该动态库,且版本必须一致或兼容,否则程序无法运行,而静态库则不存在这个问题,当既有动态库,又有静态库时程序默认优先使用动态库,使用-Wl,-Bstatic可以指定优先使用静态库12345678910111213141516171819202122232425[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -L./ -lhello[CaseZheng@VM_187_252_centos Tmp]$ ./run hello[CaseZheng@VM_187_252_centos Tmp]$ lshello.cpp hello.h libhello.so libhello.so.1.0.0 main.cpp run[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffc20f4f000) libhello.so.1.0.0 =&gt; ./libhello.so.1.0.0 (0x00007f9025501000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f90251fa000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f9024ef8000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f9024ce2000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f9024915000) /lib64/ld-linux-x86-64.so.2 (0x00007f9025703000)[CaseZheng@VM_187_252_centos Tmp]$ g++ -c hello.cpp -o hello.o[CaseZheng@VM_187_252_centos Tmp]$ ar -rcs libhello.a hello.o[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -Wl,-Bstatic -L./ -lhello/usr/bin/ld: cannot find -lstdc++/usr/bin/ld: cannot find -lgcc_s/usr/bin/ld: cannot find -lgcc_scollect2: error: ld returned 1 exit status[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -L./ -Wl,-Bstatic -lhello/usr/bin/ld: cannot find -lstdc++/usr/bin/ld: cannot find -lgcc_s/usr/bin/ld: cannot find -lgcc_scollect2: error: ld returned 1 exit status 找不到库是因为指定-Wl,-Bstatic后所有库都强制使用了静态库导致的,添加-Wl,-Bdynamic让别的库可以使用动态库12345678910[CaseZheng@VM_187_252_centos Tmp]$ g++ -o run main.cpp hello.h -L./ -Wl,-Bstatic -lhello -Wl,-Bdynamic[CaseZheng@VM_187_252_centos Tmp]$ ./run hello[CaseZheng@VM_187_252_centos Tmp]$ ldd ./run linux-vdso.so.1 =&gt; (0x00007ffcf61cf000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fa076f64000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fa076c62000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fa076a4c000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa07667f000) /lib64/ld-linux-x86-64.so.2 (0x00007fa07726b000)","categories":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"http://www.casezheng.date/tags/gcc/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}]},{"title":"linux系统架构","slug":"linux-1-system-architecture","date":"2018-03-13T11:54:33.000Z","updated":"2020-04-12T04:56:36.151Z","comments":true,"path":"2018/03/13/linux-1-system-architecture/","link":"","permalink":"http://www.casezheng.date/2018/03/13/linux-1-system-architecture/","excerpt":"","text":"Linux系统从应用角度来看，分为内核空间和用户空间两部分。内核空间是Linux操作系统的主要部分。 Linux内核主要模块Linux内核由5个子系统组成:进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。 进程调度SCHED进程调度指系统对进程的多种状态之间转换的策略。Linux进程调度主要有三种策略：SCHED_OTHER、SCHED_FIFO和SCHED_RR。 SCHED_OTHER分时调度策略（默认），针对普通进程的时间片轮转调度策略。系统给所有的运行状态的进程分配时间片。在当前进程的时间片用完后，系统从进程中优先级高的进程中选择进程运行。 SCHED_FIFO实时调度策略，先到先服务，针对运行的实时性要求比较高、运行时间短的进程调度策略。系统按照进入队列的先后进行进程的调度，在没有更高优先级到来或者当前进程没有因为等待资源而阻塞的情况下，会一直运行。 SCHED_RR实时调度策略，时间片轮转，针对实时性比较高、运行时间长的进行调度策略。SCHED_RR和SCHED_OTHER相似，但SCHED_RR的优先级要高的多。系统分配给SCHED_RR进程时间片，然后轮循进程，将时间片用完的进程放在队列末尾。 由于存在多种调度方式，Linux进程调度采用“有条件可剥夺”的调度方式。普通进程中采用SCHED_OTHER的时间片轮询方式，实时进程可以剥夺普通进程。如果普通进程在用户空间运行，则普通进程立即停止运行，将资源让给实时进程；如果普通进程在内核空间，则需要等系统调用返回用户空间后方可剥夺资源。 内存管理MMU内存管理时多个进程间共享内存的策略。在Linux中内存管理主要概念是虚拟内存。虚拟内存让内存可以使用比实际物理内存更大的内存，每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。虚拟内存的分配策略是每个进程都可以公平地使用虚拟内存。 虚拟文件系统VFSLinux支持多种文件系统。最常见的文件格式是ext2和ext3。ext2文件系统用于固定文件系统和可活动文件系统，是ext的扩展。ext3是ext2上增加日志功能后的扩展。ext2和ext3可以互相转化。 网络接口Linux支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是网络传输的通信标准，驱动程序是对硬件设备的驱动程序。 进程间通信Linux下进程通信方式：管道、信号、消息队列、共享内存、套接字。 Linux文件系统Linux操作系统文件结构的开始是一个顶级目录结构，叫做根目录。123[CaseZheng@VM_187_252_centos /]$ cd /[CaseZheng@VM_187_252_centos /]$ lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 根目录下常用目录作用： /bin Binary存放经常使用的命令 /boot 存放启动linux时需要使用的核心文件，包括连接文件和镜像文件 /dev Device存放Linux的外部设备 /etc 存放所有系统管理所需要的配置文件和子目录 /home 用户家目录 /lib 存放系统最基本的动态链接库 /lost+found 一般情况下是空的，当系统非法关机，存放一些文件 /media linux系统自动识别一些设备，当识别后会将识别的设备挂载在这个目录下 /mnt 专门给外挂的文件系统使用 /opt 可选的应用程序软件包 /proc 虚拟目录，系统内存的映射，可直接访问该目录获取系统信息，这个目录内容在内存中，而不是硬盘。 /root 根用户的主目录 /sbin 存放系统管理员使用的系统管理程序 /selinux Redhat/CentOS特有目录，Selinux是安全机制，比较复杂，该目录用于存放selinux相关文件。 /src 存放一些服务启动后需要提取的数据 /sys 该目录下安装sysfs文件系统，sysfs文件系统集成了3中文件系统信息：针对进程信息的proc文件系统、针对设备的devfs文件系统、针对伪终端的devpts文件系统，该文件系统是内核设备的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /var 包含系统定义表，以便在系统运行改变时只备份该目录 /tmp 用于临时性存储 /usr 用户的很多应用程序和文件放在该目录下 /usr/bin 系统用户使用的应用程序 /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序 /usr/src 内核源代码默认的放置目录 /usr/lib 库文件","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"博客搭建纪要","slug":"hexo-plantuml","date":"2018-03-12T14:38:04.000Z","updated":"2020-04-12T04:56:36.149Z","comments":true,"path":"2018/03/12/hexo-plantuml/","link":"","permalink":"http://www.casezheng.date/2018/03/12/hexo-plantuml/","excerpt":"","text":"Hexo博客使用记录Hexo安装gitNode.js linux 1sudo yum install nodejs windows官网下载安装 hexo1npm i -g hexo hexo中plantuml安装java linux 12sudo yum install javasudo yum install java-devel windows下载地址Java环境变量配置 12345678变量名：JAVA_HOME变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个&quot;.&quot;变量名：Path变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 安装graphviz linux 1sudo yum install graphviz -y windows下载地址将其bin目录加入系统Path变量中 安装Hexo插件hexo-filter-plantuml1npm install --save hexo-filter-plantuml hexo-filter-plantuml 站内搜索功能12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save hexo命令1234567hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo server --drafts 预览草稿 hexo报错解决找不到git部署1ERROR Deployer not found: git 解决方法1npm install hexo-deployer-git --save Jekyll目录结构 _config.yml 保存配置数据 _drafts 未发布文章 _includes _layouts 包裹在文章外部的模版，布局可以在YAML头信息中根据不同文章进行选择，标签Hexo博客使用记录Hexo安装gitNode.js linux 1sudo yum install nodejs windows官网下载安装 hexo1npm i -g hexo hexo中plantuml安装java linux 12sudo yum install javasudo yum install java-devel windows下载地址Java环境变量配置 12345678变量名：JAVA_HOME变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个&quot;.&quot;变量名：Path变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 安装graphviz linux 1sudo yum install graphviz -y windows下载地址将其bin目录加入系统Path变量中 安装Hexo插件hexo-filter-plantuml1npm install --save hexo-filter-plantuml hexo-filter-plantuml 站内搜索功能12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save hexo命令1234567hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo server --drafts 预览草稿 hexo报错解决找不到git部署1ERROR Deployer not found: git 解决方法1npm install hexo-deployer-git --save Jekyll目录结构 _config.yml 保存配置数据 _drafts 未发布文章 _includes _layouts 包裹在文章外部的模版，布局可以在YAML头信息中根据不同文章进行选择，标签{{content}}可以将content插入页面中。 _posts 存放正式发布文章，文件格式很重要，必须符合：YEAR-MONTH-DAY-title.MARKUP _data _site Jekyll完成转换，生成的页面存放处(默认)，该目录最好加入.gitignore index.html 其它html、markdown、testile 文件 如果文件包含YAML头信息部分，Jekyll自动将它们转换，其它.html、.markdown、.md或者.textile等在站点根目录下或者不是以上提到的目录中的文件也会被转化。 其它文件目录 其它未被提及的目录和文件豆浆杯完全拷贝到生成的site中。 头信息 任何只要包含YAML头信息的文件在Jekyll中都被当做一个特殊的文件来处理 头信息必须在文件开始部分，需要安装YAML的格式卸载两行三虚线之间 预定义的全局变量 layout 如果设置的话，会指定使用该模板文件。指定模板文件时候不需要扩展名。模板文件需要放在 _layouts 目录下。 permalink 如果你需要让你的博客中的URL地址不同于默认值 /year/month/day/title.html 当你设置这个变量后，就会使用最终的URL地址。 published 当站点生成的时候，如果你不需要展示一个具体的博文，可以设置这个变量为 false。 category/categories 除过将博客文章放在某个文件夹下面外，你还可以根据文章的类别来给他们设置一个或者多个分类属性。这样当你的博客生成的时候这些文章就可以根据这些分类来阅读。在一个文章中多个类别可以通过 YAML list来指定，或者用空格隔开。 tags 类似分类，一篇文章也可以给它增加一个或者多个标签。同样多个标签之间可以通过 YAML 列表或者空格隔开。 自定义变量在头信息中没有预先定义的任何变量都会在数据转换中通过 Liquid 模板被调用 在文章中预定义的变量在文章中可以使用这些在头信息变量列表中未包含的变量date 会覆盖文章名字中的日期。可以用来确定文章分类的正确。 可以将content插入页面中。 _posts 存放正式发布文章，文件格式很重要，必须符合：YEAR-MONTH-DAY-title.MARKUP _data _site Jekyll完成转换，生成的页面存放处(默认)，该目录最好加入.gitignore index.html 其它html、markdown、testile 文件 如果文件包含YAML头信息部分，Jekyll自动将它们转换，其它.html、.markdown、.md或者.textile等在站点根目录下或者不是以上提到的目录中的文件也会被转化。 其它文件目录 其它未被提及的目录和文件豆浆杯完全拷贝到生成的site中。 头信息 任何只要包含YAML头信息的文件在Jekyll中都被当做一个特殊的文件来处理 头信息必须在文件开始部分，需要安装YAML的格式卸载两行三虚线之间 预定义的全局变量 layout 如果设置的话，会指定使用该模板文件。指定模板文件时候不需要扩展名。模板文件需要放在 _layouts 目录下。 permalink 如果你需要让你的博客中的URL地址不同于默认值 /year/month/day/title.html 当你设置这个变量后，就会使用最终的URL地址。 published 当站点生成的时候，如果你不需要展示一个具体的博文，可以设置这个变量为 false。 category/categories 除过将博客文章放在某个文件夹下面外，你还可以根据文章的类别来给他们设置一个或者多个分类属性。这样当你的博客生成的时候这些文章就可以根据这些分类来阅读。在一个文章中多个类别可以通过 YAML list来指定，或者用空格隔开。 tags 类似分类，一篇文章也可以给它增加一个或者多个标签。同样多个标签之间可以通过 YAML 列表或者空格隔开。 自定义变量在头信息中没有预先定义的任何变量都会在数据转换中通过 Liquid 模板被调用 在文章中预定义的变量在文章中可以使用这些在头信息变量列表中未包含的变量date 会覆盖文章名字中的日期。可以用来确定文章分类的正确。","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/tags/other/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"排序算法","slug":"algorithm-sorting","date":"2018-02-08T14:34:02.000Z","updated":"2020-04-12T04:56:36.147Z","comments":true,"path":"2018/02/08/algorithm-sorting/","link":"","permalink":"http://www.casezheng.date/2018/02/08/algorithm-sorting/","excerpt":"","text":"插入排序插入排序是对少量元素进行排序的有效算法。123456初始状态: 4,| 9, 7, 20, 3, 16, 18第一趟: 4, 9,| 7, 20, 3, 16, 18第二趟: 4, 7, 9,| 20, 3, 16, 18第三趟: 3, 4, 7, 9,| 20, 16, 18第四趟: 3, 4, 7, 9, 16,| 20, 18第五趟: 3, 4, 7, 9, 16, 18,| 20 插入排序n个元素的排序需要进行n-1趟插入排序将所有元素完成排序。插入排序是稳定排序算法。在数据及规模不大时，插入排序具有较好的效率。最好情况下每个元素都在其正确的位置上，进行排序所需事件为对每个元素与其前一个元素对比的时间，约等于一次遍历所花时间，所以最好情况下时间复杂度为$O(n)$，在普通情况和最坏情况下，n个元素每个元素都需要被移动一个线性的距离，所以平均和最坏情况下，插入排序的时间复杂度为$O(n^2)$。 冒泡排序冒泡排序（气泡排序）是交换排序的一种。分为下沉排序和上浮排序。123456789101112下沉排序初始状态: 4, 9, 7, 20, 3, 16, 18第一趟: 4, 7, 9, 3, 16, 18, 20第二趟: 4, 7, 3, 9, 16, 18, 20第三趟: 4, 3, 7, 9, 16, 18, 20第四趟: 3, 4, 7, 9, 16, 18, 20上浮排序初始状态: 4, 9, 7, 20, 3, 16, 18第一趟: 3, 4, 9, 7, 20, 16, 18第二趟: 3, 4, 7, 9, 16, 20, 18第三趟: 3, 4, 7, 9, 16, 18, 20 冒泡排序主要步骤是相邻元素的比较和交换，终止的标志为在某一趟排序过程中值有对比动作而没有交换动作。冒泡排序在最好情况下，初始状态就已经是升序排序，则只需要经过一趟n-1次元素之间比较，且不用进行元素移动，就结束排序，最好时间复杂度为$O(n)$。最坏情况下，参加排序的数据元素为逆序排序，或最小值在序列最后时，需要进行n-1趟排序，平均和最坏时间复杂度都是$O(n^2)$。冒泡排序的元素交换发生在相邻元素之间，不会改变值相同元素的相对位置，因此，冒泡排序是稳定排序。 选择排序选择排序重复地从待排序的元素中选出最大的或最小的元素进行排序。选择排序的时间复杂度为$O(n^2)$选择排序是非稳定排序1234567891011121314151617选最小值排序初始状态: 4, 9, 7, 20, 3, 16, 18第一趟: 3, 9, 7, 20, 4, 16, 18第二趟: 3, 4, 7, 20, 9, 16, 18第三趟: 3, 4, 7, 20, 9, 16, 18第四趟: 3, 4, 7, 9,20, 16, 18第五趟: 3, 4, 7, 9,16, 20, 18第六趟: 3, 4, 7, 9,16, 18, 20选最大值排序初始状态: 4, 9, 7, 20, 3, 16, 18第一趟: 4, 9, 7, 18, 3, 16, 20第二趟: 4, 9, 7, 16, 3, 18, 20第三趟: 4, 9, 7, 3,16, 18, 20第四趟: 4, 3, 7, 9,16, 18, 20第五趟: 4, 3, 7, 9,16, 18, 20第六趟: 3, 4, 7, 9,16, 18, 20 快速排序快速排序是运用分治思想的算法。主要思想：有待排序数组S={d1, d2, d3, …, dn}，从中找出元素划界元素v，将剩下元素中小于或等于v的元素移动到v的前面，将大于或等于v的元素i移动到v的后面，v就找到了它的最终位置，并将S划分为两个不相交的子数组S1和S2。其中S1中的元素均小于或等于v，S2中的元素均大于或等于v，这个过程称为一次排序。然后快速排序递归地对子序列S1和S2进行上述排序过程。直至所有的子序列都只包含0或1个元素时停止，整个数组完成排序。划界元素一般取第一个元素、中间元素或最后一个元素。快速排序是不稳定排序，主要是因为最后异步划界元素与S[i+1]交换的时候有可能打破前面元素的稳定性。快速排序的最坏时间复杂度为$O(n^2)$，最坏情况为参与排序的元素原本有序，平均时间复杂度为$O(nlog_2n)$。 归并排序归并排序是运用分治思想的算法。归并将两个或多个已排序序列合并成为一个按值排序的序列。归并排序的平均时间复杂度为$O(nlog_2n)$12349, 4, | 7, 20, | 16, 3, | 184, 9, 7, 20, 3, 16, 184, 9, 7, 20, | 3, 16, 183, 4, 7, 9, 16, 18, 20 堆排序堆堆数据结构是一种数组对象，可以将其看成一颗完全二叉树。堆分为最大堆和最小堆，最小堆的最小元素是根结点，最大堆的最大元素是其根结点。 堆排序算法最大堆的根结点是最大值，堆排序的核心思想也是利用了堆结构的这一特性。对待排序数组进行建堆操作，使其数组中元素排列复合最大堆特性。每次取堆的最大值，再调整堆结构，直至堆的大小为2结束。123456784 9 7 20 3 16 1820 9 18 4 3 16 718 9 16 4 3 7 2016 9 7 4 3 18 209 4 7 3 16 18 207 4 3 9 16 18 204 3 7 9 16 18 203 4 7 9 16 18 20 堆排序的时间复杂度为$O(nlog_2n)$堆排序是非稳定排序 希尔排序希尔排序是一种非稳定排序，希尔排序不适合链表结构。希尔排序的主要思想：确定一个元素间隔数gap，将参与排序的元素从第一个元素开始按照间隔一次分成多个子序列，分别将所有位置相隔gap的元素看成一个子序列。对各个子序列排序，再缩小gap的值，重新按照新的gap划分数组，再对每个子序列排序，直到gap递减为1。1234 3, 7, 5, 1, 12, 10, 8, 9gap=4 3, 7, 5, 1, 12, 10, 8, 9gap=2 3, 1, 5, 7, 8, 9,12,10gap=1 1, 3, 5, 7, 8, 9,10,12 计数排序计数排序是一种稳定排序，当待排序数组中有大量重复的数值并且这些数值较为集中时，使用计数排序算法较有优势。 基数排序基数排序的主要思想：如果参加排序的元素具有d位，将元素先按最低位的值进行派位，如后按最次低位的值进行排序……最后进行最高位的排序。123456初始 个位 十位 百位329 463 329 329568 564 839 463839 -&gt; 568 -&gt; 463 -&gt; 564 463 329 564 568564 839 568 839 桶排序桶排序将数组中的数据分组，将分好的组分别放在一个个的”桶”中，然后对每个桶中的数据再进行排序。对”桶”内部的排序，可以使用插入排序、冒泡排序或快速排序等排序方法。桶排序数组中的数据满足以下两点： 均匀分布。输入数据需要均匀分布再一个给定的范围内。基于这种分配，算法创建n个桶来平分输入数据。 有序散列函数。桶必须是有序的。即，排在前面的桶中的所有数据必须小于后面桶的中的所有数据。 排序算法对比和选择排序算法时间复杂度、空间复杂度、算法稳定性 算法名称 最好时间复杂度 平均时间复杂度 最坏时间复杂度 空间复杂度 算法稳定性 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 快速排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(n^2)$ $O(log_2n)$ 不稳定 归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(n)$ 稳定 堆排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(1)$ 不稳定 希尔排序 O(n^1.3) $O(nlog_2n)$ $O(n^2)$ $O(1)$ 不稳定 计数排序 $O(n)$ $O(n)$ $O(n)$ $O(n)$ 稳定 基数排序 $O(d(n+w))$ $O(d(n+w))$ $O(d(n+w))$ $O(n+w)$ 稳定 桶排序 $O(n)$ $O(n)$ $O(n)$ $O(n)$ 稳定 排序算法选择标准 通常情况下，输入数据是随机的，快速排序、归并排序、希尔排序和堆排序的运行速度较快。其中堆排序是原地排序最节省空间，快速排序的速度是最快的。在内存空间不紧张的情况下，一般采用快速排序，如需节省空间则采用堆排序，希尔排序不适合用在链表数据结构上。 待排序数据规模不大而且一开始就局部有序，插入排序和冒泡排序的运行时间最快，为$O(n)$，一般采用这两种排序算法。 从待排序数据规模考虑：规模小，采用简单排序算法合适，整体性能高；规模大，采用改进型的算法比较合适。因为规模小时$n^2$和$log_2n$差异小，而简单算法实现比较容易。 C++代码实现github代码 https://github.com/CaseZheng123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486#include &lt;vector&gt;#include &lt;list&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt; using namespace std;void PrintVec(vector&lt;int&gt; &amp;vec)&#123; for(auto x : vec) &#123; cout&lt;&lt;x&lt;&lt;\" \"; &#125; if(vec.size()&gt;0) &#123; cout&lt;&lt;endl; &#125;&#125;void InsertSort(vector&lt;int&gt; &amp;vec) //插入排序&#123; if(vec.size() &lt;= 1) &#123; return; &#125; for(int i=1; i&lt;vec.size(); ++i) &#123; int tmpIndex = i; for(int j=0; j&lt;i; ++j) &#123; if(vec[j] &gt; vec[i]) &#123; tmpIndex = j; break; &#125; &#125; int tmpValue = vec[i]; for(int j=i; j&gt;tmpIndex; --j) &#123; vec[j] = vec[j-1]; &#125; vec[tmpIndex] = tmpValue; //PrintVec(vec); &#125;&#125;void Swap(int &amp;a, int &amp;b)&#123; int tmp = a; a = b; b = tmp;&#125;void BubbleSinkSort(vector&lt;int&gt; &amp;vec) //冒泡排序（下沉）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; for(int i=vec.size()-1; i&gt;0; --i) &#123; bool flag = false; int end = vec.size()-1-i; for(int j=vec.size()-1; j&gt;end; --j) &#123; if(vec[j] &lt; vec[j-1]) &#123; Swap(vec[j], vec[j-1]); flag = true; &#125; &#125; if(!flag) &#123; break; &#125; //PrintVec(vec); &#125;&#125;void BubbleFloatSort(vector&lt;int&gt; &amp;vec) //冒泡排序（上浮）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; for(int i=0; i&lt;vec.size(); ++i) &#123; bool flag = false; int end = vec.size()-1-i; for(int j=0; j&lt;end; ++j) &#123; if(vec[j] &gt; vec[j+1]) &#123; Swap(vec[j], vec[j+1]); flag = true; &#125; &#125; if(!flag) &#123; break; &#125; //PrintVec(vec); &#125;&#125;void SelectionSort(vector&lt;int&gt; &amp;vec) //选择排序&#123; if(vec.size() &lt;= 1) &#123; return; &#125; for(int i=0; i&lt;vec.size(); ++i) &#123; int minValue = vec[i]; int minIndex = i; for(int j=i+1; j&lt;vec.size(); ++j) &#123; if(vec[j] &lt; minValue) &#123; minValue = vec[j]; minIndex = j; &#125; &#125; Swap(vec[i], vec[minIndex]); &#125;&#125;int Partition(vector&lt;int&gt; &amp;vec, int l, int r)&#123; if(l&gt;r) &#123; return l; &#125; int position; int index = r; int tmpValue = vec[index]; while(l&lt;r) &#123; while(l&lt;r &amp;&amp; vec[l]&lt;tmpValue) ++l; //从左边向右找一个大于tmpValue的下标l while(l&lt;r &amp;&amp; vec[r]&gt;=tmpValue) --r; //从右边向左找一个小于tmpValue的下标r if(l&lt;r) &#123; Swap(vec[l], vec[r]); //交换两个值 &#125; &#125; Swap(vec[l], vec[index]); //PrintVec(vec); return r;&#125;void QuickSort_Recursion(vector&lt;int&gt; &amp;vec, int l, int r)&#123; int position = 0; if(l&lt;r) &#123; position = Partition(vec, l, r); QuickSort_Recursion(vec, l, position-1); QuickSort_Recursion(vec, position+1, r); &#125;&#125;void QuickSort_Recursion(vector&lt;int&gt; &amp;vec) //快速排序（递归）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; QuickSort_Recursion(vec, 0, vec.size()-1);&#125;void QuickSort(vector&lt;int&gt; &amp;vec) //快速排序（迭代）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; int l = 0; int r = vec.size()-1; stack&lt;int&gt; st; st.push(l); st.push(r); while(!st.empty()) &#123; r = st.top(); st.pop(); l = st.top(); st.pop(); if(l &gt;= r) &#123; continue; &#125; int position = Partition(vec, l, r); st.push(l); st.push(position-1); st.push(position+1); st.push(r); &#125;&#125;void Merge(vector&lt;int&gt; &amp;va, vector&lt;int&gt; &amp;vb, vector&lt;int&gt; &amp;vec)&#123; vec.clear(); if(va.empty()) &#123; vec = vb; &#125; else if(vb.empty()) &#123; vec = va; &#125; else &#123; int a = 0; int b = 0; while(a &lt; va.size() &amp;&amp; b &lt; vb.size()) &#123; if(va[a] &lt; vb[b]) &#123; vec.push_back(va[a++]); &#125; else &#123; vec.push_back(vb[b++]); &#125; &#125; if(a &lt; va.size()) &#123; for(; a&lt;va.size(); ++a) &#123; vec.push_back(va[a]); &#125; &#125; if(b &lt; vb.size()) &#123; for(; b&lt;vb.size(); ++b) &#123; vec.push_back(vb[b]); &#125; &#125; &#125;&#125;void MergeSort_Recursion(vector&lt;int&gt; &amp;vec) //归并排序（递归）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; vector&lt;int&gt; va; vector&lt;int&gt; vb; int mod = vec.size()/2; for(int i=0; i&lt;vec.size(); ++i) &#123; if(i&lt;mod) &#123; va.push_back(vec[i]); &#125; else &#123; vb.push_back(vec[i]); &#125; &#125; MergeSort_Recursion(va); MergeSort_Recursion(vb); Merge(va, vb, vec);&#125;void Merge(vector&lt;int&gt; &amp;vec, int x, int y, int z)&#123; vector&lt;int&gt; va; vector&lt;int&gt; vb; for(int i=x; i&lt;y; ++i) &#123; va.push_back(vec[i]); &#125; for(int i=y; i&lt;z; ++i) &#123; vb.push_back(vec[i]); &#125; vector&lt;int&gt; vc; if(va.empty()) &#123; vc = vb; &#125; else if(vb.empty()) &#123; vc = va; &#125; else &#123; int a = 0; int b = 0; while(a &lt; va.size() &amp;&amp; b &lt; vb.size()) &#123; if(va[a] &lt; vb[b]) &#123; vc.push_back(va[a++]); &#125; else &#123; vc.push_back(vb[b++]); &#125; &#125; if(a &lt; va.size()) &#123; for(; a&lt;va.size(); ++a) &#123; vc.push_back(va[a]); &#125; &#125; if(b &lt; vb.size()) &#123; for(; b&lt;vb.size(); ++b) &#123; vc.push_back(vb[b]); &#125; &#125; &#125; for(int i=x; i&lt;z; ++i) &#123; vec[i] = vc[i-x]; &#125;&#125;int min(int a, int b)&#123; return (a&lt;b ? a : b);&#125;void MergeSort(vector&lt;int&gt; &amp;vec) //归并排序（迭代）&#123; if(vec.size() &lt;= 1) &#123; return; &#125; for(int i=1; i&lt;vec.size(); i*=2) &#123; int offset = i+i; for(int j=0; j&lt;vec.size(); j+=offset) &#123; Merge(vec, j, min(j+i, vec.size()), min(j+offset, vec.size())); //cout&lt;&lt;j&lt;&lt;\" \"&lt;&lt;min(j+i, vec.size())&lt;&lt;\" \"&lt;&lt;min(j+offset, vec.size())&lt;&lt;endl; //PrintVec(vec); &#125; &#125;&#125;void KeepHead(vector&lt;int&gt; &amp;vec, int len, int i)&#123; int left = 2*i+1; int right = 2*i+2; int largest = i; if(left&lt;len &amp;&amp; vec[left]&gt;vec[i]) &#123; largest = left; &#125; if(right&lt;len &amp;&amp; vec[right]&gt;vec[largest]) &#123; largest = right; &#125; if(largest != i) &#123; Swap(vec[i], vec[largest]); KeepHead(vec, len, largest); &#125;&#125;void BuildHeap(vector&lt;int&gt; &amp;vec) //建堆&#123; if(vec.size() &lt; 2) &#123; return; &#125; int i = vec.size()/2 -1; while(i&gt;=0) &#123; KeepHead(vec, vec.size(), i); --i; &#125;&#125;void HeapSort(vector&lt;int&gt; &amp;vec) //堆排序&#123; BuildHeap(vec); int heap_size = vec.size(); for(int i=vec.size()-1; i&gt;0; --i) &#123; //PrintVec(vec); Swap(vec[0], vec[i]); --heap_size; KeepHead(vec, heap_size, 0); &#125;&#125;void CountingSort(vector&lt;int&gt; &amp;vec) //计数排序&#123; if(vec.size() &lt; 1) &#123; return; &#125; int maxValue = vec[0]; int minValue = vec[0]; for(auto x : vec) &#123; maxValue = x&gt;maxValue ? x : maxValue; minValue = x&lt;minValue ? x : minValue; &#125; vector&lt;int&gt; c(maxValue-minValue+1, 0); for(auto x : vec) &#123; ++c[x-minValue]; //统计vec各元素出现的次数 &#125; for(int i=1; i&lt;=maxValue-minValue; ++i) &#123; c[i] += c[i-1]; //分布值计算 &#125; vector&lt;int&gt; s(vec.size(), 0); for(int i=vec.size()-1; i&gt;=0; --i) &#123; int j = vec[i] - minValue; s[c[j]-1] = vec[i]; --c[j]; &#125; vec = s;&#125;void ShellSort(vector&lt;int&gt; &amp;vec) //希尔排序 &#123; if(vec.size() &lt; 2) &#123; return; &#125; int i, j, flag, counter=1, gap=vec.size(); int temp; while(gap &gt; 1) &#123; gap = gap/2; do &#123; flag = 0; for(int i=0; i&lt;=vec.size()-gap-counter; ++i) &#123; j=i+gap; if(vec[i] &gt; vec[j]) &#123; Swap(vec[i], vec[j]); flag = 1; &#125; &#125; &#125; while(counter &lt; vec.size() &amp;&amp; flag == 1); &#125;&#125;int main()&#123; vector&lt;int&gt; vecTest = &#123;4, 9, 7, 20, 3, 16, 18&#125;; vector&lt;int&gt; vec; //cout&lt;&lt;\"插入排序\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; InsertSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"冒泡排序（下沉）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; BubbleSinkSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"冒泡排序（上浮）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; BubbleFloatSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"选择排序\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; SelectionSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"快速排序（递归）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; QuickSort_Recursion(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"快速排序（迭代）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; QuickSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"归并排序（递归）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; MergeSort_Recursion(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"归并排序（迭代）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; MergeSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"计数排序\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; CountingSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"堆排序\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; HeapSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"希尔排序\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; ShellSort(vec) ; PrintVec(vec) ; vecTest = &#123;49, 55, 25, 97, 60, 27, 49, 50&#125; ; //cout&lt;&lt;\"快速排序（递归）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; QuickSort_Recursion(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"快速排序（迭代）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; QuickSort(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"归并排序（递归）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; MergeSort_Recursion(vec) ; PrintVec(vec) ; //cout&lt;&lt;\"归并排序（迭代）\"&lt;&lt;endl ; vec = vecTest ; PrintVec(vec) ; MergeSort(vec) ; PrintVec(vec) ; return 0;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.casezheng.date/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.casezheng.date/tags/排序/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}]},{"title":"算法 图相关知识","slug":"algorithm-chart","date":"2018-01-12T15:18:03.000Z","updated":"2020-04-12T04:56:36.144Z","comments":true,"path":"2018/01/12/algorithm-chart/","link":"","permalink":"http://www.casezheng.date/2018/01/12/algorithm-chart/","excerpt":"","text":"算法——图图结构图的基本概念图是由顶点的非空集合V(有n&gt;0个顶点组成)与边的集合E(顶点之间的关系)构成,常用G表示,可形式化定义如下:G=(V,E)如果图中的边集E中每一条边都没有方向性,则该图为无向图；如果E中的边具有方向性,则表示该图为有向图。无序图的边表示为无序偶对(Vi, Vj), 所以(Vi, Vj)和(Vj, Vi)是同一条边。有向图的表示的是顶点的有序偶对,边$\\langle$Vi, Vj$\\rangle$和$\\langle$Vj, Vi$\\rangle$是两条不一样的边。 度一个顶点的度指依附于某顶点V的边的条数，通常记为TD(V) 路径顶点的路径是指一个顶点Vi到另一个顶点Vj之间所经过的存在边的顶点的序列。举例来说，如果存在顶点序列 V1, V2, V3, V4, …, Vm，使得顶点偶对(Vi, Vi+1) $\\in$ (i=1, 2, 3, …, m–1),则称该顶点序列为顶点V1到Vm之间的一条路径。如果V1=Vm，则该路径成为回路或环。 子图图G=(V, E)和G’=(V’, E’)，如果存在V’$\\in$V 且 E’ $\\in$ E，则称G’为G的一个子图 图的连通在无向图中，如果顶点Vi到Vj（i!=j)存在路径，则称Vi和Vj是连通的。如果某无向图中任意两个顶点都是连通的，则称该无向图是连通图，否则为非连通图。无向图中的极大连通子图为该图的连通分量。在有向图中，如果任意两个不同的顶点都是连通的，则称该有向图为强连通图，其极大连通子图为强连通分量。无向图和有向图 图的存储结构图主要有邻接表存储结构和邻接矩阵存储结构两种。 邻接矩阵存储邻接矩阵存储(数组存储法),核心思想是使用两个数组存储一个图。具体定义如下：一个具有n个顶点的图，将每个顶点存储在数组Vertex[0…n-1]中，另定义一个二维数组E[0…n-1][0…n-1]存储相邻顶点见的关系，该二维矩阵称为邻接矩阵。在数组Vertex中的下标来表示一个顶点，则邻接数组元素E[i][j]就表示Vi和Vj之间的关系，如果存在边，则为1，如不存在则为0。无向图的矩阵是一个对称矩阵，矩阵中的值表示两者之间有直接边可到达。如果是有权图则数组存储权值，无边的顶点之间权值为$\\infty$.邻接矩阵不适合存储稀疏图，会有很多存储空间是空值，浪费空间。 图a使用邻接矩阵表示:图的邻接矩阵存储 邻接表存储邻接表存储利用链表的优势，解决了邻接矩阵不适合存储稀疏图的问题。邻接表存储法为每个顶点建立一条线性链表，如果图中有n个顶点，则其邻接表结构有n个线性表组成，每个链表设置一个头结点，称为顶点结点。每一个链表中的结点称为边结点。 图b使用邻接表表示:图的邻接表存储 图的遍历深度优先遍历图的深度优先遍历（Deepth First Search，DFS），从顶点v出发，首先将顶点v自己标记为已到达顶点，然后选择一个和v邻近的顶点u，如果u不存在则停止遍历，如果顶点存在则将u顶点标记为已到达，选择一个顶点u的未到达顶点w开始新一轮DFS。 广度优先遍历图的广度优先遍历，从顶点v出发，访问v之后依次访问v的各个未被访问的邻接点，然后从这些邻接点出发访问其它未被访问过的点，直到所有点访问完成。 示例代码 https://github.com/CaseZheng/Study/tree/master/Algorithm/Chart 图的高级算法拓扑排序拓扑排序是有向无环图的重要应用，将单向连接的事件按照其关系方向排列成一个具有先后顺序的线性结构。 偏序。偏序是一种非自反性的传递关系。用R表示元素间的关系，偏序的定义是非自反性，即不存在sRs的关系，如果sRt表示存在s到t的关系R，则必不存在tRs，说明偏序具有非对称性。如果存在关系sRt，tRu，则必存在sRu，说明偏序具有关系传递性。拓扑排序是在有向无环图这种偏序关系上的一种算法。 全序。全序关系T是一个偏序，并且对于集合中所有的元素s$\\neq$t，sTt和tTs只能取其一。 有向无环图（DAG图）。一种特殊的有向图，从该图的任一结点出发，经过若干条边，无法回到该顶点。这样的图是无环的。 拓扑排序是在有向无环图上进行的操作，对于一个有向无环图G，拓扑排序将图G的所有顶点排成一个线性序列，使图中任意一对顶点v和u，满足如果图中存在关系v-&gt;u，则排序后顶点v必在u的左边。 示例代码 https://github.com/CaseZheng/Study/tree/master/Algorithm/Chart 最小生成树算法描述：最小生成树是指在一个具有N个顶点的带权连通图G中，如果存在某个子图G’,其包含图G的所有顶点和一部分边，且不形成回路，并且子图G’的个边权值最小，则称图G’是图G的最小生成树。 最小生成树 最小生成树不能有环 最小生成树不一定唯一，在一个图中最小生成树可以有一个或多个 最小生成树边的个数等于顶点数减一，即|E|=|V|-1 最小生成树的边的权值最小 Kruskal算法核心思想：在带权连通图中，不断地在边集中找到最小的边，如果该边满足得到最小生成树的条件，就将其构造，直到最后得到一颗最小生成树。 Prim算法核心思想：在带权连通图中，图的顶点集合为V，从图中某个顶点v开始，得到集合U={v},重复执行下述操作：在所有u$\\in$U,w$\\in$V-E的边(u,w)$\\in$E中找到最小的边，将(u,w)这条边加入到已找到的边集合，并将点w加入到集合U中，当U=C时，就找到了最小生成树。 参考书籍 妙趣横生的算法（C++语言实现）","categories":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.casezheng.date/tags/算法/"},{"name":"图","slug":"图","permalink":"http://www.casezheng.date/tags/图/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}]},{"title":"linux添加开机启动任务","slug":"rc-local","date":"2017-12-30T16:40:00.000Z","updated":"2020-04-12T04:56:36.142Z","comments":true,"path":"2017/12/31/rc-local/","link":"","permalink":"http://www.casezheng.date/2017/12/31/rc-local/","excerpt":"","text":"linxu添加开启启动任务本机为fedora 26 先创建rc.local文件，编辑rc.local12sudo touch /etc/rc.d/rc.localsudo vim /etc/rc.d/rc.local 写入执行脚本12#!/bin/bashcd /home/CaseZheng/CaseZhengBlog &amp;&amp; nohup hexo serve &amp; 给予执行权限1sudo chmod +x /etc/rc.d/rc.local 执行下面的命令1sudo systemctl enable rc-local.service 如果报错，编辑rc-local.service1sudo vim /usr/lib/systemd/system/rc-local.service 在最后面加入下列内容12[Install]WantedBy=multi-user.target 再执行命令1sudo systemctl enable rc-local.service 然后重启1reboot 使用systemctl查看rc-local.service状态12345678[CaseZheng@localhost CaseZhengBlog]$ sudo systemctl status rc-local.service● rc-local.service - /etc/rc.d/rc.local Compatibility Loaded: loaded (/usr/lib/systemd/system/rc-local.service; enabled; vendor preset: disabled) Active: active (running) since Sat 2017-12-30 23:45:57 CST; 1h 3min ago Tasks: 11 (limit: 4915) CGroup: /system.slice/rc-local.service ├─852 /bin/bash /etc/rc.d/rc.local start └─859 hexo 如有错误会有报错信息","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"MySQL SQL语句基础","slug":"mysql-3","date":"2017-10-31T14:56:00.000Z","updated":"2018-03-21T11:55:00.000Z","comments":true,"path":"2017/10/31/mysql-3/","link":"","permalink":"http://www.casezheng.date/2017/10/31/mysql-3/","excerpt":"","text":"SQL语句基础知识的复习与学习 SQL简介SQL是Structure Query Language（结构化查询语言）的缩写，使用关系数据模型的数据库应用语言。 SQL分类SQL语句主要分为3类 DDL（Data Definition Language）数据定义语句定义不同的数据段、数据库、数据表、列、索引等数据库对象的定义。常用关键字：create、drop、alter等。 DML（Data Manipulation Language）数据操纵语句用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键词主要包括insert、delete、update和select等。 DCL（Data Control Language）数据控制语句用于控制不同数据段直接的许可和访问级别的语句。定义了数据库、表、字段、用户的访问权限和安全级别，主要的关键字包括grant、revoke等。 DDLDDL是数据定义语言的缩写，是对数据库内部的对象进行创建、删除、修改的操作语言。和DML语言的最大区别是DML只对表内部的操作，而不涉及表的定义、结构的修改，更不会涉及到其他对象。DDL语句更多被数据库管理员（DBA）所使用。 数据库创建create database dbname;1234567891011121314151617181920212223MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec)MariaDB [(none)]&gt; create database test;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec) 删除数据库drop database dbname;1234567891011121314151617181920212223MariaDB [information_schema]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec)MariaDB [information_schema]&gt; drop database test;Query OK, 0 rows affected (0.00 sec)MariaDB [information_schema]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建表create table tablename(column_name_1 column_type_1 constraints, column_name_2 column_type_2 constraints, … … , column_name_n column_type_n constraints)MySQL的表名以目录形式存在磁盘上，表名的字符可以使用任何目录名允许的字符。column_name是列的名字，column_type是列的数据类型，contraints是列的约束条件。123456789101112131415161718192021222324252627282930MariaDB [test]&gt; create table student(name char(32), age int(4), sex int(2));Query OK, 0 rows affected (0.04 sec)MariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| student |+----------------+1 row in set (0.00 sec)MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(4) | YES | | NULL | || sex | int(2) | YES | | NULL | |+-------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)MariaDB [test]&gt; show create table student\\G*************************** 1. row *************************** Table: studentCreate Table: CREATE TABLE `student` ( `name` char(32) DEFAULT NULL, `age` int(4) DEFAULT NULL, `sex` int(2) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin11 row in set (0.00 sec) 删除表drop table tablename;12345MariaDB [test]&gt; drop table student;Query OK, 0 rows affected (0.02 sec)MariaDB [test]&gt; show tables;Empty set (0.00 sec) 修改表表结构的修改一般使用alter table语句。 修改表类型alter table tablename modify [column] column_definition [first | after col_name]12345678910111213141516171819202122MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(4) | YES | | NULL | || sex | int(2) | YES | | NULL | |+-------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)MariaDB [test]&gt; alter table student modify age int(2);Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(2) | YES | | NULL | || sex | int(2) | YES | | NULL | |+-------+----------+------+-----+---------+-------+3 rows in set (0.00 sec) 新增表字段alter table tablename add [column] column_definition [first | after col_name]1234567891011121314MariaDB [test]&gt; alter table student add birthday date;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; desc student;+----------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(2) | YES | | NULL | || sex | int(2) | YES | | NULL | || birthday | date | YES | | NULL | |+----------+----------+------+-----+---------+-------+4 rows in set (0.00 sec) 删除表字段alter table tablename drop [column] column_name;12345678910111213MariaDB [test]&gt; alter table student drop column birthday;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(2) | YES | | NULL | || sex | int(2) | YES | | NULL | |+-------+----------+------+-----+---------+-------+3 rows in set (0.00 sec) 字段改名alter table tablename change [column] old_col_name column_definition [first | after col_name]12345678910111213MariaDB [test]&gt; alter table student change sex grade int(4);Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || age | int(2) | YES | | NULL | || grade | int(4) | YES | | NULL | |+-------+----------+------+-----+---------+-------+3 rows in set (0.01 sec) change和modify都可以修改表定义，但change后面需要写两次列名，不方便。不过change的优点是可以修改列名称，modify则不能。 修改字段排列顺序字段增加和修改(add/change/modify)中，都有可选项first|after column_name，该选项可以修改字段在表中的位置，默认add增加新字段加再表的最后位置，而change/modify默认不该表字段位置。1234567891011121314MariaDB [test]&gt; alter table student add sex int(2) after name;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0MariaDB [test]&gt; desc student;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| name | char(32) | YES | | NULL | || sex | int(2) | YES | | NULL | || age | int(2) | YES | | NULL | || grade | int(4) | YES | | NULL | |+-------+----------+------+-----+---------+-------+4 rows in set (0.00 sec) 表改名alter table tablename rename [to] new_tablename;123456789101112131415161718MariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| student |+----------------+1 row in set (0.00 sec)MariaDB [test]&gt; alter table student rename to student_new;Query OK, 0 rows affected (0.02 sec)MariaDB [test]&gt; show tables;+----------------+| Tables_in_test |+----------------+| student_new |+----------------+1 row in set (0.00 sec) DMLDML操作是指对数据库中表记录的操作，主要包括表记录的插入(insert)、更新(update)、删除(delete)和查询(select)。 插入记录insert into tablename (field1, field2, ……, fieldn) values(value1, value2, ……, valuen);12345678910MariaDB [test]&gt; insert into student (name, sex, age) values(&quot;haha&quot;, 1, 10);Query OK, 1 row affected (0.01 sec)MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 1 | 10 | NULL |+------+------+------+-------+1 row in set (0.00 sec) 也可以不指定字段名称，但values的顺序要和字段排列顺序一致，且不能缺少任何一个。1234567891011MariaDB [test]&gt; insert into student values(&quot;gaga&quot;, 2, 14, 1);Query OK, 1 row affected (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 1 | 10 | NULL || gaga | 2 | 14 | 1 |+------+------+------+-------+2 rows in set (0.00 sec) 在MySQL中insert语句可一次插入多条记录。在插入大量记录时，节省很多网络开销，大大提高插入效率。insert into tablename (field1, field2, ……, fieldn)values(value1_1, value1_2, ……, value1_n),(value2_1, value2_2, ……, value2_n),… …(valuen_1, valuen_2, ……, valuen_n);123456789101112131415161718MariaDB [test]&gt; insert into student (name, sex, grade) values -&gt; (&quot;h1&quot;, 1, 3), -&gt; (&quot;h3&quot;, 0, 4), -&gt; (&quot;h5&quot;, 1, 5);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 1 | 10 | NULL || gaga | 2 | 14 | 1 || h1 | 1 | NULL | 3 || h3 | 0 | NULL | 4 || h5 | 1 | NULL | 5 |+------+------+------+-------+5 rows in set (0.00 sec) 更新记录update tablename set field1=value1, field2=value2, ……, fieldn=valuen [where condition];123456789101112131415MariaDB [test]&gt; update student set sex=0, grade=0 where name= &apos;haha&apos;;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 0 | 10 | 0 || gaga | 2 | 14 | 1 || h1 | 1 | NULL | 3 || h3 | 0 | NULL | 4 || h5 | 1 | NULL | 5 |+------+------+------+-------+5 rows in set (0.00 sec) MySQL中update可以同时更新多个表中数据。update t1, t2, ……, tn set t1.field1=expr1, t2.field2=expr2, ……, tn.fieldn=exprn [where condition];123456789101112131415161718192021222324252627282930313233343536373839404142434445MariaDB [test]&gt; select * from home;+------+--------+| id | addr |+------+--------+| 1 | hhhhhh || 2 | jjjjj |+------+--------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 0 | 10 | 0 || gaga | 2 | 14 | 1 || h1 | 1 | NULL | 3 || h3 | 0 | NULL | 4 || h5 | 1 | NULL | 5 |+------+------+------+-------+5 rows in set (0.00 sec)MariaDB [test]&gt; update student, home set student.grade=10, home.id=20 where student.name=&apos;haha&apos;;Query OK, 3 rows affected (0.00 sec)Rows matched: 3 Changed: 3 Warnings: 0MariaDB [test]&gt; select * from home;+------+--------+| id | addr |+------+--------+| 20 | hhhhhh || 20 | jjjjj |+------+--------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+------+-------+| name | sex | age | grade |+------+------+------+-------+| haha | 0 | 10 | 10 || gaga | 2 | 14 | 1 || h1 | 1 | NULL | 3 || h3 | 0 | NULL | 4 || h5 | 1 | NULL | 5 |+------+------+------+-------+5 rows in set (0.00 sec) 删除记录delete from tablename [where condition];123456789101112131415161718192021MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| haha | 1 || hehe | 2 || gaga | 3 |+------+------+3 rows in set (0.00 sec)MariaDB [test]&gt; delete from student where age=2;Query OK, 1 row affected (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| haha | 1 || gaga | 3 |+------+------+2 rows in set (0.00 sec) delete t1,t2,…tn from t1,t2,…tn [where condition];如果 from 后面的表名用别名，则 delete 后面的也要用相应的别名，否则会提示语法错误。123456789101112131415161718192021222324252627282930313233343536MariaDB [test]&gt; select * from boy;+------+-------+| name | score |+------+-------+| haha | 10 || gaga | 30 |+------+-------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| haha | 1 || gaga | 3 |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; delete boy, s from boy, student s where s.age=1 and boy.name=s.name;Query OK, 2 rows affected (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| gaga | 3 |+------+------+1 row in set (0.00 sec)MariaDB [test]&gt; select * from boy;+------+-------+| name | score |+------+-------+| gaga | 30 |+------+-------+1 row in set (0.00 sec) 查询记录基本语法select * from tablename [where condition]; 查询不重复记录(去重)使用distinct关键字实现123456789101112131415161718MariaDB [test]&gt; select age from student;+------+| age |+------+| 3 || 3 || 4 |+------+3 rows in set (0.00 sec)MariaDB [test]&gt; select distinct age from student;+------+| age |+------+| 3 || 4 |+------+2 rows in set (0.00 sec) 条件查询使用where关键字实现1234567MariaDB [test]&gt; select * from student where age=4;+------+------+| name | age |+------+------+| tete | 4 |+------+------+1 row in set (0.00 sec) 排序和限制排序使用order by关键字实现1select * from tablename [where condition] [order by field1 [desc|asc] , field2 [desc|asc],......fieldn [desc|asc]] desc 和 asc 是排序顺序关键字，desc表示按照字段进行降序排列，asc则表示升序排列，如果不写此关键字默认是升序排列。order by后面可以跟多个不同的排序字段，并 且每个排序字段可以有不同的排序顺序。1234567891011121314151617181920212223242526272829303132333435MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| gaga | 3 || haha | 3 || tete | 4 || haha | 1 || tete | 2 |+------+------+5 rows in set (0.00 sec)MariaDB [test]&gt; select * from student order by age;+------+------+| name | age |+------+------+| haha | 1 || tete | 2 || gaga | 3 || haha | 3 || tete | 4 |+------+------+5 rows in set (0.00 sec)MariaDB [test]&gt; select * from student order by age , name desc;+------+------+| name | age |+------+------+| haha | 1 || tete | 2 || haha | 3 || gaga | 3 || tete | 4 |+------+------+5 rows in set (0.00 sec) 限制显示个数使用limit关键字1select ... ... [limit offset_start, row_count] offset_start起始偏移量 row_count显示行数，默认情况下起始偏移量为0，只写显示行数，显示前n条记录。1234567891011121314151617181920212223242526272829MariaDB [test]&gt; select * from student limit 2;+------+------+| name | age |+------+------+| gaga | 3 || haha | 3 |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student limit 3, 2;+------+------+| name | age |+------+------+| haha | 1 || tete | 2 |+------+------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| gaga | 3 || haha | 3 || tete | 4 || haha | 1 || tete | 2 |+------+------+5 rows in set (0.00 sec) 聚合123456select [field1, field2, ...... fieldn] fun_namefrom tablename[where wehre_contition][group by field1, field2, ... fieldn][with rollup][having where_contition] fun_name聚合操作(聚合函数)，常用的有：sum(求和)、count(总个数)、max(最大值)、min(最小值)group by关键字表示要进行分类聚合的字段where rollup可选语法，表示是否对分类聚合的结果进行再汇总having 关键字表示对分类后的结果再进行条件的过滤 having 和 where 的区别在于 having 是对聚合后的结果进行条件的过滤，而 where 是在聚合前就对记录进行过滤，如果逻辑允许，我们尽可能用 where 先过滤记录，这样因为结果集减小，将对聚合的效率大大提高，最后再根据逻辑看是否用 having 进行再过滤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960MariaDB [test]&gt; select * from student_score;+------+--------+-------+-------+-------+| name | shuxue | yuwen | yinyu | class |+------+--------+-------+-------+-------+| gaga | 1 | 3 | 4 | 1 || fef | 9 | 23 | 21 | 2 || ii | 45 | 123 | 42 | 1 || gr | 56 | 34 | 86 | 2 || ce | 45 | 23 | 98 | 2 || gr | 1 | 3 | 4 | 3 || khj | 9 | 23 | 21 | 4 || ko | 45 | 123 | 42 | 4 || po | 56 | 34 | 86 | 5 || ds | 45 | 23 | 98 | 3 |+------+--------+-------+-------+-------+10 rows in set (0.00 sec)MariaDB [test]&gt; select sum(shuxue), max(yinyu), min(yuwen) from student_score;+-------------+------------+------------+| sum(shuxue) | max(yinyu) | min(yuwen) |+-------------+------------+------------+| 312 | 98 | 3 |+-------------+------------+------------+1 row in set (0.00 sec)MariaDB [test]&gt; select class, sum(shuxue), sum(yinyu) from student_score group by class;+-------+-------------+------------+| class | sum(shuxue) | sum(yinyu) |+-------+-------------+------------+| 1 | 46 | 46 || 2 | 110 | 205 || 3 | 46 | 102 || 4 | 54 | 63 || 5 | 56 | 86 |+-------+-------------+------------+5 rows in set (0.00 sec)MariaDB [test]&gt; select class, sum(shuxue), sum(yinyu) from student_score group by class with rollup;+-------+-------------+------------+| class | sum(shuxue) | sum(yinyu) |+-------+-------------+------------+| 1 | 46 | 46 || 2 | 110 | 205 || 3 | 46 | 102 || 4 | 54 | 63 || 5 | 56 | 86 || NULL | 312 | 502 |+-------+-------------+------------+6 rows in set (0.00 sec)MariaDB [test]&gt; select class, sum(shuxue), sum(yinyu) from student_score group by class with rollup having sum(shuxue) &gt; 50;+-------+-------------+------------+| class | sum(shuxue) | sum(yinyu) |+-------+-------------+------------+| 2 | 110 | 205 || 4 | 54 | 63 || 5 | 56 | 86 || NULL | 312 | 502 |+-------+-------------+------------+4 rows in set (0.00 sec) 表连接表连接分为内连接和外连接，内连接仅选出两张表中互相存在的记录，而外连接会选出其他不匹配的记录。外连接分为左连接和右连接 左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录。 右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970MariaDB [test]&gt; select * from student;+------+------+| name | age |+------+------+| gaga | 3 || haha | 3 || tete | 4 || haha | 1 || tete | 2 || fee | 2 || ko | 3 |+------+------+7 rows in set (0.00 sec)MariaDB [test]&gt; select * from student_score;+------+--------+-------+-------+-------+| name | shuxue | yuwen | yinyu | class |+------+--------+-------+-------+-------+| gaga | 1 | 3 | 4 | 1 || fef | 9 | 23 | 21 | 2 || ii | 45 | 123 | 42 | 1 || gr | 56 | 34 | 86 | 2 || ce | 45 | 23 | 98 | 2 || gr | 1 | 3 | 4 | 3 || khj | 9 | 23 | 21 | 4 || ko | 45 | 123 | 42 | 4 || po | 56 | 34 | 86 | 5 || ds | 45 | 23 | 98 | 3 |+------+--------+-------+-------+-------+10 rows in set (0.00 sec)MariaDB [test]&gt; select * from student, student_score where student.name=student_score.name;+------+------+------+--------+-------+-------+-------+| name | age | name | shuxue | yuwen | yinyu | class |+------+------+------+--------+-------+-------+-------+| gaga | 3 | gaga | 1 | 3 | 4 | 1 || ko | 3 | ko | 45 | 123 | 42 | 4 |+------+------+------+--------+-------+-------+-------+2 rows in set (0.00 sec)MariaDB [test]&gt; select * from student left join student_score on student.name=student_score.name;+------+------+------+--------+-------+-------+-------+| name | age | name | shuxue | yuwen | yinyu | class |+------+------+------+--------+-------+-------+-------+| gaga | 3 | gaga | 1 | 3 | 4 | 1 || ko | 3 | ko | 45 | 123 | 42 | 4 || haha | 3 | NULL | NULL | NULL | NULL | NULL || tete | 4 | NULL | NULL | NULL | NULL | NULL || haha | 1 | NULL | NULL | NULL | NULL | NULL || tete | 2 | NULL | NULL | NULL | NUULL | NULL || fee | 2 | NULL | NULL | NULL | NULL | NULL |+------+------+------+--------+-------+-------+-------+7 rows in set (0.00 sec)MariaDB [test]&gt; select * from student right join student_score on student.name=student_score.name;+------+------+------+--------+-------+-------+-------+| name | age | name | shuxue | yuwen | yinyu | class |+------+------+------+--------+-------+-------+-------+| gaga | 3 | gaga | 1 | 3 | 4 | 1 || ko | 3 | ko | 45 | 123 | 42 | 4 || NULL | NULL | fef | 9 | 23 | 21 | 2 || NULL | NULL | ii | 45 | 123 | 42 | 1 || NULL | NULL | gr | 56 | 34 | 86 | 2 || NULL | NULL | ce | 45 | 23 | 98 | 2 || NULL | NULL | gr | 1 | 3 | 4 | 3 || NULL | NULL | khj | 9 | 23 | 21 | 4 || NULL | NULL | po | 56 | 34 | 86 | 5 || NULL | NULL | ds | 45 | 23 | 98 | 3 |+------+------+------+--------+-------+-------+-------+10 rows in set (0.00 sec) 子查询12345678MariaDB [test]&gt; select * from student where name in (select name from student_score);+------+------+| name | age |+------+------+| gaga | 3 || ko | 3 |+------+------+2 rows in set (0.00 sec) 某些情况下子查询和表连接可以相互转化 记录联合union和union all用于实现记录联合123456789101112131415161718192021222324252627282930313233343536373839404142MariaDB [test]&gt; select name from student union all select name from student_score;+------+| name |+------+| gaga || haha || tete || haha || tete || fee || ko || gaga || fef || ii || gr || ce || gr || khj || ko || po || ds |+------+17 rows in set (0.00 sec)MariaDB [test]&gt; select name from student union select name from student_score;+------+| name |+------+| gaga || haha || tete || fee || ko || fef || ii || gr || ce || khj || po || ds |+------+12 rows in set (0.00 sec) union 和 union all的区别在于union all将结果集直接合并在一起，而union将union all的结果进行一次distinct，去除重复记录的结果。 DCLDCL语句主要是DBA用来管理系统中的对象权限所使用的，一般开发人员很少使用。grant和revoke分别授出和收回用户权限。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"MySQL 简介与安装","slug":"mysql-1","date":"2017-10-30T14:06:00.000Z","updated":"2020-04-12T04:56:36.138Z","comments":true,"path":"2017/10/30/mysql-1/","link":"","permalink":"http://www.casezheng.date/2017/10/30/mysql-1/","excerpt":"","text":"mysql的简单介绍 关系型数据库数据库是(Database)是按照数据结构来组织、存储和管理数据的仓库。关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS的术语： 数据库：数据库是一些关联表的集合。 数据表：表是数据的矩阵。 主键：主键是唯一的。一个数据表中只能包含一个主键。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 MySQL数据库MySQL是一个关系型数据库管理系统(RDBMS, Relational Database Management System)，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的RDBMS, 关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MySQL分支与变种主流的三种变种：Percona Server,MariaDB和Drizzle Percona ServerPercona Server是个与Mysql向后兼容的替代品，它尽可能的不改变SQL语法，客户端/服务器协议和磁盘上的文件格式。任何运行在Mysql上的都可以运行在Percona Server上而不需要修改。切换到Percona Server只需关掉Mysql和启动Percona Server，不需要导出和重新导入数据。Percona Server包括Percona XtraDB引擎，即改进版本的InnoDB。Percona Server的许多改进特性在随后的Mysql版本中才会有体现，也就是说Percona Server成了许多新特性的“抢鲜”版。 MariaDB从 MySQL 转向 MariaDB的代表厂家：谷歌（2013年9月）、RedHat（2013年6月）、维基百科（2013年4月）MySQL 在 2008 年被Sun以10亿美金所收购，MySQL 创始人 Michael Widenius 则不满 Sun 开发团队脚步过慢，愤而离职成立开源数据库联盟，另外从现有 MySQL 程序代码中，开发出另一个延伸分支版本，也就是名为玛莉亚数据库的企业级开源数据。库玛莉亚数据库如同 MySQL 的影子版本，玛莉亚数据库是 MySQL 的一个分支版本（branch），而不是衍生版本（folk），提供的功能可和 MySQL 完全兼容。 DrizzleDrizzle是真正的Mysql分支，而非只是个变种或增强版本。它并不与Mysql兼容，尽管区分上还并不是大相径庭。在许多场合并不能简单地将Mysql后端替换为Drizzle，因为它对Mysql的语法修改太大了。 MySQL的安装最直接的方式，使用yum安装，这里使用MariaDB，操作系统是Fedora 26。1sudo yum install mariadb mariadb-server mariadb-devel mariadb-libs mariadb-common mariadb-config -y MySQL的启动将mariadb设置为开机自启动123systemctl enable mariadb.servicesystemctl start mariadb.servicesystemctl status mariadb.service 检查服务器版本12[CaseZheng@localhost ~]$ mysql --versionmysql Ver 15.1 Distrib 10.1.26-MariaDB, for Linux (x86_64) using readline 5.1 MySQL的连接MySQL刚刚安装密码为空，可直接连接。1234567[CaseZheng@localhost ~]$ mysqlWelcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 5Server version: 10.1.26-MariaDB MariaDB ServerCopyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.MariaDB [(none)]&gt; 可以使用mysqladmin创建root用户的密码，记得需要在root用户下1mysqladmin -uroot password 123456 MySQL安装后的样例配置文件在/usr/share/mysql下安装mariadb的则在/usr/share/mariadb该目录下将/etc/my.cnf备份，再将选择的样例配置文件，复制到/etc/目录下，改名为my.cnf。1234[CaseZheng@localhost mariadb]$ pwd/usr/share/mariadb[CaseZheng@localhost mariadb]$ ls *.cnfmy-huge.cnf my-innodb-heavy-4G.cnf my-large.cnf my-medium.cnf my-small.cnf wsrep.cnf MySQl基本操作show databases;查看所有的DB名称12345678910MariaDB [mysql]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.00 sec) use 数据库名;切换数据库12MariaDB [mysql]&gt; use mysqlDatabase changed show tables;查看当前数据库的所有表1234567891011MariaDB [mysql]&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| column_stats || time_zone_leap_second || time_zone_name || time_zone_transition || time_zone_transition_type || user |+---------------------------+ show columns from 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。1234567891011121314151617181920212223242526MariaDB [mysql]&gt; show columns from host;+-----------------------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------------+---------------+------+-----+---------+-------+| Host | char(60) | NO | PRI | | || Db | char(64) | NO | PRI | | || Select_priv | enum('N','Y') | NO | | N | || Insert_priv | enum('N','Y') | NO | | N | || Update_priv | enum('N','Y') | NO | | N | || Delete_priv | enum('N','Y') | NO | | N | || Create_priv | enum('N','Y') | NO | | N | || Drop_priv | enum('N','Y') | NO | | N | || Grant_priv | enum('N','Y') | NO | | N | || References_priv | enum('N','Y') | NO | | N | || Index_priv | enum('N','Y') | NO | | N | || Alter_priv | enum('N','Y') | NO | | N | || Create_tmp_table_priv | enum('N','Y') | NO | | N | || Lock_tables_priv | enum('N','Y') | NO | | N | || Create_view_priv | enum('N','Y') | NO | | N | || Show_view_priv | enum('N','Y') | NO | | N | || Create_routine_priv | enum('N','Y') | NO | | N | || Alter_routine_priv | enum('N','Y') | NO | | N | || Execute_priv | enum('N','Y') | NO | | N | || Trigger_priv | enum('N','Y') | NO | | N | |+-----------------------+---------------+------+-----+---------+-------+20 rows in set (0.00 sec) desc 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。与show columns from 数据表作用相同。1234567891011121314151617181920212223242526MariaDB [mysql]&gt; desc host;+-----------------------+---------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------------+---------------+------+-----+---------+-------+| Host | char(60) | NO | PRI | | || Db | char(64) | NO | PRI | | || Select_priv | enum('N','Y') | NO | | N | || Insert_priv | enum('N','Y') | NO | | N | || Update_priv | enum('N','Y') | NO | | N | || Delete_priv | enum('N','Y') | NO | | N | || Create_priv | enum('N','Y') | NO | | N | || Drop_priv | enum('N','Y') | NO | | N | || Grant_priv | enum('N','Y') | NO | | N | || References_priv | enum('N','Y') | NO | | N | || Index_priv | enum('N','Y') | NO | | N | || Alter_priv | enum('N','Y') | NO | | N | || Create_tmp_table_priv | enum('N','Y') | NO | | N | || Lock_tables_priv | enum('N','Y') | NO | | N | || Create_view_priv | enum('N','Y') | NO | | N | || Show_view_priv | enum('N','Y') | NO | | N | || Create_routine_priv | enum('N','Y') | NO | | N | || Alter_routine_priv | enum('N','Y') | NO | | N | || Execute_priv | enum('N','Y') | NO | | N | || Trigger_priv | enum('N','Y') | NO | | N | |+-----------------------+---------------+------+-----+---------+-------+20 rows in set (0.00 sec) show index from 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。12345678MariaDB [mysql]&gt; show index from user;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| user | 0 | PRIMARY | 1 | Host | A | NULL | NULL | NULL | | BTREE | | || user | 0 | PRIMARY | 2 | User | A | 6 | NULL | NULL | | BTREE | | |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+2 rows in set (0.00 sec) show table status from db_name [like ‘pattern’]\\G输出Mysql数据库管理系统的性能及统计信息 命令后加\\G则不需要再加; 且查询结果会按列打印12345678910111213141516171819202122232425输出数据库mysql所有表的信息MariaDB [mysql]&gt; show table status from mysql\\G数据数据库mysql以u开头的表信息MariaDB [mysql]&gt; show table status from mysql like 'u%'\\G*************************** 1. row *************************** Name: user Engine: MyISAM Version: 10 Row_format: Dynamic Rows: 6 Avg_row_length: 74 Data_length: 444Max_data_length: 281474976710655 Index_length: 4096 Data_free: 0 Auto_increment: NULL Create_time: 2017-08-27 18:47:47 Update_time: 2017-10-30 23:16:25 Check_time: NULL Collation: utf8_bin Checksum: NULL Create_options: Comment: Users and global privileges1 row in set (0.00 sec) show create table table_name\\G打印创建table_name表的SQL语句123456789101112131415161718192021222324252627MariaDB [mysql]&gt; show create table host\\G*************************** 1. row *************************** Table: hostCreate Table: CREATE TABLE `host` ( `Host` char(60) COLLATE utf8_bin NOT NULL DEFAULT '', `Db` char(64) COLLATE utf8_bin NOT NULL DEFAULT '', `Select_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Insert_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Update_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Delete_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Create_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Drop_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Grant_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `References_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Index_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Alter_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Create_tmp_table_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Lock_tables_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Create_view_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Show_view_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Create_routine_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Alter_routine_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Execute_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', `Trigger_priv` enum('N','Y') CHARACTER SET utf8 NOT NULL DEFAULT 'N', PRIMARY KEY (`Host`,`Db`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='Host privileges; Merged with database privileges'1 row in set (0.00 sec) 参考文档 MySQL教程 MySQL简介","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.casezheng.date/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"vim的自动补全插件的安装YouCompleteMe","slug":"vim-youcompleteme","date":"2017-10-19T14:04:00.000Z","updated":"2020-04-12T04:56:36.136Z","comments":true,"path":"2017/10/19/vim-youcompleteme/","link":"","permalink":"http://www.casezheng.date/2017/10/19/vim-youcompleteme/","excerpt":"","text":"目录YouCompleteMe Linux个人vim配置 环境 Fedora26YouCompleteMe官网前期准备工作 vim 支持python vim版本 安装各种库和工具 123456sudo yum install -y ruby ruby-devel lua lua-devel luajit luajit-devel ctags git python python-devel python3 python3-devel tcl-devel perl perl-devel perl-ExtUtils-ParseXS perl-ExtUtils-XSpp perl-ExtUtils-CBuilder perl-ExtUtils-Embedsudo sudo dnf install automake gcc gcc-c++ kernel-devel cmakesudo dnf install python-devel python3-develsudo dnf install clangsudo dnf install boost-devel boostsudo dnf install golang 使用Vundle vim插件管理器下载YouCompleteMe 1Plugin &apos;Valloric/YouCompleteMe&apos; 下载到YouCompleteMe后，进入YouCompleteMe目录，执行 1git submodule update --init --recursive 编译YouCompleteMe 可根据自己需要安装 详情见官网 1./install.py --clang-completer --system-libclang --system-boost --gocode-completer 配置.vimrc 配置1234let g:ycm_global_ycm_extra_conf = &apos;~/.vim/.ycm_extra_conf.py&apos; &quot;此处是全局配置文件路径let g:ycm_confirm_extra_conf = 0 &quot;关闭每次导入配置文件前的询问let g:syntastic_always_populate_loc_list = 1 &quot;方便使用syntastic进行语法检查let g:ycm_seed_identifiers_with_syntax=1 &quot; 开启语法关键字补全 .ycm_extra_conf.py配置12cd ~/.vim/cp bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py . 修改.ycm_extra_conf，主要是加入库文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546flags = [&apos;-Wall&apos;,&apos;-Wextra&apos;,&apos;-Werror&apos;,&apos;-Wno-long-long&apos;,&apos;-Wno-variadic-macros&apos;,&apos;-fexceptions&apos;,&apos;-DNDEBUG&apos;,# You 100% do NOT need -DUSE_CLANG_COMPLETER in your flags; only the YCM# source code needs it.&apos;-DUSE_CLANG_COMPLETER&apos;,# THIS IS IMPORTANT! Without the &apos;-x&apos; flag, Clang won&apos;t know which language to# use when compiling headers. So it will guess. Badly. So C++ headers will be# compiled as C headers. You don&apos;t want that so ALWAYS specify the &apos;-x&apos; flag.# For a C project, you would set this to &apos;c&apos; instead of &apos;c++&apos;.&apos;-std=c++11&apos;,&apos;-x&apos;,&apos;c++&apos;,&apos;-isystem&apos;,&apos;../BoostParts&apos;,&apos;-isystem&apos;,get_python_inc(),&apos;-isystem&apos;,&apos;../llvm/include&apos;,&apos;-isystem&apos;,&apos;../llvm/tools/clang/include&apos;,&apos;-I&apos;,&apos;.&apos;,&apos;-I&apos;,&apos;./ClangCompleter&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/gtest&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/gtest/include&apos;,&apos;-isystem&apos;,&apos;./tests/gmock&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/include&apos;,&apos;-isystem&apos;,&apos;./benchmarks/benchmark/include&apos;,]# 需要屏蔽下面这部分# try:# final_flags.remove( &apos;-stdlib=libc++&apos; )# except ValueError:# pass 问题YouCompleteMe unavailable: invalid syntax (vimsupport.py, line 1224)在使用时报这个错,最后发现是编译的vim未支持python3导致的,重新编译vim支持python3即可 参考 一步一步带你安装史上最难安装的 vim 插件 —— YouCompleteMe 官方文档","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://www.casezheng.date/tags/vim/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"Libevent源码阅读——API简介","slug":"libevent-2","date":"2017-10-07T16:41:00.000Z","updated":"2020-04-12T04:56:36.131Z","comments":true,"path":"2017/10/08/libevent-2/","link":"","permalink":"http://www.casezheng.date/2017/10/08/libevent-2/","excerpt":"","text":"重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable，本篇主要是Libevent event_base的设置、Libevent 事件循环的启动和停止、Libevent事件的创建和处理、Libevent http服务相关API的介绍 基础API日志打印回调设置API event_set_log_callbackLibevent记录内部的错误和警告日志，如果编译了日志支持功能，也会记录调试信息，日志信息默认输出到stderr，可以通过提供自己的日志函数的方法来覆盖该行为。调用event_set_log_callback()传入event_log_cb类型的函数改变默认行为，传入NULL置为默认行为。默认调试日志是禁止的，可以通过event_enable_debug_logging()函数打开调试(DEBUG)日志，EVENT_DBG_NONE为默认行为，EVENT_DBG_ALL打开所有支持的调试日志。 1234567891011121314151617181920212223242526//Libevent日志登记#define EVENT_LOG_DEBUG 0#define EVENT_LOG_MSG 1#define EVENT_LOG_WARN 2#define EVENT_LOG_ERR 3//severity libevent日志等级//msg libevent日志信息typedef void (*event_log_cb)(int severity, const char *msg);//log_fn libevent默认的日志回调函数static event_log_cb log_fn = NULL;//设置libevent新的日志回调函数void event_set_log_callback(event_log_cb cb)&#123; log_fn = cb;&#125;#define EVENT_DBG_ALL 0xffffffffu#define EVENT_DBG_NONE 0void event_enable_debug_logging(ev_uint32_t which)&#123; event_debug_logging_mask_ = which;&#125; Github示例代码 致命错误退出回调设置API event_set_fatal_callback12345678typedef void (*event_fatal_cb)(int err);static event_fatal_cb fatal_fn = NULL;void event_set_fatal_callback(event_fatal_cb cb)&#123; fatal_fn = cb;&#125; Libevent在遇到致命错误时默认调用exit()或abort()退出当前进程，Libevent提供接口在其退出前会调用一次。 更换内存管理函数的API event_set_mem_functions123456789101112static void *(*mm_malloc_fn_)(size_t sz) = NULL;static void *(*mm_realloc_fn_)(void *p, size_t sz) = NULL;static void (*mm_free_fn_)(void *p) = NULL;void event_set_mem_functions(void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void (*free_fn)(void *ptr))&#123; mm_malloc_fn_ = malloc_fn; mm_realloc_fn_ = realloc_fn; mm_free_fn_ = free_fn;&#125; 默认情况下Libevent会使用原生的malloc、calloc、realloc、free。注意:更换内存管理函数将会影响LibEvent后续所有调用allocate、resize和free内存的函数.因此你需要确保在LibEvent调用其它函数之前替换掉这些函数.否则LibEvent将会调用你提供的free函数来释放从C语言库版本的malloc分配的内存. 你的malloc和realloc函数需要返回和C语言库相同的内存对齐. 你的realloc函数需要正确处理realloc(NULL,sz),也就是说当做(malloc(sz)处理). 你的realloc函数需要正确处理realloc(ptr,0),也就是说当做free(ptr)处理. 你的free函数不必去处理free(NULL). 你的malloc函数不必去处理malloc(0). 如果你不止一个线程使用LibEvent,那么你提供的的内存管理替代函数必须是线程安全的. Github示例代码 释放LibEvent全局结构体 libevent_global_shutdown当进程退出时所有内存都会被释放，但残留的结构体会导致某些调试工具认为Libevent存在内存泄露，使用libevent_global_shutdown可以释放所有库内部的全局数据结构。但libevent_global_shutdown不会释放返回到Libevent外部的结构体，如events、event_base、bufferevents等。调用libevent_global_shutdown()函数将会使得别的LibEvent的函数产生不可预知的行为.除了程序调用了最后一个LibEvent的函数否则不要调用它。Github示例代码 其他以下设置请看官方文档或Libevent中文帮助手册 线程和锁 调试锁的使用 调试事件的使用 Libevent版本的检查 event_base创建默认的event_baseevent_base_new()函数分配和返回一个默认参数的event_base，event_base_new()函数检查环境变量，然后分配一个指向新的event_base的指针，如果错误，返回NULL。1struct event_base *event_base_new(void); 复杂的event_base创建复杂的event_base需要传入event_config。event_config通过event_config_new获得。1struct event_config *event_config_new(void); 获得event_config后对其进行设置，然后调用event_base_new_with_config()创建event_base。1struct event_base *event_base_new_with_config(const struct event_config *cfg); 使用完event_config后需要调用event_config_free()释放event_config。1void event_config_free(struct event_config *cfg); event_config的设置需要调用别的函数。12345678910111213141516171819int event_config_avoid_method(struct event_config *cfg, const char *method);enum event_method_feature &#123; EV_FEATURE_ET = 0x01, EV_FEATURE_O1 = 0x02, EV_FEATURE_FDS = 0x04, EV_FEATURE_EARLY_CLOSE = 0x08&#125;;int event_config_require_features(struct event_config *cfg, int features);enum event_base_config_flag &#123; EVENT_BASE_FLAG_NOLOCK = 0x01, EVENT_BASE_FLAG_IGNORE_ENV = 0x02, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, EVENT_BASE_FLAG_PRECISE_TIMER = 0x20&#125;;int event_config_set_flag(struct event_config *cfg, int flag); event_config_avoid_method()可通过名字让libevent避免使用特定的可用后端。event_config_require_features()可让libevent不使用不能提供所有指定特征的后端。event_config_set_flag()让libevent在创建event_base时设置一个或多个运行时标志。 event_config_require_features()可识别的选项值有： EV_FEATURE_ET 要求支持ET模式的后端（边沿触发） EV_FEATURE_O1 要求添加、删除单个事件，或者确定哪个事件激活的操作时O(1)复杂度的后端 EV_FEATURE_FDS 要求支持任意文件描述符，而不仅仅是套接字的后端 EV_FEATURE_EARLY_CLOSE 要求后台方法可以使用EV_CLOSED检测链接关闭，而不需要读完所有未决数据才能判断 支持EV_CLOSED的后台方法不是所有OS内核都支持的 设置成功返回0，失败返回-1 event_config_set_flag()可识别的选项值有： EVENT_BASE_FLAG_NOLOCK 不要为 event_base分配锁.设置这个选项可以为event_base节省一点用于锁定和解锁的时间,但是让在多个线程中访问 event_base成为不安全的 EVENTBASE_FLAG_IGNORE_ENV 选择使用的后端时,不要检测``EVENT*``环境变量. EVENT_BASE_FLAG_STARTUP_IOCP 仅用于 Windows,让 libevent在启动时就启用任何必需的IOCP分发逻辑,而不是按需启用 EVENT_BASE_FLAG_NO_CACHE_TIME 不是在事件循环每次准备执行超时回调时检测当前时间,而是在每次超时回调后进行检测.注意:这会消耗更多的CPU时间 EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST 如果决定使用epoll后端,可以安全地使用更快的基于 changelist的后端.epoll-changelist后端可以在后端的分发函数调用之间,同样的fd多次修改其状态的情况下,避免不必要的系统调用.但是如果传递任何使用 dup ()或者其变体克隆的 fd给libevent, epoll-changelist后端会触发一个内核bug,导致不正确的结果.在不使用epoll后端的情况下,这个标志是没有效果的.也可以通过设置 EVENT_EPOLL_USE_CHANGELIST:环境变量来打开epoll-changelist选项. EVENT_BASE_FLAG_PRECISE_TIMER 使用更加精确的定时机制 设置成功返回0，失败返回-1 获得特定event_base的配置信息12const char *event_base_get_method(const struct event_base *base);int event_base_get_features(const struct event_base *base); event_base_get_method返回一个指针,指向event_base所选择的后端的名称event_base_get_features返回event_base所选后端支持的特征值的比特掩码 示例代码 运行循环12345#define EVLOOP_ONCE 0x01#define EVLOOP_NONBLOCK 0x02#define EVLOOP_NO_EXIT_ON_EMPTY 0x04int event_base_loop(struct event_base *base, int flags);int event_base_dispatch (struct event_base *base); event_base_loop会运行一个event_base直到没有event注册进来，循环运行，不断重复判断是否有注册的event触发。flags标记可改变event_base_loop的行为： EVLOOP_ONCE 循环将等待某些事件成为激活的，执行激活的事件直到没有更多的事件可以执行，然会返回 EVLOOP_NONBLOCK：循环不等待事件被触发，循环将仅仅检测是否有事件已经就绪，可以立即触发，如果有，则执行事件的回调。 EVLOOP_NO_EXIT_ON_EMPTY：没有事件仍不退出，而是由其他函数触发退出 event_base_dispatch采用默认的配置调用event_base_loop();1234int event_base_dispatch(struct event_base *event_base)&#123; return (event_base_loop(event_base, 0));&#125; 停止循环1234int event_base_loopexit(struct event_base *event_base, const struct timeval *tv);int event_base_loopbreak(struct event_base *event_base);int event_base_got_break(struct event_base *event_base);int event_base_got_exit(struct event_base *event_base); event_base_loopexit()要求event_base在指定时间后停止，如果tv为NULL，则立即停止。但该函数实际会使部分event_base在执行完全部的callback之后才返回。 event_base_loopbreak()要求event_base立即停止，无视其他的active事件而停止。如果当前没有callback，则会导致event_base等到执行完下一个callback之后才退出。 event_base_got_break() 和 event_base_got_exit()event_base_got_break 如果循环因为event_base_loopbreak()退出，event_base_got_break返回true，否则返回falseevent_base_got_exit 如果循环因为event_base_loopexit()退出，event_base_got_exit返回true，否则返回false 示例代码 eventevent简介libevent的基本操作单元是事件event，每个事件代表一组条件： 文件描述符已经就绪，可以读取或者写入 文件描述符变为就绪状态，可以读取或者写入（仅对于边沿触发IO） 超时事件 信号 用户手动触发 当一个event被设置好，并且关联到一个event_base里面时，它被称为“initialized”。此时你可以执行add，这使得它进入pending(等待、未决的)状态。当event被触发或超时时，它的状态称为active，这个情况下对应的callback会被调用。如果event被配置为persist，那么它在callback执行前后都会保持pending的状态。可以通过delete来使得一个event从pending状态重新变成nonpending。 event API 介绍123456789typedef void (*event_callback_fn)(evutil_socket_t, short, void *);struct event * event_new(struct event_base *base, \\ evutil_socket_t fd, \\ short events, \\ void (*cb)(evutil_socket_t, short, void *), \\ void *arg);void event_free(struct event *ev); event创建 event_newevent_new 创建一个新的event。其中fd是文件描述符，需要自行初始化之后再作为参数传入。event_free()释放event的资源。如果event是active或者是pending状态，则函数会将event先变成非active且非pending的状态，然后再释放它。参数events表示event的需要关注绑定该fd上的哪些事件。 EV_TIMEOUT：超时 EV_READ：有数据可读 EV_WRITE：数据可写 EV_SIGNAL：系统发出的信号（signal） EV_PERSIST：持续事件 EV_ET：边沿触发 cb是event被触发后调用的回调函数，cb的类型为event_callback_fn。arg为用户数据在调用回调函数时传给回调函数。 EV_PERSIST 事件持久化默认情况下，每当未决事件成为激活的(因为fd已经准备好读取或者写入,或者因为超时),事件将在其回调被执行前成为非未决的。如果想让事件再次成为未决的,可以在回调函数中再次对其调用event_add()。如果设置了EV_PERSIST标志,事件就是持久的。这意味着即使其回调被激活,事件还是会保持为未决状态。如果想在回调中让事件成为非未决的,可以对其调用event_del()。每次执行事件回调的时候,持久事件的超时值会被复位。 超时事件的创建纯超时事件不需要fd（传-1即可）。libevent定义了创建超时事件的宏：1234567#define evtimer_assign(ev, b, cb, arg) \\ event_assign((ev), (b), -1, 0, (cb), (arg))#define evtimer_new(b, cb, arg) event_new((b), -1, 0, (cb), (arg))#define evtimer_add(ev, tv) event_add((ev), (tv))#define evtimer_del(ev) event_del(ev)#define evtimer_pending(ev, tv) event_pending((ev), EV_TIMEOUT, (tv))#define evtimer_initialized(ev) event_initialized(ev) 信号事件的创建信号事件不需要传入fd，而是传入signum。libevent定义了创建信号事件的宏：12345678#define evsignal_add(ev, tv) event_add((ev), (tv))#define evsignal_assign(ev, b, x, cb, arg) \\ event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))#define evsignal_new(b, x, cb, arg) \\ event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))#define evsignal_del(ev) event_del(ev)#define evsignal_pending(ev, tv) event_pending((ev), EV_SIGNAL, (tv))#define evsignal_initialized(ev) event_initialized(ev) 事件的初始化1int event_assign(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *); 可以使用event_new在创建event时初始化event，也可以使用event_assign初始化未初始化的event，event_assign的参数与event_new的参数意义相同。不要对已经在event_base中未决的事件调用event_assign(),这可能会导致难以诊断的错误。如果已经初始化和成为未决的,调用event_assign()之前需要调用event_del()。libevent提供了方便的宏将event_assign()用于仅超时事件或者信号事件。 event添加监听与取消监听1234567int event_add(struct event *ev, const struct timeval *tv);#define evtimer_add(ev, tv) event_add((ev), (tv))#define evsignal_add(ev, tv) event_add((ev), (tv))int event_del(struct event *ev);#define evtimer_del(ev) event_del(ev)#define evsignal_del(ev) event_del(ev) event_add 添加事件监听, tv为指定的超时值，如果为NULL表示不超时。event_del 取消事件监听。 event设置优先级12int event_priority_init(int npriorities);int event_priority_set(struct event *ev, int pri); event_priority_init()初始化优先级等级。即设置event_base的优先级数目event_priority_set()设置ev的优先级。pri是[0, npriorities)的一个值。 event状态检测12345678int event_pending(const struct event *ev, short event, struct timeval *tv);evutil_socket_t event_get_fd(const struct event *ev);struct event_base *event_get_base(const struct event *ev);short event_get_events(const struct event *ev);event_callback_fn event_get_callback(const struct event *ev);void *event_get_callback_arg(const struct event *ev);int event_get_priority(const struct event *ev);void event_get_assignment(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out); event_pendingevent_pending函数确定给出的event是未决的还是活动的.如果EV_READ、EV_WRITE、EV_SIGNAL、EV_TIMEOUT被设置为event参数,函数会返回event是未决的或者活动的所有标志.如果提供了tv_out并且设置了EV_TIMEOUT标志给event参数,当前event是未决的或者活跃在超时上,tv_out设置为保存event超时后的时间。 event_get_fd函数返回了event配置的文件描述符或者信号值。 event_get_base返回event配置的event_base。 event_get_events返回事件的标志(EV_READ、EV_WRITE等) event_get_callback 和 event_get_callback_argevent_get_callback()和event_get_callback_arg()函数返回了event的回掉函数和它的参数指针 event_get_priority返回了事件当前分配的优先级 event_get_assignment拷贝了event分配的所有字段到提供的指针。如果指针为空,则忽略。 手动激活事件1void event_active(struct event *ev, int res, short ncalls); 使ev以标志res(EV_READ、EV_WRITE、EV_TIMEOUT的组合)激活,ev不需要预先的被未决,激活event也不需要使其未决。 evbufferevbuffer 用于处理缓冲网络 IO 的”缓冲”部分. 创建和释放evbuffer12struct evbuffer * evbuffer_new(void);void evbuffer_free(struct evbuffer *buffer); evbuffer_new() 分配和返回一个新的空evbuffer;而evbuffer_free()释放evbuffer和其内容 evbuffer与线程安全123int evbuffer_enable_locking(struct evbuffer *buf, void *lock);void evbuffer_lock(struct evbuffer *buf);void evbuffer_unlock(struct evbuffer *buf); 默认情况下，在多个线程中同时访问 evbuffer 是不安全的。如果需要这样的访问，可以调用 evbuffer_enable_locking() 。 如果lock参数为NULL,libevent会使用evthread_set_lock_creation_callback 提供的锁创建函数创建一个锁.否则,libevent将lock参数用作锁。evbuffer_lock()和 evbuffer_unlock()函数分别请求和释放 evbuffer 上的锁。可以使用这两个函数让一系列操作是原子的。如果 evbuffer 没有启用锁，这两个函数不做任何操作。注意：对于单个操作，不需要调用evbuffer_lock()和evbuffer_unlock()：如果evbuffer启用了锁，单个操作就已经是原子的。只有在需要多个操作连续执行，不让其他线程介入的时候，才需要手动锁定evbuffer 检查evbuffer1size_t evbuffer_get_length(const struct evbuffer *buffer); 返回evbuffer存储的字节数 1size_t evbuffer_get_contiguous_space(const struct evbuffer *buf); 返回连续地存储在 evbuffer 前面的字节数。evbuffer 中的数据可能存储在多个分隔开的内存块中，这个函数返回当前第一个块中的字节数 向evbuffer添加数据1234int evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen);int evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...);int evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap);int evbuffer_expand(struct evbuffer *buf, size_t datlen); evbuffer_add()添加data处的datlen字节到buf的末尾.evbuffer_add_printf()和evbuffer_add_vprintf()添加格式化的数据到buf末尾.evbuffer_expand()修改缓冲区最后一块,或者添加一个新的块,使缓冲区足以容纳datlen字节,而不需要更多的内存分配 将数据从一个evbuffer移动到另一个12int evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf);int evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst, size_t datlen); evbuffer_add_buffer()将inbuf的所有数据移动到outbuf末尾.evbuffer_remove_buffer()从src中移动datlen字节到dst末尾,尽量少进行复制.如果字节数小于datlen,所有字节被移动. 添加数据到evbuffer前面12int evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen);int evbuffer_prepend_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf); 将数据移动到目标缓冲区前面 从evbuffer中移除数据12int evbuffer_drain(struct evbuffer *buf, size_t len);int evbuffer_remove(struct evbuffer *buf, void *data_out, size_t datlen); evbuffer_drain()函数从buf前面移除len字节内存evbuffer_remove()函数从buf前面复制和移除datlen字节到data_out处的内存中.如果可用字节少于datlen,复制所有字节. 从evbuffer中复制出数据1ev_ssize_t evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen); 前面复制 datlen 字节到 data_out 处的内存中。如果可用字节少于 datlen，函数会复制所有字节。失败时返回-1，否则返回复制的字节数。 面向行的输入123456789enum evbuffer_eol_style &#123; EVBUFFER_EOL_ANY, EVBUFFER_EOL_CRLF, EVBUFFER_EOL_CRLF_STRICT, EVBUFFER_EOL_LF, EVBUFFER_EOL_NUL&#125;;char * evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out, enum evbuffer_eol_style eol_style); evbuffer_readln()函数从 evbuffer 前面取出一行，用一个新分配的空字符结束的字符串返回这一行。如果 n_read_out 不是 NULL，则它被设置为返回的字符串的字节数。如果没有整行供读取，函数返回空。返回的字符串不包括行结束符。evbuffer_readln()理解4种行结束格式 EVBUFFER_EOL_ANY,行尾是单个换行符 EVBUFFER_EOL_CRLF,行尾是一个回车符，后随一个换行符 EVBUFFER_EOL_CRLF_STRICT,行尾是一个可选的回车，后随一个换行符 EVBUFFER_EOL_LF,行尾是任意数量、任意次序的回车和换行符。 在evbuffer中搜索12345678910struct evbuffer_ptr &#123; ev_ssize_t pos; struct &#123; void *chain; size_t pos_in_chain; &#125; internal_;&#125;;struct evbuffer_ptr evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start);struct evbuffer_ptr evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end);struct evbuffer_ptr evbuffer_search_eol(struct evbuffer *buffer, struct evbuffer_ptr *start, size_t *eol_len_out, enum evbuffer_eol_style eol_style); evbuffer_search()函数在缓冲区中查找含有 len 个字符的字符串 what。函数返回包含字符串位置，或者在没有找到字符串时包含-1的 evbuffer_ptr 结构体。如果提供了 start 参数，则从指定的位置开始搜索；否则，从开始处进行搜索。evbuffer_search_range()函数和 evbuffer_search 行为相同，只是它只考虑在 end 之前出现 的 what。evbuffer_search_eol()函数像 evbuffer_readln()一样检测行结束，但是不复制行，而是返回指向行结束符的 evbuffer_ptr。如果 eol_len_out 非空，则它被设置为 EOL 字符串长度。 12345enum evbuffer_ptr_how &#123; EVBUFFER_PTR_SET, EVBUFFER_PTR_ADD&#125;;int evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos, size_t position, enum evbuffer_ptr_how how); evbuffer_ptr_set 函数操作 buffer 中的位置 pos。如果 how 等于 EVBUFFER_PTR_SET,指针被移动到缓冲区中的绝对位置 position；如果等于 EVBUFFER_PTR_ADD，则向前移动 position 字节。成功时函数返回0，失败时返回-1。任何修改 evbuffer 或者其布局的调用都会使得 evbuffer_ptr 失效，不能再安全地使用。 检测数据而不复制12345struct evbuffer_iovec &#123; void *iov_base; size_t iov_len;&#125;;int evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec, int n_vec); 调用 evbuffer_peek()的时候，通过 vec_out 给定一个 evbuffer_iovec 数组，数组的长度是n_vec。函数会让每个结构体包含指向 evbuffer 内部内存块的指针（iov_base)和块中数据长度。如果 len 小于0，evbuffer_peek()会试图填充所有 evbuffer_iovec 结构体。否则，函数会进行填充，直到使用了所有结构体，或者见到 len 字节为止。如果函数可以给出所有请求的数据，则返回实际使用的结构体个数；否则，函数返回给出所有请求数据所需的结构体个数。如果 ptr 为 NULL，函数从缓冲区开始处进行搜索。否则，从 ptr 处开始搜索。 修改 evbuffer_iovec 所指的数据会导致不确定的行为 如果任何函数修改了 evbuffer，则 evbuffer_peek()返回的指针会失效 如果在多个线程中使用evbuffer，确保在调用evbuffer_peek()之前使用evbuffer_lock()，在使用完evbuffer_peek()给出的内容之后进行解锁. 直接向evbuffer添加数据12int evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size, struct evbuffer_iovec *vec, int n_vecs);int evbuffer_commit_space(struct evbuffer *buf, struct evbuffer_iovec *vec, int n_vecs); evbuffer_reserve_space()函数给出 evbuffer 内部空间的指针。函数会扩展缓冲区以至少提供 size 字节的空间。到扩展空间的指针，以及其长度，会存储在通过 vec 传递的向量数组中，n_vec 是数组的长度。n_vec 的值必须至少是1。如果只提供一个向量，libevent 会确保请求的所有连续空间都在单个扩展区中，但是这可能要求重新排列缓冲区，或者浪费内存。为取得更好的性能，应该至少提供2个向量。函数返回提供请求的空间所需的向量数。写入到向量中的数据不会是缓冲区的一部分，直到调用 evbuffer_commit_space()，使得写入的数据进入缓冲区。如果需要提交少于请求的空间，可以减小任何 evbuffer_iovec 结构体的 iov_len 字段，也可以提供较少的向量。函数成功时返回0，失败时返回-1。 调用任何重新排列evbuffer或者向其添加数据的函数都将使从 evbuffer_reserve_space()获取的指针失效。 当前实现中，不论用户提供多少个向量，evbuffer_reserve_space()从不使用多于两个。未来版本可能会改变这一点。 如果在多个线程中使用evbuffer，确保在调用evbuffer_reserve_space()之前使用 evbuffer_lock()进行锁定，然后在提交后解除锁定 使用evbuffer的网络IO123int evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd);int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch);int evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch); vbuffer_read()函数从套接字 fd 读取至多 howmuch 字节到 buffer 末尾。成功时函数返回读取的字节数，0表示 EOF，失败时返回-1。注意，错误码可能指示非阻塞操作不能立即成功，应该检查错误码 EAGAIN（或者 Windows 中的 WSAWOULDBLOCK）。如果 howmuch 为负，evbuffer_read()试图猜测要读取多少数据。evbuffer_write_atmost()函数试图将 buffer 前面至多 howmuch 字节写入到套接字 fd 中。成功时函数返回写入的字节数，失败时返回-1。跟 evbuffer_read()一样，应该检查错误码，看是真的错误，还是仅仅指示非阻塞 IO 不能立即完成。如果为 howmuch 给出负值，函数会试图写入 buffer 的所有内容。调用 evbuffer_write()与使用负的 howmuch 参数调用 evbuffer_write_atmost()一样：函数会试图尽量清空 buffer 的内容。在 Unix 中，这些函数应该可以在任何支持 read 和 write 的文件描述符上正确工作。在 Windows 中，仅仅支持套接字. evbuffer和回调12345678910111213141516struct evbuffer_cb_info &#123; size_t orig_size; size_t n_added; size_t n_deleted;&#125;;typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);struct evbuffer_cb_entry &#123; LIST_ENTRY(evbuffer_cb_entry) next; union &#123; evbuffer_cb_func cb_func; evbuffer_cb cb_obsolete; &#125; cb; void *cbarg; ev_uint32_t flags;&#125;;struct evbuffer_cb_entry * evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg); 向 evbuffer 添加数据，或者从中移除数据的时候，回调函数会被调用。函数收到缓冲区指针、一个 evbuffer_cb_info 结构体指针，和用户提供的参数。evbuffer_cb_info 结构体的 orig_size 字段指示缓冲区改变大小前的字节数，n_added 字段指示向缓冲区添加了多少字节；n_deleted 字段指示移除了多少字节。 evbuffer_add_cb()函数为 evbuffer 添加一个回调函数，返回一个不透明的指针，随后可用于代表这个特定的回调实例。cb 参数是将被调用的函数，cbarg 是用户提供的将传给这个函数的指针。可以为单个 evbuffer 设置多个回调，添加新的回调不会移除原来的回调注意：释放非空 evbuffer 不会清空其数据，释放 evbuffer 也不会为回调释放用户提供的数据指针。如果不想让缓冲区上的回调永远激活，可以移除或者禁用回调： 12345int evbuffer_remove_cb_entry(struct evbuffer *buffer, struct evbuffer_cb_entry *ent);int evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);#define EVBUFFER_CB_ENABLED 1int evbuffer_cb_set_flags(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags);int evbuffer_cb_clear_flags(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags); 可以通过添加回调时候的 evbuffer_cb_entry 来移除回调，也可以通过回调函数和参数指针来移除。成功时函数返回0，失败时返回-1。evbuffer_cb_set_flags()和 evbuffer_cb_clear_flags()函数分别为回调函数设置或者清除给定的标志。当前只有一个标志是用户可见的：EVBUFFER_CB_ENABLED。这个标志默认是打开的。如果清除这个标志，对 evbuffer 的修改不会调用回调函数. 1int evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base); 跟 bufferevent 回调一样，可以让 evbuffer 回调不在 evbuffer 被修改时立即运行，而是延迟到某 event_base 的事件循环中执行。如果有多个 evbuffer，它们的回调潜在地让数据添加到 evbuffer 中，或者从中移除，又要避免栈崩溃，延迟回调是很有用的。如果回调被延迟，则最终执行时，它可能是多个操作结果的总和。与 bufferevent 一样，evbuffer 具有内部引用计数的，所以即使还有未执行的延迟回调，释放 evbuffer 也是安全的。 为基于evbuffer的IO避免数据复制12typedef void (*evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra);int evbuffer_add_reference(struct evbuffer *outbuf, const void *data, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn, void *extra); 通过引用向 evbuffer 末尾添加一段数据。不会进行复制：evbuffer 只会存储一个到data 处的 datlen 字节的指针。因此，在 evbuffer 使用这个指针期间，必须保持指针是有效的。evbuffer 会在不再需要这部分数据的时候调用用户提供的 cleanupfn 函数，带有提供的data 指针、datlen 值和 extra 指针参数。函数成功时返回0，失败时返回-1 接受TCP连接evconnlistener机制提供了监听和接受TCP连接的方法. 创建和释放evconnlistener123struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd);struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen);void evconnlistener_free(struct evconnlistener *lev); 两个 evconnlistener_new*()函数都分配和返回一个新的连接监听器对象。连接监听器使用 event_base 来得知什么时候在给定的监听套接字上有新的 TCP 连接。新连接到达时，监听器调用你给出的回调函数。两个函数中，base 参数都是监听器用于监听连接的 event_base。cb 是收到新连接时要调用的回调函数；如果 cb 为 NULL，则监听器是禁用的，直到设置了回调函数为止。ptr 指针将传递给回调函数。flags 参数控制回调函数的行为，下面会更详细论述。backlog 是任何时刻网络栈允许处于还未接受状态的最大未决连接数。更多细节请查看系统的 listen()函数文档。如果 backlog 是负的，libevent 会试图挑选一个较好的值；如果为0，libevent 认为已经对提供的套接字调用了 listen()。两个函数的不同在于如何建立监听套接字。evconnlistener_new()函数假定已经将套接字绑定到要监听的端口，然后通过 fd 传入这个套接字。如果要 libevent 分配和绑定套接字，可以调用 evconnlistener_new_bind()，传输要绑定到的地址和地址长度。要释放连接监听器，调用 evconnlistener_free() 可标识的标志12345678910111213//默认情况下，连接监听器接收新套接字后，会将其设置为非阻塞的，以便将其用于 libevent。如果不想要这种行为，可以设置这个标志。#define LEV_OPT_LEAVE_SOCKETS_BLOCKING (1u&lt;&lt;0)//如果设置了这个选项，释放连接监听器会关闭底层套接字。#define LEV_OPT_CLOSE_ON_FREE (1u&lt;&lt;1)//如果设置了这个选项，连接监听器会为底层套接字设置 close-on-exec 标志。#define LEV_OPT_CLOSE_ON_EXEC (1u&lt;&lt;2)//某些平台在默认情况下，关闭某监听套接字后，要过一会儿其他套接字才可以绑定到同一个端口。设置这个标志会让 libevent 标记套接字是可重用的，这样一旦关闭，可以立即打开其他套接字，在相同端口进行监听。#define LEV_OPT_REUSEABLE (1u&lt;&lt;3)//为监听器分配锁，这样就可以在多个线程中安全地使用了#define LEV_OPT_THREADSAFE (1u&lt;&lt;4)#define LEV_OPT_DISABLED (1u&lt;&lt;5)#define LEV_OPT_DEFERRED_ACCEPT (1u&lt;&lt;6)#define LEV_OPT_REUSEABLE_PORT (1u&lt;&lt;7) 连接监听器回调1typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *); stener参数是接收连接的连接监听器。sock参数是新接收的套接字。addr和len参数是接收连接的地址和地址长度。ptr是调用evconnlistener_new()时用户提供的指针。 禁用和启用evconnlistener12int evconnlistener_disable(struct evconnlistener *lev);int evconnlistener_enable(struct evconnlistener *lev); 暂时禁止或者重新允许监听新连接 设置evconnlistener的回调函数1void evconnlistener_set_cb(struct evconnlistener *lev, evconnlistener_cb cb, void *arg); 函数调整 evconnlistener 的回调函数和其参数。 检测evconnlistener12evutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev);struct event_base *evconnlistener_get_base(struct evconnlistener *lev); 分别返回监听器关联的套接字和 event_base 侦测错误12typedef void (*evconnlistener_errorcb)(struct evconnlistener *, void *);void evconnlistener_set_error_cb(struct evconnlistener *lev, evconnlistener_errorcb errorcb); 如果使用 evconnlistener_set_error_cb()为监听器设置了错误回调函数，则监听器发生错误时回调函数就会被调用。第一个参数是监听器，第二个参数是调用 evconnlistener_new() 时传入的 ptr。 buffereventbufferevent 和 evbuffer每个bufferevent都有一个输出缓冲区和一个输入缓冲区,类型都是”struct evbuffer”,有数据要写入到bufferevent时,添加数据到输出缓冲区;bufferevent中有数据供读取的时候,从输入缓冲区抽取数据. 回调和水位每个bufferevent有两个数据相关的回调:读取回调和写入回调.默认情况下,从底层传输端口读取任意量的数据后会调用读取回调;输出去有足够的数据被清空到底层传输端口后写入回调会被调用. 每个bufferevent有四个水位: 读取低水位:读取操作使得输入缓冲区的数据量在此级别或者更高时，读取回调将被调用。默认值为0，所以每个读取操作都会导致读取回调被调用。 读取高水位:输入缓冲区中的数据量达到此级别后，bufferevent 将停止读取，直到输入缓冲区中足够量的数据被抽取，使得数据量低于此级别。默认值是无限，所以永远不会因为输入缓冲区的大小而停止读取。 写入低水位:写入操作使得输出缓冲区的数据量达到或者低于此级别时，写入回调将被调用。默认值是0，所以只有输出缓冲区空的时候才会调用写入回调。 写入高水位:bufferevent 没有直接使用这个水位。它在 bufferevent 用作另外一个bufferevent 的底层传输端口时有特殊意义。 错误或事件回调(向应用通知非面向数据的事件) BEV_EVENT_READING:读取操作时发生某事件 BEV_EVENT_WRITING:写入操作时发生某事件 BEV_EVENT_EOF:遇到文件结束指示 BEV_EVENT_ERROR:操作时发生错误,调用EVUTIL_SOCKET_ERROR()获取更错错误信息 BEV_EVENT_TIMEOUT:发生超时 BEV_EVENT_CONNECTED:请求的连接过程已经完成 延迟回调默认情况下,bufferevent的回调在相应的条件发生时立即被执行.在依赖关系复杂的情况下,立即调用会产生问题.要解决该问题,可以请求bufferevent延迟其回调.条件满足时,延迟回调不会立即被调用,而是在event_loop()调用中被排队.然后在通常的事件回调后执行. buffervent的选项标记bufferevent_options BEV_OPT_CLOSE_ON_FREE:释放bufferevent时关闭底层传输端口.将关闭底层套接字,释放底层bufferevent等. BEV_OPT_THREADSAFE:自动为bufferevent分配锁,可以安全的在多个线程中使用bufferevent BEV_OPT_DEFER_CALLBACKS:设置该标记,bufferevent延迟所有回调 BEV_OPT_UNLOCK_CALLBACKS:默认情况下,如果设置bufferevent为线程安全的,则bufferevent会在调用用户提供的回调时进行锁定.设置该选项让Libevent在执行回调时不锁定. 基于套接字的bufferevent创建基于套接字的bufferevent123struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options); base时event_base反应堆 fd是套接字的文件描述符 options是bufferevent选项 在基于套接字的bufferevent上启动连接1int bufferevent_socket_connect(struct bufferevent *bev, const struct sockaddr *sa, int socklen); 如果还没有为 bufferevent 设置套接字，调用函数将为其分配一个新的流套接字，并且设置为非阻塞的。如果已经为 bufferevent 设置套接字，调用 bufferevent_socket_connect()将告知 libevent 套接字还未连接，直到连接成功之前不应该对其进行读取或者写入操作。连接完成之前可以向输出缓冲区添加数据。如果连接成功启动，函数返回0；如果发生错误则返回-1。注意:如果使用bufferevent_socket_connect() 发起连接,将只会收到 BEV_EVENT_CONNECTED 事件。如果自己调用 connect()，则连接上将被报告为写入事件 通过主机名启动连接12int bufferevent_socket_connect_hostname(struct bufferevent *bev, struct evdns_base *evdns_base, int family, const char *hostname, int port);int bufferevent_socket_get_dns_error(struct bufferevent *bev); bufferevent_socket_connect_hostnam解析hostname,通过其family类型地址(允许的地址族类型有AF_INET,IF_INET6和AF_UNSPEC).如果名字解析失败,函数将调用事件回调,报告错误事件.如果解析成功,函数将启动连接请求.dns_base参数可选:如果为NULL,等待名字查找完成期间调用线程将被阻塞.如果提供dns_base参数,libevent将使用它异步查询主机名.函数返回的错误可能是DNS主机名查询错误，可以调用bufferevent_socket_get_dns_error() 来获取最近的错误。返回值0表示没有检测到 DNS 错误。 操作回调、水位和启用/禁用12345typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg); bufferevent_setcb()函数修改bufferevent的一个或多个回调.readcb、writecb、eventcb函数分别在读取到足够的数据、写入足够的数据、发生错误时被调用.每个回调的第一个参数都是发生了事件的bufferevent,最后一个参数都是调用bufferevent_setcb()时用户提供的cbarg参数(通过cbarg参数向回调函数传递参数).事件回调的events参数是一个表示事件标志的位掩码.要禁用回调,传递NULL而不是回调函数.注意:bufferevent的所有回调函数共享单个cbarg,修改它需要特别小心 123int bufferevent_enable(struct bufferevent *bufev, short event);int bufferevent_disable(struct bufferevent *bufev, short event);short bufferevent_get_enabled(struct bufferevent *bufev); bufferevent_enable()函数开启bufferevent的EV_READ、EV_WRITE事件bufferevent_disable()函数禁用bufferevent的EV_READ、EV_WRITE事件没有启用读取或写入事件时,bufferevent将不会试图进行数据的读取和写入 没有必要在输出缓冲区空时禁用写入事件：bufferevent 将自动停止写入，然后在有数据等待写入时重新开始没有必要在输入缓冲区高于高水位时禁用读取事件：bufferevent 将自动停止读取，然后在有空间用于读取时重新开始读取默认情况下，新创建的 bufferevent 的写入是启用的，但是读取没有启用bufferevent_get_enabled()可以确定bufferevent上当前开启的事件. 1void bufferevent_setwatermark(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark); bufferevent_setwatermark()函数设置单个bufferevent的读取水位、写入水位.如果events设置为EV_READ调整读取水位,events设置为EV_WARITE调整写入水位.对于高水位,0表示”无限” bufferevent中数据的操作12struct evbuffer * bufferevent_get_input(struct bufferevent *bufev);struct evbuffer * bufferevent_get_output(struct bufferevent *bufev); bufferevent_get_input()返回输入缓冲区bufferevent_get_output()返回输出缓冲区 12int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf); bufferevent_write()将内从从data处开始的size字节数据添加到输出缓冲区末尾.bufferevent_write_buffer()移除buf的所有内容,将其放置到输出缓冲区末尾. 12size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf); bufferevent_read()至多从输入缓冲区移除size字节的数据,将其存储到内存中data处,返回实际移除的字节数bufferevent_read_buffer()抽空输入缓冲区的所有内容,将其放置到buf中,成功返回0,失败返回-1 读写超时123int bufferevent_set_timeouts(struct bufferevent *bufev, const struct timeval *tv_read, const struct timeval *tv_write); bufferevent_set_timeouts()设置超时时间为NULL会移除超时回调试图读取数据的时候，如果至少等待了 timeout_read 秒，则读取超时事件将被触发。试图写入数据的时候，如果至少等待了 timeout_write 秒，则写入超时事件将被触发。注意，只有在读取或者写入的时候才会计算超时。即如果 bufferevent 的读取被禁止，或者输入缓冲区满（达到其高水位），则读取超时被禁止。如果写入被禁止，或者没有数据待写入，则写入超时被禁止。读取或者写入超时发生时，相应的读取或者写入操作被禁止，然后超时事件回调被调用，带有标志BEV_EVENT_TIMEOUT | BEV_EVENT_READING或者BEV_EVENT_TIMEOUT | BEV_EVENT_WRITING。 清空bufferevent123int bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode); 清空 bufferevent 要求 bufferevent 强制从底层传输端口读取或者写入尽可能多的数据，而忽略其他可能保持数据不被写入的限制条件。函数的细节功能依赖于 bufferevent 的具体类型。iotype 参数应该是 EV_READ、EV_WRITE 或者 EV_READ | EV_WRITE，用于指示应该处理读取、写入，还是二者都处理。state 参数可以是 BEV_NORMAL、BEV_FLUSH 或者BEV_FINISHED。BEV_FINISHED 指示应该告知另一端，没有更多数据需要发送了； 而 BEV_NORMAL 和 BEV_FLUSH 的区别依赖于具体的 bufferevent 类型。失败时 bufferevent_flush()返回-1，如果没有数据被清空则返回0，有数据被清空则返回1 类型特定的bufferevent函数1int bufferevent_priority_set(struct bufferevent *bufev, int priority); 调整bufev的优先级为priority.成功返回0,失败返回-1,该函数仅作用域基于套接字的bufferevent 12int bufferevent_setfd(struct bufferevent *bev, evutil_socket_t fd);evutil_socket_t bufferevent_getfd(struct bufferevent *bev); 设置或返回基于fd的事件的文件描述符.只有基于套接字的bufferevent支持bufferevent_setfd. 1struct event_base * bufferevent_get_base(struct bufferevent *bufev); 返回bufferevent的event_base 1struct bufferevent * bufferevent_get_underlying(struct bufferevent *bev); 返回作为 bufferevent 底层传输端口的另一个 bufferevent。 手动锁定和解锁12void bufferevent_lock(struct bufferevent *bev);void bufferevent_unlock(struct bufferevent *bev); 注意:如果创建 bufferevent 时没有指定 BEV_OPT_THREADSAFE 标志,或者没有激活 libevent 的线程支持，则锁定操作是没有效果的.用这个函数锁定 bufferevent 将自动同时锁定相关联的 evbuffer.这些函数是递归的:锁定已经持有锁的 bufferevent 是安全的.当然,对于每次锁定都必须进行一次解锁. http服务相关http Server的创建与开始首先需要使用event_base_new或event_base_new_with_config创建一个event_base，然后使用evhttp_new创建evhttp。1struct evhttp *evhttp_new(struct event_base *base); 在需要释放evhttp时需要调用evhttp_free来释放。1void evhttp_free(struct evhttp* http); 再为evhttp设置回调函数，evhttp_set_cb为特定URL指定回调函数，evhttp_set_gencb注册通用回调函数，在没有指定URL回调函数的情况下该回调函数被调用。12345678910//uri 特定的uri//cb 回调函数//cbarg 传入回调函数的参数int evhttp_set_cb(struct evhttp *http, const char *uri, \\ void (*cb)(struct evhttp_request *, void *), void *cbarg);//cb 回调函数//cbarg 传入回调函数的参数void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *cbarg); 再为evhttp绑定需要监听的ip和port。使用evhttp_bind_socket_with_handle函数。1struct evhttp_bound_socket *evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port); 可以使用libevent提供的相关函数打印监听端口信息。最后使用event_base_dispatch进入事件循环。 http请求的处理evhttp_request_get_uri得到当前请求的uri地址。1const char *evhttp_request_get_uri(const struct evhttp_request *req); evhttp_request_get_command得到当前请求的类型。123456789101112enum evhttp_cmd_type &#123; EVHTTP_REQ_GET = 1 &lt;&lt; 0, EVHTTP_REQ_POST = 1 &lt;&lt; 1, EVHTTP_REQ_HEAD = 1 &lt;&lt; 2, EVHTTP_REQ_PUT = 1 &lt;&lt; 3, EVHTTP_REQ_DELETE = 1 &lt;&lt; 4, EVHTTP_REQ_OPTIONS = 1 &lt;&lt; 5, EVHTTP_REQ_TRACE = 1 &lt;&lt; 6, EVHTTP_REQ_CONNECT = 1 &lt;&lt; 7, EVHTTP_REQ_PATCH = 1 &lt;&lt; 8&#125;;enum evhttp_cmd_type evhttp_request_get_command(const struct evhttp_request *req); evhttp_uri_parse URI解析，得到evhttp_uri。1struct evhttp_uri *evhttp_uri_parse(const char *source_uri); evhttp_parse_query对uri参数进行解析，结果保存在struct evkeyvalq结构体中。1void evhttp_parse_query(const char *uri, struct evkeyvalq *args); evhttpdecode_uri URL解码，得到UTF编码的字符，得到数据所占内存需要自己释放。evhttp_encode_uri URL编码，对所有非alphanumeric及-\\的字符都被类似于%和一个2位16进制字符替换(其中空格被+号替换)。12char *evhttp_encode_uri(const char *str);char *evhttp_decode_uri(const char *uri); 参考文献 libevent专栏 Libevent中文帮助手册 Libevent 官方文档学习笔记","categories":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"网络","slug":"网络","permalink":"http://www.casezheng.date/tags/网络/"},{"name":"libevent","slug":"libevent","permalink":"http://www.casezheng.date/tags/libevent/"}],"keywords":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}]},{"title":"Libevent源码阅读——概述、实践","slug":"libevent-1","date":"2017-10-02T03:32:00.000Z","updated":"2020-04-12T04:56:36.126Z","comments":true,"path":"2017/10/02/libevent-1/","link":"","permalink":"http://www.casezheng.date/2017/10/02/libevent-1/","excerpt":"","text":"重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable Reactor模式简介Reactor模式要求主线程(I/O处理单元)只监听文件描述符上是否有事件发生,有的话立即将事件通知工作线程(逻辑单元),除此之外,主线程不进行任何其它实质性的工作,读写数据、接收新的连接、处理客户请求均在工作线程中进行.使用同步I/O模型(以epoll_wait为例)实现的Reactor模式的工作流程: 主线程往epoll内核事件表中注册socket上的读就绪事件 主线程调用epoll_wait等待socket上的读就绪事件 当socket上有数据可读时,epoll_wait通知主线程.主线程将socket可读事件放入请求队列 睡眠在请求队列上的的某个工作线程被唤醒,从socket读取数据,并处理客户端请求,然后往epoll内核事件表注册该socket上的写就绪事件 主线程调用epoll_wait等待socket可写 当socket可写时,epoll_wait通知主线程.主线程将socket可写事件放入请求队列 睡眠在请求队列上的某个工作线程被唤醒,往socket上写入服务器处理客户端的结果 更多Reactor介绍请点击 Libevent简介Libevent是一个使用C语言编写的、轻量级的开源高性能事件通知库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue、IOCP等系统调用管理事件机制。 Libevent特点 事件驱动、高性能 轻量级、专注于网络 开源，代码精炼、易读 跨平台，支持Windows、Linux、BSD和Mac OS 支持多路I/O复用技术（epoll、poll、dev/poll、select和kqueue等），在不同操作系统下，做了多路复用模型的抽象，可以使用不同的模型，通过事件函数提供服务 支持I/O、定时器和信号等事件 采用Reactor模式 支持多线程 Libevent源码获取1git clone https://github.com/libevent/libevent.git 编译、安装详情请参考官方文档,大致过程如下12345./autogen.sh./configuremakemake verify # (optional)sudo make install 执行autogen.sh报错possibly undefined macro: AC_PROG_LIBTOOL安装libtool即可1sudo yum install libtool Libevent功能 事件通知：当文件描述符可读可写时将执行回调函数 IO缓存：缓存事件提供了输入输出缓存，能自动的读入和写入，用户不必直接操作IO 定时器：libevent提供定时器机制，能在一定事件间隔后调用回调函数 信号：触发信号，执行回调 异步DNS解析：libevent提供异步解析DNS服务器的DNS解析函数集 事件驱动的http服务器：libevent提供简单的、可集成到引用程序中的HTTP服务器 RPC客户端服务器框架：libevent为创建RPC服务器和客户端创建了一个RPC框架，能自动封装和解封数据结构 Libevent组件 evutil：用来抽象不同平台网络实现差异的通用功能。 event和event_base：libevent的核心，为各种平台特定的、基于事件的非阻塞IO后端提供抽象API，让程序可以知道套接字何时准备好，可以读或者写，并且处理基本的超时事件，检测OS信号。 bufferevent：为libevent基于事件的核心提供使用更方便的封装。除了通知程序套接字已经准备好读写之外，还让程序可以请求缓冲的读写操作，可以知道何时IO已经真正发生。（bufferevent接口有多个后端，可以采用系统能够提供的更快的非阻塞IO方式，如Windows中的IOCP。） evbuffer：在bufferevent层之下实现缓冲功能，并且提供方便有效的访问函数。 evhttp：一个简单的HTTP客户端/服务器实现。 evdns：一个简单DNS客户端/服务器实现。 evrpc：一个简单RPC实现。 Libevent库安装libevent时，默认安装下列库12345678910111213141516[CaseZheng@localhost Blog]$ ll /usr/local/lib/libevent*-rw-r--r--. 1 root root 470890 9月 30 23:02 /usr/local/lib/libevent.a-rw-r--r--. 1 root root 299550 9月 30 23:02 /usr/local/lib/libevent_core.alrwxrwxrwx. 1 root root 22 9月 30 23:04 /usr/local/lib/libevent_core.so -&gt; libevent_core.so.2.2.0-rwxr-xr-x. 1 root root 217848 9月 30 23:02 /usr/local/lib/libevent_core.so.2.2.0-rw-r--r--. 1 root root 171474 9月 30 23:02 /usr/local/lib/libevent_extra.alrwxrwxrwx. 1 root root 23 9月 30 23:04 /usr/local/lib/libevent_extra.so -&gt; libevent_extra.so.2.2.0-rwxr-xr-x. 1 root root 149576 9月 30 23:02 /usr/local/lib/libevent_extra.so.2.2.0-rw-r--r--. 1 root root 26152 9月 30 23:02 /usr/local/lib/libevent_openssl.alrwxrwxrwx. 1 root root 25 9月 30 23:04 /usr/local/lib/libevent_openssl.so -&gt; libevent_openssl.so.2.2.0-rwxr-xr-x. 1 root root 35240 9月 30 23:02 /usr/local/lib/libevent_openssl.so.2.2.0-rw-r--r--. 1 root root 4968 9月 30 23:02 /usr/local/lib/libevent_pthreads.alrwxrwxrwx. 1 root root 26 9月 30 23:04 /usr/local/lib/libevent_pthreads.so -&gt; libevent_pthreads.so.2.2.0-rwxr-xr-x. 1 root root 13600 9月 30 23:02 /usr/local/lib/libevent_pthreads.so.2.2.0lrwxrwxrwx. 1 root root 17 9月 30 23:04 /usr/local/lib/libevent.so -&gt; libevent.so.2.2.0-rwxr-xr-x. 1 root root 346224 9月 30 23:02 /usr/local/lib/libevent.so.2.2.0 libevent_core：所有核心的事件和缓存功能，包括所有的event_base、evbuffer、bufferevent和工具函数。 libevent_extra：定义程序可能需要，也可能不需要的协议特定功能，包括HTTP、DNS和RPC。 libevent：历史原因而存在，包括libevent_core和libevent_extra。 libevent_pthreads：添加基于pthread可移植线程库的线程和锁定实现，独立于libevent_core。 libevent_openssl：为使用bufferevent和OpenSSL进行加密的通信提供支持, 独立于libevent_core。 Libevent头文件libevent公用头文件安装在event2目录中 12345678910111213141516171819202122232425262728[CaseZheng@localhost /]$ ll /usr/local/include/event2/总用量 408-rw-r--r--. 1 root root 4700 9月 30 22:58 buffer_compat.h-rw-r--r--. 1 root root 4538 9月 30 22:58 bufferevent_compat.h-rw-r--r--. 1 root root 34518 9月 30 22:58 bufferevent.h-rw-r--r--. 1 root root 4848 9月 30 22:58 bufferevent_ssl.h-rw-r--r--. 1 root root 4135 9月 30 22:58 bufferevent_struct.h-rw-r--r--. 1 root root 39078 9月 30 22:58 buffer.h-rw-r--r--. 1 root root 12588 9月 30 22:58 dns_compat.h-rw-r--r--. 1 root root 26873 9月 30 22:58 dns.h-rw-r--r--. 1 root root 2596 9月 30 22:58 dns_struct.h-rw-r--r--. 1 root root 7639 9月 30 22:58 event_compat.h-rw-r--r--. 1 root root 15740 9月 30 23:02 event-config.h-rw-r--r--. 1 root root 62445 9月 30 22:58 event.h-rw-r--r--. 1 root root 5024 9月 30 22:58 event_struct.h-rw-r--r--. 1 root root 3265 9月 30 22:58 http_compat.h-rw-r--r--. 1 root root 42821 9月 30 22:58 http.h-rw-r--r--. 1 root root 4809 9月 30 22:58 http_struct.h-rw-r--r--. 1 root root 2603 9月 30 22:58 keyvalq_struct.h-rw-r--r--. 1 root root 7445 9月 30 22:58 listener.h-rw-r--r--. 1 root root 2351 9月 30 22:58 rpc_compat.h-rw-r--r--. 1 root root 21702 9月 30 22:58 rpc.h-rw-r--r--. 1 root root 3235 9月 30 22:58 rpc_struct.h-rw-r--r--. 1 root root 2141 9月 30 22:58 tag_compat.h-rw-r--r--. 1 root root 4914 9月 30 22:58 tag.h-rw-r--r--. 1 root root 9952 9月 30 22:58 thread.h-rw-r--r--. 1 root root 28536 9月 30 22:58 util.h-rw-r--r--. 1 root root 2818 9月 30 22:58 visibility.h API头文件：定义libevent公用接口。 兼容头文件：已废弃的函数提供兼容的头部包含定义。不应该使用这类头文件。 结构头文件：以”_struct”为后缀，定义各种结构体，为了快速访问而暴露，或因为历史原因而暴露。不要直接依赖这类头文件中的任何结构体，会破坏对其他版本libevent的二进制兼容性。 简单的定时器和信号事件示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;sys/signal.h&gt;#include &lt;event2/event.h&gt;#include &lt;event2/util.h&gt;using namespace std;struct timeval lasttime;static void timeout_cb(evutil_socket_t fd, short events, void *arg)&#123; struct timeval newtime, difference; struct event *timeout = (struct event*)arg; double elapsed; evutil_gettimeofday(&amp;newtime, NULL); evutil_timersub(&amp;newtime, &amp;lasttime, &amp;difference); elapsed = difference.tv_sec + (difference.tv_usec / 1.0e6); cout&lt;&lt;\"timeout_cb called at \"&lt;&lt;newtime.tv_sec&lt;&lt;\": \"&lt;&lt;elapsed&lt;&lt;\"second elapsed\"&lt;&lt;endl; lasttime = newtime;&#125;static void signal_cb(evutil_socket_t fd, short events, void *arg)&#123; struct event_base *base = (struct event_base *)arg; struct timeval delay = &#123;1, 0&#125;; cout&lt;&lt;\"1 s after exit\"&lt;&lt;endl; event_base_loopexit(base, &amp;delay);&#125;int main()&#123; struct event_base *base = event_base_new(); if(NULL == base) &#123; cout&lt;&lt;\"event_base_new error\"&lt;&lt;endl; cout&lt;&lt;strerror(errno)&lt;&lt;endl; return 0; &#125; struct event *signalevent = evsignal_new(base, SIGINT, signal_cb, (void*)base); event_add(signalevent, NULL); struct event *timeout_event = evtimer_new(base, timeout_cb, NULL); //flags设置为EV_PERSIST表示该事件一直有效 int flags = EV_PERSIST; //flags设置为0，该事件触发一次就会被删除，需要再次添加 //int flags = 0; event_assign(timeout_event, base, -1, flags, timeout_cb, (void*) timeout_event); struct timeval tv; evutil_timerclear(&amp;tv); tv.tv_sec = 2; event_add(timeout_event, &amp;tv); evutil_gettimeofday(&amp;lasttime, NULL); event_base_dispatch(base); event_free(signalevent); event_free(timeout_event); event_base_free(base); return 0;&#125; 简单的回显服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;event2/event.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/util.h&gt;using namespace std;void accept_cb(int fd, short events, void *arg);void socket_read_cb(int fd, short events, void *arg);int tcp_server_init(int port, int listen_num);int main()&#123; int listener = tcp_server_init(9999, 5); if(listener == -1) &#123; cout&lt;&lt;\"tcp_server_init error\"&lt;&lt;endl; return 0; &#125; struct event_base * base = event_base_new(); if(NULL == base) &#123; cout&lt;&lt;\"event_base_new error\"&lt;&lt;endl; return 0; &#125; struct event * ev_listen = event_new(base, listener, EV_READ|EV_PERSIST, accept_cb, base); if(NULL == ev_listen) &#123; cout&lt;&lt;\"event_new error\"&lt;&lt;endl; return 0; &#125; event_add(ev_listen, NULL); event_base_dispatch(base); event_free(ev_listen); return 0;&#125;void accept_cb(int fd, short evnets, void *arg)&#123; struct sockaddr_in client; socklen_t len = sizeof(client); evutil_socket_t sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len); if(sockfd &lt; 0) &#123; cout&lt;&lt;\"accept error\"&lt;&lt;endl; return; &#125; evutil_make_socket_nonblocking(sockfd); cout&lt;&lt;\"accpet a conn fd: \"&lt;&lt;sockfd&lt;&lt;endl; struct event_base *base = (struct event_base*)arg; struct event *ev = event_new(NULL, -1, 0, NULL, NULL); event_assign(ev, base, sockfd, EV_READ|EV_PERSIST, socket_read_cb, (void*)ev); event_add(ev, NULL);&#125;void socket_read_cb(int fd, short events, void *arg)&#123; char buff[4096] = &#123;0&#125;; struct event *ev = (struct event*)arg; int len = read(fd, buff, sizeof(buff)-1); if(len &lt;= 0) &#123; cout&lt;&lt;\"read error len: \"&lt;&lt;len&lt;&lt;endl; event_free(ev); close(fd); return; &#125; buff[len] = '\\0'; cout&lt;&lt;\"read msg : \"&lt;&lt;buff&lt;&lt;endl; write(fd, buff, strlen(buff));&#125;int tcp_server_init(int port, int listen_num)&#123; evutil_socket_t listener; listener = ::socket(AF_INET, SOCK_STREAM, 0); if(listener &lt; 0) &#123; cout&lt;&lt;\"create socket error\"&lt;&lt;endl; return -1; &#125; evutil_make_listen_socket_reuseable(listener); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(port); if(::bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) &#123; cout&lt;&lt;\"bind error\"&lt;&lt;endl; return -1; &#125; if(::listen(listener, listen_num) &lt; 0) &#123; cout&lt;&lt;\"listen error\"&lt;&lt;endl; return -1; &#125; evutil_make_socket_nonblocking(listener); return listener;&#125; 使用bufferevent的回显服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;event2/event.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/util.h&gt;using namespace std;void accept_cb(int fd, short events, void *arg);void socket_read_cb(struct bufferevent *bev, void *arg);void event_cb(struct bufferevent *bev, short event, void *arg);int tcp_server_init(int port, int listen_num);int main()&#123; int listener = tcp_server_init(9999, 5); if(listener == -1) &#123; cout&lt;&lt;\"tcp_server_init error\"&lt;&lt;endl; return 0; &#125; struct event_base * base = event_base_new(); if(NULL == base) &#123; cout&lt;&lt;\"event_base_new error\"&lt;&lt;endl; return 0; &#125; struct event * ev_listen = event_new(base, listener, EV_READ|EV_PERSIST, accept_cb, base); if(NULL == ev_listen) &#123; cout&lt;&lt;\"event_new error\"&lt;&lt;endl; return 0; &#125; event_add(ev_listen, NULL); event_base_dispatch(base); event_free(ev_listen); event_base_free(base); return 0;&#125;void accept_cb(int fd, short evnets, void *arg)&#123; struct sockaddr_in client; socklen_t len = sizeof(client); evutil_socket_t sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len); if(sockfd &lt; 0) &#123; cout&lt;&lt;\"accept error\"&lt;&lt;endl; return; &#125; evutil_make_socket_nonblocking(sockfd); cout&lt;&lt;\"accpet a conn fd: \"&lt;&lt;sockfd&lt;&lt;endl; struct event_base *base = (struct event_base*)arg; bufferevent *bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE); if(NULL == bev) &#123; cout&lt;&lt;\"bufferevent_socket_new error\"&lt;&lt;endl; close(fd); return; &#125; bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg); bufferevent_enable(bev, EV_READ | EV_PERSIST);&#125;void socket_read_cb(bufferevent *bev, void *arg)&#123; char buff[4096] = &#123;0&#125;; size_t len = bufferevent_read(bev, buff, sizeof(buff)); if(len &lt;= 0) &#123; cout&lt;&lt;\"read error len: \"&lt;&lt;len&lt;&lt;endl; return; &#125; buff[len] = '\\0'; cout&lt;&lt;\"read msg : \"&lt;&lt;buff&lt;&lt;endl; bufferevent_write(bev, buff, strlen(buff));&#125;void event_cb(struct bufferevent *bev, short event, void *arg)&#123; if(event &amp; BEV_EVENT_EOF) &#123; cout&lt;&lt;\"conn close\"&lt;&lt;endl; &#125; else if(event &amp;BEV_EVENT_ERROR) &#123; cout&lt;&lt;\"conn error\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"event :\"&lt;&lt;event&lt;&lt;endl; &#125; bufferevent_free(bev);&#125;int tcp_server_init(int port, int listen_num)&#123; evutil_socket_t listener; listener = ::socket(AF_INET, SOCK_STREAM, 0); if(listener &lt; 0) &#123; cout&lt;&lt;\"create socket error\"&lt;&lt;endl; return -1; &#125; evutil_make_listen_socket_reuseable(listener); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(port); if(::bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0) &#123; cout&lt;&lt;\"bind error\"&lt;&lt;endl; return -1; &#125; if(::listen(listener, listen_num) &lt; 0) &#123; cout&lt;&lt;\"listen error\"&lt;&lt;endl; return -1; &#125; evutil_make_socket_nonblocking(listener); return listener;&#125; 使用evconnlistener的服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;event2/event.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/util.h&gt;using namespace std;void accept_cb(evconnlistener *listener, evutil_socket_t fd, \\ struct sockaddr *sock, int socklen, void *arg);void socket_read_cb(struct bufferevent *bev, void *arg);void event_cb(struct bufferevent *bev, short event, void *arg);int main()&#123; struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_port = htons(9999); event_base *base = event_base_new(); evconnlistener * listener = evconnlistener_new_bind(base, accept_cb, \\ base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, \\ 10, (struct sockaddr*)&amp;sin, \\ sizeof(struct sockaddr_in)); event_base_dispatch(base); evconnlistener_free(listener); event_base_free(base); return 0;&#125;void accept_cb(evconnlistener *listener, evutil_socket_t fd, \\ struct sockaddr *sock, int socklen, void *arg)&#123; cout&lt;&lt;\"accept a client fd: \"&lt;&lt;fd&lt;&lt;endl; event_base *base = (event_base*)arg; bufferevent *bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if(NULL == bev) &#123; cout&lt;&lt;\"bufferevent_socket_new error\"&lt;&lt;endl; close(fd); return; &#125; bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg); bufferevent_enable(bev, EV_READ | EV_PERSIST);&#125;void socket_read_cb(bufferevent *bev, void *arg)&#123; char buff[4096] = &#123;0&#125;; size_t len = bufferevent_read(bev, buff, sizeof(buff)); if(len &lt;= 0) &#123; cout&lt;&lt;\"read error len: \"&lt;&lt;len&lt;&lt;endl; return; &#125; buff[len] = '\\0'; cout&lt;&lt;\"read msg : \"&lt;&lt;buff&lt;&lt;endl; bufferevent_write(bev, buff, strlen(buff));&#125;void event_cb(struct bufferevent *bev, short event, void *arg)&#123; if(event &amp; BEV_EVENT_EOF) &#123; cout&lt;&lt;\"conn close\"&lt;&lt;endl; &#125; else if(event &amp;BEV_EVENT_ERROR) &#123; cout&lt;&lt;\"conn error\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"event :\"&lt;&lt;event&lt;&lt;endl; &#125; bufferevent_free(bev);&#125; Libevent DNS客户端的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;event2/event.h&gt;#include &lt;event2/dns.h&gt;using namespace std;void callback(int errcode, struct evutil_addrinfo *addr, void *ptr)&#123; if (errcode) &#123; cout&lt;&lt;\"error :\"&lt;&lt;evutil_gai_strerror(errcode)&lt;&lt;endl; &#125; else &#123; struct evutil_addrinfo *ai; if (addr-&gt;ai_canonname) &#123; cout&lt;&lt;\"cannoname :\"&lt;&lt;addr-&gt;ai_canonname&lt;&lt;endl; &#125; //addr是一个链表,遍历链表 for( ai = addr ; ai != NULL ; ai = ai-&gt;ai_next) &#123; char buf[128]; const char *s = NULL; if ( ai-&gt;ai_family == AF_INET) &#123; struct sockaddr_in *sin = (struct sockaddr_in *)ai-&gt;ai_addr; s = evutil_inet_ntop(AF_INET, &amp;sin-&gt;sin_addr, buf, 128); &#125; else if ( ai-&gt;ai_family == AF_INET6) &#123; struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)ai-&gt;ai_addr; s = evutil_inet_ntop(AF_INET6, &amp;sin6-&gt;sin6_addr, buf, 128); &#125; if(s) &#123; cout&lt;&lt;\" -&gt;\"&lt;&lt;s&lt;&lt;endl; &#125; &#125; evutil_freeaddrinfo(addr); &#125;&#125;int main()&#123; struct event_base *base = event_base_new(); struct evdns_base *dnsbase = evdns_base_new(base, 1); struct evutil_addrinfo hints; memset(&amp;hints, 0, sizeof(hints)); hints.ai_family = AF_UNSPEC ; //不指定. hints.ai_flags = EVUTIL_AI_CANONNAME; //返回规范名. hints.ai_socktype = SOCK_STREAM; //只需要SOCK_STREAM套接字类型 hints.ai_protocol = IPPROTO_TCP; //只需要TCP协议的. const char* nodename = \"github.com\"; struct evdns_getaddrinfo_request *req; req = evdns_getaddrinfo(dnsbase , nodename , NULL , &amp;hints , callback , NULL); event_base_dispatch(base); if ( req != NULL) &#123; free( req ); &#125; evdns_base_free(dnsbase, 0); event_base_free(base); return 0;&#125; Libevent HTTP服务器1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;event2/event.h&gt;#include &lt;event2/http.h&gt;#include &lt;event2/buffer.h&gt;using namespace std;void callback(struct evhttp_request *request, void *arg)&#123; const struct evhttp_uri * uri = evhttp_request_get_evhttp_uri(request); char url[8192] = &#123;0&#125;; evhttp_uri_join(const_cast&lt;struct evhttp_uri*&gt;(uri), url, 8192); cout&lt;&lt;\"accept request url:\"&lt;&lt;url&lt;&lt;endl; struct evbuffer *evbuf = evbuffer_new(); if(NULL == evbuf) &#123; cout&lt;&lt;\"error! evbuffer_new\"&lt;&lt;endl; return; &#125; evbuffer_add_printf(evbuf, \"%s\", \"hello libevent http\"); evhttp_send_reply(request, HTTP_OK, \"OK\", evbuf); evbuffer_free(evbuf);&#125;int main()&#123; struct event_base *base = event_base_new(); struct evhttp *http = evhttp_new(base); evhttp_bind_socket(http, \"0.0.0.0\", 9999); evhttp_set_gencb(http, callback, NULL); event_base_dispatch(base); event_base_free(base); return 0;&#125; 参考文献 libevent源码分析 libevent专栏 libevent evhttp学习——http服务端","categories":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"网络","slug":"网络","permalink":"http://www.casezheng.date/tags/网络/"},{"name":"libevent","slug":"libevent","permalink":"http://www.casezheng.date/tags/libevent/"}],"keywords":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}]},{"title":"命令行参数的处理 gflags getopt getopt_long","slug":"command-line-arguments","date":"2017-09-22T16:38:00.000Z","updated":"2020-04-12T04:56:36.125Z","comments":true,"path":"2017/09/23/command-line-arguments/","link":"","permalink":"http://www.casezheng.date/2017/09/23/command-line-arguments/","excerpt":"","text":"命令行参数的处理 gflags getopt getopt_long的简单使用与对比 getopt getopt_longgetopt是简单的命令行处理函数。而getopt_long则复杂一些，功能也更加强大。 1234567891011121314151617#include &lt;unistd.h&gt;int getopt(int argc, char * const argv[], const char *optstring);extern char *optarg;extern int optind, opterr, optopt;#include &lt;getopt.h&gt;int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); getopt函数说明 getopt()用来分析命令行参数。参数argc和argv分别代表参数个数和内容，跟main（）函数的命令行参数是一样的。参数 optstring为选项字符串， 告知 getopt()可以处理哪个选项以及哪个选项需要参数，如果选项字符串里的字母后接着冒号“:”，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果在处理期间遇到了不符合optstring指定的其他选项getopt()将显示一个错误消息，并将全域变量optarg设为”?“字符，如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。optarg 指向当前选项参数（如果有）的指针。optind 再次调用getopt()时的下一个argv指针的索引。opterr 是否将错误信息输出到stderr的标志，置为0表示不输出。默认输出。optopt 最后一个未知选项。getopt optstring参数详解： 单个字符，表示选项。 单个字符后接一个冒号:表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。 单个字符后跟两个冒号::表示该选项后可以跟一个参数。也可以不跟。如果跟一个参数，参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。 getopt调用返回的是解析出的字符的选项。返回-1表示解析完毕。简单示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;unistd.h&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; for(auto i=0; i&lt;argc; ++i) &#123; cout&lt;&lt;\"argv \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;argv[i]&lt;&lt;endl; &#125; int ch; cout&lt;&lt;\"optind:\"&lt;&lt;optind&lt;&lt;\" opterr:\"&lt;&lt;opterr&lt;&lt;endl; while((ch = getopt(argc, argv, \"a:bcde::g\")) != -1) &#123; cout&lt;&lt;\"optind:\"&lt;&lt;optind&lt;&lt;endl; switch(ch) &#123; case 'a': cout&lt;&lt;\"option a \"&lt;&lt;optarg&lt;&lt;endl; break; case 'b': cout&lt;&lt;\"option b \"&lt;&lt;endl; cout&lt;&lt;\"optarg is NULL :\"&lt;&lt;(NULL==optarg)&lt;&lt;endl; break; case 'c': cout&lt;&lt;\"option c \"&lt;&lt;endl; break; case 'd': cout&lt;&lt;\"option d \"&lt;&lt;endl; break; case 'e': cout&lt;&lt;\"option e \"&lt;&lt;optarg&lt;&lt;endl; break; case '?': cout&lt;&lt;\"unkown option \"&lt;&lt;optarg&lt;&lt;endl; break; default: cout&lt;&lt;\"error option\"&lt;&lt;endl; &#125; &#125; for(auto i=0; i&lt;argc; ++i) &#123; cout&lt;&lt;\"after argv \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;argv[i]&lt;&lt;endl; &#125; return 0;&#125; 编译后使用： 123456789101112131415161718192021222324252627[CaseZheng@localhost Other]$ ./run -aef gege -ehaha -b gaga -cdargv 0 ./runargv 1 -aefargv 2 gegeargv 3 -ehahaargv 4 -bargv 5 gagaargv 6 -cdoptind:1 opterr:1optind:2option a efoptind:4option e hahaoptind:5option boptarg is NULL :1optind:6option coptind:7option dafter argv 0 ./runafter argv 1 -aefafter argv 2 -ehahaafter argv 3 -bafter argv 4 -cdafter argv 5 gegeafter argv 6 gaga optind初始值为1, 因为argv[0]存储的时程序名。所以从argv[1]开始解析。而optind表示的是下一次开始解析的位置，所以optind初始值为1。解析a选项，解析出紧跟着的选项参数ef。-a和ef可以紧跟着也可以用空格分割。如果选项参数中有空格需要用” “或’’括起来。例如： 12./run -a &quot;ef ef&quot;./run -a&quot;ef ef&quot; 解析e选项，解析e选项的参数haha。e选项使用了::，所以选项和选项参数必须紧跟在一起，不能用空格分割。例如： 12./run -e&apos;fefe&apos;./run -efefe 而./run -e fefe 的写法是错误的，fefe无法解析出来。再解析b c d选项，如果选项后不跟参数可以写在一起，例如-cd。解析途中碰到的gege gaga 则不解析，并将其移动到argv参数尾部。即argv[]中的选项和选项的参数会被放置在数组前面，而optind 会指向第一个非选项和参数的位置。 getopt_longgetopt_long和getopt都是解析命令行参数，但getopt_long支持长选项。12345678910int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);struct option &#123; const char *name; //长选项名字 int has_arg; //no_argument（或0）：选项不携带参数；required_argument（或1）：选项需要参数；optional_argument（或2）：选项携带可选参数 int *flag; //指定该长选项的返回值。如果flag是NULL，getopt_long会返回val。否则，getopt_long会返回0，且flag指向的值设置为val的值，前提是该选项成功找到了 int val; //当做返回值，或把值加载进flag所指的内存中。&#125;; longopts用来支持长选项。longopts指向数组的最后一个元素值都设置为0。 注意相比getopt，使用getopt_long需要加头文件&lt;getopt.h&gt; getopt_long除了会接受长选项，其他概念和getopt是一样的 如果使用getopt_long想只接受短选项，设置longopts为NULL即可；如果只想接受长选项，相应地设置optstring为NULL即可 长选项名是可以使用缩写方式，比如：选项有--file--create,那么输入--c/--cr/--cre等均会被正确识别为create选项 对于带参数的长选项格式是：--arg=param或--arg param longopts是指向struct option数组的第一个元素的指针，struct option定义在&lt;getopt.h&gt;中 longindex如果非NULL，则是返回识别到struct option数组中元素的位置指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;getopt.h&gt;using namespace std;//getopt_long示例int main(int argc, char *argv[])&#123; for(auto i=0; i&lt;argc; ++i) &#123; cout&lt;&lt;\"argv \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;argv[i]&lt;&lt;endl; &#125; int ch; cout&lt;&lt;\"optind:\"&lt;&lt;optind&lt;&lt;\" opterr:\"&lt;&lt;opterr&lt;&lt;endl; int flag; const struct option long_options[] = &#123; &#123; \"append\", 1, NULL, 'a' &#125;, &#123; \"help\", 0, NULL, 'h' &#125;, &#123; \"verbose\", 0, NULL, 'v' &#125;, &#123; \"output\", 1, &amp;flag, 'o' &#125;, &#123; NULL, 0, NULL, 0 &#125; &#125;; int longindex = 0; while((ch = getopt_long(argc, argv, \"a:hvb:cde::g\", long_options, &amp;longindex)) != -1) &#123; cout&lt;&lt;\"optind:\"&lt;&lt;optind&lt;&lt;endl; cout&lt;&lt;\"ch:\"&lt;&lt;ch&lt;&lt;endl; switch(ch) &#123; case 0: cout&lt;&lt;\"long option \"&lt;&lt;longindex&lt;&lt;\" \"&lt;&lt;long_options[longindex].name; if(NULL != optarg) &#123; cout&lt;&lt;\" arg \"&lt;&lt;optarg; &#125; cout&lt;&lt;endl; break; case 'a': case 'h': case 'v': cout&lt;&lt;\"ch \"&lt;&lt;(char)ch&lt;&lt;endl; if(NULL != optarg) &#123; cout&lt;&lt;\"arg \"&lt;&lt;optarg; &#125; cout&lt;&lt;endl; break; case 'b': cout&lt;&lt;\"option b \"&lt;&lt;endl; cout&lt;&lt;\"optarg is NULL :\"&lt;&lt;(NULL==optarg)&lt;&lt;endl; break; case 'c': cout&lt;&lt;\"option c \"&lt;&lt;endl; break; case 'd': cout&lt;&lt;\"option d \"&lt;&lt;endl; break; case 'e': cout&lt;&lt;\"option e \"&lt;&lt;optarg&lt;&lt;endl; break; case '?': cout&lt;&lt;\"option ? \"&lt;&lt;endl; if(NULL != optarg) &#123; cout&lt;&lt;\"unkown option \"&lt;&lt;optarg&lt;&lt;endl; &#125; cout&lt;&lt;\"unkown longindex \"&lt;&lt;longindex&lt;&lt;endl; break; default: cout&lt;&lt;\"error option\"&lt;&lt;endl; &#125; &#125; for(auto i=0; i&lt;argc; ++i) &#123; cout&lt;&lt;\"after argv \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;argv[i]&lt;&lt;endl; &#125; return 0;&#125; 编译运行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[CaseZheng@localhost Other]$ ./run -a fe -hv -cd -b ff -append --output feargv 0 ./runargv 1 -aargv 2 feargv 3 -hvargv 4 -cdargv 5 -bargv 6 ffargv 7 -appendargv 8 --outputargv 9 feoptind:1 opterr:1optind:3ch:97ch aarg feoptind:3ch:104ch hoptind:4ch:118ch voptind:4ch:99option coptind:5ch:100option doptind:7ch:98option boptarg is NULL :0optind:8ch:97ch aarg ppendoptind:10ch:0long option 3 output arg feafter argv 0 ./runafter argv 1 -aafter argv 2 feafter argv 3 -hvafter argv 4 -cdafter argv 5 -bafter argv 6 ffafter argv 7 -appendafter argv 8 --outputafter argv 9 fe gflagsgflags 是 google 开源的用于处理命令行参数的项目。 简单使用1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;gflags/gflags.h&gt;using namespace std;DEFINE_bool(daemon, true, \"run daemon mode\");DEFINE_int32(port, 9000, \"program listen port\");DEFINE_string(confpath, \"./config.ini\", \"program config path\");DEFINE_double(dou, 0, \"double\");// 定义对 FLAGS_port 的检查函数static bool ValidatePort(const char* name, int32_t value) &#123; if (value &gt; 0 &amp;&amp; value &lt; 32768) &#123; return true; &#125; printf(\"Invalid value for --%s: %d\\n\", name, (int)value); return false;&#125;// 使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用,确保参数检查在main函数进入时已经注册。static const bool port_dummy = gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort);int main(int argc, char *argv[])&#123; //gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort); gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true); cout&lt;&lt;\"daemon: \"&lt;&lt;FLAGS_daemon&lt;&lt;endl; cout&lt;&lt;\"port: \"&lt;&lt;FLAGS_port&lt;&lt;endl; cout&lt;&lt;\"configpath: \"&lt;&lt;FLAGS_confpath&lt;&lt;endl; cout&lt;&lt;\"dou: \"&lt;&lt;FLAGS_dou&lt;&lt;endl; FLAGS_dou = 9999.8; cout&lt;&lt;\"after dou: \"&lt;&lt;FLAGS_dou&lt;&lt;endl; // 使用 SetCommandLineOption 函数对参数进行设置才会调用检查函数 gflags::SetCommandLineOption(\"port\", \"-2\"); cout&lt;&lt;\"after port: \"&lt;&lt;FLAGS_port&lt;&lt;endl; FLAGS_port = -2; cout&lt;&lt;\"after2 port: \"&lt;&lt;FLAGS_port&lt;&lt;endl; return 0;&#125; 编译运行：123456[CaseZheng@localhost Other]$ g++ -o run CommandLine.cpp -g -lgflags[CaseZheng@localhost Other]$ ./run -confpath &quot;./config.txt&quot; -daemon=&quot;true&quot; --port=111 -dou 1.0011111./config.txt1.001 gflags支持的类型： DEFINE_bool: boolean DEFINE_int32: 32-bit integer DEFINE_int64: 64-bit integer DEFINE_uint64: unsigned 64-bit integer DEFINE_double: double DEFINE_string: C++ string 如定义: DEFINE_bool(daemon, true, &quot;run daemon mode&quot;);在命令行可以这样访问：123456./run -daemon./run -daemon=true./run -daemon=1./run -daemon=false./run --daemon true./run --daemon &quot;true&quot; 在程序中可加前缀FLAGS_来访问，例如: cout&lt;&lt;FLAGS_daemon&lt;&lt;endl;gflags变量可以被修改 FLAGS_daemon = true; gflags支持从文件中读取命令行参数。config.flags文件1-confpath &quot;./config.txt&quot; -daemon=&quot;true&quot; --port=111 -dou 1.001 命令行使用：123456[CaseZheng@localhost Other]$ ./run --flagfile config.flags19000./config.inidou: 0after dou: 9999.8 外部引用如果希望在别的文件中使用gflags变量，可以使用DECLARE_type（type为变量类型 int string double等）来声明变量。相当与extern声明变量 例如： DECLARE_bool(daemon); 参数检查可以注册检查函数值的检查函数。 123456789101112[CaseZheng@localhost Other]$ ./run -port=99[CaseZheng@localhost Other]$ ./run -port=-1Invalid value for --port: -1ERROR: failed validation of new value &apos;-1&apos; for flag &apos;port&apos;daemon: 1port: 99configpath: ./config.inidou: 0after dou: 9999.8Invalid value for --port: -2after port: 99after2 port: -2 可以看到命令行输入错误，程序会直接退出。使用SetCommandLineOption修改参数也会触发参数检测，但如果不合法，程序不退出。如果直接修改参数的值则不会触发参数检测函数。 特殊参数 --help 打印定义过的所有参数的帮助信息 --version 打印版本信息 通过google::SetVersionString()指定 --nodefok 但命令行中出现没有定义的参数时，并不退出（error-exit） --fromenv 从环境变量读取参数值 --fromenv=foo,bar表明要从环境变量读取foo，bar两个参数的值。通过export FLAGS_foo=xxx; export FLAGS_bar=yyy 程序就可读到foo，bar的值分别为xxx，yyy。 --tryfromenv与--fromenv类似，当参数的没有在环境变量定义时，不退出（fatal-exit） --flagfile 从文件读取参数值，--flagfile=my.conf表明要从my.conf文件读取参数的值。在配置文件中指定参数值与在命令行方式类似，另外在flagfile里可进一步通过--flagfile来包含其他的文件。 对比 getopt getopt_long是Linux标准库中的，可以直接使用，而gflags需要安装。 getopt只支持短选项，getopt_long支持短选项和长选项，getopt_long支持长选项缩写，gflags不支持长选项缩写。 getopt、getopt_long是C函数，通用性强，而gflags使用C++编写，C无法直接使用。 getopt、getopt_long使用不便，gflags使用方便，清晰。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"Linux I/O 复用 epoll源码解析","slug":"io-5-epoll","date":"2017-09-21T03:51:00.000Z","updated":"2020-04-12T04:56:36.123Z","comments":true,"path":"2017/09/21/io-5-epoll/","link":"","permalink":"http://www.casezheng.date/2017/09/21/io-5-epoll/","excerpt":"","text":"Linux I/O epoll 源码分析 目录 epoll epoll_create epoll_ctl epoll中的递归死循环和深度检查 循环检测 唤醒风暴 epoll_create和epoll_ctl函数调用过程 epoll_wait函数调用主要过程 epoll结构体间关系 epollepoll的简单原理 执行epoll_create时，创建了红黑树和就绪list链表。 执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。 执行epoll_wait时立刻返回准备就绪链表里的数据即可。 epoll_createepoll_create主要做两件事 创建并初始化一个eventpoll结构体变量 创建epoll的file结构，并指定file的private_data指针指向刚创建的eventpoll变量，这样，只要根据epoll文件描述符epfd就可以拿到file进而就拿到了eventpoll变量了，该eventpoll就是epoll_ctl和epoll_wait工作的场所 123456789101112131415161718192021//epoll文件系统的相关实现//epoll文件系统初始化，在系统启动时会调用 .init段static int __init eventpoll_init(void)&#123; struct sysinfo si; si_meminfo(&amp;si); //限制可添加到epoll的最多的描述符数量 max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) / EP_ITEM_COST; //检查递归检查队列 ep_nested_calls_init(&amp;poll_loop_ncalls); ep_nested_calls_init(&amp;poll_safewake_ncalls); ep_nested_calls_init(&amp;poll_readywalk_ncalls); //在内核创建内存池 //epoll用kmem_cache_create（slab分配器）分别用来分配epitem和eppoll_entry epi_cache = kmem_cache_create(\"eventpoll_epi\", sizeof(struct epitem), 0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL); pwq_cache = kmem_cache_create(\"eventpoll_pwq\", sizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546SYSCALL_DEFINE1(epoll_create, int, size)&#123; if (size &lt;= 0) return -EINVAL; return sys_epoll_create1(0);&#125;SYSCALL_DEFINE1(epoll_create1, int, flags)&#123; int error, fd; struct eventpoll *ep = NULL; struct file *file; BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC); if (flags &amp; ~EPOLL_CLOEXEC) return -EINVAL; error = ep_alloc(&amp;ep); //为ep在堆上申请空间并初始化 eventpoll if (error &lt; 0) return error; fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));//会调用alloc_fd()分配文件描述符 if (fd &lt; 0) &#123; error = fd; goto out_free_ep; &#125; //创建与eventpoll结构体相对应的file结构体，匿名文件，ep保存在file-&gt;private_data结构体中 //static const struct file_operations eventpoll_fops = &#123; // .release = ep_eventpoll_release, // .poll = ep_eventpoll_poll //&#125;; file = anon_inode_getfile(\"[eventpoll]\", &amp;eventpoll_fops, ep, O_RDWR | (flags &amp; O_CLOEXEC)); if (IS_ERR(file)) &#123; error = PTR_ERR(file); goto out_free_fd; &#125; //建立文件描述符和file之间的联系 fd_install(fd, file); ep-&gt;file = file; return fd;out_free_fd: put_unused_fd(fd);out_free_ep: ep_free(ep); //释放ep eventpoll return error;&#125; epoll_ctl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//epfd epoll内核事件表的文件描述符//op 要进行的操作类型//fd 要监测的文件描述符//event 要监测的事件SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event __user *, event)&#123; int error; int did_lock_epmutex = 0; struct file *file, *tfile; struct eventpoll *ep; struct epitem *epi; struct epoll_event epds; error = -EFAULT; //判断参数的合法性，将event从用户空间复制到内核空间 if (ep_op_has_event(op) &amp;&amp; copy_from_user(&amp;epds, event, sizeof(struct epoll_event))) goto error_return; error = -EBADF; file = fget(epfd); //根据文件描述符得到相应的文件对象，内核事件表 if (!file) goto error_return; tfile = fget(fd); //要监测的文件 if (!tfile) goto error_fput; error = -EPERM; if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll) //要监测文件设备poll方法的检查 goto error_tgt_fput; error = -EINVAL; if (file == tfile || !is_file_epoll(file)) goto error_tgt_fput; ep = file-&gt;private_data; //获取epoll对应的eventpoll结构体 if (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) &#123; mutex_lock(&amp;epmutex); did_lock_epmutex = 1; &#125; if (op == EPOLL_CTL_ADD) &#123; if (is_file_epoll(tfile)) &#123; error = -ELOOP; if (ep_loop_check(ep, tfile) != 0) &#123; //循环检测 clear_tfile_check_list(); goto error_tgt_fput; &#125; &#125; else list_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list); &#125; mutex_lock_nested(&amp;ep-&gt;mtx, 0); //互斥锁加锁 //防止重复添加（在ep的红黑树中查找是否存在这个fd），存在返回epitem，不存在返回NULL epi = ep_find(ep, tfile, fd); error = -EINVAL; switch (op) &#123; //不同的操作 case EPOLL_CTL_ADD: if (!epi) &#123; //红黑树上不存在这个节点 epds.events |= POLLERR | POLLHUP; //确保“出错，连接挂起”被当作感兴趣的事件 error = ep_insert(ep, &amp;epds, tfile, fd); //添加 &#125; else error = -EEXIST; clear_tfile_check_list(); //清空需要监测的文件的检查列表 break; case EPOLL_CTL_DEL: if (epi) //红黑树上存在这个节点 error = ep_remove(ep, epi); //删除 else error = -ENOENT; break; case EPOLL_CTL_MOD: if (epi) &#123; epds.events |= POLLERR | POLLHUP; error = ep_modify(ep, epi, &amp;epds); &#125; else error = -ENOENT; break; &#125; mutex_unlock(&amp;ep-&gt;mtx); //互斥锁，解锁error_tgt_fput: if (did_lock_epmutex) mutex_unlock(&amp;epmutex); fput(tfile);error_fput: fput(file);error_return: return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990static int ep_insert(struct eventpoll *ep, struct epoll_event *event, struct file *tfile, int fd)&#123; int error, revents, pwake = 0; unsigned long flags; struct epitem *epi; struct ep_pqueue epq; //struct ep_pqueue &#123; poll_table pt; struct epitem *epi; &#125;; if (unlikely(atomic_read(&amp;ep-&gt;user-&gt;epoll_watches) &gt;= max_user_watches)) return -ENOSPC; //初始化分配epi epitem if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL))) return -ENOMEM; //epi初始化 INIT_LIST_HEAD(&amp;epi-&gt;rdllink); //就绪的事件链表 INIT_LIST_HEAD(&amp;epi-&gt;fllink); //连接被监听的文件 INIT_LIST_HEAD(&amp;epi-&gt;pwqlist); //poll等待队列 epi-&gt;ep = ep; ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd); epi-&gt;event = *event; epi-&gt;nwait = 0; epi-&gt;next = EP_UNACTIVE_PTR; //初始化的epq epq.epi = epi; //epq.pt-&gt;qproc = ep_ptable_queue_proc 回调函数的设置 init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc); //内部会调用ep_ptable_queue_proc, 在文件对应的wait queue head 上注册回调函数 //并返回当前文件的状态 revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt); error = -ENOMEM; if (epi-&gt;nwait &lt; 0) //f_op-&gt;poll过程出错 goto error_unregister; spin_lock(&amp;tfile-&gt;f_lock); //添加当前的epitem到要监测文件的tfile-&gt;f_ep_links链表 list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links); spin_unlock(&amp;tfile-&gt;f_lock); //插入epi到红黑树 ep_rbtree_insert(ep, epi); error = -EINVAL; if (reverse_path_check()) //唤醒风暴检查 goto error_remove_epi; spin_lock_irqsave(&amp;ep-&gt;lock, flags); //文件已经就绪，插入到epitem的就绪链表rdllist if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123; list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); if (waitqueue_active(&amp;ep-&gt;wq)) //通知epoll_wait,调用回调函数唤醒epoll_wait上的进程 wake_up_locked(&amp;ep-&gt;wq); if (waitqueue_active(&amp;ep-&gt;poll_wait)) //先不通知调用eventpoll_poll的进程 pwake++; &#125; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); atomic_inc(&amp;ep-&gt;user-&gt;epoll_watches); if (pwake) ep_poll_safewake(&amp;ep-&gt;poll_wait); //安全通知调用eventpoll_poll的进程 return 0;error_remove_epi: spin_lock(&amp;tfile-&gt;f_lock); //删除文件上的epi if (ep_is_linked(&amp;epi-&gt;fllink)) list_del_init(&amp;epi-&gt;fllink); spin_unlock(&amp;tfile-&gt;f_lock); //从红黑树中删除 rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);error_unregister: //从文件的wait_queue中删除，释放epitem关联的所有epoll_entry ep_unregister_pollwait(ep, epi); spin_lock_irqsave(&amp;ep-&gt;lock, flags); if (ep_is_linked(&amp;epi-&gt;rdllink)) list_del_init(&amp;epi-&gt;rdllink); spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); //释放epi kmem_cache_free(epi_cache, epi); return error;&#125; 12345678910111213141516171819// tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt) -&gt; poll_wait() -&gt; ep_ptable_queue_proc()static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead, poll_table *pt)&#123; struct epitem *epi = ep_item_from_epqueue(pt); struct eppoll_entry *pwq; if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123; //pwq初始化，pwq-&gt;wait.func = ep_poll_callback; //唤醒回调函数 init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback); pwq-&gt;whead = whead; //监测文件的等待队列头 pwq-&gt;base = epi; //指向epitem add_wait_queue(whead, &amp;pwq-&gt;wait); //将等待队列项，加入到等待队列中去 list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); //将等待队列项保存到epi-&gt;pwqlist链表中 epi-&gt;nwait++; //poll操作中事件的个数加1 &#125; else &#123; epi-&gt;nwait = -1; //标识调用出错 &#125;&#125; 123456789101112131415161718192021222324static int ep_remove(struct eventpoll *ep, struct epitem *epi)&#123; unsigned long flags; struct file *file = epi-&gt;ffd.file; //获得要删除文件描述符的文件结构 ep_unregister_pollwait(ep, epi); //删除被监听文件的等待队列项 spin_lock(&amp;file-&gt;f_lock); if (ep_is_linked(&amp;epi-&gt;fllink)) list_del_init(&amp;epi-&gt;fllink); //从epitem.fllink中删除 spin_unlock(&amp;file-&gt;f_lock); rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr); //从红黑树中删除 spin_lock_irqsave(&amp;ep-&gt;lock, flags); if (ep_is_linked(&amp;epi-&gt;rdllink)) list_del_init(&amp;epi-&gt;rdllink); //从epitem.rdllink中删除（就绪队列） spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); kmem_cache_free(epi_cache, epi); //释放空间 atomic_dec(&amp;ep-&gt;user-&gt;epoll_watches); return 0;&#125; 123456789101112131415161718192021222324252627282930static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)&#123; int pwake = 0; unsigned int revents; epi-&gt;event.events = event-&gt;events; epi-&gt;event.data = event-&gt;data; smp_mb(); revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL); //获得事件掩码 if (revents &amp; event-&gt;events) &#123; spin_lock_irq(&amp;ep-&gt;lock); if (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123; //将已就绪的等待队列项，加入到ep-&gt;rdllist链表 list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); if (waitqueue_active(&amp;ep-&gt;wq)) wake_up_locked(&amp;ep-&gt;wq); if (waitqueue_active(&amp;ep-&gt;poll_wait)) pwake++; &#125; spin_unlock_irq(&amp;ep-&gt;lock); &#125; if (pwake) ep_poll_safewake(&amp;ep-&gt;poll_wait); return 0;&#125; 123456789101112131415161718192021222324252627282930SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout)&#123; int error; struct file *file; struct eventpoll *ep; //检查输入数据有效性 if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS) return -EINVAL; if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) &#123; error = -EFAULT; goto error_return; &#125; error = -EBADF; file = fget(epfd); if (!file) goto error_return; error = -EINVAL; if (!is_file_epoll(file)) goto error_fput; ep = file-&gt;private_data; //获得eventpoll结构 error = ep_poll(ep, events, maxevents, timeout);error_fput: fput(file);error_return: return error;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)&#123; int res, eavail; unsigned long flags; long jtimeout; wait_queue_t wait; //timeout &lt; 0 或者timeout &gt;= EP_MAX_MSTIMEO jtimeout = (timeout &lt; 0 || timeout &gt;= EP_MAX_MSTIMEO) ? MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;retry: spin_lock_irqsave(&amp;ep-&gt;lock, flags); res = 0; if (list_empty(&amp;ep-&gt;rdllist)) &#123; //事件就绪队列为空 init_waitqueue_entry(&amp;wait, current); //对当前进程设置等待项 //static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p) //&#123; // q-&gt;flags = 0; // q-&gt;private = p; // q-&gt;func = default_wake_function; //&#125; wait.flags |= WQ_FLAG_EXCLUSIVE; //标记等待的进程是互斥进程 __add_wait_queue(&amp;ep-&gt;wq, &amp;wait); //加入ep_wait()等待队列 for (;;) &#123; //进程状态的设置，TASK_INTERRUPTIBLE表示进程可以被信号和wake_up()唤醒 set_current_state(TASK_INTERRUPTIBLE); //就绪队列为不空 或者 睡眠时间为0 if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout) break; if (signal_pending(current)) &#123; //收到信号 res = -EINTR; break; &#125; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); //进入睡眠等待ep_poll_callback()将当前进程唤醒或超时，返回值是剩余的时间。 jtimeout = schedule_timeout(jtimeout); spin_lock_irqsave(&amp;ep-&gt;lock, flags); &#125; //end for( ; ; ) __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait); //将等待队列项从ep_wait()等待队列中移除 set_current_state(TASK_RUNNING); //表示TASK_RUNNING运行或就绪状态 &#125; //end if //ep-&gt;rdllist不空 或者 ep-&gt;ovflist不空 eavail为true eavail = ! list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); //如果没有被信号中断，并且有事件就绪，但发送成功的文件描述符为0，并且没有超时 //则跳转到retry标签处，重新等待文件状态就绪 if ( !res &amp;&amp; eavail &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout) goto retry; return res; //返回获取的事件的个数或者错误码&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//发送结果到用户空间static int ep_send_events(struct eventpoll *ep, struct epoll_event __user *events, int maxevents)&#123; struct ep_send_events_data esed; esed.maxevents = maxevents; //需要检测的文件描述符个数 esed.events = events; return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0);&#125;static int ep_scan_ready_list(struct eventpoll *ep, int (*sproc)(struct eventpoll *, struct list_head *, void *), void *priv, int depth)&#123; int error, pwake = 0; unsigned long flags; struct epitem *epi, *nepi; LIST_HEAD(txlist); mutex_lock_nested(&amp;ep-&gt;mtx, depth); spin_lock_irqsave(&amp;ep-&gt;lock, flags); //将ep-&gt;rdllist链表添加到txlist链表中去，使ep-&gt;rdllist链表为空 list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist); //标记ep_scan_ready_list()准备向用户空间传递事件，当有唤醒函数ep_poll_callback()调用时 //将就绪的文件描述符的epitem实例加入到ovflist链表中。 ep-&gt;ovflist = NULL; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); error = (*sproc)(ep, &amp;txlist, priv); //ep_send_events_proc spin_lock_irqsave(&amp;ep-&gt;lock, flags); //在执行上面代码期间，又有可能有就绪事件，这样就进入ep-&gt;ovflist队列， //将ovflist链表中的就绪文件描述符加入到rdllist #define EP_UNACTIVE_PTR ((void *) -1L) for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL; nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123; //如果epi-&gt;rdllink为空，将epi加入到ep-&gt;rdllist中 if (!ep_is_linked(&amp;epi-&gt;rdllink)) //list_empty(&amp;epi-&gt;rdllink) list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); &#125; ep-&gt;ovflist = EP_UNACTIVE_PTR; //标记向用户空间传递事件结束 list_splice(&amp;txlist, &amp;ep-&gt;rdllist); //如果txlist不为空，将txlist链表加入到rdllist链表中 if ( ! list_empty(&amp;ep-&gt;rdllist)) &#123; //如果文件描述符就绪链表ep-&gt;rdllist不为空 if (waitqueue_active(&amp;ep-&gt;wq)) wake_up_locked(&amp;ep-&gt;wq); //如果ep-&gt;wq不空，唤醒ep-&gt;wq上的进程 if (waitqueue_active(&amp;ep-&gt;poll_wait)) pwake++; //如果ep-&gt;poll_wait不空 &#125; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); mutex_unlock(&amp;ep-&gt;mtx); if (pwake) ep_poll_safewake(&amp;ep-&gt;poll_wait); //通知调用了poll的进程 return error; //返回发送的就绪的文件描述符个数或错误码&#125; 123456789101112131415161718192021222324252627282930313233343536static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)&#123; struct ep_send_events_data *esed = priv; int eventcnt; unsigned int revents; struct epitem *epi; struct epoll_event __user *uevent; for (eventcnt = 0, uevent = esed-&gt;events; !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents; ) &#123; epi = list_first_entry(head, struct epitem, rdllink); //得到epitem结构体 list_del_init(&amp;epi-&gt;rdllink); //从就绪链表中删除该epitem//立即返回当前文件的就绪事件 revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL) &amp; epi-&gt;event.events; if (revents) &#123;//将就绪事件的poll_event发送至用户空间 if (__put_user(revents, &amp;uevent-&gt;events) || __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123; list_add(&amp;epi-&gt;rdllink, head); //发送失败，将epi重新加入head return eventcnt ? eventcnt : -EFAULT; &#125; eventcnt++; uevent++;//#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET) if (epi-&gt;event.events &amp; EPOLLONESHOT) //如果文件描述符检测EPOLLONESHOT epi-&gt;event.events &amp;= EP_PRIVATE_BITS; else if (!(epi-&gt;event.events &amp; EPOLLET)) &#123;//未设置为ET(非边缘触发)模式，就将epi-&gt;rdllink加入到ep-&gt;rdllist链表中 list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); &#125; &#125; //end if revents &#125; //end for return eventcnt; //返回发送的就绪的文件描述符个数&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ep_poll_callback唤醒回调函数static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)&#123; int pwake = 0; unsigned long flags; struct epitem *epi = ep_item_from_wait(wait); //得到epitem struct eventpoll *ep = epi-&gt;ep; //得到eventpoll if ((unsigned long)key &amp; POLLFREE) &#123; //有错误发生 ep_pwq_from_wait(wait)-&gt;whead = NULL; //等待队列头置为NULL list_del_init(&amp;wait-&gt;task_list); //从等待队列中删除等待队列项 &#125; spin_lock_irqsave(&amp;ep-&gt;lock, flags); //#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET) if (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))//有非EPOLLONESHOT | EPOLLET不懂！！！ goto out_unlock; if (key &amp;&amp; !((unsigned long) key &amp; epi-&gt;event.events)) goto out_unlock; //没有事件发生 //ep-&gt;ovflist != EP_UNACTIVE_PTR成立时，ep_scan_ready_list()正在向用户空间传递事件。 //如果当前进程正在向用户空间传递事件，则将当前的事件对应的epitem实例加入到ovflist链表中。 if (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123; //如果epi-&gt;next不等于EP_UNACTIVE_PTR， //则说明已经添加到ovflist链表中，就不用再添加了 if (epi-&gt;next == EP_UNACTIVE_PTR) &#123; epi-&gt;next = ep-&gt;ovflist; //把epi放到ovflist链表中 ep-&gt;ovflist = epi; &#125; goto out_unlock; &#125; if (!ep_is_linked(&amp;epi-&gt;rdllink)) list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); //把epitem放到strcut eventpoll的rdllist中去 if (waitqueue_active(&amp;ep-&gt;wq)) wake_up_locked(&amp;ep-&gt;wq); //唤醒调用epoll_wait()函数时睡眠的进程 if (waitqueue_active(&amp;ep-&gt;poll_wait)) pwake++;out_unlock: spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); if (pwake) ep_poll_safewake(&amp;ep-&gt;poll_wait); return 1;&#125; 123456789101112131415//由于epoll自身也是文件系统，其描述符也可以被poll/select/epoll监视，因此需要实现poll方法static unsigned int ep_eventpoll_poll(struct file *file, poll_table *wait)&#123; int pollflags; struct eventpoll *ep = file-&gt;private_data; //把等待队列项插入到ep-&gt;poll_wait poll_wait(file, &amp;ep-&gt;poll_wait, wait); //扫描就绪的文件列表，调用每个文件上的poll检查是否真的就绪，然后复制到用户空间， //文件列表中有可能有epoll文件，调用poll的时候有可能产生递归， //调用所以用ep_call_nested包装一下，防止死循环和过深的调用 pollflags = ep_call_nested(&amp;poll_readywalk_ncalls, EP_MAX_NESTS, ep_poll_readyevents_proc, ep, ep, current); return pollflags != -1 ? pollflags : 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static int ep_poll_readyevents_proc(void *priv, void *cookie, int call_nests)&#123; return ep_scan_ready_list(priv, ep_read_events_proc, NULL, call_nests + 1);&#125;static int ep_scan_ready_list(struct eventpoll *ep, int (*sproc)(struct eventpoll *, struct list_head *, void *), void *priv, int depth)&#123; int error, pwake = 0; unsigned long flags; struct epitem *epi, *nepi; LIST_HEAD(txlist); mutex_lock_nested(&amp;ep-&gt;mtx, depth); spin_lock_irqsave(&amp;ep-&gt;lock, flags); //移动ep-&gt;rdllist到新的链表txlist list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist); ep-&gt;ovflist = NULL; //改变ovflist的状态 spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); error = (*sproc)(ep, &amp;txlist, priv); //ep_read_events_proc spin_lock_irqsave(&amp;ep-&gt;lock, flags); //调用ep_read_events_proc时可能出现了新的事件，遍历这些新的事件将其插入到rdllink for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL; nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123; //epi不在rdllink,插入 if (!ep_is_linked(&amp;epi-&gt;rdllink)) list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); &#125; ep-&gt;ovflist = EP_UNACTIVE_PTR; //还原ep-&gt;ovflist的状态 list_splice(&amp;txlist, &amp;ep-&gt;rdllist); //将处理后的txlist链接到rdllist if (!list_empty(&amp;ep-&gt;rdllist)) &#123; if (waitqueue_active(&amp;ep-&gt;wq)) wake_up_locked(&amp;ep-&gt;wq); //唤醒epoll_wait if (waitqueue_active(&amp;ep-&gt;poll_wait)) pwake++; &#125; spin_unlock_irqrestore(&amp;ep-&gt;lock, flags); mutex_unlock(&amp;ep-&gt;mtx); if (pwake) ep_poll_safewake(&amp;ep-&gt;poll_wait); //安全唤醒外部的事件通知机制 return error;&#125; 1234567891011121314151617static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)&#123; struct epitem *epi, *tmp; list_for_each_entry_safe(epi, tmp, head, rdllink) &#123; if (epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL) &amp; epi-&gt;event.events)//只要有一个文件描述符就绪返回可读 或 普通数据可写 return POLLIN | POLLRDNORM; else &#123;//文件描述符未就绪，但在就绪队列中，将其移除 list_del_init(&amp;epi-&gt;rdllink); &#125; &#125; return 0;&#125; 123456789static void ep_poll_safewake(wait_queue_head_t *wq)&#123; int this_cpu = get_cpu(); ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS, ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu); put_cpu();&#125; 1234567891011121314static int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)&#123; ep_wake_up_nested((wait_queue_head_t *) cookie, POLLIN, 1 + call_nests); return 0;&#125;static inline void ep_wake_up_nested(wait_queue_head_t *wqueue, unsigned long events, int subclass)&#123;//唤醒所有正在等待此epfd的select/epoll/poll等//如果唤醒的是epoll就可能唤醒所有其他的epoll，产生连锁反应 wake_up_poll(wqueue, events);&#125; epoll中的递归死循环和深度检查如果epoll之间相互监视就有可能导致死循环。epoll的实现中，所有可能产生递归调用的函数都由函函数ep_call_nested进行包裹，递归调用过程中出现死循环或递归过深就会打破死循环和递归调用直接返回。该函数的实现依赖于一个外部的全局链表nested_call_node(不同的函数调用使用不同的节点)，每次调用可能发生递归的函数(nproc)就向链表中添加一个包含当前函数调用上下文ctx(进程，CPU，或epoll文件)和处理的对象标识cookie的节点，通过检测是否有相同的节点就可以知道是否发生了死循环，检查链表中同一上下文包含的节点个数就可以知道递归的深度。1234567891011121314151617181920212223242526272829303132333435363738394041//限制epoll中直接或间接递归调用的深度并防止死循环//ctx:任务运行上下文（进程，CPU等）//cokie:每个任务的标识//priv:任务运行需要的私有数据static int ep_call_nested(struct nested_calls *ncalls, int max_nests, int (*nproc)(void *, void *, int), void *priv, void *cookie, void *ctx)&#123; int error, call_nests = 0; unsigned long flags; struct list_head *lsthead = &amp;ncalls-&gt;tasks_call_list; struct nested_call_node *tncur; struct nested_call_node tnode; spin_lock_irqsave(&amp;ncalls-&gt;lock, flags); //检查原有的嵌套调用链表ncalls，查看是否有深度超过限制的情况 list_for_each_entry(tncur, lsthead, llink) &#123; //同一上下文（ctx）中有相同的任务（cookie）说明产生了死循环 //同一上下文的递归深度call_nests超过限制 if (tncur-&gt;ctx == ctx &amp;&amp; (tncur-&gt;cookie == cookie || ++call_nests &gt; max_nests)) &#123; error = -1; goto out_unlock; &#125; &#125; //将当前的任务请求添加到调用列表 tnode.ctx = ctx; tnode.cookie = cookie; list_add(&amp;tnode.llink, lsthead); spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags); //nproc 可能会导致递归调用(直接或间接)ep_call_nested ，如果发生递归调用, 那么在此函数返回之前, ncalls 又会被加入额外的节点, 这样通过前面的检测就可以知道递归调用的深度 error = (*nproc)(priv, cookie, call_nests); spin_lock_irqsave(&amp;ncalls-&gt;lock, flags); //从链表中删除当前任务 list_del(&amp;tnode.llink);out_unlock: spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags); return error;&#125; 循环检测循环检查(ep_loop_check)，该函数递归调用ep_loop_check_proc利用ep_call_nested来实现epoll之间相互监视的死循环。因为ep_call_nested中已经对死循环和过深的递归做了检查，实际的ep_loop_check_proc的实现只是递归调用自己。其中的visited_list和visited标记完全是为了优化处理速度，如果没有visited_list和visited标记函数也是能够工作的。该函数中得上下文就是当前的进程，cookie就是正在遍历的epoll结构 123456789101112131415static int ep_loop_check(struct eventpoll *ep, struct file *file)&#123; int ret; struct eventpoll *ep_cur, *ep_next; ret = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS, ep_loop_check_proc, file, ep, current);//清除链表和标志 list_for_each_entry_safe(ep_cur, ep_next, &amp;visited_list, visited_list_link) &#123; ep_cur-&gt;visited = 0; list_del(&amp;ep_cur-&gt;visited_list_link); &#125; return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)&#123; int error = 0; struct file *file = priv; struct eventpoll *ep = file-&gt;private_data; struct eventpoll *ep_tovisit; struct rb_node *rbp; struct epitem *epi; mutex_lock_nested(&amp;ep-&gt;mtx, call_nests + 1); ep-&gt;visited = 1; //标志当前为已遍历 list_add(&amp;ep-&gt;visited_list_link, &amp;visited_list); //遍历所有ep监视的文件 for (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) &#123; epi = rb_entry(rbp, struct epitem, rbn); if (unlikely(is_file_epoll(epi-&gt;ffd.file))) &#123; ep_tovisit = epi-&gt;ffd.file-&gt;private_data; if (ep_tovisit-&gt;visited) //跳过先前已遍历的，避免循环检查 continue; //所有ep监视的未遍历的epoll error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS, ep_loop_check_proc, epi-&gt;ffd.file, ep_tovisit, current); if (error != 0) break; &#125; else &#123; //文件不在file-&gt;tfile_check_list中，添加 //最外层的epoll需要检查epoll监视的文件 if (list_empty(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink)) list_add(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink, &amp;tfile_check_list); &#125; &#125; mutex_unlock(&amp;ep-&gt;mtx); return error;&#125; 唤醒风暴当文件状态发生改变时，会唤醒监听在其上的epoll文件，而这个epoll文件还可能唤醒其他的epoll文件，这种连续的唤醒就形成了一个唤醒路径，所有的唤醒路径就形成了一个有向图。如果文件对应的epoll唤醒有向图的节点过多，那么文件状态的改变就会唤醒所有的这些epoll(可能会唤醒很多进程，这样的开销是很大的)，而实际上一个文件经过少数epoll处理以后就可能从就绪转到未就绪，剩余的epoll虽然认为文件已就绪而实际上经过某些处理后已不可用。epoll的实现中考虑到了此问题，在每次添加新文件到epoll中时，就会首先检查是否会出现这样的唤醒风暴。该函数的实现逻辑是这样的，递归调用reverse_path_check_proc遍历监听在当前文件上的epoll文件，在reverse_pach_check_proc中统计并检查不同路径深度上epoll的个数，从而避免产生唤醒风暴。 12345678910111213141516171819static int reverse_path_check(void)&#123; int length = 0; int error = 0; struct file *current_file; //遍历全局tfile_chack_list中的文件，第一级 list_for_each_entry(current_file, &amp;tfile_check_list, f_tfile_llink) &#123; length++; //初始化 path_count_init(); //限制递归的深度，并检查每个深度上唤醒的epoll数量 error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS, reverse_path_check_proc, current_file, current_file, current); if (error) break; &#125; return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static int reverse_path_check_proc(void *priv, void *cookie, int call_nests)&#123; int error = 0; struct file *file = priv; struct file *child_file; struct epitem *epi; list_for_each_entry(epi, &amp;file-&gt;f_ep_links, fllink) &#123; //遍历监视file的epoll child_file = epi-&gt;ep-&gt;file; if (is_file_epoll(child_file)) &#123; if (list_empty(&amp;child_file-&gt;f_ep_links)) &#123; //没有其他的epoll监视当前的这个epoll，已经是叶子了 if (path_count_inc(call_nests)) &#123; error = -1; break; &#125; &#125; else &#123; //遍历监视这个epoll文件的epoll，递归调用 error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS, reverse_path_check_proc, child_file, child_file, current); &#125; if (error != 0) break; &#125; else &#123; printk(KERN_ERR \"reverse_path_check_proc: \" \"file is not an ep!\\n\"); &#125; &#125; return error;&#125;#define PATH_ARR_SIZE 5//深度限制static const int path_limits[PATH_ARR_SIZE] = &#123; 1000, 500, 100, 50, 10 &#125;;//计算出来的深度static int path_count[PATH_ARR_SIZE];static int path_count_inc(int nests)&#123; if (nests == 0) return 0; if (++path_count[nests] &gt; path_limits[nests]) return -1; return 0;&#125;static void path_count_init(void)&#123; int i; for (i = 0; i &lt; PATH_ARR_SIZE; i++) path_count[i] = 0;&#125; epoll_create和epoll_ctl函数调用过程 epoll_wait函数调用主要过程 epoll结构体间关系","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Linux I/O 复用 poll源码解析","slug":"io-4-poll","date":"2017-09-21T01:15:00.000Z","updated":"2020-04-12T04:56:36.120Z","comments":true,"path":"2017/09/21/io-4-poll/","link":"","permalink":"http://www.casezheng.date/2017/09/21/io-4-poll/","excerpt":"","text":"Linux I/O poll 源码分析 poll poll系统调用的函数调用过程 poll系统调用图解 pollpoll函数系统调用1234567891011121314151617181920212223242526272829303132333435363738394041int poll(struct polled* fds, nfds_t nfds, int timeout);struct pollfd &#123; int fd; short events; short revents;&#125;;SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds, long, timeout_msecs)&#123; struct timespec end_time, *to = NULL; int ret; //计算timespec类型的超时时间 if (timeout_msecs &gt;= 0) &#123; to = &amp;end_time; poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC, NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC)); &#125; ret = do_sys_poll(ufds, nfds, to); //重要函数，返回就绪的文件描述符的总数 // do_sys_poll 被信号中断, 重新调用, 对使用者来说 poll 是不会被信号中断的. if (ret == -EINTR) &#123; struct restart_block *restart_block; restart_block = &amp;current_thread_info()-&gt;restart_block; restart_block-&gt;fn = do_restart_poll; //设置重启的函数 restart_block-&gt;poll.ufds = ufds; restart_block-&gt;poll.nfds = nfds; if (timeout_msecs &gt;= 0) &#123; restart_block-&gt;poll.tv_sec = end_time.tv_sec; restart_block-&gt;poll.tv_nsec = end_time.tv_nsec; restart_block-&gt;poll.has_timeout = 1; &#125; else restart_block-&gt;poll.has_timeout = 0; // ERESTART_RESTARTBLOCK 不会返回给用户进程, 而是会被系统捕获, 然后调用 do_restart_poll ret = -ERESTART_RESTARTBLOCK; &#125; return ret;&#125; 123456789101112131415161718192021static long do_restart_poll(struct restart_block *restart_block)&#123; struct pollfd __user *ufds = restart_block-&gt;poll.ufds; int nfds = restart_block-&gt;poll.nfds; struct timespec *to = NULL, end_time; int ret; if (restart_block-&gt;poll.has_timeout) &#123; end_time.tv_sec = restart_block-&gt;poll.tv_sec; end_time.tv_nsec = restart_block-&gt;poll.tv_nsec; to = &amp;end_time; &#125; ret = do_sys_poll(ufds, nfds, to); if (ret == -EINTR) &#123; restart_block-&gt;fn = do_restart_poll; ret = -ERESTART_RESTARTBLOCK; &#125; return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds, struct timespec *end_time)&#123; struct poll_wqueues table; int err = -EFAULT, fdcount, len, size; //首先使用栈上的空间，加速访问 long stack_pps[POLL_STACK_ALLOC/sizeof(long)]; //long stack_pps[64]; /* struct poll_list &#123; struct poll_list *next; int len; //本poll_list的entries长度 struct pollfd entries[0]; &#125;; */ struct poll_list *const head = (struct poll_list *)stack_pps; struct poll_list *walk = head; unsigned long todo = nfds; if (nfds &gt; current-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur) return -EINVAL; // 文件描述符数量超过当前进程限制 len = min_t(unsigned int, nfds, N_STACK_PPS); //计算链表头结点的entries数组长度 for (;;) &#123; //将用户空间的pollfd全部拷贝到内核空间 walk-&gt;next = NULL; walk-&gt;len = len; if (!len) break; //当用户传入的fd很多时，由于poll系统调用每次都要把所有struct pollfd拷进内核，所以参数传递和页分配此时就成了poll系统调用的性能瓶颈。 if (copy_from_user(walk-&gt;entries, ufds + nfds-todo, sizeof(struct pollfd) * walk-&gt;len)) //拷贝前walk-&gt;len个 goto out_fds; todo -= walk-&gt;len; //计算未拷贝的pollfd个数 if (!todo) break; //全部已拷贝，退出 len = min(todo, POLLFD_PER_PAGE); //计算个数 size = sizeof(struct poll_list) + sizeof(struct pollfd) * len; //计算申请空间的大小 walk = walk-&gt;next = kmalloc(size, GFP_KERNEL); //在堆上申请空间 if (!walk) &#123; err = -ENOMEM; goto out_fds; &#125; &#125; //初始化table，设置函数指针table.pt.qproc为__pollwait poll_initwait(&amp;table); fdcount = do_poll(nfds, head, &amp;table, end_time); poll_freewait(&amp;table); for (walk = head; walk; walk = walk-&gt;next) &#123; struct pollfd *fds = walk-&gt;entries; int j; for (j = 0; j &lt; walk-&gt;len; j++, ufds++) if (__put_user(fds[j].revents, &amp;ufds-&gt;revents)) goto out_fds; &#125; err = fdcount;out_fds: walk = head-&gt;next; while (walk) &#123; struct poll_list *pos = walk; walk = walk-&gt;next; kfree(pos); &#125; return err;&#125; 1234567891011121314void poll_initwait(struct poll_wqueues *pwq)&#123; init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait); pwq-&gt;polling_task = current; pwq-&gt;triggered = 0; pwq-&gt;error = 0; pwq-&gt;table = NULL; pwq-&gt;inline_index = 0;&#125;static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)&#123; pt-&gt;qproc = qproc; //__pollwait pt-&gt;key = ~0UL; /* all events enabled */&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int do_poll(unsigned int nfds, struct poll_list *list, struct poll_wqueues *wait, struct timespec *end_time)&#123; poll_table* pt = &amp;wait-&gt;pt; ktime_t expire, *to = NULL; int timed_out = 0, count = 0; unsigned long slack = 0; if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123; //已超时 pt = NULL; //不执行__pollwait timed_out = 1; //不睡眠 &#125; if (end_time &amp;&amp; !timed_out) //计算睡眠时间，纳秒 slack = estimate_accuracy(end_time); for (;;) &#123; struct poll_list *walk; for (walk = list; walk != NULL; walk = walk-&gt;next) &#123; //遍历整个链表 struct pollfd * pfd, * pfd_end; pfd = walk-&gt;entries; pfd_end = pfd + walk-&gt;len; for (; pfd != pfd_end; pfd++) &#123; //遍历一个节点中的entries数组 //当用户传入的fd很多时，对do_pollfd就会调用很多次，poll效率瓶颈的另一原因就在这里。 if (do_pollfd(pfd, pt)) &#123; count++; //就绪文件描述符个数加1 pt = NULL; //有文件描述符就绪，进程不需要再睡眠了，所以不需要再给后面文件的wait queue中添加唤醒函数了 &#125; &#125; &#125; pt = NULL; //所有的文件描述符都已执行__pollwait，以后不再执行 if (!count) &#123; //若count为0（表示无文件描述符就绪） count = wait-&gt;error; //count = 0； //当用户程序在调用poll后挂起时，发信号可以让程序迅速退出poll调用，而通常的系统调用是不会被信号打断的。 if (signal_pending(current)) //判断是否为信号唤醒 count = -EINTR; &#125; if (count || timed_out) //有文件描述符就绪 或者 进程不再睡眠 break; if (end_time &amp;&amp; !to) &#123; //仅首次循环时执行，超时时间转换，转换为内核时间 expire = timespec_to_ktime(*end_time); to = &amp;expire; &#125; //当前进程从这里进入睡眠，等待直到超时，或由回调函数唤醒，喊醒后文件等待队列中的等待 //队列项并不清除，到后边统一清除 //超时，返回0；被唤醒，返回-EINTR if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack)) timed_out = 1; &#125;return count;&#125; 123456789101112131415161718192021222324252627282930313233static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait)&#123; unsigned int mask; int fd; mask = 0; fd = pollfd-&gt;fd; //得到要检测文件的文件描述符 if (fd &gt;= 0) &#123; //检测fd的正确性 int fput_needed; struct file * file; //从当前进程描述符中取得文件结构，并增加引用计数 file = fget_light(fd, &amp;fput_needed); mask = POLLNVAL; //初始化，文件描述符没有打开 if (file != NULL) &#123; //#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM) mask = DEFAULT_POLLMASK; if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;poll) &#123; if (pwait) //设置当前fd待检测的事件掩码 pwait-&gt;key = pollfd-&gt;events | POLLERR | POLLHUP; //获取当前的就绪状态，并添加进程到文件的对应等待队列中 mask = file-&gt;f_op-&gt;poll(file, pwait); &#125; //去除不关心的状态掩码 mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP; //释放通过fget_light得到的file指针，实际就是减少引用计数 fput_light(file, fput_needed); &#125; &#125; //记录当前fd的就绪状态 pollfd-&gt;revents = mask; return mask;&#125; select用位图组织文件描述符和事件掩码，而poll用链表+数组的形式 要检测的文件描述符多的情况下，select全部用堆上的空间，poll用栈空间和堆空间 select可以被信号终止，poll不能被信号终止，会重新启动 poll系统调用的函数调用过程 poll系统调用图解","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Linux I/O 复用 select源码解析","slug":"io-3-select","date":"2017-09-20T05:19:00.000Z","updated":"2020-04-12T04:56:36.118Z","comments":true,"path":"2017/09/20/io-3-select/","link":"","permalink":"http://www.casezheng.date/2017/09/20/io-3-select/","excerpt":"","text":"Linux I/O select 源码分析 select select系统调用的具体实现过程图解： select结构体依赖关系 selectselect系统调用原型：12345678910111213int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);struct timeval &#123; long tv_sec; //秒 long tv_usec; //微秒 10E-6秒&#125;;struct timespec &#123; long tv_sec; //秒 long tv_nsec; //纳秒 10E-9秒&#125;;typedef struct&#123; unsigned long fds_bits [1024/(8 * sizeof(unsigned long))]; //unsigned long fds_bits[32] //32*4*8 = 1024&#125;fd_set; select实现在fs/select.c中，源码如下：12345678910111213141516171819202122//select主流程函数SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,fd_set __user *, exp, struct timeval __user *, tvp)&#123; struct timespec end_time, *to = NULL; struct timeval tv; int ret; if (tvp) &#123; //超时时间非空 if (copy_from_user(&amp;tv, tvp, sizeof(tv))) //把超时时间从用户空间复制到内核空间 return -EFAULT; to = &amp;end_time; //计算timespec类型的超时时间 if (poll_select_set_timeout(to, tv.tv_sec + (tv.tv_usec / USEC_PER_SEC), (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC)) return -EINVAL; &#125; ret = core_sys_select(n, inp, outp, exp, to); //select实现的核心函数 //复制剩余的超时时间拷贝到用户空间 ret = poll_select_copy_remaining(&amp;end_time, tvp, 1, ret); return ret; //返回就绪的文件描述符的个数&#125; core_sys_select实现select事件监听的主要功能。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timespec *end_time)&#123; fd_set_bits fds; /* typedef struct &#123; unsigned long *in, *out, *ex; unsigned long *res_in, *res_out, *res_ex; &#125; fd_set_bits; */ void *bits; int ret, max_fds; unsigned int size; struct fdtable *fdt; /* struct fdtable &#123; //进程的文件描述符表 unsigned int max_fds; struct file ** fd; //文件对象指针数组,长度放在max_fds中 fd_set *close_on_exec; fd_set *open_fds; struct rcu_head rcu; struct fdtable *next; &#125;; */ long stack_fds[SELECT_STACK_ALLOC/sizeof(long)]; //long stack_fds[64]; ret = -EINVAL; if (n &lt; 0) goto out_nofds; rcu_read_lock(); //加锁 //取得进程中的fdtable(文件描述符表) fdt = files_fdtable(current-&gt;files); max_fds = fdt-&gt;max_fds; //取得系统当前允许的最大文件描述符 rcu_read_unlock(); //解锁 if (n &gt; max_fds) //如果传入的n大于当前进程最大的文件描述符，修改n n = max_fds; size = FDS_BYTES(n); //按一个文件描述符一个bit位计算一个字段所需字节数 /* #define FDS_BITPERLONG (8*sizeof(long)) #define FDS_LONGS(nr) (((nr)+FDS_BITPERLONG-1)/FDS_BITPERLONG) #define FDS_BYTES(nr) (FDS_LONGS(nr)*sizeof(long)) */ bits = stack_fds; //bits先指向栈上空间，小对象使用栈上空间 if (size &gt; sizeof(stack_fds) / 6) &#123; //栈上空间不足，全部使用堆上空间，使用kmalloc申请空间 ret = -ENOMEM; bits = kmalloc(6 * size, GFP_KERNEL); if (!bits) goto out_nofds; &#125; fds.in = bits; fds.out = bits + size; fds.ex = bits + 2*size; fds.res_in = bits + 3*size; fds.res_out = bits + 4*size; fds.res_ex = bits + 5*size; //从用户空间拷贝fd_set到内核空间，调用copy_from_user() if ((ret = get_fd_set(n, inp, fds.in)) || (ret = get_fd_set(n, outp, fds.out)) || (ret = get_fd_set(n, exp, fds.ex))) goto out; //将存放返回状态的字段清0 zero_fd_set(n, fds.res_in); zero_fd_set(n, fds.res_out); zero_fd_set(n, fds.res_ex); ret = do_select(n, &amp;fds, end_time); //核心函数 if (ret &lt; 0) //有错误 goto out; if (!ret) &#123; //ret == 0，没有设备就绪 ret = -ERESTARTNOHAND; if (signal_pending(current)) goto out; ret = 0; &#125; //将结果从内核空间拷贝到用户空间，调用__copy_to_user() if (set_fd_set(n, inp, fds.res_in) || set_fd_set(n, outp, fds.res_out) || set_fd_set(n, exp, fds.res_ex)) ret = -EFAULT;out: //如果申请了空间kmalloc，释放空间 if (bits != stack_fds) kfree(bits);out_nofds: return ret; //返回就绪的文件描述符的个数&#125; 一些select内核实现需要了解的数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243struct poll_wqueues &#123; //非常重要，一个调用select()的应用程序只存在一个poll_wqueues结构体， //用来统一辅佐实现这个进程中所有待检测的fd的轮询工作 poll_table pt; struct poll_table_page *table; //动态申请的物理页挂在它上 struct task_struct *polling_task; //保存当前调用select的用户进程struct task_struct结构体 //struct task_struct即进程控制块PCB结构 int triggered; // 当前用户进程被唤醒后置成1，以免该进程接着进睡眠 int error; //错误码 int inline_index; //数组inline_entries的引用下标 struct poll_table_entry inline_entries[N_INLINE_POLL_ENTRIES];&#125;;typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);typedef struct poll_table_struct &#123; poll_queue_proc qproc; unsigned long key;&#125; poll_table;struct poll_table_page &#123; //申请的物理页都会将起始地址强制转换成该结构体指针 struct poll_table_page * next; //指向下一个申请的物理页 struct poll_table_entry * entry; //指向entries[]中首个待分配(空的)poll_table_entry结构 struct poll_table_entry entries[0]; //该page页后边都是待分配的poll_table_entry结构体&#125;;struct poll_table_entry &#123; //每个fd的都有一个该结构体 struct file *filp; //指向特定fd对应的file结构体 unsigned long key; //等待特定fd对应硬件设备的事件掩码 wait_queue_t wait; //代表调用select()的应用进程，等待在fd对应设备的特定事件（读或 //写）的等待队列头上的等待队列项 wait_queue_head_t *wait_address; //设备驱动程序中特定事件的等待队列头&#125;;typedef struct __wait_queue wait_queue_t;typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);struct __wait_queue &#123; //等待队列项 unsigned int flags; //标记该等待的进程是互斥进程还是非互斥进程#define WQ_FLAG_EXCLUSIVE 0x01 //互斥进程 void *private; //指向poll_wqueues wait_queue_func_t func; //等待队列的回调函数 struct list_head task_list; //链表的前向和后向指针&#125;;struct __wait_queue_head &#123; //等待队列头 spinlock_t lock; //锁 struct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t;struct list_head &#123; struct list_head *next, *prev;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127int do_select(int n, fd_set_bits *fds, struct timespec *end_time)&#123; ktime_t expire, *to = NULL; struct poll_wqueues table; poll_table *wait; int retval, i, timed_out = 0; unsigned long slack = 0; rcu_read_lock(); //检查fds中fd的有效性（要求fd必须打开），并获取当前最大的fd retval = max_select_fd(n, fds); rcu_read_unlock(); if (retval &lt; 0) return retval; n = retval; //初始化table，设置函数指针table.pt.qproc为__pollwait poll_initwait(&amp;table); wait = &amp;table.pt; //超时时间设为0时 if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123; wait = NULL; //不执行__pollwait timed_out = 1; //timed_out设置为1，表示已超时。 &#125; if (end_time &amp;&amp; !timed_out) //设置的超时时间不为0 //超时时间转换 slack = estimate_accuracy(end_time); retval = 0; for (;;) &#123; unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp; inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex; rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex; //遍历所有的描述符（n个），i文件描述符 从这里可以看出select使用了遍历的方式 for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) &#123; unsigned long in, out, ex, all_bits, bit = 1, mask, j; unsigned long res_in = 0, res_out = 0, res_ex = 0; //file_operations定义了一系列对字符设备的操作方法 const struct file_operations *f_op = NULL; struct file *file = NULL; //检查当前的位置中的描述符 in = *inp++; out = *outp++; ex = *exp++; all_bits = in | out | ex; //组合要监测的事件 if (all_bits == 0) &#123; //没有需要监测的描述符，下一个位置 // #define __NFDBITS (8 * sizeof(unsigned long)) i += __NFDBITS; continue; &#125; //每次循环32次 4字节 32个位 使用位图的方式 for (j = 0; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= 1) &#123; //第一次bit==1 int fput_needed; if (i &gt;= n) //是否超出了最大待检测的fd break; //不需要监听描述符i，直接跳过 if (!(bit &amp; all_bits)) continue; //根据i指定的索引，从当前进程描述符中取得文件结构，并增加引用计数 file = fget_light(i, &amp;fput_needed); if (file) &#123; //file存在 f_op = file-&gt;f_op; //#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM) mask = DEFAULT_POLLMASK; if (f_op &amp;&amp; f_op-&gt;poll) &#123; //设置当前fd待检测的事件掩码，wait-&gt;key wait_key_set(wait, in, out, bit); //获取当前的就绪状态，并添加进程到文件的对应等待队列中 mask = (*f_op-&gt;poll)(file, wait); &#125; //释放通过fget_light得到的file指针，实际就是减少引用计数 fput_light(file, fput_needed); //检测文件i是否已有事件就绪 //mask是每一个 (*f_op-&gt;poll)()程序返回的设备状态掩码 if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123; //mask&amp;POLLIN_SET该文件是否可写，in&amp;bit应用程序是否关心该文件可写 res_in |= bit; //fd对应的设备可写 retval++; //就绪的文件描述符个数加1 //如果已有就绪事件就不再向其他文件的等待队列中添加回调函数。 //避免重复执行__pollwait() wait = NULL; &#125; if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123; res_out |= bit; retval++; wait = NULL; &#125; if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123; res_ex |= bit; retval++; wait = NULL; &#125; &#125; &#125; //根据poll()的结果，写回到输出字段里面 if (res_in) *rinp = res_in; if (res_out) *routp = res_out; if (res_ex) *rexp = res_ex; cond_resched(); &#125; wait = NULL; //避免重复执行__pollwait() //有设备就绪或有异常 || 超时 || 有终止信号出现 if (retval || timed_out || signal_pending(current)) break; if (table.error) &#123; retval = table.error; break; &#125; //第一轮循环，时间的转换timespec到ktime if (end_time &amp;&amp; !to) &#123; expire = timespec_to_ktime(*end_time); to = &amp;expire; &#125; //当前进程从这里进入睡眠，等待直到超时，或由注册的函数唤醒超时，返回0；被唤醒，返回-EINTR if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE, to, slack)) timed_out = 1; //超时后，将timed_out设为1，再遍历一次文件描述符后，退出循环 &#125; //清除等待队列 poll_freewait(&amp;table); return retval; //返回就绪的文件描述符的个数&#125; 1234567891011121314void poll_initwait(struct poll_wqueues *pwq)&#123; init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait); pwq-&gt;polling_task = current; pwq-&gt;triggered = 0; pwq-&gt;error = 0; pwq-&gt;table = NULL; pwq-&gt;inline_index = 0;&#125;static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)&#123; pt-&gt;qproc = qproc; //__pollwait pt-&gt;key = ~0UL; /* all events enabled */&#125; 1234567891011121314#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)#define POLLEX_SET (POLLPRI)static inline void wait_key_set(poll_table *wait, unsigned long in, unsigned long out, unsigned long bit)&#123; if (wait) &#123; wait-&gt;key = POLLEX_SET; if (in &amp; bit) wait-&gt;key |= POLLIN_SET; if (out &amp; bit) wait-&gt;key |= POLLOUT_SET; &#125;&#125; poll 方法是3 个系统调用的后端:poll, epoll, 和select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞.poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的,并且,可能地,提供给内核信息用来使调用进程睡眠直到I/O 变为可能.如果一个驱动的poll 方法为NULL, 设备假定为不阻塞地可读可写.首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后，返回表示是否能对设备进行无阻塞读写访问的掩码。把当前进程添加到wait_address参数指定的等待列表中。需要注意的是这个函数是不会引起阻塞的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647unsigned int (*poll) (struct file *, struct poll_table_struct *); //设备驱动static unsigned int evdev_poll(struct file *file, poll_table *wait)&#123; struct evdev_client *client = file-&gt;private_data; struct evdev *evdev = client-&gt;evdev; poll_wait(file, &amp;evdev-&gt;wait, wait); return ((client-&gt;head == client-&gt;tail) ? 0 : (POLLIN | POLLRDNORM)) | (evdev-&gt;exist ? 0 : (POLLHUP | POLLERR));&#125;static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)&#123; if (p &amp;&amp; wait_address) p-&gt;qproc(filp, wait_address, p); //__pollwait&#125;//filp特定fd对应的file结构体指针//wait 特定fd对应的硬件驱动程序中的等待队列头指针//p 调用select()的应用程序中poll_wqueues结构体的poll_table项static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,poll_table *p)&#123; //通过container_of宏得到结构体poll_wqueues的地址 struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt); //调用poll_get_entry()得到一个poll_table_entry结构体 //空间不足，动态申请物理内存页，以链表的形式挂在poll_wqueues.table上统一管理。 struct poll_table_entry *entry = poll_get_entry(pwq); if (!entry) return; get_file(filp); entry-&gt;filp = filp; // 保存对应的file结构体 entry-&gt;wait_address = wait_address; // 保存来自设备驱动程序的等待队列头 entry-&gt;key = p-&gt;key; // 保存对该fd关心的事件掩码 // 初始化等待队列项，pollwake是唤醒该等待队列项时候调用的函数 init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);//static inline void init_waitqueue_func_entry(wait_queue_t *q,wait_queue_func_t func)//&#123;// q-&gt;flags = 0; //设为非互斥进程// q-&gt;private = NULL;// q-&gt;func = func;//&#125; //等待队列项private指向poll_wqueues entry-&gt;wait.private = pwq; //将该等待队列项添加到从驱动程序中传递过来的等待队列头中去 //即：设置等待的进程为非互斥进程，并将其添加进等待队列头的队头中 add_wait_queue(wait_address, &amp;entry-&gt;wait);&#125; 12345678910111213141516171819void poll_freewait(struct poll_wqueues *pwq)&#123; struct poll_table_page * p = pwq-&gt;table; int i; for (i = 0; i &lt; pwq-&gt;inline_index; i++) free_poll_entry(pwq-&gt;inline_entries + i); while (p) &#123; struct poll_table_entry * entry; struct poll_table_page *old; entry = p-&gt;entry; do &#123; entry--; free_poll_entry(entry); &#125; while (entry &gt; p-&gt;entries); old = p; p = p-&gt;next; free_page((unsigned long) old); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243int poll_schedule_timeout(struct poll_wqueues *pwq, int state, ktime_t *expires, unsigned long slack)&#123; int rc = -EINTR; set_current_state(state); //设置当前进程的状态state = TASK_INTERRUPTIBLE,有可能在尚 //未到期时由其它信号唤醒进程从而导致函数返回 if (!pwq-&gt;triggered) //只要有一个fd对应的设备将当前进程唤醒，将会把triggered设置为1 rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS); __set_current_state(TASK_RUNNING); set_mb(pwq-&gt;triggered, 0); return rc;&#125;//唤醒的时候调用pollwakestatic int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)&#123; struct poll_table_entry *entry; //取得文件对应的poll_table_entry entry = container_of(wait, struct poll_table_entry, wait); //过滤不关心的事件,防止应用进程被误唤醒 if (key &amp;&amp; !((unsigned long)key &amp; entry-&gt;key)) return 0; //唤醒 return __pollwake(wait, mode, sync, key);&#125;static int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)&#123; struct poll_wqueues *pwq = wait-&gt;private; //定义一个wait_queue_t类型的变量dummy_wait，并初始化 DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task); //#define __WAITQUEUE_INITIALIZER(name, tsk) &#123; \\ // .private = tsk, \\ // .func = default_wake_function, \\ // .task_list = &#123; NULL, NULL &#125; &#125; //#define DECLARE_WAITQUEUE(name, tsk) \\ // wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) smp_wmb(); pwq-&gt;triggered = 1; //标记为已触发 //唤醒函数 return default_wake_function(&amp;dummy_wait, mode, sync, key);&#125; select系统调用的具体实现过程图解： select结构体依赖关系","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Linux I/O select、poll、epoll的使用方式和优缺点","slug":"io-2-multiplexing","date":"2017-09-18T14:55:00.000Z","updated":"2020-04-12T04:56:36.111Z","comments":true,"path":"2017/09/18/io-2-multiplexing/","link":"","permalink":"http://www.casezheng.date/2017/09/18/io-2-multiplexing/","excerpt":"","text":"Linux I/O select、poll、epoll的使用方式和优缺点 I/O复用I/O复用使得程序可以同时监听多个文件描述符，对提升程序性能至关重要。I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。多个文件描述符同时就绪，如果不采取措施，程序只能顺序以此处理其中的每个文件描述符，使得服务器看起来像是串行工作。如果要实现并发，只能使用多进程或多线程等编程手段。 Linux下实现I/O复用的系统调用主要有select、poll和epoll。 selectselect 系统调用的用途：在一段时间内，监听用户感兴趣的文件描述符的可读、可写和异常等事件。select系统调用的原型：12int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds通常被设置为selcet监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。 readfds、writefds、exceptfds分别指向可读、可写、异常等事件对应的文件描述符集合。fd_set结构体仅包含一个整数数组，数组中每个元素的每一个位标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，限制了select能同时处理的文件描述符的总量。linux定义了一系列的宏来访问fd_set结构体中的位。 1234void FD_CLR(int fd, fd_set *set);int FD_ISSET(int fd, fd_set *set);void FD_SET(int fd, fd_set *set);void FD_ZERO(fd_set *set); timeout用来设置select函数的超时时间。是timeval结构体类型的指针。内核修改它告诉应用程序select等待了多长时间，这个timeval的返回指不能完全信任，比如调用失败时timeval值是不确定的。 1234struct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */&#125;; 由定义可见，select提供了微秒级的定时方式，如果给timeout变量的tv_sec成员和tv_usec成员都传递0，select将立即返回。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1,并设置errno为EINTR。 网络编程中socket可读的情况： socket内核接收缓冲区中的字节数大于或等于其低水位标记SO_REVLOWAT。此时可以无阻塞地读socket，并且读操作返回的字节数大于0。 socket通信的对方关闭连接。此时对该socket的读操作返回0。 监听socket上有新的连接请求。 socket上有未处理的错误。可用getsockopt来读取和清除错误。 网络编程中socket可写的情况： socket内核发送缓存区中的可用字节数大于或等于其最低水位标记SO_SNDLOWAT。此时可以无阻塞的写该socket，并且写操作返回的字节数大于0。 socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。 socket使用非阻塞connect连接成功或失败（超时）之后。 socket上由未处理的错误。可使用getsockopt来读取和清楚该错误。 网络编程中异常情况只有一种：socket上接收到带外数据。 pollpoll原型：12#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout); fds是pollfd结构类型的数组，指定所有感兴趣的文件描述符上发生的可读、可写和异常等时间。12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; fd成员指定文件描述符 events告诉poll监听fd的哪些事件 revents由内核修改，通知引用程序fd上实际发生了哪些事件 poll支持的事件： 事件 描述 是否可作为输入 是否可作为输出 POLLIN 数据（包括普通数据和优先数据）可读 是 是 POLLRDNORM 普通数据可读 是 是 POLLRDBAND 优先级带数据可读（Linux）不支持 是 是 POLLPRI 高优先级数据可读，比如TCP带外数据 是 是 POLLOUT 数据（包括普通数据和优先数据）可写 是 是 POLLWRNORM 普通数据可写 是 是 POLLWRBAND 优先级带数据可写 是 是 POLLRDHUP TCP连接被对方关闭，或者对方关闭了写操作，由GNU引入 是 是 POLLERR 错误 否 是 POLLHUP 挂起。比如通道的写端被关闭后，读端描述符将收到POLLHUP事件 否 是 POLLNVAL 文件描述符没有打开 否 是 nfds参数指定被监听事件集合fds的大小。timeout参数指定poll的超时时间，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。poll系统调用的返回值含义与select相同。 epollepoll维持一个内核事件表。epoll是Linux特有的I/O复用函数。epoll使用一组函数来完成任务。epoll将用户关心的文件描述符上的事件放在内核的一个事件表里。不需要像select和poll每次调用都重复传入文件描述符集或事件集。但epool需要一个额外的文件描述符，来唯一标识内核中的事件表。内核事件表使用epoll_create函数创建。12#include &lt;sys/epoll.h&gt;int epoll_create(int size); size并不起作用，只是给内核一个提示，告诉其内核事件表的期望大小。操作内核事件表：1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); fd参数是要操作的文件描述符，op参数则指定操作类型。操作类型有如下3种： EPOLL_CTL_ADD 往事件表注册fd上的事件 EPOLL_CTL_MOD 修改fd上的注册事件 EPOLL_CTL_DEL 删除fd上的注册事件 event参数指定事件，是epoll_event结构指针类型。12345678910typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events epoll事件*/ epoll_data_t data; /* User data variable 用户数据*/&#125;; epoll支持的事件类型和poll基本相同，表示epoll类型的宏是在poll对应的宏前加上”E”。epoll两个额外的事件类型——EPOLLET和EPOLLONESHOT。epoll_ctl成功返回0,失败返回-1并设置errno。epoll_wait函数在一段时间内等待一组文件描述符上的事件。该函数返回就绪的文件描述符的个数，失败返回-1并设置errno。12int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); maxevents指定最多监听多少个事件，必须大于0。epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表复制到events所指的数组中。 poll和epoll如何索引就绪文件描述符：poll必须遍历所有已注册文件描述符并找到其中的就绪者。epoll仅遍历就绪的ret个文件描述符。 epoll对文件描述符的操作有两种模式：LT（电平触发）模式和ET（边沿触发）模式。LT是默认的工作模式，错误率比较小。LT模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作文件描述符。ET是epoll的高效工作模式，错误率较大。LT模式下，epoll_wait检测到事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件，下次调用epoll_wait时，epoll_wait还会再次通知该应用程序事件，直到事件被处理。ET模式下，epoll_wait检测到事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件。每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作就会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。因为ET模式只通知以此，所以需要循环读、循环写，如果时阻塞模式当不能读写的时候会阻塞，所以要设置非阻塞模式。epoll的EPOLLONESHOT事件，注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上的注册的一个可读、可写或者异常事件，且只触发一次。 select、poll、epoll的对比 系统调用 select poll epoll 事件集合 用户通过3个参数分别出入感兴趣的可读、可写、异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。使得用户每次调用select都要重置这3个参数。 统一处理所有事件类型，因此只需要一个事件参数集合。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件 内核通过一个事件表直接管理用户感兴趣的所有事件。每次调用epoll_wait时，无须重复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件。 应用程序索引就绪文件描述符的时间复杂度 O(n) O(n) O(1) 最大支持文件描述符数 一般由最大值限制 65535 65535 工作模式 LT LT 支持ET高效模式 内核实现和工作效率 采用轮询方式来检测就绪事件，算法复杂度O(n) 采用轮询方式来检测就绪事件，算法时间复杂度O(n） 采用回调方式来检测就绪事件，算法时间复杂度为O(1) 简单实现client12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/select.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; int clisock = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9999); servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); if(connect(clisock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; cout&lt;&lt;\"connect error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; cout&lt;&lt;\"connect succ \"&lt;&lt;endl; fd_set rfds; fd_set wfds; struct timeval tv; tv.tv_sec = 5; int retval; char buff[1024] = &#123;0&#125;; string input; //命令行输入 string serinput; //服务器返回 while(1) &#123; FD_ZERO(&amp;rfds); FD_ZERO(&amp;wfds); FD_SET(0, &amp;rfds); FD_SET(1, &amp;wfds); FD_SET(clisock, &amp;rfds); FD_SET(clisock, &amp;wfds); retval = select(clisock+1, &amp;rfds, &amp;wfds, NULL, &amp;tv); if(retval == -1) &#123; cout&lt;&lt;\"select error \"&lt;&lt;errno&lt;&lt;endl; &#125; else &#123; if(FD_ISSET(0, &amp;rfds)) &#123; cout&lt;&lt;\"可读\"&lt;&lt;endl; cin&gt;&gt;input; &#125; if(FD_ISSET(1, &amp;wfds) &amp;&amp; !serinput.empty()) &#123; cout&lt;&lt;\"server return: \"&lt;&lt;serinput&lt;&lt;endl; serinput.clear(); &#125; if(FD_ISSET(clisock, &amp;rfds)) &#123; char buffer[1024] = &#123;0&#125;; if(recv(clisock, buffer, sizeof(buffer), 0) &lt; 0) &#123; close(clisock); cout&lt;&lt;\"close \"&lt;&lt;clisock&lt;&lt;endl; return 0; &#125; serinput = string(buffer); &#125; if(FD_ISSET(clisock, &amp;wfds) &amp;&amp; !input.empty()) &#123; if(send(clisock, input.c_str(), input.size(), 0) &gt; 0) &#123; cout&lt;&lt;\"send \"&lt;&lt;input&lt;&lt;endl; &#125; else &#123; close(clisock); cout&lt;&lt;\"close \"&lt;&lt;clisock&lt;&lt;endl; &#125; input.clear(); &#125; &#125; &#125; return 0;&#125; select_server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/select.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; int sersock = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9999); servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int on = 1; setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); if(bind(sersock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; cout&lt;&lt;\"bind error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; if(listen(sersock, 5) == -1) &#123; cout&lt;&lt;\"listen error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; fd_set rfds; fd_set wfds; struct timeval tv; int retval; char buff[1024] = &#123;0&#125;; map&lt;int, string&gt; clisock; while(1) &#123; int maxfd = sersock; FD_ZERO(&amp;rfds); FD_ZERO(&amp;wfds); FD_SET(sersock, &amp;rfds); for( auto pairs : clisock) &#123; int c = pairs.first; string s = pairs.second; FD_SET(c, &amp;rfds); if(!s.empty()) &#123; cout&lt;&lt;\"s info: \"&lt;&lt;s&lt;&lt;endl; FD_SET(c, &amp;wfds); &#125; cout&lt;&lt;\"set fd: \"&lt;&lt;c&lt;&lt;endl; maxfd = c&gt;maxfd ? c : maxfd; &#125; tv.tv_sec = 5; retval = select(maxfd+1, &amp;rfds, &amp;wfds, NULL, &amp;tv); if(retval &lt; -1) &#123; cout&lt;&lt;\"select error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; else &#123; if(FD_ISSET(sersock, &amp;rfds)) &#123; struct sockaddr_in clientaddr; socklen_t length = sizeof(clientaddr); int c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length); clisock[c] = string(\"\"); cout&lt;&lt;\"new conn \"&lt;&lt;c&lt;&lt;endl; &#125; for( auto &amp;pairs : clisock) &#123; int c = pairs.first; string &amp;s = pairs.second; if(FD_ISSET(c, &amp;rfds)) &#123; char buffer[1024] = &#123;0&#125;; if(recv(c, buffer, sizeof(buffer), 0) &gt; 0) &#123; clisock[c] = string(buffer); cout&lt;&lt;\"recv: \"&lt;&lt;clisock[c]&lt;&lt;endl; &#125; else &#123; clisock.erase(c); close(c); FD_CLR(c, &amp;wfds); FD_CLR(c, &amp;rfds); cout&lt;&lt;\"recv close conn \"&lt;&lt;c&lt;&lt;endl; &#125; &#125; if(FD_ISSET(c, &amp;wfds)) &#123; if(send(c, s.c_str(), s.size(), 0) &gt; 0) &#123; cout&lt;&lt;\"send succ: \"&lt;&lt;s&lt;&lt;endl; &#125; else &#123; clisock.erase(c); cout&lt;&lt;\"send close conn \"&lt;&lt;c&lt;&lt;endl; &#125; s.clear(); &#125; &#125; &#125; &#125; return 0;&#125; poll_server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/poll.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; int sersock = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9999); servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int on = 1; setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); if(bind(sersock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; cout&lt;&lt;\"bind error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; if(listen(sersock, 5) == -1) &#123; cout&lt;&lt;\"listen error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; int retval; struct pollfd fds[1024] = &#123;-1, 0, 0&#125;; fds[0].fd = sersock; fds[0].events = POLLRDNORM; char buff[1024] = &#123;0&#125;; int maxi = 0; map&lt;int, string&gt; clisock; for(;;) &#123; retval = poll(fds, maxi+1, -1); if(retval &lt; -1) &#123; cout&lt;&lt;\"poll error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; else &#123; if(POLLRDNORM == (fds[0].revents &amp; POLLRDNORM)) &#123; struct sockaddr_in clientaddr; socklen_t length = sizeof(clientaddr); int c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length); clisock[c] = string(\"\"); fds[++maxi].fd = c; fds[maxi].events = POLLRDNORM; fds[maxi].revents = 0; cout&lt;&lt;\"new conn \"&lt;&lt;c&lt;&lt;endl; &#125; for(int i=1; i&lt;1024; ++i) &#123; if(fds[i].fd &lt; 0) &#123; continue; &#125; int &amp;c = fds[i].fd; auto &amp;s = clisock[fds[i].fd]; if(POLLRDNORM == (fds[i].revents &amp; POLLRDNORM)) &#123; fds[i].revents &amp;= ~POLLRDNORM; char buffer[1024] = &#123;0&#125;; if(recv(c, buffer, sizeof(buffer), 0) &gt; 0) &#123; clisock[c] = string(buffer); cout&lt;&lt;\"recv: \"&lt;&lt;clisock[c]&lt;&lt;endl; fds[i].events |= POLLWRNORM; &#125; else &#123; clisock.erase(c); close(c); fds[i].fd = -1; fds[i].events = 0; fds[i].revents = 0; cout&lt;&lt;\"recv close conn \"&lt;&lt;c&lt;&lt;endl; &#125; &#125; if(POLLWRNORM == (fds[i].revents &amp; POLLWRNORM)) &#123; fds[i].revents &amp;= ~POLLWRNORM; if(send(c, s.c_str(), s.size(), 0) &gt; 0) &#123; cout&lt;&lt;\"send succ: \"&lt;&lt;s&lt;&lt;endl; &#125; else &#123; clisock.erase(c); close(c); cout&lt;&lt;\"send close conn \"&lt;&lt;c&lt;&lt;endl; &#125; fds[i].events &amp;= ~POLLWRNORM; s.clear(); &#125; fds[i].revents = 0; &#125; &#125; &#125; return 0;&#125; epoll_server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; int sersock = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9999); servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int on = 1; setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); if(bind(sersock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; cout&lt;&lt;\"bind error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; if(listen(sersock, 5) == -1) &#123; cout&lt;&lt;\"listen error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; int retval; int epollfd = epoll_create(1024); if(epollfd &lt; 0) &#123; cout&lt;&lt;\"epoll_create error\"&lt;&lt;endl; return 0; &#125; struct epoll_event tmpfds; tmpfds.events = EPOLLRDNORM; tmpfds.data.fd = sersock; epoll_ctl(epollfd, EPOLL_CTL_ADD, sersock, &amp;tmpfds); char buff[1024] = &#123;0&#125;; map&lt;int, string&gt; clisock; for(;;) &#123; struct epoll_event fds[1024]; retval = epoll_wait(epollfd, fds, 1024, -1); if(retval &lt; -1) &#123; cout&lt;&lt;\"epoll_wait error \"&lt;&lt;errno&lt;&lt;endl; return 0; &#125; else &#123; for(int i=0; i&lt;retval; ++i) &#123; if(fds[i].data.fd == sersock &amp;&amp; (fds[i].events &amp; EPOLLRDNORM) == EPOLLRDNORM) &#123; struct sockaddr_in clientaddr; socklen_t length = sizeof(clientaddr); int c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length); clisock[c] = string(\"\"); tmpfds.data.fd = c; tmpfds.events = EPOLLRDNORM; epoll_ctl(epollfd, EPOLL_CTL_ADD, c, &amp;tmpfds); cout&lt;&lt;\"new conn \"&lt;&lt;c&lt;&lt;endl; continue; &#125; int c = fds[i].data.fd; auto &amp;s = clisock[c]; if(fds[i].data.fd != sersock &amp;&amp; (fds[i].events &amp; EPOLLRDNORM) == EPOLLRDNORM) &#123; tmpfds.data.fd = c; tmpfds.events = EPOLLWRNORM | EPOLLRDNORM; epoll_ctl(epollfd, EPOLL_CTL_MOD, c, &amp;tmpfds); char buffer[1024] = &#123;0&#125;; if(recv(c, buffer, sizeof(buffer), 0) &gt; 0) &#123; clisock[c] = string(buffer); cout&lt;&lt;\"recv: \"&lt;&lt;clisock[c]&lt;&lt;endl; &#125; else &#123; clisock.erase(c); close(c); epoll_ctl(epollfd, EPOLL_CTL_DEL, c, NULL); cout&lt;&lt;\"recv close conn \"&lt;&lt;c&lt;&lt;endl; &#125; &#125; if((fds[i].events &amp; EPOLLWRNORM) == EPOLLWRNORM) &#123; tmpfds.data.fd = c; tmpfds.events = EPOLLRDNORM; epoll_ctl(epollfd, EPOLL_CTL_MOD, c, &amp;tmpfds); if(send(c, s.c_str(), s.size(), 0) &gt; 0) &#123; cout&lt;&lt;\"send succ: \"&lt;&lt;s&lt;&lt;endl; &#125; else &#123; clisock.erase(c); close(c); epoll_ctl(epollfd, EPOLL_CTL_DEL, c, NULL); cout&lt;&lt;\"send close conn \"&lt;&lt;c&lt;&lt;endl; &#125; s.clear(); &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Linux I/O 阻塞、非阻塞、同步、异步的理解","slug":"io-1","date":"2017-09-18T13:12:00.000Z","updated":"2020-04-12T04:56:36.110Z","comments":true,"path":"2017/09/18/io-1/","link":"","permalink":"http://www.casezheng.date/2017/09/18/io-1/","excerpt":"","text":"Linux I/O 阻塞、非阻塞、同步、异步的理解 在进行网络编程时，常见到同步、异步、阻塞、非阻塞四种调用方式。同步、异步关注的时消息通信机制。 同步：发出一个调用时，在没有得到结果时，该调用不返回，一旦调用返回，就得到返回值。 异步：调用发出后，该调用直接返回，没有返回结果，被调用者通过状态、通知来通知调用者，或通过回调函数处理该调用。 阻塞、非阻塞关注的是等待调用结果（消息、返回值）的状态。 阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才返回。 非阻塞：调用不能立即得到结果之前，该调用不会阻塞当前线程。 在处理IO的时候，阻塞和非阻塞都是同步IO。只有特殊的API才是异步IO。对于unix而言：阻塞式I/O（默认）、非阻塞式I/O（nonblock）、I/O复用（select/poll/epoll）都属于同步I/O，因为在数据由内核空间复制回进程缓冲区时都是阻塞的。只有异步I/O模型（AIO）时符合异步I/O操作含义的，即在数据准备完成，由内核空间拷贝回缓冲区后通知进程的。 阻塞和非阻塞的区别：如果因为各种原因不能马上进行IO操作，继续等待则是阻塞IO，否则则为非阻塞IO。同步和异步的区别：等待一次IO操作完成再返回则是同步，否则为异步。 阻塞式IO 非阻塞式IO","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"网络相关知识复习","slug":"network-review","date":"2017-09-16T04:06:00.000Z","updated":"2020-04-12T04:56:36.108Z","comments":true,"path":"2017/09/16/network-review/","link":"","permalink":"http://www.casezheng.date/2017/09/16/network-review/","excerpt":"","text":"复习下网络相关知识，包括TCP/IP协议族题解结构和主要协议介绍、封装、复用、ARP协议、IP协议、TCP协议、IP模块工作流程、TCP网络连接的建立和状态转移、DNS服务、HTTP服务的介绍。 浏览器网页访问的过程简介 浏览器分析链接指向的URL 浏览器向DNS请求解析域名的IP地址(DNS协议基于UDP协议) UDP(用户数据报)协议 不可靠、无连接、基于数据报 IP协议 不可靠(不保证IP数据报准确到达接收端)、无连接、无状态(简单、高效) 封装 DNS报文 + UDP头部 -&gt; UDP数据报 + IP头部 -&gt; IP数据报 + 以太网头部 + 以太网尾部 -&gt; 以太网帧 传输 传输层端对端 网络层 选路和转发 使用IP地址寻址 数据链路层 网络驱动程序 使用物理地址寻址 (ARP协议 IP地址转为物理地址) (RARP协议 物理地址转化为IP地址) 分片:帧的最大传输单元(MTU),受到网络类型的限制,以太网帧的MTU1500字节,过长的IP数据报可能会被分片传输.分片只有在最终目标机器上才会被内核IP模块重新组装. 分用 以太网帧到目的主机后,根据各层协议头,将报文逐层解析,最终将处理后的数据交给目标应用程序 DNS获取域名的IP地址,并返回解析到的IP地址 递归查询(一般采用方式) 主机 -&gt; 本地域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器 -&gt; 顶级域名服务器 -&gt; 本地域名服务器 -&gt; 权限域名服务器 -&gt; 本地域名服务器 -&gt; 主机 迭代查询 主机 -&gt; 本地域名服务器 -&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权限域名服务器 -&gt; 顶级域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器 -&gt; 主机 浏览器和服务器建立TCP链接(TCP三次握手) TCP(传输控制)协议 可靠(发送应答机制,超时重传机制,乱序/重复IP报文重排/整理机制)、面向连接(保存状态占用内核资源,全双工)、基于流(数据的发送和接收没有边界限制) 浏览器(CLOSED-&gt;SYN_SENT)发送SYN到服务器 服务器(LISTEN-&gt;SYN_RECV)接收SYN并发送SYN和ACK到浏览器 浏览器(SYN_SENT-&gt;ESTABLISHED)接收ACK并发送ACK到服务器(SYN_RECV-&gt;ESTABLISHED) 浏览器发出命令 HTTP协议 无连接,无状态 封装 传输 拥塞窗口 慢开始 拥塞避免 慢开始门限(拥塞窗口) 快重传 快恢复 发送窗口(拥塞窗口和对方给出接收窗口中较小的那一个) 路由器的尾部丢弃和随机丢弃策略 糊涂窗口综合症 滑动窗口 分用 服务器给出响应 浏览器关闭释放TCP连接(TCP四次挥手) 浏览器(ESTABLISHED-&gt;FIN_WAIT_1)发送FIN到服务器 服务器(ESTABLISHED-&gt;CLOSE_WAIT)接收FIN并发送ACK到浏览器,浏览器(FIN_WAIT_1-&gt;FIN_WAIT_2)接收ACK 服务器(CLOSE_WAIT-&gt;LAST_ACK)发送FIN到浏览器 浏览器(FIN_WAIT_2-&gt;TIME_WAIT)接收FIN,并发送ACK到服务器,服务器(LAST_ACK-&gt;CLOSED)接收ACK 先关闭链接的一方进入TIME_WAIT状态,TIME_WAIT状态需要等待2MSL(TCP报文段最大生存时间): 可靠的终止链接(重发ACK) 保证让迟来的TCP报文段有足够时间被识别并丢弃 浏览器显示返回结果 TCP/IP协议族Internet（因特网）主流协议族是TCP/IP协议族。TCP/IP协议族是一个多层、多协议的通信协议。 TCP/IP协议族体系结构和主要结构TCP/IP协议是四层协议系统，从底到上分别是数据链路层、传输层、网络层、应用层。每层完成不同的功能，通过若干协议来实现，上层协议使用下层协议提供的服务。 网络链路层网络链路层实现网卡接口的网络驱动程序，处理数据在物理媒介（比如以太网、令牌环等）上的传输。不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供了一个统一的接口。数据链路层主要协议： ARP协议（地址解析协议） 将IP地址转换为物理地址（通常为MAC地址，以太网、令牌环、802.11无线网络都是用MAC地址）。 RARP协议（逆地址解析协议） 将物理地址转化为IP地址，利用网卡上的物理地址向网络管理者（服务器或网络管理软件）查询自身的IP地址，RARP协议仅用于网络上的某些无盘工作站,无盘工作站缺乏存储设备，所以无法记住自身的地址。运行RARP服务的网络管理者通常存有该网路上所有及其的物理地址到IP地址的映射。 数据链路层使用物理地址来寻址一台机器，而网络层使用IP地址寻找一台机器。 网络层网络层实现数据包的选路和转发。WAN（广域网）通常使用众多分级的路由器来连接分散的主机或LAN（局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）相连，网络层的任务就是选择这些中间节点，以确认主机之间的通信路径。网络层对上层协议隐藏网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。 网络层核心协议：IP协议（因特网协议）IP协议通过数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目的主机，那么IP协议就为它寻找一个和合适的下一跳路由器，并将数据包交付给该路由器来转发。多次重复该过程，数据包最终到达目标主机，或者因为发送失败而被丢弃。IP协议使用逐跳的方式确定通信路径。网络层重要协议ICMP协议（因特网控制报文协议），IP协议的重要补充，主要用来检测网络连接。 ICMP协议并不是严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务。8位类型，用来区分报文类型 差错报文，主要用来回应网络错误，比如目标不可达（类型值为3）和重定向（类型值为5）。 查询报文，主要用来查询网络信息，比如ping程序使用ICMP报文查看目标是否可达（类型值为8）。 8位代码，进一步区分不同的条件，比如重定向报文使用代码值0表示对网络重定向，用代码值1标识对主机重定向。16位校验和，对整个报文（包括头部和内容部分）进行循环冗余检验（CRC），以检验报文在传输过程中是否损坏，不同的ICMP报文类型具有不同的正文内容。 传输层传输层为两台主机上的应用程序提供端到端的通信，传输层只关心通信的起始端和目的端，而不关心数据包的中转过程。传输层协议主要有三个：TCP协议，UDP协议和SCTP协议。 TCP协议（传输控制协议）为应用层提供可靠的、面向连接的和基于流的服务。 UDP协议（用户数据报协议）为应用层提供不可靠的、无连接的和基于数据报的服务。 SCTP协议（流控制传输协议）相对较新的传输层协议，为了在因特网上传输电话信号而设计。图中垂直实线箭头表示TCP/IP协议族之间的实体通信（数据包确实沿着这些线路传递），水平虚线箭头表示逻辑通信线路。数据链路层（驱动程序）封装了物理网路的电气细节；网络层封装了网络连接的细节；传输层为应用程序封装了一条端到端的逻辑通信链路，负责数据的收发、链路的超时重连等。 应用层应用层负责处理应用程序的逻辑。数据链路层、网络层、传输层负责处理网络通信细节，这些部分必须既稳定又高效，因此它们都在内核空间中实现。应用层在用户空间实现，因为它处理众多逻辑，比如文件传输、名称查询、网络管理等。如果应用层实现在内核中，内核会变得非常庞大。应用层实现在内核中，内存不用在用户空间和内核空间中来回切换（主要是数据复制），可以提高工作效率，但实现复杂、不够灵活、不方便移植。应用层协议众多： ping是应用程序，而是不协议，利用ICMP报文检测网络连接，是调试网络环境的必备工具。 telent协议是一种远程登陆协议，使我们能在本地完成远程任务。 OSPF（开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间通信，以告知对方各自的路由信息。 DNS（域名服务）协议提供及其域名到IP地址的转换。 应用层协议（或程序）可以跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP协议，比如DNS协议。 封装应用程序数据在发送到物理网络上之前，先沿着协议栈从上向下传递，每层协议都在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程叫做封装。经过TCP封装获得数据成为TCP报文段（TCP段）。TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中TCP模块首先将这些数据复制到与该连接相对应的TCP内核发送缓存区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP内核缓存区（发送缓存区或接收缓存区）数据一起构成TCP报文段。经过UDP封装后的数据称为UDP数据报。UDP对应用程序数据的封装与TCP类似。UDP无须为应用层数据保存副本，提供不可靠的服务。当一个UDP数据报被成功发送后，UDP内核缓存区中的该数据报就被丢弃了。如果应用程序检测到该数据报未被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓存区。经过IP封装后的数据称为IP数据报，IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或着ICMP报文。经过数据链路层封装的数据成为帧，传输媒介不同，帧的类型也不同。比如，以太网上是以太网帧，令牌环网络为令牌环帧。以太网帧如下图所示：以太网帧使用6字节的目的物理地址和6字节的源物理地址来表示通信的双方。2字节类型字段用来标识上层协议。4字节CRC字段对帧的其他部分提供循环冗余教研。帧的最大传输单元（MTU），集帧最多携带多少上层协议数据，通常受到网络类型的限制，以太网帧的MTU是1500字节，过长的IP数据报可能需要被分片传输。帧才是最终在物理网络上传输的字节序列。 分用当帧到达目的主机后，将沿着协议栈自底向上依次传递，各层协议以此处理帧中本层负责的头部信息获取所需的信息，并最终将处理后的数据交给目标应用程序，这个过程叫做分用。分用是依靠头部信息中的类型字段来实现的。帧中用2字节类型字段区分上层协议，即IP协议、ARP协议或RARP协议。类型字段为0x800，即帧的数据部分为IP数据报。类型字段为0x806，即帧的数据部分为ARP请求或应答报文。类型字段为0x835，即帧的数据部分为RARP请求或应答报文。IP数据报的头部采用16位的协议字段来区分ICMP协议、TCP协议和UDP协议。TCP报文段和UDP报文段则通过其头部中的16位端口号字段来区分上层应用程序。 ARP协议ARP协议实现任意网络层地址到物理层地址的转换。IP地址到以太网地址（MAC）的转换。工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。硬件类型：定义物理地址的类型，值为1表示MAC地址。协议类型：表示要映射的协议地址类型，值为0x800表示IP地址。硬件地址长度和协议地址长度：单位为字节。MAC地址长度为6,IP(v4)地址长度为4。操作类型：4种操作类型。ARP请求（1）、ARP应答（2）、RARP请求（3）、RARP应答（4）。最后四个字段指定通信双方的以太网地址（MAC）和IP地址。发送端填充除了目的端以太网地址之外的其他3个字段，以构建ARP请求并发送。接收端发送请求的目的端IP地址是自己，就把自己的以太网地址填充进取，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回。ARP请求/应答报文长度为28字节，加上以太网头部和尾部的18字节，一个携带ARP请求/应答的以太网帧帧长度为46字节，有的实现要求以太网数据长度至少为46字节，此时ARP请求/应答报文会增加一些填充字节，满足该要求，这样携带ARP请求/应答报文的以太网帧为64字节。ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。避免了重复的ARP请求，提高了发送数据报的速度。ARP高速缓存是动态变化的。每个ARP广播中都包含发送方的IP地址到物理地址的绑定，接收方在处理ARP分组前，先更新缓存中IP到物理地址的绑定信息。 IP协议IP协议是TCP/IP协议的动力，为上层提供无状态、无连接、不可靠的服务。无状态：IP通信双方不同步传输数据的状态信息。 优点：简单、高效。无连接：IP通信双方不长久地维持双方的任何信息。上层协议每次发送数据的时候，都必须明确制定对方的IP地址。不可靠：Ip协议不保证IP数据报准确地到达接收端。 选项： 记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，用于跟踪数据报的传递路径。 时间戳，告诉每个路由器都将数据报转发的时间填入IP头部的选项部分，测量途径路由之间的数据报传输时间。 松散源路由选择，指定一个路由器IP地址列表，数据报发送过程中必须经过所有的路由器。 严格源路由选择，和松散源路由选择类似，不过数据报只能经过被指定的路由器。 当IP数据报的长度超过帧的MTU时，将被分片传输。分片可以发送在发送端，也可以发生在中转路由器上，而且在传输过程中可能被多次分片，但只有在最终的目的机器上，这些分片才会被内核中IP模块重新组装。IP头部中的数据报标识、标志和片偏移三个字段给IP的分片和组装提供了足够的信息，一个IP数据报的每个分片都具有自己的IP头部，具有相同的标识符，但具有不同的片偏移。并且除了最后一个分片外，每个分片都将设置MF标志，每个分片的IP头部的总长度字段将被设置为该分片的长度。 IP模块工作流程IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括本机上层数据（ICMP报文、TCP报文段和UDP报文段）的IP数据报。从IP输入队列中取出一个IP数据报： 对该IP数据报的头部做CRC校验，确认无误后分析其头部的具体信息。 如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理该数据报。 如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者广播地址，即该数据报是发送给本机的，则IP模块根据数据报头部的协议字段来句町将它分派给那个上层应用（分用）。否则该数据报不是发送给本机的，将其交给转发子模块来处理。 数据报转发子模块将首先检测系统是否允许转发，如果不允许，IP模块就丢弃该数据报。如果允许，数据报转发子模块就对该数据报执行一些操作，然后将其交给IP数据报输出子模块。 IP数据报应该发送至下一跳路由（或者目标机器），以及经过哪个网卡来发送，就是IP路由过程。IP模块实现数据报路由的核心数据结构是路由表，这个表按照数据报的目标IP分类，同一类型的IP数据报就被发往相同的下一跳路由器（或目标机器）。虚线箭头显示路由表更新的过程，这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，成为IP路由测策略。123456[CaseZheng@localhost Picture]$ routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault gateway 0.0.0.0 UG 100 0 0 enp2s0192.168.0.0 0.0.0.0 255.255.255.0 U 100 0 0 enp2s0192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 IP路由机制： 查找路由表中和数据报中的目的IP地址完全匹配的主机IP地址，如果找到，就是用该路由项，没找到则转步骤2。 查找路由表中和数据报中目标IP地址具有相同网路ID的网络IP地址。如果找到，就是用该路由项，没找到则转步骤3。 选择默认路由，通常表示网关。 路由器更新：路由器必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。 通过route命令或者其他工具手动修改路由表，是静态的路由更新方式。 对大型路由器，通过BGP（边际网关协议）、RIP（路由信息协议）、OSFP等协议来发现路径，并更新自己的路由表。这种方式是动态的、自动的。 ICMP重定向报文。 IP转发： 检测数据报头部的TTL值，如果TTL值已经为0,则丢弃该数据报。 查看数据报头部的严格源路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站路由失败报文给发送端。 如果有必要，则给源端发送一个ICMP重定向报文，告诉它一个更合理的下一跳路由器。 将TTL值减1。 处理IP头部选项。 如果有必要，则执行IP分片。 一般来说，主机只接收ICMP重定向报文，路由器只能发送ICMP重定向报文。ICMP重定向报文的类型值为5，代码字段有4个可选值，用来区分不同的重定向类型。主机重定向代码值为1。更新路由表通常是更新路由表缓存，而不是直接更改路由表。 TCP协议TCP服务：面向连接、字节流和可靠传输。面向连接：使用TCP通信的双方必须先建立连接，然后才可以开始数据的读写。双方必须为该连接分配必要的内核资源，以管理连接的状态和连接上的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行，完成数据交换后，通信双方必须断开连接以释放系统资源。TCP连接是一对一的，所以基于广播和多播的应用程序不能使用TCP连接。而无连接协议UDP协议则非常适合于广播和多播。字节流：发送端执行的写操作次数和接收端执行的读操作次数没有任何数量关系，应用程序对数据的发送和接受没有边界限制。可靠连接： 发送应答机制，发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。 超时重传机制，发送端在发送一个TCP报文后启动定时器，如果定时器时间内未收到应答，将重新发送该报文段。 TCP报文段最终以IP数据报发送，而IP数据报到达接收端可能是乱序、重复的，所以TCP协议会对接收到的IP报文重排、整理，再交给应用层。 由于TCP使用两个端点来标识连接，一个机器上的某个TCP端口可以被多个连接所共享。 TCP头部结构如下图所示16位端口号，告知主机该数据报来自哪个（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行TCP通信时，客户端使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。32位序列号，一次TCP通信（从TCP连接建立到断开）过程中某个传输方向上的字节流的每个字节的编号。32位确认号，对于另一方发送来的TCP报文段的响应，其值是收到的TCP报文段的序号家1。4位头部长度，表示该TCP头部有多少个32bit（4字节）。6位标志位： URG，紧急指针是否有效。 ACK，表示确认号是否有效，携带ACK标志的TCP报文段为确认报文段。 PSH，提示接收端应用程序应该立即从TCP接收缓存区读走数据，为后续数据腾出空间。 RST，要求对方重新建立连接，携带RST标志的TCP报文段位复位报文段。 SYN，要求建立一个连接，携带SYN标志的TCP报文段位同步报文段。 FIN，通知对方本端要关闭了，携带FIN标志的TCP的报文段为结束报文段。 16位窗口大小，是TCP流量控制的一个手段，指接收通告窗口，告诉对方本端的TCP接收缓存区还能容纳多少字节的数据，对方据此控制发送数据的速度。16位校验和，由发送端填充，接收端对TCP报文段执行CRC算法以校验TCP报文段在传输过程中是否损坏，注意：检验包括头部和数据部分。是TCP可靠传输的一个保障。16位紧急指针，一个正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。该字段，实际是紧急指针相对当前序号的偏移，紧急偏移。TCP的紧急指针的发送端向接收端发送紧急数据的方法。紧急指针指出紧急数据在报文段中的结束位置。 TCP头部的最后一个字段选项是可变长的可选信息，最多包含40个字节。kind说明选项类型，常见的TCP选项有7种。length说明该选项的长度。info是选项的具体信息。kind=0,选项表结束选项。kind=1,空操作选项，没有特殊含义，一般用于将TCP选项的长度填充为4字节的整数倍。kind=2,最大报文段长度选项。kind=3,窗口扩大引子选项。kind=4,选择性确认（SACK）选项。kind=5,SACK实际工作的选项。kind=8,时间戳选项。 TCP报文段伪首部，用于TCP校验和计算。TCP确认信息指出了接收方期望收到的下一个报文组的序号。拥塞窗口:拥塞窗口发送方使用,用来控制发送速率,避免发的过多.慢开始：在启动新连接的传输或者在拥塞之后增加通信量时，仅以一个报文段作为拥塞窗口的初始值，而每收到一个确认后，将拥塞窗口大小加1,使用慢开始算法后，每经过一个往返时间RTT，拥塞窗口的值就加倍。拥塞避免算法：让拥塞窗口缓慢增加，每经过一个往返时间RTT就把发送窗口的拥塞窗口加1,而不是加倍。慢开始门限： 拥塞窗口小于慢开始门限，使用慢开始算法。 拥塞窗口大于慢开始门限，使用拥塞避免算法。 拥塞窗口等于慢开始门限，即可使用慢开始算法，也可使用拥塞避免算法。滑动窗口:控制接收和同步数据,通知接收方目前接收的数据范围,用于流量控制,接收端使用.快重传：接收方每收到一个失序的报文段就立即发出重复确认，而不是等待自己发送数据时才进行捎带确认。当发送方一次收到3个重复确认就应立即重传对方尚未收到的报文段。快恢复:当发送方连续收到三个重复确认时，就执行“乘法减小算法”，把快启动门限减半，把拥塞窗口设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法。发送方的发送窗口一定不能超过对方给出的接收窗口值。发送窗口的取值为拥塞窗口和对方给出的接收窗口中较小的那一个。路由器的尾部丢弃策略：如果数据报到达时输入队列已被填满，则丢弃该数据报。可能会丢弃来自多个TCP连接的一个数据报，而不是来自一个连接的多个数据报，造成全局性的同步，丢失数据报的多个TCP连接同时进入慢开始状态。路由器的随机丢弃策略（RED）：当数据报到达时，如果输入队列已满，则丢弃这个数据报，如果输入队列未满，但大小超过了上限阀值，则通过按概率p丢弃数据报来避免同步。糊涂窗口综合症：发送方应用进程产生数据很慢或者接收端应用程序处理接收缓冲区数据很慢，或者二者皆有；就会导致应用进程间传送的报文很小；极端情况下，有效载荷可能只有1个字节，传输开销有40个字节（20个字节的IP头和20字节的TCP头）这种现象。接收方避免糊涂窗口综合症的策略：通告0窗口后，要等缓冲区可用空间至少达到宗空间的一半或达到最大报文段长度后才发送更新的窗口通告。实现接收方避免糊涂窗口综合症的策略可使用两种手段： TCP对收到的报文段进行确认，但要等到窗口空间达到启发式策略所指定的限度之后才发出窗口增大的通告。 在窗口大小不足以避免该症的策略所指定的限度时，则延迟发送确认。TCP标准推荐延迟发送确认。 延迟确认技术优点：降低通信量并提高吞吐量 延迟确认技术缺点：当接收方的确认延迟太大时，发送方会进行报文段的重传（浪费网络宽带，降低了吞吐量，加重了收发双方的计算负载）。推迟确认造成了估算值的混乱并增大了重传时间。TCP实现确认推迟时间最多推迟500ms，TCP标准推荐接收方按照至少每隔一个报文段使用正常的方式对报文段进行确认。发送方避免糊涂窗口综合症的策略：在一个连接上已经传输的数据还未收到确认的情况下，发送方的应用程序又生成了后续数据，并照常将数据送到输出缓冲区中，但这时并不发送后续报文段，而是等数据足以填满一个达最大长度的报文段之后再把缓冲区的数据发送出去，该策略适用于任何情况，包括推操作在内。现行的TCP要求收发双方实现避免糊涂窗口综合症的启发式策略。接收方要避免小窗口通告，而接收方要使用自适应机制来推迟传送，以便将数据组块形成较长的大报文段。 TCP网络连接TCP通信双方建立TCP连接的一般过程。如下图： TCP通信双方的各种状态变化如下图所示： DNS协议DNS是一套分布式的域名服务系统，每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且时动态更新的。众多网络客户端程序使用DNS协议来向服务器查询目标主机的IP地址。DNS报文格式如下：16位标识：用来标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。16位标志：用来协商具体的通信方式和反馈通信状态16位问题个数、16位应答资源记录个数、16位授权资源记录数目和16位额外的资源记录数目分别指出DNS报文的最后四个字段的资源记录数目。对查询报文，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。对应答报文，应答资源记录数则至少为1,而授权资源记录数和额外资源记录数可为0或非0。 HTTP协议 HTTP协议HTTPS是以安全为目标的HTTP通道,是HTTP的安全版本,即HTTP+SSL层,HTTPS的安全基础是SSL.HTTPS协议的主要作用: 建立一个信息安全通道,确保数据传输安全 确保网站真实性 HTTP以明文方式发送内容,不提供任何方式的数据加密 HTTP和HTTPS区别 HTTP是明文传输,HTTPS具有安全性的SSL加密传输协议 HTTPS需要CA申请证书,免费证书少,需要一定费用,HTTP则不需要 HTTP和HTTPS使用完全不同的连接方式,HTTP默认80端口,HTTPS默认443端口 HTTP连接无状态,HTTPS协议由HTTP+SSL协议构建,可进行加密传输、身份认证的网络协议,安全性高于HTTP HTTPS优缺点 优点: 使用HTTPS协议认证用户的服务器,确保数据发送到正确的客户机和服务器 HTTPS有SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,比HTTP协议安全,可防止数据在传输过程中不被窃取、改变,确保数据的安全和完整. 缺点: HTTPS握手阶段耗时多 SSL证书需要钱 HTTPS的协议加密范围有限, 面试问题TCP三次握手,客户端发送的最后确认的ACK丢失,服务端会怎么样? 服务器在没有收到第二个ACK时,客户端发送数据,被服务端接收到,服务端怎么处理? 客户端在回复ACK的同时携带数据服务器会怎么处理? TCP三次握手,如果第2个ACK丢失,此时服务端状态为SYN_RECV,等段时间后会触发超时重传,依次等待时间为3s,6s,12s,24s,48s,之后重发SYN+ACK包(服务端重发SYN+ACK包的次数可通过/proc/sys/net/ipv4/tcp_synack_retries修改,默认为5次),让客户端重发ACK.如果重发指定次数的SYN+ACK后仍然未收到ACK应答,过一段时间,Server将自动关闭这个连接. 虽然第二个ACK丢失,但客户端在发出ACK后即确认连接建立,此时发送数据到服务端,服务端将发送RST,让客户端断开这个异常连接. 客户端在第二个ACK携带数据,服务端会正常建立连接,并处理数据 主动关闭TCP连接的一方进入TIME_WAIT状态,还是被动关闭的一方进入?TIME_WAIT状态有何特殊之处,为什么? 主动关闭的一方进入TIME_WAIT状态 TIME_WAIT状态需要等待2MSL(TCP报文段最大生存时间),才会完全关闭 可靠地终止TCP连接,当被动关闭的一方发出FIN,在等待一段时间后未收到ACK,此时会重发FIN,令主动关闭的一方重发ACK. 保证来迟的TCP报文段有足够的时间被识别并丢弃 关闭TCP连接时,如果通信双方同时发出了FIN会怎么样? 同时发出FIN则都先进入FIN_WAIT_1状态,在收到对方的FIN后进入CLOSING状态,并发出自己的ACK,等收到对方的ACK后,再进入TIME_WAIT状态 被动关闭一方在LAST_ACK收不到ACK如何关闭?如果超时未收到ACK则会重发FIN,此时: 主动关闭一方仍处于TIME_WAIT状态,则会发送ACK,被动关闭方收到ACK则顺利从LAST_ACK进入CLOSED. 主动断开的一方经过2MSL已经进入了CLOSED状态,此时会返回RST给被动关闭方,被断开方收到后从LAST_ACK进入CLOSED. 四次挥手可能变成三次挥手吗? 当被动关闭方在收到FIN后,回复ACK的时候,可能由于TCP延迟确认,延迟发送这个ACK,此时被动关闭一方也关闭了连接,被动关闭一方将同时发送FIN和ACK给主动关闭一方,被动关闭方由CLOSE_WAIT状态直接到LAST_ACK状态,而主动关闭一方由FIN_WAIT_1状态直接进入TIME_WAIT状态.此时TCP四次挥手,变为三次挥手 四次挥手,被动关闭一方何时发送FIN? 被动关闭一方收到FIN并回复ACK后不会理解发送FIN,需要等待应用层关闭连接后才会发送FIN 为什么是三次握手,四次挥手? 三次握手,为了防止已经失效的连接请求报文段突然又传到服务端,因而产生错误. 例如:客户端发送一个连接请求给服务端,这个请求并没有丢失,但由于未知原因在某个网络节点,导致延迟到连接释放的某个时间点到达服务端,这是一个本已失效的报文段,但服务端再收到报文后,会误以为A再次发出了一个新的连接请求,服务端向客户端发送确认报文,确认连接成功,但客户端并没有发出建立连接的请求,服务端等不到客户端的消息,也不会结束连接,白白浪费服务器资源 四次挥手是因为TCP连接是全双工的,允许同时通信的双方同时进行数据的收发,也运行收发的两个方向的连接被独立关闭,避免客户端数据发送完毕,向服务端发送FIN关闭连接,而服务端还有发送到客户端的数据没有发送完毕的情况.所以关闭TCP连接需要四次,每次关闭一个方向上的连接需要FIN和ACK两次. 什么是半打开、半关闭、半连接? 半打开,一方已经关闭或者异常终止连接,而另一方却不知道,这样的连接称为半打开 半关闭,TCP是全双工的,其在关闭写后,仍然可以读取对方发送的数据称为半关闭 半连接,客户端向服务端发起TCP连接发送SYN,服务端正常回复SYN和ACK,但客户端未回复ACK close和shutdown的区别 单进程、单线程、多线程在使用close时行为是一致的,都会真正的关闭连接,而多进程下调用close函数只是对其引用计数减一,只有当引用计数为0时才会真正的关闭连接,如果多进程共享同一个socket则需要都调用close才会真正关闭连接 shutdown则和多进程、多线程无关,只要调用shutdown都会去真正的关闭连接.shutdown可以通过标志位选择关闭读(对端发送过来的消息丢弃掉)、关闭写(发送FIN)、关闭读写 listen函数的第二个参数的含义是什么? TCP在三次握手时,服务端维护了两个队列,一个是连接尚未建立完成的队列(SYN队列,即收到SYN,回复SYN+ACK后,尚未收到ACK),一个是连接建立完成的队列(ACCEPT队列,即收到SYN,回复SYN+ACK后,收到ACK),listen函数第二个参数的含义即为连接建立完成的队列的长度,一般设置为5-10,因为服务器处理能力优先,而且维护队列需要消耗资源 TCP的定时器有哪些? 建立连接定时器 TCP建立连接客户端发送第一个SYN后,起一个定时器(默认3s),如果SYN丢失,定时器到后会重发SYN,配置/proc/sys/net/ipv4/tcp_syn_retries查看重传次数,时间倍数递增 重传定时器 TCP发出数据时设定,超时未收到ACK则重传 延迟应答定时器 延迟应答时使用,延迟应答是为了提高网络传输的效率(糊涂窗口综合症) 坚持定时器 专门为对付零窗口通告而设立,发送端收到零窗口通告则启动,发送探测报文段 保活定时器 收到消息则重置保活定时器,如果超时(通常是2小时),则每75s(发送10次)发送一个探测报文段,若收不到响应则终止连接 FIN_WAIT_2定时器 主动断开连接一方发送FIN收到ACK后进入FIN_WAIT_2状态,此时启动该定时器,当对端一直不发送数据,超时后终止连接 TIME_WAIT定时器 2MSL定时器,主动关闭方进入TIME_WAIT状态时启动,定时器设定为1分钟,TCP控制块被删除,端口号可重用 大端和小端的区别 大端和小端都是指主机字节序,网络字节序采用大端的方式 小端将低位字节存放在内存的低地址端,高位字节存放在内存的高地址端 大端将低地字节存放在内存的高地址端,高位字节存放在内存的低地址段12345678910111213141516171819202122232425262728293031323334栈 由高地址向低地址增长 1的16进制为 0x00 00 00 01|----| 高地址|0x00||----||0x00||----||0x00||----||0x01|&lt;---&amp;x p 低地址|----|| ||----|#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; //方法1 unsigned int x = 1; unsigned char *p = (unsigned char*)(&amp;x); cout &lt;&lt; (((int)(*p) == 1) ? \"小端\" : \"大端\") &lt;&lt; endl; //方法2 union &#123; unsigned i; unsigned char c; &#125;un; un.i = 1; cout &lt;&lt; ((un.c == 1) ? \"小端\" : \"大端\") &lt;&lt; endl; return 0;&#125; 参考资料 Linux高性能服务器编程 TCP三次握手的第二个ack丢了会怎样 TCP连接建立的三次握手过程可以携带数据吗？","categories":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://www.casezheng.date/tags/网络/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://www.casezheng.date/categories/基础/"}]},{"title":"设计模式探秘-27-比较总结","slug":"design-pattern-27","date":"2017-09-12T13:42:00.000Z","updated":"2020-04-12T04:56:36.106Z","comments":true,"path":"2017/09/12/design-pattern-27/","link":"","permalink":"http://www.casezheng.date/2017/09/12/design-pattern-27/","excerpt":"","text":"创建类模式包括工厂方法模式、建造者模式、抽象工厂模式、单例模式和原型模式，都能够提供对象的创建和管理职责。单例模式要求在内存中只有一个对象，原型模式要求通过复制的方法产生一个新的对象。 工厂方法模式和建造者模式工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步的精准构造创建出一个复杂的对象。工厂方法模式和建造者模式都属于对象创建类模式，都用来创建类的对象，但区别还是比较明显的： 意图不同，工厂方法模式中，关注产品整体，无须关心产品的各部分是如何创建出来的；在建造者模式中，一个具体产品的产生依赖各个部件的产生以及装配顺序，关注的是“由零件一步一步地组装出产品对象”。简单说：工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注产品组成部分的创建过程。 产品复杂度不同，工厂方法模式创建的产品一般都是单一性质产品，而建造者模式创建的都是复合产品，由哥哥不见复合而成，不见不同产品对象也不相同。工厂方法模式的对象粒度比较粗，而建造者模式的对象粒度比较粗。 抽象工厂模式和建造者模式抽象工厂模式实现对产品家族的创建，一个产品家族是一系列的产品：具有不同分类维度的产品组合，采用抽象工厂模式则不需要关心构建过程，只关心什么产品由什么工厂生产即可，而建造者模式则是要求按照指定蓝图建造产品，主要目的是通过组装零部件而产生一个新产品。抽象工厂模式比建造者模式的尺度要大，关注产品整体，建造者模式关注建造过程，因此建造者模式可以很容易构建出一个崭新产品。抽象工厂模式适用于希望屏蔽对象的创建过程，只提供一个封装良好的对象，而建造者模式可以用在构建的装配方面，通过不同装配方案产生新对象，其可产生一个非常灵活的架构，方便地扩展和维护系统。 结构类模式包括适配器模式、桥梁模式、组合模式、装饰模式、门面模式、享元模式、代理模式。结构类模式：通过组合类或对象产生更大结构以适应更高层次的逻辑需求。 代理模式和装饰模式装饰模式是代理模式的一种特殊应用。共同点：具有相同的接口。不同点：代理模式着重代理过程的控制，装饰模式则是对类的功能进行加强和减弱，着重类的功能变化。代理模式把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真是角色的消息进行变形处理，不对被主题角色（被代理类）的功能做任何处理，保证原汁原味的调用。装饰模式在保证接口不变的情况下加强类功能，保证被修饰对象功能比原始对象丰富，但不做准入条件判断和准入参数过滤。 装饰模式和适配器模式装饰模式和适配器模式在功能上相似，都是包装作用，通过委托方式实现其功能，不同点是，装饰模式包装的是自己的兄弟类，隶属同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，其本质还是非相同接口的对象。 不同点： 意图不同 装饰模式的意图是加强对象的功能。 适配器模式关注的是转化，主要意图是两个对象间的转化。 施与对象不同 装饰模式装饰对象必须是自己的同宗，即有相同的接口或父类 适配器模式必须是两个不同的对象 场景不同 装饰模式在任何时候都可以用，只是相增强类的功能 适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的羡慕中。 扩展性不同 装饰器模式易于扩展 适配器模式建立容易，想去掉就不容易拉 行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模版方法模式、访问者模式。 命令模式和策略模式策略模式的意图是封装算法，让算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户。命令模式是对动作的解耦，把一个动作的执行分为执行对象（接受者角色）、执行行为（命令角色）、让两者相互独立而不相互影响。 不同： 关注点不同，策略模式关注算法的替换，而命令模式关注的是解耦问题。 角色功能不同，策略模式中的具体算法是负责一个完整算法逻辑，是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。命令模式关注命令的实现，也就是功能的实现。 使用场景不同，策略模式适用于算法要求变换的场景，命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。 策略模式和状态模式策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的，而状态模式封装的是不同的状态，已到达状态切换行为随之发生改变的目的。虽然都有变换的行为，但两者目标不同。 不同： 环境角色的职责不同 策略模式的环境角色只是一个委托作用，负责算法的替换，而状态模式的环境角色不仅仅是委托行为，还具有登记状态变化的功能，与具体状态类协作，共同完成状态切换行为随之切换的任务。 解决问题的重点不同 策略模式旨在解决内部算法如何改变的问题，将内部算法的改变对外界的影响降低到最小程度，保证的是算法可以自由地切换，状态模式旨在解决内在状态变化而引起行为改变的问题，出发点是事物的状态，封装状态而暴露行为，一个对象的状态改变，从外界看好像行为改变。 解决问题的方法不同 策略模式只是确保算法可以自由切换，什么时候用什么算法它不能决定，而状态模式对外暴露的是行为，状态的变化由环境角色和具体状态共同完成，状态模式封装了状态的变化而暴露了不同行为或行为结果。 应用场景不同 策略模式的算法必须是平行的，状态模式要求一系列状态发生变化的场景，要求是有状态且有行为的场景，一个对象必须具有二维（状态和行为）描述才能采用状态模式，如果只有状态而没有行为，则状态的变化就失去了意义。 复杂度不同 策略模式较简单（结构简单，扩展容易，代码容易阅读）。状态模式较复杂，要从两个角色看出对象状态和行为的改变，即封装的是变化。 观察者模式和责任链模式触发链和责任链虽然都是链结构，但有所区别 链中的消息对象不同 从首节点开始到最终的尾节点，两个链中传递的消息对象是不同的。责任链模式基本不改变消息对象的结构，虽然每个节点都可以参与消费（一般不参与消费），但结构不会发生变化。触发链模式中链中对象可以自由变化，上下级之间传递对象了解即可，不要求链中消息对象不变化，只要求链中相邻两个节点的消息对象固定。 上下节点的关系不同 责任链模式中，上下节点没有关系，都接受相同的对象，所有传递的对象都是从链首传递过来，上一节点是没有什么关系，按照自己的逻辑处理即可。触发链模式上下级关系亲密，链中任意两个相邻节点都是一个牢固的独立团体。 消息分销渠道不同 责任链模式中，一个消息从链首传递进来后，沿着链条向链尾移动，方向是单一、固定的。触发链模式不同，采用观察者模式，非常灵活，一个消息传递到链首后，具体怎么传递不固定，可以广播方式传递，也可跳跃方式传递，取决于处理消息的逻辑。 创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式着重如何建立软件结构。 策略模式和桥梁模式策略模式是行为模式，旨在封装一系列的行为。桥梁模式解决在不破坏封装的情况下抽取出抽象部分和实现部分，前提是不破坏封装，让抽象部分和实现部分都可以独立的变化。策略模式使用继承和多态建立一套可以自由切换算法的模式，桥梁模式在不破坏封装性的前提下解决抽象和实现都可以独立扩展的模式。 门面模式和中介者模式门面模式为复杂系统提供统一的访问界面，定义的是一个高层接口，该接口使子系统更加容易使用，避免外部模块深入到子系统内部，而产生与子系统内部细节耦合的问题。中介者模式使用中介对象封装一系列同事对象的交互行为，使各个对象之间不再显式地引用，从而使其耦合松散，建立可扩展的应用架构。 不同： 功能区别 门面模式只是增加了一个门面，对子系统没有增加任何功能，子系统脱离门面模式完全可以独立运行，中介者模式增加了业务功能，把各个同事类中的原有耦合关系移植到中介者，同事类不可能脱离中介者而独立存在。 知晓状态不同 门面模式中子系统不知道门面的存在，对中介者来说，每个同事类都知道中介者存在，因为要依靠中介者调和同事间关系。 封装程度不同 门面模式是简单封装，所有请求处理都委托给子系统完成，中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，术语更进一步的业务功能封装。 包装模式比较包装模式包括：装饰模式、适配器模式、门面模式、代理模式、桥梁模式。包装模式都通过委托的方式对一个对象或一系列对象施行包装，使设计的系统更加灵活、稳定、具有扩展性。从实现角度看，都是代理的一种表现形式。 代理模式：主要用在不希望展示一个对象内部细节的场景中。 装饰模式：特殊的代理模式，倡导不改变接口的前提下为对象增强功能，或动态添加额外职责，就扩展性而言，比子类更加灵活。 适配器模式：主要意图是接口转换，把一个对象的接口转换成系统希望的另一种接口，避免外界深入系统内部，提高系统的稳定性和可靠性。 桥梁模式：在抽象层产生耦合，解决自行扩展的问题，使两个耦合关系的对象互不影响的扩展。 门面模式：一个粗粒度的封装，提供一个方便访问子系统的接口，不具有任何业务逻辑，仅仅是一个访问复杂系统的快速通道，没有门面，子系统也可正常运行。 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-26-桥梁模式","slug":"design-pattern-26-bridge","date":"2017-09-08T15:41:00.000Z","updated":"2020-04-12T04:56:36.103Z","comments":true,"path":"2017/09/08/design-pattern-26-bridge/","link":"","permalink":"http://www.casezheng.date/2017/09/08/design-pattern-26-bridge/","excerpt":"","text":"桥梁模式的学习与实践 模式定义桥梁模式也叫桥接模式，其定义：将抽象和实现解耦，使得两者可以独立地变化。 类图 Abstraction 抽象化角色 主要职责是定义该角色的行为，同时保存一个对实现化角色的引用，该角色是一般为抽象类。 Implementor 实现化角色 接口或者抽象类，定义角色必须的行为和属性。 RefinedAbstraction 修正抽象化角色 引用实现化角色对抽象化角色进行修正。 ConcreteImplementor 具体具现化角色 实现接口或者抽象类定义的方法和属性。 抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。桥梁模式使用类间的聚合关系、继承、覆写等常用功能提供了非常清晰、稳定的架构。 优点 抽象和实现分离 完全是为了解决继承的缺点而提出的设计模式。该模式下实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。 优秀的扩充能力。 实现细节对用户透明 客户不关心细节的实现，已经由抽象层通过聚合关系完成了封装。 缺点使用场景 不希望或不适用使用继承的场景 接口或抽象类不稳定的场景 重用性要求高的场景 注意事项使用桥梁模式主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。当系统设计时发现类的继承有N层时，可以考虑使用桥梁模式。 扩展实践Bridge是设计模式中比较复杂和难理解的模式之一，在ＯＯ开发中经常会使用到．使用组合（委托）的方式将抽象和实现彻底地解耦，抽象和实现分别独立的变化，系统的耦合性得到了下降。 桥梁模式要抽象和实现分离，这里的实现不是指抽象基类中虚函数（接口）的实现，而是指如何去实现用户的需求，通过组合（委托）方式去实现，并不是指通过继承基类、实现基类接口，而是指通过对象组合实现用户的需求。 简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;using namespace std;//桥梁模式class AbstractionImp;class Abstraction&#123;public: virtual ~Abstraction() &#123;&#125;; virtual void Operation() = 0;protected: Abstraction() &#123;&#125;;&#125;;class AbstractionImp&#123;public: virtual ~AbstractionImp() &#123;&#125; virtual void Operation() = 0;protected: AbstractionImp() &#123;&#125;&#125;;void AbstractionImp::Operation()&#123; cout&lt;&lt;\"IMP\"&lt;&lt;__FUNCTION__&lt;&lt;endl;&#125;class RefinedAbstraction : public Abstraction&#123;public: RefinedAbstraction(AbstractionImp *imp) &#123; m_pImp = imp; &#125; ~RefinedAbstraction() &#123;&#125; void Operation() &#123; m_pImp-&gt;Operation(); &#125;private: AbstractionImp *m_pImp;&#125;;class ConcreteAbstractionImpA : public AbstractionImp&#123;public: ConcreteAbstractionImpA() &#123;&#125; ~ConcreteAbstractionImpA() &#123;&#125; virtual void Operation() &#123; cout&lt;&lt;\"A\"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class ConcreteAbstractionImpB : public AbstractionImp&#123;public: ConcreteAbstractionImpB() &#123;&#125; ~ConcreteAbstractionImpB() &#123;&#125; virtual void Operation() &#123; cout&lt;&lt;\"B\"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;int main()&#123; AbstractionImp *impa = new ConcreteAbstractionImpA(); Abstraction *absa = new RefinedAbstraction(impa); absa-&gt;Operation(); AbstractionImp *impb = new ConcreteAbstractionImpB(); Abstraction *absb = new RefinedAbstraction(impb); absb-&gt;Operation(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-25-享元模式","slug":"design-pattern-25-flyweight","date":"2017-09-08T05:30:00.000Z","updated":"2020-04-12T04:56:36.095Z","comments":true,"path":"2017/09/08/design-pattern-25-flyweight/","link":"","permalink":"http://www.casezheng.date/2017/09/08/design-pattern-25-flyweight/","excerpt":"","text":"享元模式的学习与实践 模式定义享元模式是池技术的重要实现方式，使用享元对象可有效支持大量的细粒度的对象。 享元模式的定义提出了两点要求：细粒度的对象和共享对象。细粒度对象使得对象数量多且性质相近，将对象的信息分为两部分：内部状态和外部状态。 内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而变化，可以作为对象的动态附加信息，不必直接储存在具体某个对象中，属于可以共享的部分。 外部状态是对象得以依赖的一个标记，随环境改变而变化、不可以共享的状态。 类图 Flyweight 抽象享元角色 简单来说就是产品的抽象类，同时定义出对象的内部状态和外部状态的接口或实现。 ConcreteFlyweight 具体享元角色 具体的产品类，实现抽象角色定义的业务，该角色中需要注意内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，又改变了外部状态。 unsharedConcreteFlyweight 不可共享的享元角色 不存在外部状态或者安全要求不能使用共享计数的对象。 FlyweightFactory 享元工厂 职责非常简单 就是构造一个池容器，同时提供从池中获得对象的方法。 优点大大减少应用程序创建的对象，降低程序内存的占用，增强程序性能。 缺点提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固话特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。 使用场景 系统中有大量的相似对象 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，即对象没有特定身份 需要缓冲池的场景 注意事项 线程安全问题 性能平衡 扩展实践对象池着重在系统的复用上，池中对象可相互替换，从同一池中获取的对象对于客户端来说完全相同。享元模式主要解决对象的共享问题，如何建立多个可共享的细粒度对象是其关注的重点。 简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//享元模式class Flyweight&#123;public: virtual ~Flyweight() &#123; ; &#125; virtual void Operation(const string &amp;extrinsicState) &#123; ; &#125; string GetIntrinsicState() &#123; return m_sIntrinsicState; &#125;protected: Flyweight(string intrinsicState) &#123; m_sIntrinsicState = intrinsicState; &#125;private: string m_sIntrinsicState;&#125;;class ConcreteFlyweight : public Flyweight&#123;public: ConcreteFlyweight(string intrinsicState) : Flyweight(intrinsicState) &#123; cout&lt;&lt;\"ConcreteFlyweight Build ....\"&lt;&lt;intrinsicState&lt;&lt;endl; &#125; ~ConcreteFlyweight() &#123; ; &#125; void Operation(const string &amp;extrinsicState) &#123; cout&lt;&lt;\"ConcreteFlyweight:内\"&lt;&lt;GetIntrinsicState()&lt;&lt;\"外\"&lt;&lt;extrinsicState&lt;&lt;endl;; &#125;&#125;;class FlyweightFactory&#123;public: FlyweightFactory() &#123; ; &#125; ~FlyweightFactory() &#123; ; &#125; Flyweight *GetFlywgight(const string &amp;key) &#123; //auto it = m_vFly.begin(); //for(; it!=m_vFly.end(); ++it) //&#123; //if((*it)-&gt;GetIntrinsicState() == key) //&#123; //cout&lt;&lt;\"already creteed by users ...\"&lt;&lt;key&lt;&lt;endl; //return *it; //&#125; //&#125; for(auto it:m_vFly) &#123; if(it-&gt;GetIntrinsicState() == key) &#123; cout&lt;&lt;\"already creteed by users ...\"&lt;&lt;key&lt;&lt;endl; return it; &#125; &#125; Flyweight *fn = new ConcreteFlyweight(key); m_vFly.push_back(fn); return fn; &#125;private: vector&lt;Flyweight*&gt; m_vFly;&#125;;int main()&#123; FlyweightFactory fc; Flyweight *fw1 = fc.GetFlywgight(\"hello\"); cout&lt;&lt;fw1-&gt;GetIntrinsicState()&lt;&lt;endl; Flyweight *fw2 = fc.GetFlywgight(\"world\"); cout&lt;&lt;fw2-&gt;GetIntrinsicState()&lt;&lt;endl; Flyweight *fw3 = fc.GetFlywgight(\"hello\"); cout&lt;&lt;fw3-&gt;GetIntrinsicState()&lt;&lt;endl; return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-24-解释器模式","slug":"design-pattern-24-interpreter","date":"2017-09-07T14:49:00.000Z","updated":"2020-04-12T04:56:36.093Z","comments":true,"path":"2017/09/07/design-pattern-24-interpreter/","link":"","permalink":"http://www.casezheng.date/2017/09/07/design-pattern-24-interpreter/","excerpt":"","text":"解释器模式的学习与实践 模式定义给定一门语言，定义其文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 类图 AbstraceExpression 抽象解释器 具体的解释任务由各个实现类完成，TerminalExpression和NonterminalExpression完成具体解释器 TerminalExpression 终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但由多个实例，对应不同终结符。 NonterminalExpression 非终结符表达式 文法中的每条规则对应于一个非终结表达式。 Context 环境角色 解释器是一个比较少用的模式。 优点解释器是简单语法分析工具，最显著的优点是扩展性，修改语法规则只要修改相应的非终结符表达式，若扩展语法，则只要增加非终结符类即可。 缺点 解释器模式会引起类膨胀 解释器模式采用递归调用方法 效率问题 使用场景 重复发生的问题可以使用解释器模式 一个简单语法需要解释的场景 注意事项在重要模块尽量不要使用解释器模式，否则维护会比较麻烦。 扩展实践简单实现参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-23-状态模式","slug":"design-pattern-23-state","date":"2017-09-07T14:20:00.000Z","updated":"2020-04-12T04:56:36.092Z","comments":true,"path":"2017/09/07/design-pattern-23-state/","link":"","permalink":"http://www.casezheng.date/2017/09/07/design-pattern-23-state/","excerpt":"","text":"状态模式的学习与实践 模式定义当一个对象内在状态改变时允许其改变行为，该对象看起来像改变了其类。状态模式的核心是封装，状态的变化引起了行为的变更，从外部看起来好像这个对象对应的类改变了一样。 类图 State 抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色已实现状态切换。 ConcreteState 具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，即本状态要做什么，以及本状态如何过渡到其他状态。 Context 环境角色 定义客户端需要的接口，并且负责具体状态的切换。 环境角色的约定： 状态对象声明为静态常量。 环境角色具有状态抽象角色定义的所有行为。 优点 结构清晰 遵循设计原则 很好的体现了开闭原则和单一职责原则 封装性好 缺点子类会有太多。 使用场景 行为随状态而改变的场景 条件、分支判断语句的替代者 注意事项状态模式适用于当某个对象在它的状态发生改变时，行为随着发生比较大的变化，即行为受状态约束的情况下可以使用状态模式。使用是对象的状态最好不要超过5个。 扩展实践简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;using namespace std;//状态模式class State;class Context;class ConcreteStateA;class ConcreteStateB;class State&#123;public: State() &#123; ; &#125; virtual ~State() &#123; ; &#125; virtual void OperationInterface(Context *) = 0; virtual void OperationChangeState(Context *) = 0;protected: bool ChangeState(Context *con, State *st);&#125;;void State::OperationInterface(Context *con)&#123; cout&lt;&lt;\"State::..\"&lt;&lt;endl;&#125;class ConcreteStateA : public State&#123;public: ConcreteStateA() &#123; ; &#125; virtual ~ConcreteStateA() &#123; ; &#125; virtual void OperationInterface(Context *con) &#123; cout&lt;&lt;\"ConcreteStateA::OperationInterface...\"&lt;&lt;endl; &#125; virtual void OperationChangeState(Context *con);&#125;;class ConcreteStateB : public State&#123;public: ConcreteStateB() &#123; ; &#125; virtual ~ConcreteStateB() &#123; ; &#125; virtual void OperationInterface(Context *con) &#123; cout&lt;&lt;\"ConcreteStateB::OperationInterface...\"&lt;&lt;endl; &#125; virtual void OperationChangeState(Context *con) &#123; OperationInterface(con); ChangeState(con, new ConcreteStateA()); &#125;&#125;;class Context&#123;public: Context() &#123; ; &#125; Context(State *state) &#123; m_State = state; &#125; ~Context() &#123; delete m_State; &#125; void OperationInterface() &#123; m_State-&gt;OperationInterface(this); &#125; void OperationChangeState() &#123; m_State-&gt;OperationChangeState(this); &#125; bool ChangeState(State *state) &#123; m_State = state; return true; &#125;private: State *m_State;friend class State;&#125;;bool State::ChangeState(Context *con, State *st)&#123; con-&gt;ChangeState(st);&#125;void ConcreteStateA::OperationChangeState(Context *con)&#123; OperationInterface(con); ChangeState(con, new ConcreteStateB());&#125;int main()&#123; State *st = new ConcreteStateA(); Context *con = new Context(st); con-&gt;OperationChangeState(); con-&gt;OperationChangeState(); con-&gt;OperationChangeState(); con-&gt;OperationChangeState(); con-&gt;OperationChangeState(); con-&gt;OperationChangeState(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-22-访问者模式","slug":"design-pattern-22-visitor","date":"2017-09-07T05:33:00.000Z","updated":"2020-04-12T04:56:36.091Z","comments":true,"path":"2017/09/07/design-pattern-22-visitor/","link":"","permalink":"http://www.casezheng.date/2017/09/07/design-pattern-22-visitor/","excerpt":"","text":"访问者模式的学习与实践 模式定义封装一些作用于某种数据结构中的各元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 类图 Visitor 抽象访问者 抽象类或者接口，声明访问者可以访问的元素。具体到程序中即visit方法的参数定义哪些对象是可以被访问的。 ConcreteVisitor 具体访问者 影响访问者访问到一个类后该怎么干，要做什么事情。 Element 抽象元素 接口或者抽象类，声明接受哪一类访问者访问，程序上通过accept方法中的参数定义。 ConcreateElement 具体元素 实现accept方法，通常是visitor.visit(this) 基本上形成了一个模式。 ObjectStruture 结构对象 元素产生者，一般容纳多个不同类、不同接口的容器。项目中很少抽象出该角色。 优点 符合单一职责原则 优秀的扩展性 灵活性非常高 缺点 具体元素对访问者公布细节 具体元素变更比较困难 违背依赖倒置原则 使用场景业务规则要求遍历多个不同对象。 注意事项扩展 统计功能 多个访问者 实践简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;using namespace std;//访问者模式class ConcreteElementA;class ConcreteElementB;class Element;class Visitor&#123;public: virtual ~Visitor() &#123; &#125; virtual void VisitConcreteElementA(Element *elm) = 0; virtual void VisitConcreteElementB(Element *elm) = 0;protected: Visitor() &#123; &#125;&#125;;class ConcreteVisitorA : public Visitor&#123;public: ConcreteVisitorA() &#123; &#125; virtual ~ConcreteVisitorA() &#123; &#125; virtual void VisitConcreteElementA(Element *elm) &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" i will visit ConcreteElementA...\"&lt;&lt;endl; &#125; virtual void VisitConcreteElementB(Element *elm) &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" i will visit ConcreteElementB...\"&lt;&lt;endl; &#125;&#125;;class ConcreteVisitorB : public Visitor&#123;public: ConcreteVisitorB() &#123; &#125; virtual ~ConcreteVisitorB() &#123; &#125; virtual void VisitConcreteElementA(Element *elm) &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" i will visit ConcreteElementA...\"&lt;&lt;endl; &#125; virtual void VisitConcreteElementB(Element *elm) &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" i will visit ConcreteElementB...\"&lt;&lt;endl; &#125;&#125;;class Element&#123;public: virtual ~Element() &#123; &#125; virtual void Accept(Visitor *vis) = 0;protected: Element() &#123; &#125;&#125;;class ConcreteElementA : public Element&#123;public: ConcreteElementA() &#123; &#125; ~ConcreteElementA() &#123; &#125; void Accept(Visitor *vis) &#123; cout&lt;&lt;\"visiting ConcreteElementA...\"&lt;&lt;endl; vis-&gt;VisitConcreteElementA(this); &#125;&#125;;class ConcreteElementB : public Element&#123;public: ConcreteElementB() &#123; &#125; ~ConcreteElementB() &#123; &#125; void Accept(Visitor *vis) &#123; cout&lt;&lt;\"visiting ConcreteElementB...\"&lt;&lt;endl; vis-&gt;VisitConcreteElementB(this); &#125;&#125;;int main()&#123; Visitor *visa = new ConcreteVisitorA(); Element *elma = new ConcreteElementA(); elma-&gt;Accept(visa); Visitor *visb = new ConcreteVisitorB(); Element *elmb = new ConcreteElementB(); elmb-&gt;Accept(visb); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-21-备忘录模式","slug":"design-pattern-21-memento","date":"2017-09-06T16:16:00.000Z","updated":"2020-04-12T04:56:36.089Z","comments":true,"path":"2017/09/07/design-pattern-21-memento/","link":"","permalink":"http://www.casezheng.date/2017/09/07/design-pattern-21-memento/","excerpt":"","text":"备忘录模式的学习与实践 模式定义在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 类图 Originator 发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 Memento 备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 Caretaker 备忘录管理员角色 对备忘录进行管理、保存和提供备忘录。 优点缺点使用场景 需要保存和回数数据的相关状态场景。 提供一个可回滚的操作。 需要监控的副本场景中。 数据库连接的事物管理。 注意事项 备忘录的生命期。 备忘录的性能。 扩展 clone方式的备忘录 多状态的备忘录 多备份的备忘录 封装性更好的备忘录 实践简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;using namespace std;typedef string State;class Originator;class Memento&#123;public: friend class Originator; Memento(); Memento(const State &amp;sdt); ~Memento() &#123; &#125; void SetState(const State &amp;sdt); State GetState();private: State m_sSdt;&#125;;Memento::Memento()&#123;&#125;Memento::Memento(const State &amp;sdt)&#123; m_sSdt = sdt;&#125;State Memento::GetState()&#123; return m_sSdt;&#125;void Memento::SetState(const State &amp;sdt)&#123; m_sSdt = sdt;&#125;class Originator&#123;public: Originator() &#123; m_sSdt = \"\"; m_pMt = nullptr; &#125; Originator(const State &amp;sdt) &#123; m_sSdt = sdt; m_pMt = nullptr; &#125; ~Originator() &#123; &#125; Memento *CreateMemento() &#123; return new Memento(m_sSdt); &#125; void RestoreToMemento(Memento *mt) &#123; m_sSdt = mt-&gt;GetState(); &#125; State GetState() &#123; return m_sSdt; &#125; void SetState(const State &amp;sdt) &#123; m_sSdt = sdt; &#125; void PrintState() &#123; cout&lt;&lt;\"Originator \"&lt;&lt;__FUNCTION__&lt;&lt;\" \"&lt;&lt;m_sSdt&lt;&lt;endl; &#125;private: State m_sSdt; Memento *m_pMt;&#125;;int main()&#123; Originator *o = new Originator(); o-&gt;SetState(\"old\"); o-&gt;PrintState(); Memento *m = o-&gt;CreateMemento(); o-&gt;SetState(\"new\"); o-&gt;PrintState(); o-&gt;RestoreToMemento(m); o-&gt;PrintState(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-20-门面模式（外观）","slug":"design-pattern-20-facade","date":"2017-09-06T15:29:00.000Z","updated":"2020-04-12T04:56:36.086Z","comments":true,"path":"2017/09/06/design-pattern-20-facade/","link":"","permalink":"http://www.casezheng.date/2017/09/06/design-pattern-20-facade/","excerpt":"","text":"门面模式的学习与实践 门面模式（外观模式）要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 类图 Facade 门面角色 客户端调用该角色的方法，该角色知晓子系统的所有功能和责任。该角色将所有从客户端发来的请求委派到相应的子系统，即该角色没有实际的业务逻辑，只是一个委托类。 SubsystemClasses 子系统角色，可以同时存在一个或多个子系统，每个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在，对于子系统，门面仅仅是另一个客户端而已。 优点 减少系统的相互依赖 提高灵活性 提高安全性 缺点不符合开闭原则，门面角色一旦出现问题，遵从开闭原则，没有好的解决方法，只能修改门面角色的代码。 使用场景 为法则的模块或子系统提供一个供外界访问的接口。 子系统相对独立，外界对子系统的访问只是黑箱操作而已。 预防低水平人员带来的风险扩散。 注意事项 一个子系统可以有多个门面 门面过于庞大 子系统可以提供不同访问路径 门面不参与子系统内的业务逻辑 扩展实践门面模式是很好的封装方法，一个子系统比较复杂时可以封装出一个或多个门面出来，项目结构简单，而且扩展性好。 简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;class Subsystem1&#123;public: Subsystem1() &#123; &#125; ~Subsystem1() &#123; &#125; void Operation() &#123; cout&lt;&lt;\"Subsystem1 \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class Subsystem2&#123;public: Subsystem2() &#123; &#125; ~Subsystem2() &#123; &#125; void Operation() &#123; cout&lt;&lt;\"Subsystem2 \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class Facade&#123;public: Facade() &#123; m_pSub1 = new Subsystem1(); m_pSub2 = new Subsystem2(); &#125; ~Facade() &#123; delete m_pSub1; delete m_pSub2; &#125; void Operation() &#123; cout&lt;&lt;\"Facade \"&lt;&lt;__FUNCTION__&lt;&lt;endl; m_pSub1-&gt;Operation(); m_pSub2-&gt;Operation(); &#125;private: Subsystem1 *m_pSub1; Subsystem2 *m_pSub2;&#125;;int main()&#123; Facade fac; fac.Operation(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-19-观察者模式","slug":"design-pattern-19-observer","date":"2017-09-06T05:33:00.000Z","updated":"2020-04-12T04:56:36.078Z","comments":true,"path":"2017/09/06/design-pattern-19-observer/","link":"","permalink":"http://www.casezheng.date/2017/09/06/design-pattern-19-observer/","excerpt":"","text":"观察者模式的学习与实践，观察者模式是软件开发过程中必须掌握和使用的模式之一。 观察者模式观察者模式（发布订阅模式）：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 类图 Subject 被观察者 定义被观察者必须实现的职责，必须能能够动态地增加、删除观察者。一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。 Observer 观察者 观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。 ConcreteSubject 具体的被观察者 定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。 ConcreteObserver 具体的观察者 每个观察者在接收到信息后的处理反应是不同的，各个观察者有自己的处理流程。 优点 观察者和被观察者之间是抽象耦合，增加观察者和被观察者非常容易扩展。 建立一套触发机制。 缺点开发效率和运行效率问题。 使用场景 关联行为场景。关联行为是可拆分的，而不是“组合”关系。 事件多级触发场景。 跨系统的消息交换场景。 注意事项 广播链的问题。建议一个观察者模式中最多出现一个对象既是观察者也是被观察者。 异步处理问题。 扩展实践简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;typedef string State;class Observer;class Subject&#123;public: virtual ~Subject() &#123; &#125; virtual void Attach(Observer *obv) &#123; m_lObvs.push_front(obv); &#125; virtual void Detach(Observer *obv) &#123; if(obv != NULL) &#123; m_lObvs.remove(obv); &#125; &#125; virtual void Notify(); virtual void SetState(const State &amp;st) = 0; virtual State GetState() = 0;protected: Subject() &#123; &#125;private: list&lt;Observer *&gt; m_lObvs;&#125;;class ConcreteSubject : public Subject&#123;public: ConcreteSubject() &#123; &#125; ~ConcreteSubject() &#123; &#125; State GetState() &#123; return m_sSt; &#125; void SetState(const State&amp; st) &#123; m_sSt = st; Notify(); &#125;private: State m_sSt;&#125;;class Observer&#123;public: virtual ~Observer() &#123; &#125; virtual void Update(Subject *sub) = 0; virtual void PrintInfo() = 0;protected: Observer() &#123; &#125; State m_sSt;&#125;;class ConcreteObserverA : public Observer&#123;public: virtual Subject *GetSubject() &#123; return m_pSub; &#125; ConcreteObserverA(Subject *sub) &#123; m_pSub = sub; m_pSub-&gt;Attach(this); &#125; virtual ~ConcreteObserverA() &#123; m_pSub-&gt;Detach(this); &#125; void Update(Subject *sub) &#123; m_sSt = m_pSub-&gt;GetState(); PrintInfo(); &#125; void PrintInfo() &#123; cout&lt;&lt;\"A \"&lt;&lt;m_pSub-&gt;GetState()&lt;&lt;endl; &#125;private: Subject *m_pSub;&#125;;class ConcreteObserverB : public Observer&#123;public: virtual Subject *GetSubject() &#123; return m_pSub; &#125; ConcreteObserverB(Subject *sub) &#123; m_pSub = sub; m_pSub-&gt;Attach(this); &#125; virtual ~ConcreteObserverB() &#123; m_pSub-&gt;Detach(this); &#125; void Update(Subject *sub) &#123; m_sSt = m_pSub-&gt;GetState(); PrintInfo(); &#125; void PrintInfo() &#123; cout&lt;&lt;\"B \"&lt;&lt;m_pSub-&gt;GetState()&lt;&lt;endl; &#125;private: Subject *m_pSub;&#125;;void Subject::Notify()&#123; for(auto pObv : m_lObvs) &#123; if(pObv != NULL) &#123; pObv-&gt;Update(this); &#125; &#125;&#125;int main()&#123; ConcreteSubject *sub = new ConcreteSubject(); Observer *o1 = new ConcreteObserverA(sub); sub-&gt;SetState(\"state1\"); Observer *o2 = new ConcreteObserverB(sub); sub-&gt;SetState(\"state2\"); sub-&gt;SetState(\"state3\"); delete o1; delete o2; delete sub; return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-18-组合模式","slug":"design-pattern-18-composite","date":"2017-09-05T15:36:00.000Z","updated":"2020-04-12T04:56:36.076Z","comments":true,"path":"2017/09/05/design-pattern-18-composite/","link":"","permalink":"http://www.casezheng.date/2017/09/05/design-pattern-18-composite/","excerpt":"","text":"组合模式的学习与实践 组合模式组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 类图 Component 抽象构件角色 定义参加组合对象的公有方法和属性，可以定义一些默认的行为和属性 Leaf 叶子构件 叶子对象，其下不再有分支，遍历的最小单位 Composite 树枝构建 组合树枝节点和叶子节点形成树形结构 优点 高层模块调用简单 节点自由添加 缺点直接使用实现类，在面向接口编程上很不恰当，与依赖倒置原则冲突。 使用场景 维护和展示部分——整体关系的场景 从一个整体中能够独立出部分模块或功能的场景 注意事项只要是树形结构就可以考虑组合模式，只要是要体现局部和整体的关系，而关系比较深，考虑组合模式。 扩展 组合模式实现 透明模式 具体操作在抽象类中定义实现 组合模式实现 安全模式 具体操作在具体类中定义实现 实践简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Component&#123;public: Component() &#123; &#125; virtual ~Component() &#123; &#125;public: virtual void Operation() = 0; virtual void Add(const Component *com) &#123; &#125; virtual void Remove(const Component *com) &#123; &#125; virtual Component* GetChild(int) &#123; return nullptr; &#125;&#125;;class Componsite : public Component //中间节点，可添加子节点&#123;public: Componsite() &#123; &#125; ~Componsite() &#123; &#125;public: void Operation() &#123; for(auto it : m_vCom) &#123; it-&gt;Operation(); &#125; &#125; void Add(Component *com) &#123; m_vCom.push_back(com); &#125; void Remove(Component *com) &#123; auto it = find(m_vCom.begin(), m_vCom.end(), com); if(it != m_vCom.end()) &#123; m_vCom.erase(it); &#125; &#125; Component* GetChild(int index) &#123; if(index &gt;= m_vCom.size()) &#123; return nullptr; &#125; return m_vCom[index]; &#125;private: vector&lt;Component*&gt; m_vCom;&#125;;class Leaf : public Component //叶子节点，不可添加子节点&#123;public: Leaf() &#123; &#125; ~Leaf() &#123; &#125; void Operation() &#123; cout&lt;&lt;\"Leaf \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;int main()&#123; Leaf *l = new Leaf(); l-&gt;Operation(); Componsite *com = new Componsite(); com-&gt;Add(l); com-&gt;Operation(); Component *ll = com-&gt;GetChild(0); ll-&gt;Operation(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-17-迭代器模式","slug":"design-pattern-17-iterator","date":"2017-09-05T14:22:00.000Z","updated":"2020-04-12T04:56:36.072Z","comments":true,"path":"2017/09/05/design-pattern-17-iterator/","link":"","permalink":"http://www.casezheng.date/2017/09/05/design-pattern-17-iterator/","excerpt":"","text":"迭代器模式的学习与实践 迭代器模式迭代器模式：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。 类图 Iterator 抽象迭代器 抽象迭代器负责定义访问和遍历元素的接口 ConcreteIterator 具体迭代器 实现迭代器接口，完成容器元素的遍历 Aggregate 抽象容器 负责提供具体迭代器角色的接口 ConcreteAggregate 具体容器 具体容器实现容器接口定义的方法，创建出容纳迭代器的对象 优点缺点使用场景注意事项扩展实践简单实现参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-16-适配器模式","slug":"design-pattern-16-adapter","date":"2017-09-04T05:28:00.000Z","updated":"2020-04-12T04:56:36.069Z","comments":true,"path":"2017/09/04/design-pattern-16-adapter/","link":"","permalink":"http://www.casezheng.date/2017/09/04/design-pattern-16-adapter/","excerpt":"","text":"适配器模式的学习与实践 适配器模式适配器模式：将一个类的接口变换成客户端所期待的另一种接口，使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 类图 Target 目标角色，该角色定义把其他类转换为何种接口 Adaptee 源角色 Adapter适配器角色 适配器模式的核心角色，Target和Adaptee是已存在的角色，而Adapter是需要新建立的，职责是通过继承或者类关联的方式把源角色转化为目标角色。 优点 可以把两个没有任何关系的类在一起运行 增加类的透明性 提高类的复用性 灵活性非常好 缺点使用场景当需要修改一个已经使用的接口的时候 注意事项适配器模式不是为了解决开发阶段的问题，而是解决正在使用的项目问题。其主要使用场景是扩展应用中。 扩展对象适配器是对象的合成关系（或关联关系）。类适配器是类间关系。 实践简单实现cpp 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-15-策略模式","slug":"design-pattern-15-strategy","date":"2017-09-03T08:46:00.000Z","updated":"2020-04-12T04:56:36.060Z","comments":true,"path":"2017/09/03/design-pattern-15-strategy/","link":"","permalink":"http://www.casezheng.date/2017/09/03/design-pattern-15-strategy/","excerpt":"","text":"策略模式的学习与实践 策略模式策略模式定义：定义一组算法，将每个算法封装起来，并且使它们之间可以互相互换。 类图 Context 封装角色（上下文角色），起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 Strategy 抽象策略角色 策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。 ConcreteStrategy 具体策略角色 实现抽象策略中的操作，该类含有具体的算法。 优点 算法可以自由切换 策略模式本身定义的，只要实现抽象策略，即为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供可自由切换的策略。 必买年使用多重条件判断。 扩展性良好 缺点 策略类数量增多，每个策略都是一个类，复用的可能性低 所有的策略类都需要对外暴露 使用场景 多个类只是在算法或行为上稍有不同的场景 算法需要自由切换的场景 需要屏蔽算法规则的场景 注意事项如果系统中一个策略家族的具体策略数量超过4个，则需要考虑混合模式，解决策略类膨胀和对外暴露的问题。 扩展实践简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;using namespace std;class Strategy&#123;public: Strategy() &#123; &#125; virtual ~Strategy() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; virtual void AlgrithmInterface() = 0;&#125;;class StrategyA : public Strategy&#123;public: StrategyA() &#123; &#125; virtual ~StrategyA() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; void AlgrithmInterface() &#123; cout&lt;&lt;\"A \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class StrategyB : public Strategy&#123;public: StrategyB() &#123; &#125; virtual ~StrategyB() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; void AlgrithmInterface() &#123; cout&lt;&lt;\"B \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class Context&#123;public: Context(Strategy *stg) &#123; SetStg(stg); &#125; ~Context() &#123; if(m_pStg != nullptr) &#123; delete m_pStg; &#125; &#125; void DoAction() &#123; if(m_pStg != nullptr) &#123; m_pStg-&gt;AlgrithmInterface(); &#125; &#125; void SetStg(Strategy *stg) &#123; if(m_pStg != nullptr) &#123; delete m_pStg; m_pStg = nullptr; &#125; m_pStg = stg; &#125;private: Strategy *m_pStg;&#125;;int main()&#123; Context *pc = new Context(new StrategyA()); pc-&gt;DoAction(); pc-&gt;SetStg(new StrategyB()); pc-&gt;DoAction(); if(pc != nullptr) &#123; delete pc; pc = nullptr; &#125; return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-14-装饰模式","slug":"design-pattern-14-decorator","date":"2017-09-02T16:46:00.000Z","updated":"2020-04-12T04:56:36.058Z","comments":true,"path":"2017/09/03/design-pattern-14-decorator/","link":"","permalink":"http://www.casezheng.date/2017/09/03/design-pattern-14-decorator/","excerpt":"","text":"装饰模式的学习与实践 装饰模式装饰模式定义：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活。 类图 Component 抽象构建 一个接口或者抽象类，定义最核心的对象，最原始的对象 ConcreteComponent 具体构建 最核心、最原始、最基本接口或抽象类的实现，需要修饰的对象 Decorator 修饰角色 必然有一个private变量指向Componet抽象构建 ConcreteDecorator 具体装饰角色 优点 装饰类和被装饰类可以独立发展，而不会相互耦合。 装饰模式是继承关系的替代方案。 装饰模式可以动态扩展一个实现类的功能。 缺点多层的装饰是比较复杂的，应尽量减少装饰类的数量，降低系统复杂度。 使用场景 需要扩展一个类的功能，或给一个类增加附加功能 需要动态地给一个对象增加功能，该功能可以再动态的撤销 需要为一批兄弟类进行改装或加装功能 注意事项扩展实践装饰模式是对继承的有力补充。 简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;//装饰模式class Component&#123;public: virtual ~Component() &#123; &#125; virtual void Operation() &#123; &#125;;protected: Component() &#123; &#125;&#125;;class ConcreteComponent : public Component&#123;public: ConcreteComponent() &#123; &#125; ~ConcreteComponent() &#123; &#125; void Operation() &#123; cout&lt;&lt;\"ConcreteComponent \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;class Decorator : public Component&#123;public: Decorator(Component *com) &#123; m_pCom = com; &#125; virtual ~Decorator() &#123; delete m_pCom; &#125; void Operation() &#123; &#125;protected: Component *m_pCom;&#125;;class ConcreteDecorator : public Decorator&#123;public: ConcreteDecorator(Component *com) : Decorator(com) &#123; &#125; ~ConcreteDecorator() &#123; &#125; void Operation() &#123; m_pCom-&gt;Operation(); AddedBehavior(); &#125; void AddedBehavior() &#123; cout&lt;&lt;\"ConcreteDecorator \"&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;int main()&#123; Component *com = new ConcreteComponent(); Decorator *dec = new ConcreteDecorator(com); dec-&gt;Operation(); delete dec; return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-13-责任链模式","slug":"design-pattern-13-chain-of-responsibility","date":"2017-09-02T15:37:00.000Z","updated":"2020-04-12T04:56:36.056Z","comments":true,"path":"2017/09/02/design-pattern-13-chain-of-responsibility/","link":"","permalink":"http://www.casezheng.date/2017/09/02/design-pattern-13-chain-of-responsibility/","excerpt":"","text":"责任链模式学习与实践 责任链模式责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为之。 类图责任链模式的核心在“链”上，“链”是由多个处理者Concreteandler组成。 优点将请求和处理分开，请求者可以不用知道谁处理的，处理者不用知道请求的全貌，两者解耦，提高系统灵活性。 缺点性能，每个请求都从链头遍历到链尾，当链表特别长时，性能是一个非常大的问题。 使用场景注意事项链表中节点数量需要控制，避免出现超长链的情况。 扩展实践简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;using namespace std;//责任链模式class Handle&#123;public: virtual ~Handle() &#123; delete m_pSucc; &#125; virtual void HandleRequest() = 0; void SetSuccessor(Handle *succ) &#123; m_pSucc = succ; &#125; Handle *GetSuccessor() &#123; return m_pSucc; &#125;protected: Handle() &#123; m_pSucc = nullptr; &#125; Handle(Handle *succ) &#123; &#125;private: Handle *m_pSucc;&#125;;class ConcreteHandleA : public Handle&#123;public: ConcreteHandleA() &#123; &#125; ~ConcreteHandleA() &#123; &#125; ConcreteHandleA(Handle *succ) : Handle(succ) &#123; &#125; void HandleRequest() &#123; if(GetSuccessor() != 0) &#123; cout&lt;&lt;\"ConcreteHandleA next\"&lt;&lt;endl; GetSuccessor()-&gt;HandleRequest(); &#125; else &#123; cout&lt;&lt;\"ConcreteHandleA process\"&lt;&lt;endl; &#125; &#125;&#125;;class ConcreteHandleB : public Handle&#123;public: ConcreteHandleB() &#123; &#125; ~ConcreteHandleB() &#123; &#125; ConcreteHandleB(Handle *succ) : Handle(succ) &#123; &#125; void HandleRequest() &#123; if(GetSuccessor() != 0) &#123; cout&lt;&lt;\"ConcreteHandleB next\"&lt;&lt;endl; GetSuccessor()-&gt;HandleRequest(); &#125; else &#123; cout&lt;&lt;\"ConcreteHandleB process\"&lt;&lt;endl; &#125; &#125;&#125;;int main()&#123; Handle *h1 = new ConcreteHandleA(); Handle *h2 = new ConcreteHandleB(); h1-&gt;SetSuccessor(h2); h1-&gt;HandleRequest(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-12-命令模式","slug":"design-pattern-12-command","date":"2017-09-02T02:47:00.000Z","updated":"2020-04-12T04:56:36.055Z","comments":true,"path":"2017/09/02/design-pattern-12-command/","link":"","permalink":"http://www.casezheng.date/2017/09/02/design-pattern-12-command/","excerpt":"","text":"命令模式的学习与实践 命令模式命令模式是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 类图 Receive接受者角色，执行命令的角色 Command命令角色，需要执行的所有命令都在这里申明 Invoker调用者角色，接受到命令，并执行命令 命令模式简单，封装性非常好，将请求方和执行方分开，扩展性有了保障，通用代码简单。 优点 类间解偶，调用者和接收者角色之间没有任何依赖关系，调用者实现功能只需调用Command抽象类的execute方法，不需要了解是那个接收者。 可扩展性，Command的子类容易扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。 命令模式结合其他模式会更优秀，命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。 缺点Command的子类，如果由N个命令，Command的子类会有N个，该类会膨胀的非常大。 使用场景在出现命令的地方都可以使用命令模式。 注意事项扩展实践简单实现在实际应用中可以有多个Reciever，将Reciever封装在Command中，不对Client暴露，并在Command中维护队列，将多个事件按队列依次执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;using namespace std;//命令模式class Reciever&#123;public: Reciever() &#123;&#125;; virtual ~Reciever() &#123;&#125;; virtual void Action() = 0;&#125;;class RecieverA : public Reciever&#123;public: RecieverA() &#123;&#125;; virtual ~RecieverA() &#123;&#125;; void Action() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" A\"&lt;&lt;endl; &#125;&#125;;class RecieverB : public Reciever&#123;public: RecieverB() &#123;&#125;; virtual ~RecieverB() &#123;&#125;; void Action() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" B\"&lt;&lt;endl; &#125;&#125;;class Command&#123;public: virtual ~Command() &#123;&#125;; virtual void Excute() = 0;protected: Command()&#123;&#125;;&#125;;class ConcreteCommand : public Command&#123;public: ConcreteCommand(Reciever *rec) &#123; m_pRev = rec; &#125; ~ConcreteCommand() &#123; delete m_pRev; &#125; void Excute() &#123; m_pRev-&gt;Action(); cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;private: Reciever *m_pRev;&#125;;class Invoker&#123;public: Invoker(Command* cmd) &#123; m_pCmd = cmd; &#125; ~Invoker() &#123; delete m_pCmd; &#125; void Invoke() &#123; m_pCmd-&gt;Excute(); &#125;private: Command *m_pCmd;&#125;;int main()&#123; Reciever *reva = new RecieverA(); Command *cmda = new ConcreteCommand(reva); Invoker *inva = new Invoker(cmda); inva-&gt;Invoke(); Reciever *revb = new RecieverB(); Command *cmdb = new ConcreteCommand(revb); Invoker *invb = new Invoker(cmdb); invb-&gt;Invoke(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-11-中介者模式","slug":"design-pattern-11-mediator","date":"2017-08-31T14:46:00.000Z","updated":"2020-04-12T04:56:36.053Z","comments":true,"path":"2017/08/31/design-pattern-11-mediator/","link":"","permalink":"http://www.casezheng.date/2017/08/31/design-pattern-11-mediator/","excerpt":"","text":"中介者模式的学习与实践 中介者模式中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散可以独立地改变它们之间的交互。 类图 优点减少类间的依赖，将原有的一对多的依赖变成一对一的依赖。降低类间的耦合。 缺点中介者会膨胀的很大，而且逻辑复杂，原先对象直接的依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。 使用场景类图中出现了蜘蛛网状结构，使用中介者模式将蜘蛛网梳理为星形结构，使混乱的关系变得清晰简单。 注意事项扩展实践简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//中介者模式class Mediator;class Colleage&#123;public: ~Colleage() &#123;&#125; virtual void Action() = 0; virtual void SetState(const string &amp;sdt) = 0; virtual string GetState() = 0;protected: Colleage() &#123;&#125; Colleage(Mediator *mdt) &#123; m_pMdt = mdt; &#125; Mediator *m_pMdt;&#125;;class Mediator&#123;public: virtual ~Mediator() &#123;&#125;; virtual void ActionA() = 0; virtual void ActionB() = 0;protected: Mediator() &#123;&#125;;&#125;;class ConcreteMediator : public Mediator&#123;public: ConcreteMediator() &#123;&#125; ConcreteMediator(Colleage *clgA, Colleage *clgB) &#123; m_pClgA = clgA; m_pClgB = clgB; &#125; ~ConcreteMediator() &#123;&#125; void SetConcreteColleageA(Colleage *clgA) &#123; m_pClgA = clgA; &#125; void SetConcreteColleageB(Colleage *clgB) &#123; m_pClgB = clgB; &#125; Colleage *GetConcreteColleageA() &#123; return m_pClgA; &#125; Colleage *GetConcreteColleageB() &#123; return m_pClgB; &#125; void IntroColleage(Colleage *clgA, Colleage *clgB) &#123; m_pClgA = clgA; m_pClgB = clgB; &#125; void ActionA() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" A \"&lt;&lt;m_pClgA-&gt;GetState()&lt;&lt;endl; &#125; void ActionB() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;\" B \"&lt;&lt;m_pClgB-&gt;GetState()&lt;&lt;endl; &#125;private: Colleage * m_pClgA; Colleage * m_pClgB;&#125;;class ConcreteColleageA : public Colleage&#123;public: ConcreteColleageA() &#123;&#125; ConcreteColleageA(Mediator *mdt) : Colleage(mdt) &#123; ; &#125; ~ConcreteColleageA() &#123;&#125; void Action() &#123; m_pMdt-&gt;ActionB(); cout&lt;&lt;\"state of ConcreteColleageA:\"&lt;&lt;GetState()&lt;&lt;endl; &#125; void SetState(const string&amp; sdt) &#123; m_sSdt = sdt; &#125; string GetState() &#123; return m_sSdt; &#125;private: string m_sSdt;&#125;;class ConcreteColleageB : public Colleage&#123;public: ConcreteColleageB() &#123;&#125; ConcreteColleageB(Mediator *mdt) : Colleage(mdt) &#123; ; &#125; ~ConcreteColleageB() &#123;&#125; void Action() &#123; m_pMdt-&gt;ActionA(); cout&lt;&lt;\"state of ConcreteColleageB:\"&lt;&lt;GetState()&lt;&lt;endl; &#125; void SetState(const string&amp; sdt) &#123; m_sSdt = sdt; &#125; string GetState() &#123; return m_sSdt; &#125;private: string m_sSdt;&#125;;int main()&#123; ConcreteMediator *m = new ConcreteMediator(); ConcreteColleageA *ca = new ConcreteColleageA(m); ConcreteColleageB *cb = new ConcreteColleageB(m); m-&gt;IntroColleage(ca, cb); m-&gt;ActionA(); ca-&gt;SetState(\"a\"); cb-&gt;SetState(\"b\"); cout&lt;&lt;ca-&gt;GetState()&lt;&lt;endl; cout&lt;&lt;cb-&gt;GetState()&lt;&lt;endl; ca-&gt;Action(); cb-&gt;Action(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-10-原型模式","slug":"design-pattern-10-prototype","date":"2017-08-31T13:40:00.000Z","updated":"2020-04-12T04:56:36.052Z","comments":true,"path":"2017/08/31/design-pattern-10-prototype/","link":"","permalink":"http://www.casezheng.date/2017/08/31/design-pattern-10-prototype/","excerpt":"","text":"原型模式的学习与实践 原型模式原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。即：新对象的创建可以通过已有对象进行创建。 类图 Prototype模式提供通过已存在对象进行新对象创建的接口。C++中通过拷贝构造函数实现。 优点 性能优良，原型模式是在内存中二进制流的拷贝，比直接new一个对象性能好很多，特别是在循环体内产生大量的对象时，原型模式可以更好的体现其优点。 逃避构造函数的约束，直接在内存中拷贝，构造函数不会执行，优点是减少了约束，缺点也是减少了约束。 缺点使用场景 资源优化场景，类初始化需要消耗很多资源，包括数据、硬件资源等。 性能和安全要求的场景，通过new产生一个对象需要非常繁琐的数据准备或访问权限，可以使用原型模式。 一个对象多个修改者的场景，一个对象需要提供给多个对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 注意事项 构造函数不会执行 浅拷贝和深拷贝 扩展实践 Builder模式重在复杂对象的一步步创建（并不直接返回对象） AbstractFaxtory模式重在产生多个相互依赖类的对象 Prototype模式重在从自身复制自身创建新类 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-9-代理模式","slug":"design-pattern-9-proxy","date":"2017-08-30T13:13:00.000Z","updated":"2020-04-12T04:56:36.050Z","comments":true,"path":"2017/08/30/design-pattern-9-proxy/","link":"","permalink":"http://www.casezheng.date/2017/08/30/design-pattern-9-proxy/","excerpt":"","text":"代理模式的学习与实践 模板方法模式代理模式（委托模式）：为其他对象提供一个代理以控制对这个对象的访问。 类图抽象主题角色：可以是抽象类，也可以是接口，普通的业务类型定义，无特殊要求具体主题角色：被代理角色、被委托角色。业务逻辑的具体执行者代理主题角色：委托类、代理类。负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真正主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作 一个代理类可以代理多个被委托对象或被代理者，因此一个代理类具体代理哪个真实主题角色由场景类决定。最简单的情况就是一个主题类和一个代理类。 优点 职责清晰 高扩展性 智能化 实现逻辑和实现的彻底解耦 缺点使用场景 创建开销大的对象的时候，将创建过程交给代理完成。 智能指针 扩展 普通代理，客户端只能访问代理角色，而不能访问真实角色。普通代理模式的约束问题，应通过团队内的编程规范约束，因为每一个主题类都是可被重用和可维护的，使用技术约束的方法对相同维护是一种非常不利的因素。 强制代理，通过真实角色指定的代理类访问，由真实角色管理代理角色，即创建真实角色，返回代理角色。代理的管理由真实角色自己完成。 代理可以增强目标对象方法（拦截、过滤等） 虚拟代理，在需要的时候再初始化主题对象，避免被代理对象较多而引起的初始化缓慢问题。缺点是需要在每个方法中判断主题对象是否被创建。 动态代理，在实现阶段不关心谁代理谁，在运行阶段才指定代理哪一个对象。面对横切面编程（AOP） 实践参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-8-建造者模式","slug":"design-pattern-8-builder","date":"2017-08-30T05:48:00.000Z","updated":"2020-04-12T04:56:36.047Z","comments":true,"path":"2017/08/30/design-pattern-8-builder/","link":"","permalink":"http://www.casezheng.date/2017/08/30/design-pattern-8-builder/","excerpt":"","text":"建造者模式的学习与实践 建造者模式建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 类图 Product 产品 实现模版方法和基本方法 Builder 抽象建造者 规范Product的组建，一般由子类实现。 ConcreteBuilder 具体建造者 实现抽象类定义的所有方法，并且返回一个组建好的对象。 Director 导演类 负责安排已有模块的顺序，然后告诉Builder开始建造。 优点 封装性 客户端不必知道产品内部组成的细节 建造者独立，容易扩展 便于控制细节风险 缺点使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，采用建造者模式 多个部件或零件都可以装配到一个对象中，但产生的运行结果又不相同时，则可以使用该模式 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能 注意事项建造者模式关注的是零件类型和装配工艺（顺序），这是建造者模式和工厂方法模式最大的区别，虽然同为建造类模式，但注重点不同。工厂模式重点是创建，创建对象时其主要职责，组装顺序则不是其所关心的。AbstractFaxtory模式强调的是为创建多个相互依赖的对象提供一个同一的接口。 扩展使用建造者模式时可以考虑模版方法模式，通过组合多种模式达成目的。 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-7-模板方法模式","slug":"design-pattern-7-template","date":"2017-08-29T14:35:00.000Z","updated":"2020-04-12T04:56:36.042Z","comments":true,"path":"2017/08/29/design-pattern-7-template/","link":"","permalink":"http://www.casezheng.date/2017/08/29/design-pattern-7-template/","excerpt":"","text":"模板方法模式的学习与实践 模板方法模式模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式很简单，只使用了继承机制。抽象模板的方法分为两类： 基本方法：由子类实现，并且在模板中被调用。 模板方法：可能有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。一般模板方法不允许被覆写。 具体模板：实现父类所定义的一个或多个抽象方法，即父类定义的基本方法在子类中实现。 模板方法的类图 模板方法模式优点 封装不变部分，扩展可变部分。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。 模板方法模式缺点模板方法模式和一般的设计习惯不一样，一般设计抽象类负责最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法，但在模板方法模式中，抽象类定义了一部分抽象方法，由子类实现，子类的执行结果影响父类的结果，即子类对父类产生了影响。 使用场景 多个子类有共有的方法，并且逻辑基本相同。 重要、复杂的算法，可以将核心算法设计为模板方法，周边细节功能由各个子类实现。 重构时，模板方法是常用的模式，将相同的代码抽象到父类中，然后通过钩子函数约束其行为。 模板方法的扩展父类定义抽象的方法确定系统某个功能的默认行为，子类覆写该方法，改变父类的行为。即由子类的方法返回值确定公共部分的执行结果。 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-6-抽象工厂方法模式","slug":"design-pattern-6-abstact-factory","date":"2017-08-28T05:40:00.000Z","updated":"2020-04-12T04:56:36.039Z","comments":true,"path":"2017/08/28/design-pattern-6-abstact-factory/","link":"","permalink":"http://www.casezheng.date/2017/08/28/design-pattern-6-abstact-factory/","excerpt":"","text":"抽象工厂模式介绍与实践，抽象工厂模式与工厂模式比较 抽象工厂模式抽象工厂模式：为创建一组相关或相互依赖的对象提供接口，而别无需指定它们的具体类。 抽象工厂模式优点 封装性，高层模块调用产生对象的接口即可，不需要了解对象的实现类 对象间约束关系非公开状态 抽象工厂模式缺点对象扩展困难 使用场景一组没有任何关系的对象都有相同约束，则可以使用抽象工厂模式 抽象工厂模式注意事项抽象工厂模式扩展困难时对象横向扩展困难，而纵向扩展是非常容易扩展的。 抽象工厂模式和工厂模式AbstractFactory模式和Factory模式的区别在于AbstractFactory模式是为创建一组（有多类）相关或依赖的对象提供创建接口，而Factory模式是为一类对象提供创建接口或延迟对象的创建到子类中实现。AbstractFactory模式通常使用Factory模式实现。 工厂方法模式 抽象工厂模式 针对的是一个产品等级结构 针对的是面向多个产品等级结构 一个抽象产品类 多个抽象产品类 可以派生出多个具体产品类 每个抽象产品类可以派生出多个具体产品类 一个抽象工厂类，可以派生出多个具体工厂类 一个抽象工厂类，可以派生出多个具体工厂类 每个具体工厂类只能创建一个具体产品类的实例 每个具体工厂类可以创建多个具体产品类的实例 抽象工厂模式实现抽象工厂模式类图 参考资料 设计模式之禅 GoF+23种设计模式解析 http://blog.csdn.net/wyxhd2008/article/details/5597975","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"centos7 vim8.0 编译安装","slug":"vim-install","date":"2017-08-26T10:04:00.000Z","updated":"2020-04-12T04:56:36.035Z","comments":true,"path":"2017/08/26/vim-install/","link":"","permalink":"http://www.casezheng.date/2017/08/26/vim-install/","excerpt":"","text":"安装依赖环境最好使用yum安装，如果没有可以下载源码编译安装1sudo yum install -y ruby ruby-devel lua lua-devel luajit luajit-devel ctags git python python-devel python3 python3-devel tcl-devel perl perl-devel perl-ExtUtils-ParseXS perl-ExtUtils-XSpp perl-ExtUtils-CBuilder perl-ExtUtils-Embed gcc 编译123456789101112131415161718git clone https://github.com/vim/vim.gitcd vim./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --with-ruby-command=/usr/bin/ruby \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr \\ --enable-perlinterp=yes \\ --enable-fontset \\ --enable-luainterp=yes \\ --enable-gui=auto \\ --enable-gnome-check \\ --with-x \\ --enable-cscope \\ --prefix=/usr/local/vim80 支持python、lua 完成后12makesudo make install 如果有旧版本的将其备份，最好别删123sudo mv /usr/bin/vim /usr/bin/vim7.4sudo ln -s /usr/local/vim80/bin/vim /usr/bin/vimvim --version 问题requires Vim compiled with Python (2.6+ or 3.3+) support当同时存在python2和python3时会出现这种问题,去除编译命令中的python2或python3即可, 例如去除python2后的编译命令如下1234567891011121314./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --with-ruby-command=/usr/bin/ruby \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr \\ --enable-perlinterp=yes \\ --enable-fontset \\ --enable-luainterp=yes \\ --enable-gui=auto \\ --enable-gnome-check \\ --with-x \\ --enable-cscope \\ --prefix=/usr/local/vim80","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://www.casezheng.date/tags/vim/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"设计模式探秘-5-工厂方法模式","slug":"design-pattern-5-factory","date":"2017-08-23T05:29:00.000Z","updated":"2020-04-12T04:56:36.033Z","comments":true,"path":"2017/08/23/design-pattern-5-factory/","link":"","permalink":"http://www.casezheng.date/2017/08/23/design-pattern-5-factory/","excerpt":"","text":"工厂方法模式工厂方法模式的定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 工厂方法优点 良好的封装性，代码结构清晰，一个对象创建是有约束的，只要知道对象类的名称（或约束字符串）就可以了，不需要知道创建对象的过程，降低模块间耦合。 工厂方法模式的扩展性非常优秀。 屏蔽产品类，调用者不用关心产品类的实现，只需要关系产品的接口。 工厂模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其它的实现类则不用关系，符合迪米特法则，不需要就不要去交流，符合依赖倒置原则，只依赖产品的抽象类，也符合里氏替换原则，使用产品子类替换父类。 使用场景 工厂方法模式是new一个对象的替代品，在需要生成对象的地方都可以使用，但需要慎重考虑。因为会增加代码的复杂度。 需要灵活、可扩展的框架时，可以考虑工厂方法模式。 工厂模式可以用在异构项目中。 可以使用在测试驱动开发的框架下。 工厂方法模式的扩展 缩小为简单工厂模式（静态工厂模式），其缺点是工厂类的扩展比较困难，不符合开闭原则，但仍然是非常使用的设计模式。 升级为多个工厂类 替代单例模式，工厂每次都返回唯一的那个对象即可 延迟初始化，对象使用完，不销毁，下次申请的时候从缓存取一个，初始化后返回 工厂模式实现常见工厂模式类图 简单工厂模式 多个工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;//工厂模式class Product&#123;public: virtual ~Product()&#123;&#125;;protected: Product()&#123;&#125;;&#125;;class ConcreteProduct:public Product&#123;public: ConcreteProduct() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; ~ConcreteProduct() &#123; &#125;;&#125;;class Factory&#123;public: virtual ~Factory()&#123;&#125;; virtual void* CreateProduct() = 0;protected: Factory()&#123;&#125;;&#125;;class ConcreteFactory:public Factory&#123;public: ConcreteFactory() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; ~ConcreteFactory() &#123; &#125; Product* CreateProduct() &#123; return new ConcreteProduct(); &#125;&#125;;int main()&#123; Factory *fac = new ConcreteFactory(); Product *p = (Product*)fac-&gt;CreateProduct(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-4-单例模式","slug":"design-pattern-4-singleton","date":"2017-08-21T15:12:00.000Z","updated":"2020-04-12T04:56:36.027Z","comments":true,"path":"2017/08/21/design-pattern-4-singleton/","link":"","permalink":"http://www.casezheng.date/2017/08/21/design-pattern-4-singleton/","excerpt":"","text":"单例模式单例模式定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供该实例。 单例模式优点： 单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁创建、销毁，而且创建或销毁时性能又无法优化时，单例模式的优势非常明显。 单例模式只生产一个实例，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，则可以通过在应用启动时直接生产一个单例对象，然后永久驻留在内存中的方式来解决。 单例模式可以避免对资源的多重访问。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 单例模式缺点： 单例模式一般没有接口，扩展困难。因为接口对于单例模式没有意义，单例模式“自行实例化”，并且提供单一实例，接口和抽象类是不可能被实例化的。但特殊情况下单例模式可以实现接口、被继承等。 单例模式对测试不利。并行开发环境中，单例模式未完成前，不能进行测试，没有接口也就无法虚拟对象。 单例模式与单一职责原则有冲突。单例模式把“要单例”和业务逻辑融合在一个类中。 单例模式使用场景在一个系统中，如果要求有且仅有一个对象，如果出现多个会有不良反应，就可以使用单例模式。 要求生成唯一化序列号的环境。 在整个项目中需要一个共享访问点或共享数据。 创建一个对象需要消耗的资源过多。 需要定义大量静态方法或静态变量的环境，可以采用单例模式。 单例模式和全局变量 全局变量不能防止实例化多个对象。 使用全局变量将使对象无论是否被用到都要被创建。 单例模式的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;using namespace std;//常见的单例模式class SingletonOne&#123;private: SingletonOne() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; SingletonOne(const SingletonOne &amp;right); SingletonOne &amp; operator=(const SingletonOne &amp;right); static SingletonOne _instance;public: static SingletonOne&amp; Instance() &#123; return _instance; &#125;; ~SingletonOne() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;;&#125;;SingletonOne SingletonOne::_instance;class SingletonTwo&#123;private: SingletonTwo() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; SingletonTwo(const SingletonTwo &amp;right); SingletonTwo &amp; operator=(const SingletonTwo &amp;right); static SingletonTwo *_instance;public: static SingletonTwo* Instance() &#123; if( nullptr == _instance ) &#123; _instance = new SingletonTwo(); &#125; return _instance; &#125;; ~SingletonTwo() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;;&#125;;SingletonTwo* SingletonTwo::_instance = nullptr;template &lt;class T&gt;class SingletonThree&#123;private: SingletonThree()&#123;&#125; SingletonThree(const SingletonThree &amp;right); SingletonThree &amp; operator=(const SingletonThree &amp;right); static T _instance;public: static T&amp; Instance() &#123; return _instance; &#125;; virtual ~SingletonThree()&#123;&#125;&#125;;template &lt;class T&gt;T SingletonThree&lt;T&gt;::_instance;class A&#123;public: A() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; virtual ~A() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;__FUNCTION__&lt;&lt;endl; &#125;&#125;;typedef SingletonThree&lt;A&gt; SingletonA; //SingletonAint main()&#123; //SingletonOne::Instance().print(); //SingletonTwo::Instance()-&gt;print(); SingletonA::Instance().print(); return 0;&#125; 参考资料 设计模式之禅 GoF+23种设计模式解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-3-设计模式简介","slug":"design-pattern-3","date":"2017-08-19T14:02:00.000Z","updated":"2020-04-12T04:56:35.988Z","comments":true,"path":"2017/08/19/design-pattern-3/","link":"","permalink":"http://www.casezheng.date/2017/08/19/design-pattern-3/","excerpt":"","text":"设计模式简介Christopher Alexander 说:“模式是在某一背景下某个问题的一种解决方案。”它们绝不只是解决某人个别问题的模板。它们是描述动机的一种方式,不仅包括我们要得到的效果,也包括困扰我们的问题。 设计模式的关键特征 项目 描述 意图 每个模式都有唯一的用于标识的名称 问题 模式的目的 解决方案 模式能够为问题提供合适其所处环境的一个解决方案 参与者和协作者 模式所涉及的实体 效果 使用模式的效果，研究模式中起作用的各种因素 实现 模式的实现方式。实现只是模式的具体体现，而不能视为模式本身 一般性结构 显示模式典型结构的标准图 一个好的设计模式的论述应该覆盖使用这个模式的优点和缺点 学习设计模式的好处 对不断重复出现问题,复用既有的、高质量的解决方案。 确立通用的术语,改善团队内的沟通。 提升思考层次。 判断设计是否正确,而不仅仅是能够奏效。 改善个人学习和团队学习。 提高代码的可修改性和可维护性。 采用更佳设计方案,即使没有明确使用模式。 发现巨型继承层次结构的替代方案。 设计模式分类根据目的，设计模式可分为创建型、结构型和行为型三种。 创建型主要用于创建对象 结构型用于处理类和对象的组合 行为型用于描述类和对象如何交互和怎样分配职责 根据范围，即模式主要用于处理类之间关系还是对象之间的关系可分为类模式和对象模式两种 类模式处理类和子类之间的关系，通常通过继承建立，编译时刻确定下来，属于静态的 对象模式处理对象间关系，运行时时刻变化，具有动态性 范围\\目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式模版方法模式 对象模式 抽象工厂模式建造者模式原型模式单例模式 （对象）适配器模式桥接模式组合模式装饰模式享元模式外观模式代理模式 职责模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 基本设计模式概述 Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。 Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。 Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 软件设计六大原则 单一职责原则 里氏替换原则 依赖导致原则 接口隔离原则 迪米特法则 开闭原则 单一职责原则（Single Responsibility Principle）简称SRP单一职责原则定义：应该有且仅有一个原因引起类的变更There should never be more than one reason for a class to change. 单一职责原则的好处： 降低类的复杂性，实现的职责都有清晰明确的定义 可读性提高 可维护性提高 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其它接口无影响，这对系统的扩展性、维护性都有非常大的帮助 单一职责原则最难划分的就是职责。单一职责原则适用于接口、类，也适用于方法。对于接口和方法一定要做到单一职责，对于类的设计尽量做到只有一个原因引起变化。 里氏替换原则（Liskov Substitution Principle）简称LSP继承优点： 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性 提高代码的重用性 子类可以形似父类，但又异于父类 提高代码的可扩展性 提高产品或项目的开放性 继承缺点： 继承是有侵入性的。只要继承，就必须拥有父类的所有属性和方法 降低代码的灵活性。子类必须拥有父类的属性和方法 增强耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改 两种里氏替换原则的定义： 最正宗的，如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有对象o1替换为o2时，程序P的行为没有发生变化，那么类型S时类型T的子类型。 所有引用基类的地方必须能透明的使用其子类的对象。 通俗的讲，只要父类能出现的地方子类就可以出现，而且替换为其它子类也不会产生任何错误或异常，使用者可能根本不需要知道是父类还是子类。但反过来就不行了，有子类出现的地方，父类未必适应。 里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层定义。 子类必须完全实现父类的方法 在类中调用其它类时务必使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚合、组合等关系替代继承。 子类可以有自己的方法和属性 覆盖或实现父类的方法时输入参数可以被放大 子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。 覆盖或实现父类的方法时输出结果可以被缩小 父类方法的返回值是一个类型T，子类的相同方法（重写或覆盖）的返回值为S，里氏替换原则要求S必须小于等于T，即S和T是同一类型，或S是T的子类。 采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。 采用里氏替换原则时，应尽量避免子类的“个性”，一旦子类有“个性”，该子类和父类的关系就很难调和了，把子类当做父类，子类的“个性“被抹杀，将子类作为一个业务来使用，会让代码的耦合关系变得扑朔迷离——缺乏类替换的标准。 依赖倒置原则（Dependence Inversion Principle）简称DIP依赖倒置原则，要依赖于抽象，不要依赖于具体： 高层模块不应该依赖底层模块，两者都应该依赖于其抽象 抽象不应该依赖于细节 细节应该依赖于抽象 即”面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并发开发引起的风险，提高代码的可读性和可维护性。依赖时可以传递的，A依赖于B对象，B又依赖于C，C又依赖于D…… 但只要做到抽象依赖，即使是多层的依赖也无所畏惧。依赖的三种写法： 构造函数传递依赖对象（构造函数注入） Setter方法传递依赖对象 接口声明依赖对象（接口注入） 使用依赖倒置原则的方法： 每个类尽量都有接口或抽象类、或抽象类和接口都有 类型的表面尽量是接口或者抽象类 任何类都不应该从具体类派生 尽量不去覆写基类的方法 结合里氏替换原则使用 接口隔离原则接口分为两种： 实例接口 类接口 隔离的定义： 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 即建立单一接口，不要建立臃肿庞大的接口。通俗说：接口尽量细化，同时接口中方法尽量少。 接口隔离原则是对接口进行规范约束，包含4层含义： 接口尽量小 根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 接口要高内聚 高内聚就是提高接口、类、模块的处理能力，减少对外的交互。 定制服务 定制服务就是单独为一个个体提供优良的服务。定制服务必然要求：只提供访问者需要的接口。 接口设计是有限度的，不能无限细化，否则虽然提高了灵活性，但也带来了结构的复杂性，开发难度增加，可维护性降低，所以接口设计要注意适度。 接口隔离原则的原子划分： 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑压缩接口中的public方法，接口设计时常去回顾，让接口更加精简 已经污染的接口尽量去修改，若变更的风险更大，则采取适配器模式进行转化 了解环境，拒绝盲从。环境不同，接口拆分的标准就不同，深入了解业务逻辑，设计更好的接口 迪米特法则（Law of Demeter）简称LoD迪米特法则也称为最少知识原则（Least Knowledge Principle，LKP），规则：一个对象应该对其它对象有更少的了解。 迪米特法则对类的低耦合提出明确要求包含4层含义： 只和朋友交流 两个对象之间有耦合关系即为耦合，如：组合、聚合、依赖等。 朋友之间也是有距离的 类尽量不要公布太多的public方法和非静态的public变量，尽量内敛，多使用private和protected等访问权限 是自己的就是自己的 如果一个方法放在本类中可以，放在其它类中也可以，则坚持这个原则：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，就放置在本类中。 谨慎使用Serializable（序列化） 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合之后，类的复用率才可以提高。但会产生大量的中转或调转类，导致系统复杂性提高，使维护困难。使用迪米特法则需反复权衡，既做到结构清晰，同时做到高内聚低耦合。 开闭原则（Open-ClosePrinciple）简称OCP开闭原则即一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。开闭原则指出应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，开闭原则是为软件实体的未来事件而定制的对现行开发设计进行约束的一个原则。开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无缘的代码片段。 变化： 逻辑变化 子模块变化 可见视图变化 开闭原则的重要性: 开闭原则对测试的影响 开闭原则可以提高复用性 开闭原则可以提高可维护性 面向对象开发的要求 开闭原则是一个非常虚的原则，前五个原则是对开闭原则的具体解释，但开闭原则并不局限于这么多。开闭原则在工作中的运用： 抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现接口或抽象类中不存在的public方法 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类 抽象类尽量保持稳定，一旦确定即不允许修改 元数据控制模块行为 元数据即描述环境和数据的数据，通俗的来说就是配置参数。 指定项目章程 封装变化 将相同的变化封装到一个接口或抽象类中 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。 参考资料 设计模式解析（第二版）（书籍） 设计模式之禅（书籍） 百度百科 设计模式 设计模式概论博客","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-2-UML简介","slug":"design-pattern-2-uml","date":"2017-08-17T13:55:00.000Z","updated":"2020-04-12T04:56:35.983Z","comments":true,"path":"2017/08/17/design-pattern-2-uml/","link":"","permalink":"http://www.casezheng.date/2017/08/17/design-pattern-2-uml/","excerpt":"","text":"UML简介UML是一种创建程序模型的图形语言（即带有语意的一种图形记号）。程序模型指的是程序的图形表示，说明代码中对象之间的关系。 分析阶段 用例图 涉及系统（即用户和其它系统）之间交互的实体，以及要实现的功能点。 活动图 关注的是问题领域的工作流，而不是程序的逻辑流。 观察对象交互交互图 说明特定对象如何相互交互。最常见的交互图是顺序图。 设计阶段类图 详细描述类之间的关系 观察对象所处状态不同时行为的差异状态图 详细描述对象可能所处的不同状态以及各个状态间的转换 使用UML的好处UML主要用于交流，有利于清晰的表达信息，有利于精确的表达信息。 类图说明类之间的关系 当一种类是“一种”另一个类时：is-a（是一种/一个）关系。 两个类存在关联时 一个类“包含”另一个类：has-a（拥有一个）关系 一个类“使用”另一个类：use-a（使用一个）关系 一个类“创建”另一个类 被包含者是包含者的一部分，组合，汽车中的发动机多个东西共同构成一个集合，集合中的东西可以单独存在，聚合，雁群和大雁 类图三方面信息： 类名 类的数据成员 类的方法 表示访问权限的UML记号 公开 +号 表示所有对象都可访问的数据或方法 保护 #号 表示该类及其派生类可访问的数据或方法 私有 -号 表示只有该类可以访问的数据或方法 表示关系的UML记号 继承关系 组合关系 聚合关系 依赖关系 关联关系 一个UML类图实例 交互图表示对象间如何交互的UML图成为交互图，最常用的交互图为顺序图顺序图 最上面的矩形都表示一个特定的对象，垂直线表示对象的生命线。垂直线之间的水平线表示对象互相发送消息。 参考资料 设计模式解析（第二版） plantuml官网 plantuml交互图 plantuml类图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"},{"name":"uml","slug":"uml","permalink":"http://www.casezheng.date/tags/uml/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"设计模式探秘-1-面向对象","slug":"design-pattern-1","date":"2017-08-16T14:15:00.000Z","updated":"2020-04-12T04:56:35.973Z","comments":true,"path":"2017/08/16/design-pattern-1/","link":"","permalink":"http://www.casezheng.date/2017/08/16/design-pattern-1/","excerpt":"","text":"面向对象简介功能分解功能分解是一种处理复杂问题的自然方法。将问题分解为多个功能步骤，再将步骤细分，然后解决更小的问题，将一个复杂问题变为解决多个简单的小问题。功能分解的问题 主程序需要负责控制子程序的前后顺序，还要确保整个程序正确工作，主程序承担了太多功能。 应对变化的能力弱，功能的变化需要对整个函数或模块进行修改。 模块化可以在功能分解中模块化问题，将功能划分为一个个模块，模块间再相互调用，在功能需要变化时只需要修改对应的模块即可。模块化可是代码易于理解和维护。模块化的问题是容易低内聚和紧耦合。 内聚性描述一个功能内部组成部分之间的紧密程度。耦合性描述各个模块间的紧密程度。软件开发的目标应该是创建模块内部完整（高内聚），与其它模块间的联系小巧、直接、可见、灵活（松耦合）。 如果修改一个函数或函数使用的某个数据对其它函数产生严重破坏。因为功能分解将主要的精力放在具体的函数中，对一个函数或函数数据的修改会影响其它函数和数据。 面向对象想象一个问题，一个厨子根据工人的反馈决定下顿饭做什么饭。方法一： 厨子把可以做的菜列出来。 厨子得到工人名单和住址。 厨子前往工人住处。 厨子询问工人想吃什么菜，并记录下来。 厨子返回。 厨子汇总，找到票数最高的几个菜下顿饭做。 方法二： 厨子把可以做的菜列出来，张贴起来。 通知工人自行在菜单上选择要吃的菜，并记录。 厨子查看菜单，找到票数最高的几个菜下顿饭做。 方法二明显优于方法一，方法一需要关注大量细节、责任繁重，而方法二则简单的多，让工人明白，完成自身的任务。方法二将责任从厨子转移到每一个工人身上，实现责任的转移。新需求，要求厨子区分女性工人和男性工人，如果是方法一统计时需要增加一个步骤，区分女性工人和男性工人。而方法二则只需要给出两份菜单即可，女性一份，男性一份。 软件开发过程中的不同视角 概念 软件负责什么？ “呈现所研究领域的各种概念，得出概念时应该很少或不考虑实现软件“ 规约 怎么使用软件？ 考虑软件的接口，而不是如何实现 实现 软件怎样履行自己的责任？ 考虑代码本身，根据规约实现代码 面向对象编程以对象为中心，一切重点集中在对象身上。编写代码围绕对象而非函数进行组织。对象有自己的属性和方法，属性告诉对象自身状态，方法告诉对象如何完成某些功能。 按照Martin Fowler的视角框架观察对象。 概念层次，对象是一组责任 规约层次，对象是可被其它对象或者对象自己调用的方法 实现层次，对象是代码和数据，以及对象之间的计算交互 对象具有供其它对象调用的公共接口。围绕类组织对象，类是对对象行为的定义，包含对象的数据元素、对象能够操作的方法、访问数据元素和方法的方式。对象可以拥有不同的数据，但拥有相同的功能。对象是类的实例。 抽象类抽象类定义其它相关类的一般属性。例如抽象类学生，定义了学生的一般属性。代表了某种类型的相关行为的类成为具体类，因为它代表一个概念既定、不变的实现。例如，本科生和研究生就是具体类，而学生则是抽象类。抽象类和具体类是一种is-a（是一种）的关系，称之为继承。例如本科生继承学生类，研究生继承学生类。抽象类可以定义派生类必须实现的公共方法。派生类使用抽象类的默认行为还是自己重新定义由派生类自身决定。如果抽象类只提供规约而不提供实现，则是接口。 类的访问控制对象对自己负责，有很多东西是自己私有的，不能暴露给其它对象，所以需要访问控制。 公开 public 任何对象可见 保护 protected 自身和派生类对象可见 私有 private 自身可见 类的封装类的属性控制，达到隐藏数据的目的，实现数据的封装，但类的封装不只是数据封装，而是各种隐藏。 多态多态，抽象引用概念性的要求对象做什么，对于不同的派生对象有不同的实现方式。 特殊的对象方法 构造方法 负责初始化或创建一个对象 析构方法 负责清除一个对象 概念回顾 功能分解 结构化程序员总是使用功能分解进行程序设计。功能分解是将一个问题逐渐分解为更小功能的方法,每个函数都分解到可管理为止 需求变更 需求变更是开发过程中与生俱来的。与其向用户或者自己抱怨获得理想而且完整的需求看来是不可能完成的任务”,不如使用更有效的开发方法,应对需求变更 对象 对象是由其责任定义的。对象能够自己负责自己,从而简化了使用对象的控制程序的任务 构造函数和析构函数 对象具有在创建和销毁自己时自动调用的特殊方法。这些特殊方法是: 构造函数:初始化或创建对象 析构函数:在对象删除时清除对象 所有面向对象语言都使用构造函数和析构函数辅助对对象的管理 抽象类 定义了概念上相似的一组类的方法和公共属性。抽象类不能实例化 属性 与对象关联的数据(也称为数据成员,data member) 类 对象的蓝图——为其类型的对象定义方法和数据 构造函数 在创建对象时调用的特殊方法 派生类 从基类特化的类,包含基类所有的属性和方法,但还可能包含其他属性或不同的方法实现 析构函数 在销毁对象时调用的特殊方法 封装 任何形式的隐藏。对象封装其数据,抽象类封装其派生的具体类 功能分解 一种分析方法,将问题逐步分解成小的功能 继承 一种特化类的方式,用于将派生类与其基类联系起来 实例 类的特定对象 实例化 创建类的一个实例的过程 成员 类的数据或方法 方法 与对象关联的例程 对象 具有责任的实体。一个特殊的、自成一体的容器,包含数据和操作数据的方法。对象的数据对于外部对象是受保护的 多态 相关的对象根据其具体类型实现方法的能力 超类 其他的类从中派生的类,包含所有派生类都要使用的主要数据和方法的定义(方法可能改写) 参考书籍 设计模式解析（第二版）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.casezheng.date/categories/设计模式/"}]},{"title":"Centos python2.6 升级 python2.7","slug":"python26-update-python27","date":"2017-08-02T11:21:00.000Z","updated":"2020-04-12T04:56:35.966Z","comments":true,"path":"2017/08/02/python26-update-python27/","link":"","permalink":"http://www.casezheng.date/2017/08/02/python26-update-python27/","excerpt":"","text":"Centos python2.6 升级 python2.7安装python2.7 下载python2.7源码，解压 123wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgztar xvf Python-2.7.13.tgzcd Python-2.7.13 安装，默认安装位置为/usr/local/bin/ 123./configuremakesudo make install 替换python2.6，建立python2.7软链接 12345cd /usr/local/bin/sudo ln -s /usr/local/python27/bin/python2.7 python2.7sudo ln -s /usr/local/python27/bin/python2.7-config python2.7-configsudo mv python python.backsudo ln -s python2.7 python 问题解决 yum不支持python2.7，修改下，让其直接调用python2.6，如果有别的工具也不支持python2.7，方法相同 12sudo vim /usr/bin/yum将第一行#!/usr/bin/python 修改为#!/usr/bin/python2.6 为python2.7安装easy_install 12wget wget -q http://peak.telecommunity.com/dist/ez_setup.pysudo python ez_setup.py -U setuptools 为python2.7安装pip，在https://pypi.python.org/pypi/pip/9.0.1 下载pip源码 12345678tar zxvf pip-9.0.1.tar.gzcd pip-9.0.1python setup.py buildsudo python setup.py installsudo ln -s /usr/local/python27/bin/pip2.7 /usr/bin/pip2.7cd /usr/bin/sudo mv pip pip.backsudo ln -s pip2.7 pip python2.7命令行不可用 1sudo pip install readline","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"python","slug":"python","permalink":"http://www.casezheng.date/tags/python/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"Shell脚本学习","slug":"shell","date":"2017-07-29T04:20:00.000Z","updated":"2020-04-12T04:56:35.964Z","comments":true,"path":"2017/07/29/shell/","link":"","permalink":"http://www.casezheng.date/2017/07/29/shell/","excerpt":"","text":"shell特性查看历史命令historyshell中history命令可以查看历史命令，默认保存1024条历史命令记录。shell中使用!!自动执行上一条历史命令。shell中使用!num表示执行第num条历史命令。shell中使用!str表示执行最近的以str开头的命令。 alias 和 unaliasalias给一条命令设置别名，简化操作。unalias取消别名。123456789101112131415161718[CaseZheng@home Study]$ alias myls=&quot;ls -la&quot;[CaseZheng@home Study]$ myls总用量 44drwxrwxr-x. 9 CaseZheng CaseZheng 4096 7月 26 23:14 .drwx------. 29 CaseZheng CaseZheng 4096 7月 29 11:49 ..drwxrwxr-x. 5 CaseZheng CaseZheng 4096 6月 5 22:52 BoostStudydrwxrwxr-x. 8 CaseZheng CaseZheng 4096 7月 29 11:52 .git-rw-rw-r--. 1 CaseZheng CaseZheng 41 6月 3 22:00 .gitignoredrwxrwxr-x. 2 CaseZheng CaseZheng 4096 6月 3 22:00 Lua_C_Server_Clientdrwxrwxr-x. 2 CaseZheng CaseZheng 4096 6月 26 23:03 Mahjongdrwxrwxr-x. 2 CaseZheng CaseZheng 4096 7月 27 22:55 Python-rw-rw-r--. 1 CaseZheng CaseZheng 8 6月 3 22:00 README.mddrwxrwxr-x. 3 CaseZheng CaseZheng 4096 6月 3 22:00 Redis_Luadrwxrwxr-x. 3 CaseZheng CaseZheng 4096 7月 27 22:55 WebStudy[CaseZheng@home Study]$ unalias myls[CaseZheng@home Study]$ mylsbash: myls: 未找到命令...[CaseZheng@home Study]$ &gt; &gt;&gt; &lt;&gt; 重定向&gt;&gt; 追加&lt; 反向重定向 1234567891011[CaseZheng@home ~]$ echo &quot;hello shell&quot; &gt; hello.txt[CaseZheng@home ~]$ cat hello.txthello shell[CaseZheng@home ~]$ echo &quot;hello clear&quot; &gt; hello.txt[CaseZheng@home ~]$ cat hello.txthello clear[CaseZheng@home ~]$ echo &quot;hello append&quot; &gt;&gt; hello.txt[CaseZheng@home ~]$ cat hello.txthello clearhello append[CaseZheng@home ~]$ 2&gt; 错误重定向2&gt;&gt; 错误追加 123456789[CaseZheng@home ~]$ ls hahahals: 无法访问&apos;hahaha&apos;: No such file or directory[CaseZheng@home ~]$ ls hahaha 2&gt; log.txt[CaseZheng@home ~]$ cat log.txtls: 无法访问&apos;hahaha&apos;: No such file or directory[CaseZheng@home ~]$ ls 2&gt; log.txtBlog hello.txt log.txt Package PythonWeb SourceCodeAnalysis Study 桌面[CaseZheng@home ~]$ cat log.txt[CaseZheng@home ~]$ shell脚本 #!/bin/sh #!/bin/bash 写在shell脚本第一行 指名脚本解释执行的解释器 # 除第一行以#!开头有特殊用途外 其它以#开头的行均为注释 chmod a+x xxx.sh 给xxx.sh增加执行权限 bash -x xxx.sh 查看xxx.sh的执行过程 date打印或设置系统日期和时间 shell变量注意等于号左右不能有空格1234#!/bin/shtest=&quot;test str&quot;echo $testecho $&#123;test&#125; # 花括号可以帮助解释器识别变量边界 unset 命令可以删除变量1234#!/bin/shtest=&quot;test str&quot;unset testecho $test readonly 命令使变量只读 unset不能删除只读变量123456789[CaseZheng@localhost ~]$ cat test.sh#!/bin/shreadonly a=10a=20[CaseZheng@localhost ~]$ bash -x test.sh+ readonly a=10+ a=10+ a=20test.sh:行3: a: 只读变量 shell读取命令行参数 $0 命令本身 $1 $2 $3 以此为参数1 2 3 $# 参数个数12345678910111213[CaseZheng@localhost ~]$ cat test.sh#!/bin/shecho $0echo $1echo $2echo $3echo $#[CaseZheng@localhost ~]$ ./test.sh 10 11 12 13 14 15./test.sh1011126 从屏幕读入1234567[CaseZheng@localhost ~]$ cat test.sh#!/bin/shread -p &quot;请输入&quot; numecho $num[CaseZheng@localhost ~]$ ./test.sh请输入44 算术运算1234567891011[CaseZheng@localhost ~]$ cat test.sh#!/bin/sha=1;b=2;echo $a+$b # 字符串连接echo $[$a+$b] # 算术运算echo $(($a+$b)) # 算术运算[CaseZheng@localhost ~]$ ./test.sh1+233 数字比较 -eq 相等（equal） -ne 不等（not equal） -gt 大于（greater than） -lt 小于（less than） -ge 大于等于 （greater than or equal） -le 小于等于 （less than or equal） 流程控制12345678910111213141516171819202122232425262728293031323334353637[CaseZheng@localhost ~]$ cat test.sh#!/bin/shif [ 1 -eq 1 ] # 方括号两边都要有空格 == 两边加空格then echo &quot;true&quot;fiif [ 1 -eq 2 ] # 方括号两边都要有空格 == 两边加空格then echo &quot;true&quot;else echo &quot;false&quot;fi[CaseZheng@localhost ~]$ bash -x test.sh+ &apos;[&apos; 1 -eq 1 &apos;]&apos;+ echo truetrue+ &apos;[&apos; 1 -eq 2 &apos;]&apos;+ echo falsefalse[CaseZheng@localhost ~]$ cat test.sh#!/bin/shif [ 1 -eq 2 ]then echo &quot;true 1==2&quot;elif [ 1 -lt 2 ] # 小于等于then echo &quot;true 1&lt;2&quot;else echo &quot;false&quot;fi[CaseZheng@localhost ~]$ bash -x test.sh+ &apos;[&apos; 1 -eq 2 &apos;]&apos;+ &apos;[&apos; 1 -lt 2 &apos;]&apos;+ echo &apos;true 1&lt;2&apos;true 1&lt;2","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"C++复习学习笔记","slug":"cplusplus-review","date":"2017-07-22T07:18:00.000Z","updated":"2020-04-12T04:56:35.961Z","comments":true,"path":"2017/07/22/cplusplus-review/","link":"","permalink":"http://www.casezheng.date/2017/07/22/cplusplus-review/","excerpt":"","text":"复习到的知识点1. C++三种编程方式 面向过程编程 面向对象编程 C++模板支持的泛型编程 2. 注释C++的注释为//，C的为/*...*/，C++可以识别/*...*/，C99将//注释加入到C标准 3. 名词空间12using std::cout; //只将std名字空间下的cout暴露出来using namespace std; //将std名字空间的下所有标识符暴露出来 4. 函数 函数头 指出函数返回值的类型和函数期望通过参数传递给它的信息的类型 函数体 由花括号中的C++语句组成 5. C++语句 声明语句 定义变量的名称和类型 赋值语句 使用赋值运算符给变量赋值 消息语句 将消息发送给对象，激发某种行动 函数调用 执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句 函数原型 申明函数的返回类型、函数接受的参数数量和类型 返回语句 将一个值从被调用的函数返回到调用函数中 6. C++命名规则 在名称中只能使用字母字符、数字和下划线 名称的第一个字符不能是数字 区分大写字符和小写字符 不能将C++关键字作为名称 以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器和其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符 C++对于名称的长度没有限制，名称中所有字符都有意义，但有些平台有长度限制（和C标准有所区别C标准只保证前63个字符有意义 ps:gcc6.3.1下使用长度超过63且前63个字符相同的两个变量测未出现错误） 7. climits头文件定义了符号常量表示类型的限制1234567891011121314#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int main(int argc, char *args[])&#123; // g++ 6.3.1 fedora25 64位 linux cout&lt;&lt;sizeof LLONG_MAX&lt;&lt;endl; //8 cout&lt;&lt;sizeof SHRT_MAX&lt;&lt;endl; //4 cout&lt;&lt;sizeof INT_MAX&lt;&lt;endl; //4 cout&lt;&lt;sizeof LONG_MAX&lt;&lt;endl; //8 return 0;&#125; 8. const与#define优先使用const const可指定类型 const可设定作用域 cosnt可用于更复杂的类型 9. C++中const变量可用来申明数组长度（C语言不可以）123//使用g++可以编译通过，使用gcc会报错const int arraylen = 10;int arr[arraylen] =&#123;0&#125;; 10. 基础类型，整数和浮点数11. 类型转换 初始化和赋值进行的转换 以{}方式初始化时进行的转换（C++11） 表达式中的转换 传递参数时进行的转换 强制类型转换 123(typename) value; //C语言风格typename(value); //C++static_cast&lt;typename&gt; (value); //C++四种强制类型转换运算符，static_cast是其中一种可用于将数值类型转换为另一种数值类型，比传统强制类型转换更严格 12. C++11中auto申明，使用关键字auto，不指定变量类型，编译器将把变量的类型设置成与初始值相同13. 结构体struct、共用体union、枚举enum14. 位字段，可使用按位运算替代这种方法1234567struct torgle_register&#123; unsigned int SN : 4; unsigned int : 4; //表示有4个位未使用 bool goodIn : 1; bool goodTorgle : 1;&#125;; 15. 使用new和delete应遵守的规则 不要使用delete来释放不是new分配的内存 不用使用delete释放同一块内存块两次 如果使用new[]为数组分配内存，应使用delete[]来使用 使用new[]为一个实体分配内存，则应使用delete（没有方括号）来释放 对空指针使用delete是安全的 16. C++三种管理数据内存的方式 自动存储，栈上的临时变量 静态存储，整个程序执行期间都存在，static变量，全局变量 动态存储，堆，new和delete 17. STL模板类vector是动态数组的替代品，C++11模板类array是定长数组的替代品18. 类型别名 预处理器1#define BYTE char 编译阶段用char替换所有的BYTE typedef（C++、C关键字）1typedef char BYTE; typedef不会创建新类型，只是为已有类型创建新的名称。 19. 数组指针、指针数组12int (*p)[4]; //数组指针，指向一个数组的指针int *q[3]; //指针数组，包含指针的数组 20. 函数指针，是一个指针，指向一个函数21. 内联函数inline关键字，类联函数将使用相应函数代码替换函数调用，程序无需跳转到另一位值执行代码，提高运行速度，但需要占用更多内存，内联函数只是对编译器的建议，如果函数定义占用太多行，则不会被内联。C语言使用#define可以实现函数内联，但由于#define只是代码替换会引发问题，所以应尽量使用inline。 函数声明前加上关键字inline 函数定义前加上关键字inline 22. 左值引用&amp;123int a = 0;int &amp;b = a; //b成为a的一个别名，对b的操作相当于操作b int *const b = &amp;a;b = 10; //*b = 10; 23. 默认参数对于带参数列表的函数，必须从右向左添加默认值。即，要为某个参数设置默认值，其右边的所有参数都必须提供默认值。1int func(int x, int y, int z=0, int w=0); 24. 函数重载函数重载的关键是函数的参数列表，称为函数特征标，和其返回值无关，和参数列表中参数的变量名也无关。编译器在检查函数特征标时，把类型引用和其本身视为同一个特征标。 25. 函数模板12345678template &lt;typename Type&gt;void Swap(Type &amp;a, Type &amp;b)&#123; Type temp; temp = a; a = b; b = temp;&#125; 模板函数也可以重载函数模板特化12345678910111213typedef struct Job&#123; Job &amp; operator =(Job const &amp;r) &#123; return *this; &#125;&#125;Job;template &lt;&gt;void Swap(Job &amp;a, Job &amp;b)&#123; Job temp(a); a = b; b = temp;&#125; 函数模板偏特化是不可以的，可以使用函数重载实现 26. 说明符和限定符 auto C++11之前在申明中使用，指明变量为自动变量，但在C++11中auto用于自动类型推断 12auto int x = 10; //C++11中编译错误，C中可编译通过 指明x为自动变量即存放在栈上auto y = 10; //C++11中编译通过 register 声明将变量存储到寄存器中，C++11中只是显示指出变量是自动的 static 限制全局变量或函数的作用域 申明某个变量为静态变量 用于类函数 extern 声明是引用声明，即声明引用在其它地方定义的变量 mutable 即使变量所在的类或结构体变量为const，其用mutable修饰的变量仍可被修改 const 被其修饰的变量不可改变 volatile 禁止编译器对某个变量进行优化，每次都去内存中取值，不使用寄存器中的缓存值 27. new、delete的用法 常用的用于创建对象并初始化的new，如果失败抛出异常std::bad_alloc 12string *str = new string(\"abc\");int *arr = new int[4]; 常用的用于创建对象并初始化的new，如果失败不抛出异常返回NULL 12int *arr1 = new() int[10000000000]; //抛出std::bad_allocint *arr2 = new(nothrow) int[10000000000]; //不抛出异常，返回NULL 用于申明空间，类似malloc 1void *p = operator new(10000000000 * sizeof(int)); //失败抛出std::bad_alloc 在已有空间上构建对象 12void *p = operator new(sizeof(int));int *a = new(p) int(10); 析构对象并释放空间 1234string *str = new string(&quot;abc&quot;);delete str;int *arr = new int[4];delete[] arr; 释放空间 12void *p = operator new(10 * sizeof(int)); //失败抛出std::bad_allocoperator delete p; 28. 名字空间（名称空间、命名空间）namespace29. 类 class多态、继承、封装和数据隐藏、代码可重用、抽象 访问控制 public protected private 方法 内联方法（inline） 构造方法、析构方法、拷贝构造函数、等号运算符重载函数、取址运算符重载函数、取址运算符重载函数const版本(编译器会自动生成它们的默认版本) C++11列表初始化也可用于类 const成员函数 函数内部不可修改成员变量的值，const修饰的变量和非const变量都可调用，const修饰的变量无法调用非const成员函数 this指针，在成员函数中默认传入 static修饰的成员函数，不会传入this指针，只能访问类中staitc成员变量 30. 运算符重载重载限制 重载后的运算符必须至少有一个操作数为用户自定义类型，防止用户为标准类型重载运算符。 使用运算符不能违反运算符原来的句法规则。不能改变优先级 不能创建新运算符。 不能重载部分运算符。 sizeof . 成员运算符 .* 成员指针运算符 :: 作用域解析运算符 ?: typeid const_cast dynamic_cast reinterpret_cast static_cast 部分运算符只能通过成员函数进行重载。=、()、[]、-&gt;。 31. 友元 friend让外部的函数、类、成员方法可以访问本类的私有变量和方法 友元函数 友元类 友元成员函数 32. 类的自动转化和强制类型转换 隐式类型转换，在只接受一个参数的构造方法前使用关键字explicit限定，可禁止隐式类型转换 显式类型转换 将类对象转化为其他类型，转换函数，特殊类成员运算符函数 33. 类构造函数初始化列表类构造函数初始化列表初始化成员变量，顺序与初始化器中的排列顺序无关，与出现在类申明中的顺序相同。 34. 继承继承是is-a的关系派生类继承基类的方法和属性 公有继承 保护继承 私有继承 虚方法、纯虚方法虚析构函数，确保正确的析构函数序列被调用123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Basic&#123;public: Basic() &#123; cout &lt;&lt; \"Basic\" &lt;&lt; endl; &#125; virtual ~Basic() &#123; cout &lt;&lt; \"~Basic\" &lt;&lt; endl; &#125; //如果不使用virtual pB在析构时将不会调用~Child&#125;;class Child : public Basic&#123;public: Child() &#123; cout &lt;&lt; \"Child\" &lt;&lt; endl; &#125; virtual ~Child() &#123; cout &lt;&lt; \"~Child\" &lt;&lt; endl; &#125;&#125;;int main()&#123; Child *pC = new Child(); Basic *pB = dynamic_cast&lt;Basic*&gt;(pC); delete pB; return 0;&#125; 虚方法会被加入到虚函数表中。如果派生类提供了虚函数的新定义，则虚函数表将保存新函数的地址。当派生类对象调用虚函数时就会调用派生类的新定义的虚函数了。非虚函数在编译时即可得到其调用函数的地址，虚函数则要在运行时才去找需要调用函数的地址。有纯虚方法的类，不能用来创建对象。C++支持多重继承。虚继承。避免多重继承继承了多个基类对象的问题。 35. 模板类 正常模板类 类的特化 类的偏特化 36. 异常123456789try&#123; ...&#125;catch(exception &amp; ex) //捕获异常&#123; ... //处理异常 throw ex; //抛出异常&#125; 37. RTTI运行阶段类别识别 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则返回空指针。 typeid运算符返回一个指出对象的类型的值。 type_info结果存储有关特定类型的信息。 只能将RTTI用于包含虚函数的类层次结构，因为只有对于这种类层次机构，才能将派生对象的地址赋给基类指针。RTTI只适用于包含虚函数的类。 38. 类型转化运算符 dynamic_cast 在类层级结构中进行向上转换，而不允许其他转换 const_cast 改变值为const或volatile static_cast reinterpret_cast 新学的C++11新知识1. C++11初始化方式12int a1 = &#123;1, 2, 3&#125;; //花括号用于数组、结构体初始化int x1 = &#123;24&#125;; //C++98也可用于单值变量 C++11 新方式1234int x2&#123;7&#125;; //变量初始化为7int x3 = &#123;7&#125;; //变量初始化为7int x4&#123;&#125;; //变量初始化为0int x5 = &#123;&#125;; //变量初始化为0 C++11使得可将大括号初始化器用于任何类型，称为通用的初始化语法。列表初始化禁止缩窄转换12345678double d1[4] &#123;1.0, 2, 3, 4.0&#125;;double d2[100] &#123;&#125;; //默认初始化为0long l3[] = &#123;20, 30, 2.3&#125;; //C++编译错误，从double无法转化为long C语言编译成功，2.3转化为2char str1[] = &#123;\"hello C++11\"&#125;;char str2[] &#123;\"hello C++11\"&#125;;string str3 = &#123;\"hello C++11\"&#125;;string str4 &#123;\"hello C++11\"&#125;;vector&lt;int&gt; vi&#123;1, 2, 3, 4, 5&#125;; //C++11中可以对vector使用列表初始化 2. C++11新增基于范围的for循环123456789double arr[]&#123;1, 2, 3, 4, 5,&#125;;for(double x:arr)&#123; cout&lt;&lt;x&lt;&lt;endl;&#125;for (auto x : &#123;23, 1, 45, 23&#125;)&#123; cout&lt;&lt;x&lt;&lt;endl;&#125; 3. 右值引用&amp;&amp;1int &amp;&amp;rr = 1; //int const &amp;rr = 1; 4. 关键字decltype从表达式推断其结果类型。1234567891011template &lt;typename T1, typename T2&gt;void sum(T1 x, T2 y)&#123; type z = x + y; //type无法确定&#125;template &lt;typename T1, typename T2&gt;void sum(T1 x, T2 y)&#123; decltype(x+y) z = x + y; //使用关键字解决&#125; 5. 后置返回类型1234567891011template &lt;typename T1, typename T2&gt;type sum(T1 x, T2 y) //type无法确定&#123; return x + y;&#125;template &lt;typename T1, typename T2&gt;auto sum(T1 x, T2 y) -&gt; decltype(x+y) //通过后置返回类型解决&#123; type z = x + y;&#125; 6. thread_local关键字声明变量的生命周期和所在线程相同。 7. 作用域内枚举1234enum XX &#123;one, two&#125;;enum YY &#123;haha, one&#125;; //编译错误 one重复定义enum class XX &#123;one, two&#125;;enum class YY &#123;haha, one&#125;; //编译成功 作用域内枚举不能隐式转化为整型，需要显式类型转化作用域内枚举可指定底层类型1enum class : short XX &#123;one, two&#125;; //将底层类型设为short 8. nullptr空指针C++11引入新关键字nullptr表示空指针。 9. C++11允许类内初始化，和在构造函数中使用初始化列表等价123456class Test&#123;public: int a = 10; int b = 20;&#125;; 9. 模板别名1234567template &lt;typename T&gt;using arrtype = std::arry&lt;T, 12&gt;;array&lt;double&gt; gallones;array&lt;int&gt; days;arrtype&lt;std::string&gt;months;using BYTE = char; //using 用于非模板和typedef等价 10. Lambda函数1[ capture ] ( params ) mutable exception attribute -&gt; ret &#123; body &#125; mutable 修饰符说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获对象的 non-const 方法 exception 说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f() throw(X, Y)。 attribute 用来声明属性。 capture 指定了在可见域范围内 lambda 表达式的代码内可见得外部变量的列表 params 指定 lambda 表达式的参数。123int x = 10;auto func = [x] (int y) mutable -&gt; int &#123; return x &gt; y ? x :y;&#125;;cout&lt;&lt;func(30)&lt;&lt;endl; 11. 包装器参考资料 C++PrimerPlus（第六版）中文版","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"mongodb 基础学习","slug":"mongodb","date":"2017-07-12T14:47:00.000Z","updated":"2020-04-12T04:56:35.959Z","comments":true,"path":"2017/07/12/mongodb/","link":"","permalink":"http://www.casezheng.date/2017/07/12/mongodb/","excerpt":"","text":"mongodb各个程序功能介绍bsondump 导出bson结构mongo 客户端mongod 服务器mongodump 整体数据库导出 二进制mongoexport 导出易识别的json文档或csv文档mongorestore 数据库整体导入mongos 路由器(分片时用) mongodb启动 连接1mongod --dbpath=/ptah/to/database --logpath=/path/to/logfile --fork --port 27017 参数解释： --dbpath数据存储目录 --logpath日志存储文件 --port 允许端口 --fork 后台允许 --smallfiles 12345sudo mongod --dbpath=/data/mongodb --logpath=/data/mongodb/mongodb.log --port 27017 --forkabout to fork child process, waiting until server is ready for connections.forked process: 4237child process started successfully, parent exiting mongdb连接，默认连接27017端口12345678910111213[CaseZheng@home mongodb]$ mongoMongoDB shell version: 3.2.12connecting to: testWelcome to the MongoDB shell.For interactive help, type &quot;help&quot;.For more comprehensive documentation, see http://docs.mongodb.org/Questions? Try the support group http://groups.google.com/group/mongodb-userServer has startup warnings:2017-07-12T23:32:29.327+0800 I CONTROL [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.2017-07-12T23:32:29.327+0800 I CONTROL [initandlisten]&gt; mongodb入门命令 show dbs; show databases; 查看数据库 use databasesname; 选中数据库 show tables; show collection; 查看数据库中的所有表 创建数据库 隐式创建 use databasesname 如果数据库不存在，则创建 db.createCollection(‘tablename’) 创建表 db.tablename.drop() 删除表 db.dropDatabase() 删除数据库 1234567891011121314151617&gt;show databaseslocal 0.000GB&gt; use localswitched to db local&gt; show tablesstartup_log&gt; use testswitched to db test&gt; db.createCollection(&apos;stu&apos;)&#123; &quot;ok&quot; : 1 &#125;&gt; show tablesstu&gt; db.stu.drop()true&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1 &#125;&gt; mongodb增db.tablename.insert(jsonvalue);一次可插入多个数据，使用json数组即可。1234567&gt; db.test.insert(&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;casezheng&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; show tables;test&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598090b7817bfe1400a371be&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; mongodb删db.tablename.remove(expression);12345678910111213141516171819202122232425&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598090b7817bfe1400a371be&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt;&gt; db.test.insert(&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;casezheng&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.insert(&#123;&quot;id&quot;:4,&quot;name&quot;:&quot;casezheng&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.insert(&#123;&quot;id&quot;:5,&quot;name&quot;:&quot;casezheng&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.insert(&#123;&quot;id&quot;:6,&quot;name&quot;:&quot;casezheng&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.remove(&#123;&quot;id&quot;:2&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091ee817bfe1400a371c1&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091f2817bfe1400a371c2&quot;), &quot;id&quot; : 6, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; db.test.remove(&#123;&quot;id&quot;:6&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091ee817bfe1400a371c1&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; db.tablename.remove(expression, true);不论匹配多少行只删掉一行12345678910111213141516171819202122232425&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091ee817bfe1400a371c1&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; db.test.insert(&#123;&quot;id&quot;:5,&quot;name&quot;:&quot;casezheng2&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091ee817bfe1400a371c1&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598092ac817bfe1400a371c3&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng2&quot; &#125;&gt; db.test.remove(&#123;&quot;id&quot;:5&#125;, true);WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598092ac817bfe1400a371c3&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng2&quot; &#125;&gt; db.test.insert(&#123;&quot;id&quot;:5,&quot;name&quot;:&quot;casezheng3&quot;&#125;);WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.test.remove(&#123;&quot;id&quot;:5&#125;);WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; mongodb改db.tablename.update(expression, jsonvalue);将符合expression的行改为jsonvalue12345678 db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; db.test.update(&#123;&quot;id&quot;:3&#125;, &#123;&quot;name&quot;:&quot;casezhenghaha&quot;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125; 可使用谓词set设置其中某个列的值12345678910&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&gt; db.test.update(&#123;&quot;id&quot;:4&#125;, &#123;$set:&#123;&quot;name&quot;:&quot;casezhenghehehe&quot;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125; unset 删除某个列rename 重命名某个列inc 增长某个列 mongodb查db.tablename.find(expression);db.tablename.findOne(expression);查询所有123456789&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125; 查询单独的某列12&gt; db.test.find(&#123;&quot;id&quot;:4&#125;, &#123;&quot;name&quot;:1&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;name&quot; : &quot;casezhenghehehe&quot; &#125; findOne只查询一行12345678910&gt; db.test.find(&#123;&quot;id&quot;:5&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&gt; db.test.findOne(&#123;&quot;id&quot;:5&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot;&#125; mongodb查询表达式12345678910&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&gt; 不等于ne123456&gt; db.test.find(&#123;&quot;id&quot;:&#123;$ne:5&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125; in nin12345678910&gt; db.test.find(&#123;&quot;id&quot;:&#123;$in:[4, 5, 3]&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&gt; db.test.find(&#123;&quot;id&quot;:&#123;$nin:[4, 5, 3]&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125; all取出field列是数组，且至少包含v1,v2值1&#123;fiels:&#123;$all:[v1, v2]&#125;&#125; exi存在某个属性12345678&gt; db.test.find(&#123;&quot;id&quot;:&#123;$exists:1&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125; 与，写在一个json里面即可1234567891011121314151617&gt; db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809b69817bfe1400a371cb&quot;), &quot;id&quot; : 10 &#125;&gt; db.test.find(&#123;&quot;id&quot;:&#123;$ne:5&#125;, &quot;name&quot;:&#123;$exists:1&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&gt; nor 所有条件都不满足的文档为真返回12345678&gt; db.test.find(&#123;$nor:[&#123;&quot;id&quot;:5&#125;,&#123;&quot;name&quot;:&quot;casezheng&quot;&#125;]&#125;);&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809b69817bfe1400a371cb&quot;), &quot;id&quot; : 10 &#125;&gt; where速度慢 mongodb游标123456789101112131415161718192021222324&gt; var cursor = db.test.find()&gt; while(cursor.hasNext())&#123;... printjsononeline(cursor.next())... &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809b69817bfe1400a371cb&quot;), &quot;id&quot; : 10 &#125;&gt; var cursor = db.test.find()&gt; cursor.forEach(function(obj)&#123;printjsononeline(obj)&#125;);&#123; &quot;_id&quot; : ObjectId(&quot;598091e7817bfe1400a371bf&quot;), &quot;name&quot; : &quot;casezhenghaha&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598091eb817bfe1400a371c0&quot;), &quot;id&quot; : 4, &quot;name&quot; : &quot;casezhenghehehe&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809440817bfe1400a371c5&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c0817bfe1400a371c6&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng4&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c3817bfe1400a371c7&quot;), &quot;id&quot; : 5, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095c7817bfe1400a371c8&quot;), &quot;id&quot; : 3, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095ca817bfe1400a371c9&quot;), &quot;id&quot; : 2, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;598095cd817bfe1400a371ca&quot;), &quot;id&quot; : 1, &quot;name&quot; : &quot;casezheng45&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;59809b69817bfe1400a371cb&quot;), &quot;id&quot; : 10 &#125; mongodb分组maoReduce","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://www.casezheng.date/tags/mongodb/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://www.casezheng.date/categories/数据库/"}]},{"title":"初学Python","slug":"python","date":"2017-07-04T14:57:00.000Z","updated":"2020-04-12T04:56:35.953Z","comments":true,"path":"2017/07/04/python/","link":"","permalink":"http://www.casezheng.date/2017/07/04/python/","excerpt":"","text":"Python的数据类型 整数 整数的运算结果是精确的 浮点数 浮点数的运算结果不一定是精确的，可能有精度损失。整数和浮点数一起运算结果为浮点数。 字符串 用’’或””括起来的任意文本。 如果字符串中有’可以用””括起来。 例如：”aaa ‘bbb’ aaa” 如果字符串中有”可以用’’括起来。 例如：’aaa “bbb” aaa’ 如果字符串中既有’又有”，可以用\\转义。 例如：&quot;aaa \\&#39;bbb\\&#39;\\&quot;ccc\\&quot; aaa&quot; 或 &#39;aaa \\&#39;bbb\\&#39;\\&quot;ccc\\&quot; aaa&#39; 如果字符串中存在多个需要转义的字符，对每个字符都转义很麻烦，可以在字符串前加前缀r，表示一个raw字符串，里面的字符就不需要转义啦。 例如：r&#39;\\(~_~)/ \\(~_~)/&#39; 但r’…’表示法不能表示多行字符串，也不能表示包含’和”的字符串。 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示。 例如 123''' Line1 Line2 Line3''' 可以在多行字符串前加r前缀，将其变为raw字符串。 布尔值 True、False 运算：与(and)、或(or)、非(not) Python将0、空字符串、None看作False，其它数值和非空字符串都看成True。and和or短路计算。 空值 None None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 Python的注释以#开头Python变量Python标识符必须是大小写英文、数字和下划线的组合，且不能数字开头。不能使保留字。区分大小写。Python是动态语言。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。 Python中Unicode字符串需要在字符串前加多u前缀。1# -*- coding: utf-8 -*- 告诉Python解释器，用UTF-8编码读取源代码。文件格式也要保存为UTF-8格式。 Python创建listlist是一种有序的集合，可以随时添加和删除其中元素。构造list直接用[]将list的所有元素都括起来，就是list对象。list中包含的元素可以是不同的数据类型。一个元素都没有的list就是空list。list可以通过索引获取指定元素。索引从0开始。使用索引访问list注意不要越界，超过索引范围会报错。list可以用-1访问最后一个元素。-n表示倒数第n个，注意不要越界。 Python中list添加新元素 使用list的append()方法。append将新元素添加到list的尾部。 使用list的insert()方法，insert接受两个参数，第一个是索引号，第二个是待添加的新元素，表示将新元素插入到索引号所在的位置，原有元素后移。 Python中list删除元素 使用list的pop()方法。pop方法不带参数，删除并返回list的最后一个元素。 使用list的pop()方法。pop方法带一个索引号参数，删除并返回索引号所在位置的元素，后面的元素前移。 Python替换元素对list的某个索引赋值，直接用新元素替换原来的元素。 Python创建tuple元组一旦创建完毕就不能修改了。创建元组使用()将tuple的所有元素都括起来。tuple可以使用索引访问元素。Python创建单元素tuple，()可以表示tuple，也可以作为括号表示运算时的优先级。1234# 错误，t不是tuple，而是整数1 (1)会被Python解释器计算出结果1t = (1)# 正确t = (1,) Python条件判断和循环Python具有相同缩进的代码被视为代码块。缩进习惯：4个空格，不要使用Tab，更不要使用Tab和空格。 if语句12if 判断语句 : 代码块 if-else语句1234if 判断语句 : 代码块else : 代码块 if-elif-else123456if 判断条件 : 代码块elif 判断条件 : 代码块else : 代码块 不能忘记”:”号 for循环1234567891011for 临时变量 in 要遍历的容器 代码块L = [1, 2, 3, 4,]for num in L print numfor 临时变量 in 要遍历的容器 代码块else : # 循环结束 则会执行下面的代码块 如果循环被break打断，则不会执行 代码块 while循环12345678910111213while 判断条件 : 代码块N = 10x = 0while x &lt; N : print x x = x + 1while 判断条件 : 代码块else : # 循环结束 则会执行下面的代码块 如果循环被break打断，则不会执行 代码块 while循环每次先判断判断条件，如果为True，则继续执行循环体的代码块，否则，退出循环。 break退出循环用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 continue退出本次循环，继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 Python的循环可以嵌套for循环比while循环执行速度快Python提供两个内置函数用于在for循环中定制特殊的循环 range或xrange range一次性地返回连续的整数列表 xrange一次产生一个数据元素，相较于range更节约空间 zip 返回并行的元素元组的列表，常用于在for循环中遍历数个序列 Python中dict的创建dict用来存储键值对。花括号{}表示一个dict，然后按照key:value，将元素填入。12345678910&#123; 键 : 值, ......&#125;&#123; 'key1' : value1, 'key2' : value2, 'key3' : value3,&#125; len()函数可以计算任意集合的大小。dict、list、tuple都是集合。 Python中dict的访问可以是通过key访问dict的value，只要key存在，dict返回对应的value。如果key不存在，直接报错:KeyError。避免KeyError的两种方法： 线判断Key是否存在，用in操作符 使用dict提供的get方法，在Key不存在时，返回None 123456789101112d = &#123;'key1': 1'key2': 2&#125;if 'key1' in d: print d['key1']if 'key3' in d: print d['key3']print d.get('key1')print d.get('key3') Python中dict的特点 dict查找速度快，查找速度不会随着元素数量增多而变慢。list的查找速度回随着元素增多而逐渐下降。 dict的key不可重复。 dict存储的key-value是没有顺序的。 dict作为key的元素必须不可变。 Python更新dict添加新的键值对，如果key已经存在则会替换掉原来的value123d = &#123; 'key1' : 1, 'key2' : 2, &#125;d['key3'] = 3d['key3'] = 6 Python遍历dict通过for循环可以遍历dict的key，通过key获取value。123d = &#123; &apos;key1&apos; : 1, &apos;key2&apos; : 2, &#125;for key in d : print key Python中set的创建创建set的方式是调用set()并传入一个list，list的元素将作为set的元素。12s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;,])print s Python中set的访问set存储的无序集合，无法通过索引访问。访问一个set中的某个元素实际上就是判断该元素是否存在于set中。可以用in操作符判断。123s = set(['A', 'B', 'C',])print 'A' in sprint 'D' in s Python中set的特点 访问速度快 set存储的元素不可变 set存储元素没有顺序 Python中set的遍历通过for循环遍历123s = set(['A', 'B', 'C',])for value in s : print value Python更新set给set添加元素，使用set提供的add()方法从set中删除元素，使用set提供的remove()方法。如果remove的元素不存在，remove会报错，所有remove前需要判断。 Python函数Python中定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号，然后，在缩进块中编写函数体，函数的返回值用return语句返回。如果没有return语句，函数执行完毕也会返回结果，只是结果为None。return None可以简写为return。12345def my_abs(x) if x &gt;= 0 : return x else : return -x Python函数可以返回多个返回值Python函数返回多个值，其返回值其实是一个tuple。在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple。 Python函数调用可以递归调用自身递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。12345678910def move(n, a, b, c): if n==1 : print a, '--&gt;', c return move(n-1, a, c, b) print a, '--&gt;', c move(n-1, b, a, c)move(4, 'A', 'B', 'C') 递归需要边界条件，递归前进段和递归返回段 Python函数定义默认参数函数默认参数的作用是简化调用。由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面。123456def power(x, n=2) s = 1 while n &gt; 0 : n = n - 1 s = s * x return s Python定义可变参数可变参数让一个函数可以接受任意个参数。12def fn(*args) : pirnt args 可变参数的名字前加*号，可以传入0个、1个或多个参数给可变参数。传入可变参数，实质是传入了一个tuple。 Python函数内使用全局变量，需要使用global关键字声明123456789x = 32print x # 32def f1(): global x x = 43 print x # 43f1()print x # 43 Python 参数传递形式位置参数：从左到右关键字参数：按关键名称匹配既有位置参数，又有关键词参数时：所有位置参数，所有关键字参数定义函数时使用默认参数：有默认值的参数混用有默认和无默认值的参数对，无默认值在前调用函数时使用可变参数要求：定义函数时使用*，收集位置参数定义函数时使用**，收集关键字参数 Python对list进行切片对于经常取指定索引范围的操作，Python提供切片(Slice)操作符。123L = [1, 2, 3, 4, 5, 6, 7, 8, 9,]L[0:3] #从索引0开始到索引3为止 1 2 3L[:3] #与L[0:3]左右相同 切片操作实质是复制出一个新的list切片操作还可以指定第三个参数，表示每N个取一个。12L = [1, 2, 3, 4, 5, 6, 7, 8, 9,]L[0:6:2] #从索引0开始到索引6结束，每2个取一个，即隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。list支持L[-1]取倒数第一个元素，同样支持倒数切片。倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。字符串也支持切片操作，操作结果是字符串。Python没有对字符串的截取函数。 Python迭代在Python中迭代通过for…in来完成。Python迭代操作是对于一个集合，无论该集合是有序或者无序，用for循环总是可以依次取出集合的每一个元素。集合： 有序集合：list、tuple、str和unicode 无序集合：set 无序集合并且具有key-value对：dict 迭代是一个动词，指一种操作，在python中就是for循环。迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，前者只关心迭代结果，不关心迭代内部的具体实现。 Python索引迭代Python中迭代永远是取出元素本身，而非元素的索引。如果想在for循环中拿到索引，可以使用enumerate()函数。enumerate将迭代的每个元素实际是一个tuple。12345678L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in enumerate(L): print index, '-', namefor t in enumerate(L): index = t[0] name = t[1] print index, '-', name Python迭代dict用for直接迭代dict可以得到dict的key，如果想迭代dict对象的value，可以使用dict对象的values()方法，该方法将dict转换成包含所有value的list。dict提供的itervalues方法可以替代value方法，迭代效果完全一样。 values()方法实际把一个dict转换成包含value的list。 itervalues()方法不会转换，在迭代过程中依次从dict中取出value，itervalues方法比values方法节省内存。 如果迭代dict时即想得到key，又想得到value，可以使用dict对象的items()方法返回的值。该方法将dict转化为包含tuple的list。通过对该list的迭代得到key和value。 Python迭代iterator(可迭代)对象支持每次返回自己包含的一个成员的对象对象实现__iter__方法 序列类型 非序列类型 用户自定义包含__iter__()或__getitem__()方法的类 Python生成列表 range() 列表生成式 字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤，列表生成式的for循环后面可以加上if判断。 列表表达式多层for循环可以嵌套。 12345678# [1x1, 2x2, 3x3, ..., 10x10][x * x for x in range(1, 11)]# 获得偶数的平方[x * x for x in range(1, 11) if x % 2 == 0]# 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。[n1*100+n2*10+n3 for n1 in range(1,10) for n2 in range(10) for n3 in range(10) if n1==n3] Python列表解析Python列表解析是Python迭代机制的一种应用，常用于创建新的列表，因此放置在[]中。语法：12[expression for iter_var in iterable][expression for iter_var in iterable if cond_expr] Python生成器表达式生成器表达式并不真正创建数字列表，而是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目”产生”（yield）出来。生成器表达式使用惰性计算或称为延迟求值的机制。序列过长，并且每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析语法：12(expr for iter_var in iterable)(expr for iter_var in iterable if cond_expr) 高阶函数函数名就是指向函数的变量。高阶函数：能接收函数作为参数的函数。 map()map()函数是Python内置的高阶函数，接受一个函数f和一个list，并通过把函数f依次作用于list的每个元素上，得到新的list并返回。map()不会改变原有的list，而是返回一个新的list。 reduce()reduce()函数是Python内置的高阶函数，接受一个函数f和一个list，函数f必须接受两个参数，reduce()对list的每个元素重复调用函数f，并返回最终结果值。reduce()可以接受第三个可选参数，作为计算的初值。12345def f(x, y) return x + yreduce(f, [1, 3, 5, 7]) # f(1, 3) f(4, 5) f(9, 7) 返回最终结果16reduce(f, [1, 3, 5, 7], 100) # 最终结果116 filter()filter()函数是Python内置的高阶函数，接受一个函数f和一个list，函数f的作用是对每个元素进行判断，返回True或False，filter()根据判断结果自动过滤不符合条件的元素，返回由符合条件元素组成的新list。1234# 从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数def is_odd(x): return x % 2 == 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) sorted()Python内置sorted()函数可以对list进行排序。sorted()函数也是一个高阶函数，可以接收一个函数来实现自定义排序，比较函数定义是，传入两个待比较的元素x、y，如果x应该排在y的前面，返回-1,如果x应该排在y的后面，返回1,如果x和y相等，返回0。123456789print sorted([36, 5, 12, 9, 21])def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0print sorted([36, 5, 12, 9, 21], reversed_cmp) Python中返回函数Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数。12345678910def f(): print 'call f()...' # 定义函数g: def g(): print 'call g()...' # 返回函数g: return gx = f()x() #会调用g() 返回函数可以把一些计算延迟执行。 Python闭包在函数内部定义的函数和外部定义的函数是一样的，只是无法被外部访问。如果内层函数引用了外层函数的变量(参数也算变量)，然后返回内层函数的情况，称为闭包(Closure)。外层函数提供了内层函数的环境闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。返回函数不要引用任何循环变量，或者后续会发生变化的变量。12345678910111213141516171819202122def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 9, 9, 9def count(): fs = [] for i in range(1, 4): def f(j): # 加多一层，保存临时变量的值 后续不会再变化 def g(): return j*j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 1, 4, 9 Python匿名函数lambda args: expression args:用逗号分隔的参数列表 expression:表达式 Python对匿名函数提供了有限支持。匿名函数有个限制，就是只能有一个表达式，不能是别的非表达式语句，不写return，返回值就是该表达式的结果。使用匿名函数，可以不必定义函数名，直接创建一个函数对象。关键字lambda 表示匿名函数，冒号前面的 x 表示函数参数。12345map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])# lambda x: x*x 实际就是：def f(x): return x*x 返回函数的时候也可以返回匿名函数。lambda的首要用途是指定短小的回调函数lambda将返回一个函数而不是将函数赋值给某个变量名lambda是一个表达式而非语句lambda是一个单个表达式，而不是一个代码块lambda也支持默认参数 Python装饰器Python内置的@语法简化装饰器调用。装饰器简化代码，避免每个函数编写重复性代码。12345678910111213141516171819202122def f1(x): return x*2def new_fn(f): def fn(x): print 'call' + f.__name__ + '()' return f(x) retun fng1 = new_fn(f1)print g1(5)f1 = new_fn(f1) # 彻底隐藏原函数print f1(5)@new_fndef f2(x): return x*3# 等同于def f2(x): return x*3f2 = new_fn(f2) python中编写无参数decoratorPython中的decorator本质上是一个高阶函数，接受一个函数作为参数，返回一个新的函数。使用decorator用Python提供的@语法，简化decorator的书写。利用Python的*args 和**kw，保证任意个数的参数总是能正常调用。123456789101112131415161718192021def log(f): def fn(x): print 'call ' + f.__name__ + '()...' return f(x) return fn@logdef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) #正常@logdef add(x, y): return x + yprint add(1, 2) #错误，参数不是一个def log(f): def fn(*args, **kw): #保证任意个数的参数总是能正常调用。 print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn python中编写带参数的decorator123456789101112131415161718192021222324252627def log(prefix): def log_decorator(f): def wrapper(*args, **kw): print '[%s] %s()...' % (prefix, f.__name__) return f(*args, **kw) return wrapper return log_decorator@log('DEBUG')def test(): passprint test()#拆开看def test(): passtest = log('DEBUG')(test)#再展开log_decorator = log('DEBUG')test = log_decorator(test)# 又相当于log_decorator = log('DEBUG')@log_decoratordef test(): pass Python中完善decorator用Python内置的functools可将原函数的属性复制到新函数。但原函数的原始参数信息无法获得。 Python中偏函数当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值。12345def int2(x, base=2): return int(x, base)int2 = functools.partial(int, base=2)int2('1000000') Python yield与生成器123456789def getNum(x) y = 0 while y&lt;=x: yield y y += 1g1 = getNum(10)print g1.next()print g1.next() 函数中使用yield会生成一个生成器对象 Python包和模块包：包是一个有层次的文件目录结构，定义了由n个模块或n个子包组成的Python应用程序执行环境。包是一个包含init.py 文件的目录，该目录下一定得有这个init.py文件和其它模块或子包。模块：在Python可理解为对应于一个文件。 Python之导入模块要使用一个模块，必须首先导入该模块。Python使用import语句导入一个模块。如果只希望导入某个模块的某几个函数，使用from import。12import math # 导入整个math模块from math import pow, sin, log # 导入math模块pow() sin() log()函数 如果使用import导入模块，必须通过模块名引用函数名。通过from import导入可能会出现名字冲突，可利用别名解决。1234from math import logfrom logging import log as logger # logging的log有个logger的别名print log(10) # 调用的math的loglogger(10, 'import from logging') # 调用的是logging的log Python动态导入模块如果导入的模块不存在，Python解释器会报ImportError错误。因为Python是动态语言，解释执行，因此Python代码运行速度慢。12345try: from cStringIO import StringIOexcerpt ImportError: from StringIO import StringIO# StringIO 和 cStringIO 都提供StringIO功能，StringIO 是纯Python代码编写的，而 cStringIO 部分函数是 C 写的，因此 cStringIO 运行速度更快。先尝试从cStringIO导入，如果失败了，再尝试从StringIO导入。 import和from都是隐性赋值语句，import将整个模块对象赋值给一个变量名，from将一个或多个变量名赋值给导入此模块的模块中的同名对象 import工作机制 查找模块文件，在指定路径下搜索模块文件 程序主目录 PYTHONPATH目录（如果设置了） 标准链接库目录 任何.pth文件的内容（如果存在.pth文件） 编译为字节码，当文件导入时会编译，顶层文件的.pyc字节码文件在内部使用后会被丢弃，只有被导入文件才会留下.pyc文件 执行模块的代码创建其所定义的对象，模块文件的所有语句依次执行，从头到尾，而此步骤中任何对变量名的赋值运算，都会所得到的模块文件的属性 模块只在第一次导入时执行如上步骤，后续的导入操作只不过是提取内存中已加载的模块对象，reload()可用于重新加载模块。 Python future当新版本的一个特性与旧版本不兼容时，该特性将会在旧版本中添加到future中，以便旧的代码能在旧版本中测试新特性。 Python按照第三方模块 使用pipPython包包将一组模块归并到一个目录中，此目录即为包，目录名即为包名。包是一个有层次的文件目录结构，定义了一个由模块和子包组成的Python应用程序执行环境。基于包，Python在执行导入模块时，可以指定模块的导入路径。包导入语句的路径内的每个目录内必须有__init__.py文件，__init__.py可包含Python代码，但通常为空，仅用于扮演包初始化的挂钩、替目录产生模块命名空间以及使用目录导入时实现from *行为的角色。 Python distutils发布模块distutils模块能帮助完成模块或程序发布。创建发布，将个代码文件组织到模块容器中，准备README或README.txt文件，在容器中创建setup.py文件属性大体分为两类：元数据信息和包中的内容列表1python setup.py sdist 可以为sdist指定格式： —formats zip: zip file gztar: tar.gz file bztar: tar.bz2 file ztar: tar.Z file tar: tar file 1python setup.py bdist 可以为bdist指定格式： —formats gztar: tar.gz file ztar: tar.Z file tar: tar file zip: zip file rpm RPM Package pkgtool: Solaris pkgtool Wininst: Windows上自解压的zip格式的包 msi: Microsoft Installer bdist_dumpbdist_rpmbdist_wininstbdist_msi 获取帮助1234python setup.py --helppython setup.py --help-commands 所有可以使用的命令python setup.py COMMAND --help 获取特定命令的帮助python setup.py COMMAND --help-formats 获取给定命令支持使用的格式 Python安装包1python setup.py install 第三方模块默认安装路径默认为site-packages Python面向对象编程类用于定义抽象类型。实例根据类的定义被创建出来。 Python定义类并创建实例在Python中，类通过class关键词定义。类体可以包含：申明语句、类成员定义、数据属性、方法12345class Person(object): passxiaoming = Person()xiaohong = Person() Python中创建实例属性每个实例可以拥有各自不同的属性，可以直接给其属性赋值。实例的属性可以像腹痛变量一样进行操作。 Python中初始化实例属性在定义类时，可以为类添加特殊的init()方法，在创建实例时，init方法会被自动调用。可以在此为每个实例都统一加上属性。1234567891011121314151617class Persion(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birthxiaoming = Person('Xiao ming', 'Male', '1992-1-1')class Persion(object): def __init__(self, name, gender, birth, **kw): self.name = name self.gender = gender self.birth = birth for k, v in kw.iteritems(): setattr(self, k, v)xiaohong = Person('Xiao hong', 'Female', '1992-1-1', jog=\"student\") init方法的第一个参数必须是self，后面参数可以自由指定，和定义函数没有任何区别。可以使用setattr将任意关键词参数作为属性赋值给实例。 Python访问限制Python对属性权限的控制通过函数名来实现，如果一个属性由双下划线开头(__)，该属性无法被外部访问。注意以__开头，以__结尾的属性可被外界访问，__xxx__定义的属性被称为特殊属性。 Python创建类属性类是模版，实例则是根据类创建的对象。绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！即：实例属性每个实例各自拥有，互相独立，而类属性有且只有一份。定义类属性直接在class中定义：123456789class Person(object): address = \"Earth\" def __init__(self, name) self.name = nameprint Person.addressPerson.email = '1111@google.com'Person.address = 'china' 因为类属性是直接绑定在类上的，所有，访问类属性不需要创建实例，就可以直接访问。对一个实例调用类的属性也是可以访问的，所有实例都可以访问到它所属的类的属性。由于Python是动态语言，类属性也是可以动态添加和修改的。因为类属性只有一份，所以，当类的属性改变时，所有实例访问到的类属性都改变了。 Python中类属性和实例属性冲突当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。 方法的可用变量实例变量：指定变量名称及实例自身进行引用局部变量：方法内部创建的变量，可直接使用类变量：通过指定变量名与类名进行引用全局变量：直接使用 Python中定义实例方法实例的方法就是在类中定义的函数，第一个参数永远是self，执行调用该方法的实例本身，其他参数和一个普通函数是完全一样的。在实例方法内部可以访问所有实例属性。123456789class Person(object) def __init__(self, name) self.__name = name def get_name(self) return self.__namep = Person('bob')print p.get_name() Python中方法也是属性在class中定义的实例方法其实也是属性，实际上是一个函数对象。使用types.MethodType()可以把一个函数变成一个方法。12345678910111213141516171819import typesdef fn_get_grade(self): if self.score &gt;= 80: return 'A' if self.score &gt;= 60: return 'B' return 'C'class Person(object): def __init__(self, name, score): self.name = name self.score = scorep1 = Person('Bob', 90)p1.get_grade = types.MethodType(fn_get_grade, p1, Person)print p1.get_grade()p2 = Person('Alice', 65)print p2.get_grade() # 错误 p2没有get_grade方法 Python中定义类方法Python类中定义的方法分为类方法和实例方法。在class中定义的全部都是实例方法，实例方法第一个参数是实例本身。定义类方法需要使用@classmethod，将方法绑定到Person类上，而非类实例上。类方法的第一个参数传入类本身，因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。 Python类连结至超类的方式将超类列在类头部的括号内，其从左到右的顺序决定树的顺序，从下至上，从左至右 Python继承总是从某个类继承，如果没有则需要继承object类。不要忘记调用super().__init__用来初始化父类属性123class MyClass(object): def __init__(self) super(MyClass, self).__init__() Python中判断类型函数isinstance()可以判断一个变量的类型，既可以用于Python内置的数据类型，也可以用于自定义类。 Python多态类具有继承关系，并且子类类型可以向上转型看做父类类型。 Python多重继承Python允许从多个父类继承，称为多重继承 Python获取对象信息 用type()函数获取变量的类型，返回一个Type对象。 用dir()函数获取变量的所有属性。 Python定制类Python的特殊方法 特殊方法定义在class中。 不需要直接调用，某些函数或者操作符会调用对应的特殊方法。 str和repr如果要把一个类的实例变成str，需要实现特殊方法__str__()。__repr__()方法用于显示给开发人员。 cmp对int、str等内置数据类型排序时，Python的sorted()按照默认的比较函数cmp排序，如果对自定义类的实例排序，必须提供自定义的特殊方法__cmp__()。 lenandint@propertyslotscall类、实例和其它对象的内建函数 issubclass() 布尔函数，判断一个类是否由另一个类派生，语法：issubclass(sub, sup) isinstance() 布尔函数，判断一个对象是否是给定类的实例，语法：isinstance(obj1, class_obj2) hasattr() 布尔函数，判断一个对象是否拥有指定属性，语法：hasattr(obj, attr) 同类函数getattr()、setattr()、delattr() super() 在子类中找到其父类以便于调试其属性，一般仅采用非绑定方式调用祖先类方法，而super()可用于传入实例或类型对象，语法：super(type[,boj]) Python运算符重载运算符重载在方法中拦截内置操作，当类的实例出现内置操作时，Python自动调用自定义方法，并返回调用结果。运算符重载荣类拦截常规的Python运算，重载使类实例的行为像内置类型，重载通过提供特殊名称的类方法实现。 Python函数的属性： __doc__ __name__ __dict__ __code__ __globals__ Python方法的属性： __doc__ __name__ __class__: 方法所属类 __func__： 实现该方法的函数对象 __self__：调用次方法的实例 Python内置函数： __doc__ __name__ __self__ Python类： __doc__ __name__ __bases__ __func__ __module__ Python异常Python的运行时错误称为异常 语法错误 逻辑错误 Python异常是一个对象，表示错误或意外情况，在Python检测到一个错误时，将触发一个异常，Python可以通过异常传导机制传递一个异常，发出一个异常情况的信号。程序员也可以在代码中手动触发异常。Python异常可以理解为程序出现了错误而在正常控制流程以外采取的行为。 解释器触发异常，此时当前程序流被打断 异常处理 错误处理Python的默认处理：停止程序，打印错误信息。可以使用try语句处理异常并从异常中恢复 事件通知用于发出有效状态信号 特殊情况处理无法调整代码去处理的场景 终止行为try/finally语句可确保执行必需的结束处理机制 非常规流程控制异常是一种高级跳转机制（goto） 异常通过try语句来检测任何在try语句块里的代码都会被检测，以检测有无异常发生 try语句两种形式 try-execpt：检测和处理异常，支持多个execpt，支持使用else子句处理没有探测异常的执行的代码 123456789101112131415161718#定义进行异常监控的一段代码，并提供处理异常的机制try: try_suiteexecpt Exception[, reason]: execpt_suittry: try_suiteexecpt Exception1[, reason]: execpt_suit1execpt (Exception2, Exception3, ...)[, reason]: # 一次捕获多个异常使用元组 execpt_suit2execpt: #空execpt用于捕获所有异常 suitelse: else_suit #没有异常发生时else分句才会执行#没有符合的execpt语句时，异常会向上传递到程序之前的try中或者到进程的顶层 try-finally：仅检测异常并做一些必要的处理工作，仅能有一个finally，无论异常是否发生，finally子句都会都会执行，finally中所有代码执行完毕后会向上一层引发异常。 try的复合形式try-execpt-finally raise 语句可显式触发异常raise [SomeException [, args[, traceback]]] SomeException可选，异常的名字，仅能使用字符串、类或实例 args 可选，以元组的形式传递给异常的参数 traceback 可选，异常触发时新生成的一个用于异常-正常化的跟踪记录，多用于重新引发异常 Python异常对象Python异常是内置的经典类Exception的子类的实例，为了向后兼容，Python允许使用字符串或任何经典类实例，Python2.5后，Exception是从BaseException继承的新式类Python自身引发的所有异常都是Exception的子类的实例，大多的标准异常都是由StandardError派生的，其中三个抽象子类 ArithmeticError 由算数错误而引发的异常基类 OverflowError ZeroDivisonError FlootingPointError LookupError LookupError 容器在接收到一个无效键或索引时引发的异常的基类 IndexEeror KeyError EnvironmentError 由于外部原因而导致的异常的基类 IOError OSError WindowsError Python assert语句assert语句用于在程序中引入调试代码assert condition[, expression]如果condition条件满足，则assert不做任何操作如果condition条件不满足，则assert使用expression作为参数实例化AssertionError并引发结果实例如果Python运行使用-O，则assert是一个空操作，编译器不为assert语句生成代码，不使用-O选项，则debug内置变量为True，否则其值为False。1234# assert condition[, expression] 相当于if __debug__: if not condition: raise AssertionError, &lt;expression&gt; Python程序的执行12source code PVM bytecode PVM .py ----Complier------&gt; .pyc -----Interpreter----&gt; processor python源代码第一次执行时被Python虚拟器编译为Python字节码，然后Python虚拟器根据Python字节码执行程序。 Python的实现Cpython 原始、标准的实现方式Jythin 用于和Java语言集成的实现IronPython 用于与.NET框架集合实现 Python性能优化工具Psyco Python语言的一个扩展模块，即时对程序代码进行算法优化，可以一定程度提高程序的执行速度，尤其是程序中有大量循环操作时，目前该工具研发工作已经停止，由pypy所替代。PyPy PyPy是用Python实现的Python解释器，Python语言的动态编译器，是Psyco的后继项目。可以运行在Linux32和64位、MocOS和Windows的32位平台上。Shed Skin Python编译器，能将Pythona代码转化为优化的C++代码。 Python程序文件Python程序可分解为模块、语句、表达式和对象 程序由模块组成 模块包含语句 语句包含表达式 表达式建立并处理对象 表达式是”某事”，而语句是”做某事(即指令)”。 语句的特性：改变令事物。 面向过程：以指令为中心，由指令处理数据面向对象：以数据为中心，所有的代码都围绕数据展开 Python要素 基本数据类型Python要素 对象引用 Python将所有数据都存为内存对象，Python中变量其实是指向内存对象的引用。 动态类型：在任何时刻，只要需要，某个对象引用都可以重新引用一个不同的对象。 内建函数type()用于返回给定数据项的数据内型。 “=”用于将变量名与内存中的某个对象绑定：如果对象事先存在，就直接进行绑定；否则，则在”=”创建引用的对象。 注意，变量名没有类型，对象才有。 列表和元素并不存储数据，而是存放对象引用 Python要素 组合数据类型Python要素 逻辑操作符Python提供4组逻辑运算 身份操作符 is，判断左端对象引用是否相同于右端对象，也可以与None进行。 比较操作符 &lt;, &gt;, &lt;=, &gt;=, !=, == 成员操作符 in 或 not in：测试成员关系 逻辑运算符：and、or、not Python要素 控制流语句Python要素 算数运算符Python提供了完整的算数操作符。Python的int类型是不可变的，因此给一个int变成加减其实是重新创建一个新的变量来存储结果后将变量名执行重新绑定。 Python要素 输入/输出命令行输出 print()函数 python3 print语句 python2命令行输入 input() raw_input()Python解释器提供3种标准文件对象，标准输入sys.stdio 标准输出sys.stdout 标准错误sys.stderr, 存在与sys模块中。 Python要素 函数callable()函数可以检测函数是否可调用。Python有很多内置函数 __builtins__Python有很多标准库，可以导入后直接使用。 Python 语句和语法注释 #续行 \\ ‘’’代码组 缩进相同的一组语句可构成代码块 首行以关键字开始，以冒号结束，Python使用缩进来分隔代码组，同一代码组的代码行必须严格左对齐，否则会造成语法错误。同一行多个语句，以;为分隔符模块 每个Python脚本文件都是一个模块 Python 文件结构 起始行 #/usr/bin/env python 模块文档(文档字符串) __doc__ 模块导入 (模块全局)变量定义 类定义(若有) 函数定义(若有) 主程序 每个模块都有__name__内建变量，此变量根据调用该模块的方式而变化。__name__指示模块该如何加载，如果模块是被导入，__name__的值是模块名字 如果模块是直接执行__name__的值是__main__ Python两个对象比较 值比较：对象中的数据是否相同 身份比较：两个变量引用的是否同一个对象 也就是内存地址比较 类型比较：两个对象的类型是否相同 Python类型转换个人理解Python中类型转换，都是根据原有对象新建对象str() repr()或format():字符串int():整数float():浮点数list():列表tuple():元组set():集合dict():字典，传入参数必须是(key, value)的元组序列chr():字符(ASCII码)，传入参数为整数ord():整数，传入参数为字符hex():16进制整数bin()cot() Python数字类型Python 5种数字类型：布尔型(True 1 False 0)、整数、长整数、浮点数、复数，所有数字类型均不可变。数字操作： 加+ 减- 乘* 除/ 截断除法// 乘方 ** 取模%位操作：左移 &lt;&lt; 右移 &gt;&gt; 按位与&amp; 按位或| 按位异或^ 按位求反~ Python序列类型Python内置序列类型list tuple str str是字符序列 list和tuple是任何Python对象序列 str和tuple属于不可变序列 所有序列都支持迭代所有序列类型支持索引、切片min()取序列中的最小值max()取序列中的最大值sum()对序列求和len()求序列元素个数all()检查序列中所有元素为True Python列表支持在原处修改：修改指定的索引元素、修改指定分片、删除语句、内置方法合并两个列表，返回一个新的列表，不会修改原列表in:成员关系判断字符，用法 obj in containernot in: obj not in container列表解析：[]列表复制：浅拷贝 深拷贝(copy.deepcopy()) Python元组任意对象的有序集合，通过索引访问其中内容，不可变对象，长度固定innot in Python集合只能使用工厂函数set()和frozenset()创建不支持：索引、切片、元素获取 Python引用计数sys模块 sys.getrefcount()获得对象的引用计数Python对象引用计数为0，对象被释放，归还内存 Python真假 所有非0数字和非空对象都为真 数字0、空对象和特殊对象None均为假 Python解释器环境与选项python [option] [-c cmd | filename | -] [ args ] Python文件操作Python内置函数open()用于打开文件和创建文件对象。1open(name [,mode[,bufsize]]) open方法可以接受三个参数：文件名、模式、缓冲区参数 open函数返回一个文件对象 mode指定文件打开模式 r只读 w写入(如果没有文件会自动创建一个) a附加 r+默认读模式打开支持写操作 w+默认写模式打开支持读操作 a+默认附加模式打开支持读操作 在r、w、a、r+、w+、a+后面中附加b，表示以二进制方式打开 bufsize定义输出缓存 0表示无输出缓存 1表示使用缓存 负数表示使用系统默认配置 正数表示使用近似指定大小的缓冲。 file.next() 返回文件中下一行内容 不会移动文件游标file.close() 关闭当前文件file.fileno() 返回文件描述符file.readline() 读取文件中一行file.readlines() 以列表形式每行为一个元素，返回所有文件内容file.tell() 返回当前文件游标的位置(第n个字节处)file.read(size) 返回size个字节的数据，返回字符串file.seek(offset [, whencel]) 移动文件游标到指定位置 offset偏移量 whencel 偏移起点 0文件头 1当前位置 2文件尾部 默认为0file.write(str) 将str写入文件中file.writeline(list) 将字符串列表list写入文件中file.flush() 将数据从缓存区刷新到磁盘中file.isatty() 判断该文件是否为终端设置文件 如果是返回True 否则返回Falsefile.truncate(size) 将文件截取保留size大小的文件，其余的删除 file.closed 返回文件是否已经关闭 返回True表示已关闭 返回False表示未关闭file.encoding 返回文件编码格式file.mode 返回文件打开模式file.name 当前打开文件名称file.softspace Python OS模块目录相关os.mkdir(path) 创建目录pathos.mkdirs(path) 创建目录path如果父目录不存在先创建父目录os.rmdir(path) 删除目录pathos.rmdirs(path) 删除多级目录os.getcwd() 返回当前目录os.chdir(path) 改变当前目录为pathos.fchdir(file) 通过文件描述符改变当前目录os.chroot() 设定当前进程的根目录os.listdir(path) 列出指定目录下的所有文件名 文件相关os.stat(path) 获取path的状态信息os.remove(file) 删除文件os.rename(file) 文件重命名os.symlink(src, dst) 创建链接os.utime(path) 更新时间os.walk() 权限相关os.access(path, mode) 检验权限是否存在os.chmod(path, mode) 修改权限为modeos.chown(path, pid, gid) 改变文件的属主和属组权限)os.umask() 设置默认权限模式 文件描述符os.open()os.close()os.read()os.write() os.path 文件路径相关os.path.basename() 文件名os.path.dirname() 目录名os.path.join() 整合路径os.path.split() 返回dirname() basename()元组os.path.splitext() 返回(filename, extension)元组 os.path.getatime()os.path.getctime()os.path.getmtime()os.path.getsize() 返回文件大小 os.path.exists() 判断指定文件是否存在os.path.isabs() 判断给定路径是否为绝对路径os.path.isdir() 判断是否为目录os.path.isfile() 判断是否为文件os.path.islink() 判断是否为链接os.path.ismount() 判断是否为挂载点os.path.samefile() 判断两个路径是否指向同一文件 对象流式化、持久化pickle Python 文件对象可迭代12345In [14]: f = open(&apos;/etc/passwd&apos; , &apos;r&apos;)In [15]: for line in f: ....: print line ....: Python正则表达式基础知识正则表达式，使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。常用正则表达式的表达式符号和特殊字符 literal 匹配字符串的值 例如: foo re1|re2 匹配正则表达式re1或re2 例如: foo|bar . 匹配任何单个字符(换行符除外) 例如: b.b ^ 匹配字符串的开始 例如: ^Dear $ 匹配字符串的结尾 * 匹配前面出现的正则表达式零次或多次 例如: [A-Za-z0-9]* + 匹配前面出现的正则表达式一次或多次 例如: [a-z]+.com ? 匹配前面出现的正则表达式零次或一次 例如: goo? {N} 匹配前面出现的正则表达式N次 例如: [0-9]{3} {M,N} 匹配前面出现的正则表达式M次到N次 例如: [0-9]{5,9} [...] 匹配字符组里出现的任意一个字符 例如: [aeiou] [..x-y..] 匹配从字符x到字符y的任意一个字符 例如: [0-9], [A-Za-z] [^...] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在次字符集中出现）例如: [^aeiou], [^A-Za-z0-9_] (*|+|?|{})? 用于上面出现的任何“非贪婪”版本重复匹配次数符号(*,+,?,{}) 例如: .*?[a-z] (...) 匹配封闭括号中正则表达式(RZ), 并保存为子组 例如: ([0-9]{3})?,f(oo|u)bar \\d 匹配任何数字，和[0-9]一样(\\D是\\d的反义：任何非数字符) 例如: data\\d+.txt \\w 匹配任何数字字母字符，和[A-Za-z0-9]相同(\\W是\\w的反义) 例如：[A-Za-z\\_]w+ \\s 匹配任何空白符，和[\\n\\t\\r\\v\\f]相同，(\\S是\\s的反义) 例如: of\\sthe \\b 匹配单词边界(\\B是\\b的反义) 例如: \\bThe\\b \\c 逐一匹配特殊字符c(即，取消它的特殊含义，按字面匹配) 例如: \\., \\\\, \\* \\A(\\Z)匹配字符串的起始(结束) 例如: \\ADear Python正则表达式模块re模块re.match() 尝试用正则表达式模式从字符串的开头匹配，如果匹配成功，则返回一个匹配对象，否则返回Nonere.search() 在字符串中查找正则表达式模式第一次出现，如果匹配成功，则返回一个匹配对象，否则返回Nonere.findall() 在字符串中查找正则表达式默认的所有(非重复)出现；返回一个匹配对象的列表re.split() 根据正则表达式中的分隔符将字符分割为一个列表，返回成功匹配的列表，可以设定次数（默认是分割所有匹配的地方）re.sub() 把字符串中所有匹配正则表达式的地方替换为字符串，如果没有次数限制，则对所有匹配的地方进行替换，并返回替换后整个串re.subn() 和re.sub()功能相同，不过其返回值为元组，包含其替换后的串和替换次数re.compile() 贪婪匹配和非贪婪匹配当正则表达式中包含能接受重复的限定符时，匹配尽可能多的字符，即贪婪匹配。贪婪匹配:a.*b，将会匹配最长的以a开始以b结束的字符串。如果以它来搜索aabab的化，会匹配整个字符串aabab。非贪婪匹配，在正则表达式后面加个?。 .*?意味着在能使匹配成功的前提下使用最少的重复。a.*b匹配最短的以a开始以b结束的字符，应用于aabab的话，会匹配aab和ab。 Python使用过程中碰到问题python josn dumps中文乱码问题123456789In [1]: strMsg = &#123;\"测试\":\"值\"&#125;In [2]: import jsonIn [3]: print json.dumps(strMsg)&#123;\"\\u6d4b\\u8bd5\": \"\\u503c\"&#125;In [4]: print json.dumps(strMsg, ensure_ascii=False)&#123;\"测试\": \"值\"&#125;","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.casezheng.date/tags/python/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"Linux CRONTAB","slug":"crontab","date":"2017-06-29T13:44:00.000Z","updated":"2020-04-12T04:56:35.950Z","comments":true,"path":"2017/06/29/crontab/","link":"","permalink":"http://www.casezheng.date/2017/06/29/crontab/","excerpt":"","text":"Crontab是什么Crontab是一个用于设置周期性被执行的任务的工具。被周期性执行的任务：Cron Job周期性执行的任务列表：Cron Table Crontab的使用service crond status 查看crontab的状态1234567891011121314151617[CaseZheng@home ~]$ service crond statusRedirecting to /bin/systemctl status crond.service crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled) Active: active (running) since 四 2017-06-29 21:26:55 CST; 36min ago Main PID: 921 (crond) Tasks: 1 (limit: 4915) CGroup: /system.slice/crond.service └─921 /usr/sbin/crond -n6月 29 21:26:55 home systemd[1]: Started Command Scheduler.6月 29 21:26:55 home crond[921]: (CRON) INFO (Syslog will be used instead of sendmail.)6月 29 21:26:55 home crond[921]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 81% if used.)6月 29 21:26:55 home crond[921]: (CRON) INFO (running with inotify support)6月 29 22:01:01 home CROND[3867]: (root) CMD (run-parts /etc/cron.hourly)6月 29 22:01:01 home run-parts[3870]: (/etc/cron.hourly) starting 0anacron6月 29 22:01:01 home anacron[3878]: Anacron started on 2017-06-29 service crond 可以产看crontab支持的命令12[CaseZheng@home ~]$ service crondThe service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl. service crond start 启动crontab service crond stop 停止crontab crontab -e 编辑当前用户的cron table文件 Crontab的基本组成配置文件 使用文件方式设定定时任务系统服务 CROND 每分钟从配置文件中刷新定时任务配置工具 crontab用于调整定时任务 Crontab的配置文件格式 12345678910111213141516171819每晚21：30重启apache 30 21 * * * service httpd restart每月1,10,22日的4：45重启apache 多个时间用逗号分隔 45 4 1,10,22 * * service httpdd restart每月1到10日的4：45重启apache 连续时间用-连接 45 4 1-10 * * service httpd restart每隔两分钟重启apache服务器 */2 * * * * service httpd restart 1-59/2 * * * * service httpd restart晚上11点到早上7点之间，每隔一小时重启apache 0 23-7/1 * * * service httpd restart每天18：00到23：00之间每隔30分钟重启apache 0,30 18-23 * * * service httpd restart 0-59/30 18-23 * * * service httpd restart Crontab的使用12345查看crontab的帮助crontab --helpcrontab -l 查看当前用户的Cron tablecrontab -e 编辑当前用户的Cron table Crontab的配置文件全局（系统）配置文件 /etc/crontab12345678910111213141516[root@home CaseZheng]# cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed*/1 * * * * root echo &quot;First System Crontabs&quot; “First System Crontabs”可以在/var/log/cron中查看 Crontab的日志crontab的日志保存在/var/log/cron Crontab的常见错误","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"SGI STL adapters（配接器) 13","slug":"stl-adapters-13","date":"2017-06-24T12:04:00.000Z","updated":"2020-04-12T04:56:35.937Z","comments":true,"path":"2017/06/24/stl-adapters-13/","link":"","permalink":"http://www.casezheng.date/2017/06/24/stl-adapters-13/","excerpt":"","text":"配接器概述 配接器在STL组件的灵活组合运用功能上，扮演轴承、转换器的角色。配接器实际上是一种设计模式。将一个class的接口转化为另一个class的接口，使原本因为接口不兼容而不能工作的class，可以正常工作。STL配接器改变容器接口称为container adapter、改变迭代器接口称为iterator adapter、改变仿函数接口称为function adapter。 container adaptersstack和queue都是配接器，底层使用deque，其方法的实现也是转调用deque。 iterator adaptersSTL提供许多应用于迭代器身上的配接器，包括insert iterators, reverse iterators,iostream iterators。 insert iterators可以将一般迭代器的赋值操作转化为插入操作。 尾部插入操作back_insert_iterator 头部插入操作front_insert_iterator 任意位置插入操作insert_insert 提供三个相应函数，提升便利性。back_inserter()、front_inserter()、inserter()。底层维护一个容器，当对insert iterators做赋值操作时，就在insert iterators中对该容器的迭代器做插入操作。 reverse iterator可以将一般迭代器的行进方向逆转，使原本应该前进的operator++变成后退操作，使原本应该后退的operator--变成前进操作。有双向迭代器的容器才可使用reverse iteator迭代器。 iostream iterators可以将迭代器绑定到某个iostream对象身上。 istream_iterator输入能力 ostream_iteraotr输出能力 functor adaptersfunctor adapters是所有配接器中数量最庞大的一个族群，极其灵活，可以配接、配接、再配接。functor adapters可以通过配接器间的绑定、组合、修饰能力，可以无限制创造出各种可能的表达式，搭配STL算法使用。所有期望获得配接能力的组件，本身必须是可配接的。即一元仿函数必须继承unary_function，二元仿函数必须继承binary_function，成员函数经过mem_func处理，一般函数经过ptr_fun处理。一个未经过处理的一般函数可以传递给STL算法使用，但其无法拥有任何配接能力。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL functors（仿函数） 12","slug":"stl-functors-12","date":"2017-06-24T10:11:00.000Z","updated":"2020-04-12T04:56:35.942Z","comments":true,"path":"2017/06/24/stl-functors-12/","link":"","permalink":"http://www.casezheng.date/2017/06/24/stl-functors-12/","excerpt":"","text":"仿函数（函数对象）大概介绍 函数对象，即”行为类似函数”的对象，重载function call运算子(operator ())。STL仿函数根据操作数个数划分，可分为一元和二元仿函数，按功能划分可分为算数运算、关系运算、逻辑运算三大类。使用内建仿函数需包含&lt;functional&gt;头文件。 仿函数可配接的关键 为了拥有配接能力，需要依照规定定义自己的5个相应型别。仿函数的相应型别主要用来表现函数参数型别和传回值型别。为了方便期间，&lt;stl_function.h&gt;定义了两个class，分别表示一元仿函数和二元仿函数(STL不支持三元仿函数)，其中只有型别定义，没有成员函数和成员变量。任何仿函数只需要根据需求继承其中一个class即可拥有相应型别，也就自动拥有了配接能力。 unary_functionunary_function用来呈现一元仿函数的参数型别和返回值型别。12345template &lt;class _Arg, class _Result&gt;struct unary_function &#123; typedef _Arg argument_type; typedef _Result result_type;&#125;; binary_functionbinary_function用来呈现二元函数的第一参数型别、第二参数型别、返回值型别。 123456template &lt;class _Arg1, class _Arg2, class _Result&gt;struct binary_function &#123; typedef _Arg1 first_argument_type; typedef _Arg2 second_argument_type; typedef _Result result_type;&#125;; binder1st配接器用于将某个二元仿函数转化为一元仿函数 12345678910111213141516template &lt;class _Operation&gt;class binder1st : public unary_function&lt;typename _Operation::second_argument_type, typename _Operation::result_type&gt; &#123;protected: _Operation op; typename _Operation::first_argument_type value;public: binder1st(const _Operation&amp; __x, const typename _Operation::first_argument_type&amp; __y) : op(__x), value(__y) &#123;&#125; typename _Operation::result_type operator()(const typename _Operation::second_argument_type&amp; __x) const &#123; return op(value, __x); &#125;&#125;; 算数仿函数 STL内建算数仿函数支持加、减、乘、除、求余、否定运算。除了否定运算其它均为二元运算。 加:plus&lt;T&gt; 减:minus&lt;T&gt; 乘:multiplies&lt;T&gt; 除:divides&lt;T&gt; 求余:modulus&lt;T&gt; 否定:negate&lt;T&gt; 关系运算类仿函数 STL内建关系运算符仿函数支持等于、不等于、大于、大于等于、小于、小于等于六类。每一个都是二元源算。 等于:equal_to&lt;T&gt; 不等于:not_equal_to&lt;T&gt; 大于:greater&lt;T&gt; 大于等于:greater_equal&lt;T&gt; 小于:less&lt;T&gt; 小于等于:less_equal&lt;T&gt; 逻辑运算符仿函数 STL内建的逻辑运算符仿函数支持And、Or、Not三种，And和Or为二元运算符，Not为一元运算符。 And:logical_and&lt;T&gt; Or:logical_or&lt;T&gt; Not:logical_not&lt;T&gt; 功能极其简单的仿函数都是为了搭配STL算法。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL-algorithms 介绍分析 11","slug":"stl-algorithms-11","date":"2017-06-24T08:08:00.000Z","updated":"2020-04-12T04:56:35.940Z","comments":true,"path":"2017/06/24/stl-algorithms-11/","link":"","permalink":"http://www.casezheng.date/2017/06/24/stl-algorithms-11/","excerpt":"","text":"算法分析和复杂度表示O()算法复杂度分析：时间和空间。Big-Oh表示法，如果有任何常数c和N0，使得当N&gt;=N0时，T(N)&lt;=cF(N)，那么可将T(N)的复杂度表示为O(F(N))。Big-Oh被普遍运用，但不适合标记数据量小的情况。 算法总览 质变算法 非质变算法质变算法会改变操作对象的值。非质变算法不改变操作对象的值。 STL算法的一般形式所有泛型算法前两个参数都是一对迭代器(iterator)，通常称为first和last，用以标识算法的操作区间。STL习惯采用前闭后开区间表示法[first, last)，表示first到last(不含last)之间的所有元素。[first, last)必须可以支持operator++，从first到last。迭代器分为五类，每个STL算法的申明都表现出其所需要的最低程度的迭代器类型。许多STL算法不只支持一个版本，其中某个版本采用缺省运算行为，另一个版本提供额外参数，允许外界传入仿函数(functor)，以便采用其它策略。所有数值算法实现于SGI&lt;stl_numeric.h&gt;，用户使用必须包含&lt;numeric&gt; ，其它STL算法实现于SGI的&lt;stl_algo.h&gt;和&lt;stl_algobase.h&gt;，用户使用需要包含&lt;algorithm&gt;。 STL算法泛化过程1234567891011121314151617181920212223242526272829303132333435363738394041//该算法暴露令容器过多实现细节，太过依附特定容器。int *find(int *arrayHead, int arraySize, int value)&#123; for(int i=0; i&lt;arraySize; ++i) &#123; if(arrayHead[i] == value) &#123; break; &#125; &#125; return &amp;(attayHead[i]);&#125;//该算法只能针对int*数组int *find(int *begin, int *end, int value)&#123; while(begin!=end &amp;&amp; *begin!=value) &#123; ++begin; &#125; return begin;&#125;//该算法将传值改为传引用，使用operator!= operator* operator++，但只能对指针类型使用，可改造使普通对象重载操作符也可使用该算法。template&lt;typename T&gt;T *find(T *begin, T *end, const T&amp; value)&#123; while(begin!=end &amp;&amp; *begin!=value) &#123; ++begin; &#125; return begin;&#125;//最终形式template&lt;typename Iterator, typename T&gt;Iterator find(Iterator begin, Iterator end, const T&amp; value)&#123; while(begin!=end &amp;&amp; *begin!=value) &#123; ++begin; &#125; return begin;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL hashset hashmap hashmultiset hashmultimap 10","slug":"stl-hashset-hashmap-10","date":"2017-06-24T03:07:00.000Z","updated":"2020-04-12T04:56:35.947Z","comments":true,"path":"2017/06/24/stl-hashset-hashmap-10/","link":"","permalink":"http://www.casezheng.date/2017/06/24/stl-hashset-hashmap-10/","excerpt":"","text":"hash_setSTL set多以RB-tree作为底层容器，SGI在STL标准规范外提供hash_set，以hashtable为底层机制。hash_set所提供的操作接口，hashtable都有提供，所以几乎所有hash_set的操作都是转调用hashtable的操作。set底层使用RB-tree可以自动排序，而hash_set没有。hash_set和set元素的键值就是实值，实值就是键值。 hash_mapSTL map多以RB-tree作为底层容器，SGI在STL标准规范外提供hash_map，以hashtable为底层机制。hash_map所提供的操作接口，hashtable都有提供，所以几乎所有hash_map的操作都是转调用hashtable的操作。map底层使用RB-tree可以自动排序，而hash_map没有。hahsh_map和map每个元素同时拥有实值和键值。 hash_multisethash_multiset与multiset特性相同，唯一差别是底层容器，hash_multiset底层是hashtable，因此hash_multiset底层未排序。hash_multiset与hash_set实现唯一差别是hash_multiset元素插入底层使用hashtable的insert_equal()，而hash_set使用令insert_unique()。 hash_multimaphash_multimap与multimap特性相同，唯一差别是底层容器，hash_multimap底层是hashtable，因此hash_multimap底层未排序。hash_multimap与hash_map实现唯一差别是hash_multimap元素插入底层使用hashtable的insert_equal()，而hash_map使用令insert_unique()。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 hashtable 9","slug":"stl-hashtable-9","date":"2017-06-20T11:04:00.000Z","updated":"2020-04-12T04:56:35.935Z","comments":true,"path":"2017/06/20/stl-hashtable-9/","link":"","permalink":"http://www.casezheng.date/2017/06/20/stl-hashtable-9/","excerpt":"","text":"hashtablehashtable使用一段连续空间存储元素，元素的下标使用散列函数计算得出，如果不同元素通过散列函数映射到相同位置，可通过线性探测、二次探测、开链等方法解决。负载系数：元素个数除以数组大小。线性探测：如果通过散列函数计算的插入位置已被使用，最简单的方法就是循序往下寻找到一可用空间为止（如果到了尾部，就从头再找起）。最坏情况是遍历整个数组。由于每次都顺序加一查找可用空间，导致主集团问题。二次探测：如果通过散列函数计算的插入位置已被使用，再查找可用位置时不再循序查找，而是按照2的幂次方尝试，即每次前进n^2。二次探测解决主集团问题，但可能导致次集团问题。线性探测和二次探测的负载系数永远在0-1之间。开链：在每个表格元素中维护一个list，当有元素时，将元素加入到list中，如果list足够短，其效率并不慢。可以和二次探测的效率相提并论。SGISTL采用开链法实现hashtable。开链法的负载系数可能会大于1。 hashtable 的buckets和nodes 1234567//hashtable 节点template &lt;class _Val&gt;struct _Hashtable_node&#123; _Hashtable_node* _M_next; _Val _M_val;&#125;; buckets以vector作为容器，以便有动态扩充能力，nodes自身实现单链表相连接。 hashtable的迭代器 123456789101112131415161718192021222324252627282930313233343536//hashtable迭代器template &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;struct _Hashtable_iterator &#123; typedef hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt; _Hashtable; typedef _Hashtable_iterator&lt;_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc&gt; iterator; typedef _Hashtable_const_iterator&lt;_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc&gt; const_iterator; typedef _Hashtable_node&lt;_Val&gt; _Node; typedef forward_iterator_tag iterator_category; typedef _Val value_type; typedef ptrdiff_t difference_type; typedef size_t size_type; typedef _Val&amp; reference; typedef _Val* pointer; _Node* _M_cur; //迭代器目前所指之节点 _Hashtable* _M_ht; //保持对容器的联结关系(因为可能需要从bucket调到bucket) _Hashtable_iterator(_Node* __n, _Hashtable* __tab) : _M_cur(__n), _M_ht(__tab) &#123;&#125; _Hashtable_iterator() &#123;&#125; reference operator*() const &#123; return _M_cur-&gt;_M_val; &#125; pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125; iterator&amp; operator++(); iterator operator++(int); bool operator==(const iterator&amp; __it) const &#123; return _M_cur == __it._M_cur; &#125; bool operator!=(const iterator&amp; __it) const &#123; return _M_cur != __it._M_cur; &#125;&#125;; hashtable的迭代器没有operator—，也就没有定义逆向迭代器。 hashtable数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//开链法并不要求数组数组大小必须为质数，但SGISTL仍以质数设计数组大小，并将28个质数计算好，//以备随时访问，并提供一个函数，用来查询28个质数中，最接近某数并大于某数的质数。static const unsigned long __stl_prime_list[__stl_num_primes] =&#123; 53ul, 97ul, 193ul, 389ul, 769ul, 1543ul, 3079ul, 6151ul, 12289ul, 24593ul, 49157ul, 98317ul, 196613ul, 393241ul, 786433ul, 1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul, 50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul, 1610612741ul, 3221225473ul, 4294967291ul&#125;;//找出28个质数中，最接近并大于n的那个质数inline unsigned long __stl_next_prime(unsigned long __n)&#123; const unsigned long* __first = __stl_prime_list; const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes; const unsigned long* pos = lower_bound(__first, __last, __n); return pos == __last ? *(__last - 1) : *pos;&#125;// _Val 节点的实值型别 _Key 节点的键值类型 _HashFcn hash function的函数型别// _ExtractKey 从节点中取出键值的方法 _EqualKey 判断键值相同的与否的方法// _Alloc 空间配置器，缺省使用std::alloctemplate &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;class hashtable &#123;public: typedef _Key key_type; typedef _Val value_type; typedef _HashFcn hasher; typedef _EqualKey key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; hasher hash_funct() const &#123; return _M_hash; &#125; key_equal key_eq() const &#123; return _M_equals; &#125; //......private: hasher _M_hash; key_equal _M_equals; _ExtractKey _M_get_key; vector&lt;_Node*,_Alloc&gt; _M_buckets; //buckets以vector作为容器 size_type _M_num_elements; //......&#125;; hashtable的构造与内存管理 以下具体见源码解析 插入操作和表格重整 123456789101112131415//插入元素，不允许重复pair&lt;iterator, bool&gt; insert_unique(const value_type&amp; __obj)&#123; //判断是否需要重建buckets，如果需要就扩充 resize(_M_num_elements + 1); return insert_unique_noresize(__obj);&#125;//插入元素，允许重复iterator insert_equal(const value_type&amp; __obj)&#123; //判断是否需要重建buckets，如果需要就扩充 resize(_M_num_elements + 1); return insert_equal_noresize(__obj);&#125; 元素hash 12345//计算元素在buckets中的位置 包装hash functionsize_type _M_bkt_num(const value_type&amp; __obj) const&#123; return _M_bkt_num_key(_M_get_key(__obj));&#125; hashtable拷贝与清空 clear() _M_copy_from() hash function &lt;stl_hash_fun.h&gt;定义数个现成的hash function全都是仿函数。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 set map multiset multimap 8","slug":"stl-set-map-multiset-multimap-8","date":"2017-06-19T05:22:00.000Z","updated":"2020-04-12T04:56:35.933Z","comments":true,"path":"2017/06/19/stl-set-map-multiset-multimap-8/","link":"","permalink":"http://www.casezheng.date/2017/06/19/stl-set-map-multiset-multimap-8/","excerpt":"","text":"github源码分析仓库 set set特性 所有元素会根据元素的键值自动排序。set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。set无法通过迭代器改变set元素的值，因为set元素值就是键值，关系到set元素的排列规则。set的迭代器set&lt;T&gt;::iterator被定义为底层RB-tree的const_iterator，杜绝写入操作。set当进行元素新增操作或删除操作时，除了被删除元素的迭代器，操作之前的所有迭代器，在操作完成后依然有效。set以RB-tree作为底层容器，set几乎所有的操作，都是转调用RB-tree的操作。set使用RB-tree的insert_unique()，因为set不允许相同键值存在。 map map特性 所有元素会根据元素的键值进行排序。map的所有元素都是pair，同时拥有实值和键值。pair的第一个元素被视为键值，第二个元素被视为实值。map不允许两个元素拥有相同的键值。123456789101112131415template &lt;class _T1, class _T2&gt;struct pair &#123; typedef _T1 first_type; typedef _T2 second_type; _T1 first; _T2 second; pair() : first(_T1()), second(_T2()) &#123;&#125; pair(const _T1&amp; __a, const _T2&amp; __b) : first(__a), second(__b) &#123;&#125;#ifdef __STL_MEMBER_TEMPLATES template &lt;class _U1, class _U2&gt; pair(const pair&lt;_U1, _U2&gt;&amp; __p) : first(__p.first), second(__p.second) &#123;&#125;#endif&#125;; 可以通过迭代器修改map元素的实值，但不能通过迭代器修改map元素的键值，因为map元素的键值关系到其排序，而其实值不影响。对map进行新增、删除操作，不会影响迭代器的有效性，被删除元素的迭代器除外。map以RB-tree作为底层容器。map的insert()转调用RB-tree的insert_unique()函数，保证元素的键值唯一。map的下标操作符，用法有两种，可作为左值运用(内容可被修改)，也可作右值使用(内容不可被修改)。左值和右值都适用的关键在于返回值采用传引用的传递方式。 multiset multiset和set的特性与用法完全相同，唯一的差别在于它允许键值重复，因为它的插入采用的是底层容器RB-tree的insert_equal()。 multimap multimap和map的特性与用法完全相同，唯一的差别在于它允许键值重复，因为它的插入采用的是底层容器RB-tree的insert_equal()。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 tree简介 RB-tree解析 7","slug":"stl-tree-rb-tree-7","date":"2017-06-16T01:44:00.000Z","updated":"2020-04-12T04:56:35.932Z","comments":true,"path":"2017/06/16/stl-tree-rb-tree-7/","link":"","permalink":"http://www.casezheng.date/2017/06/16/stl-tree-rb-tree-7/","excerpt":"","text":"github源码分析仓库 关联式容器 标准的STL关联式容器分为set(集合)和map(映射表)两大类，还有multiset(多键集合)和multimap(多键映射表)。set、map、multiset、multimap的底层都使用RB-tree完成，RB-tree是一个独立容器，但并不开放给外界使用。SGI STL提供不在标准内的关联容器hash table(散列表)，以hash table为底层容器完成的hash_set(散列集合)、hash_map(散列映射表)、hash_multiset(散列多键集合)、hash_multimap(散列多键映射表)。关联式容器：每个元素都有一个键值(key)和一个实值(value)。当元素被插入关联式容器中时，容器内部结构按照键值大小，以某种特定规则将该元素放置于适当位置。关联式容器的内部结构一般是balanced binary tree(平衡二叉树)，获得良好的搜寻效率。balanced binary tree有多种类型，AVL-tree、RB-tree、AA-tree，STL运用的是RB-tree(红黑树)。 树 树由节点(nodes)和边(edges)构成，整棵树最顶端节点称为根节点。每个节点有具有方向性的边(directed edges)，用来和其它节点相连。相连节点之中，在上方者为父节点(parent)，下方者子节点(child)，无子节点者称为叶节点(leaf)。子节点可以存在多个，如果最多只允许两个子节点，即所谓二叉树(binary tree)。不同的节点如果拥有相同的父节点，则彼此互为兄弟节点(siblings)。根节点至任何节点之间有唯一路径(path)，路径所经过的边数，称为路径长度。根节点至任一节点的路径长度即该节点的深度(depth)。根节点的深度永远为0，。某节点至其最深子节点(叶节点)的路径长度，称为该节点的高度(height)。这棵树的高度以根节点的高度来表示。如果节点A-&gt;B之间存在唯一路径，A称为B的祖代(ancestor)，B称为A的子代(descendant)。任何节点的大小(size)是指其所有子代(包括自己)的节点总数。 二叉搜索树 二叉树是指任何节点最多只允许两个子节点的树。两个子节点称为左子节点和右子节点。二叉搜索树提供对数时间的元素插入和访问，二叉搜索树的节点放置规则：任何检点的键值一定大于其左子树的每个节点的键值，并小于其右子树的每一个节点的键值。因此，从根节点一直向左走，直至左路可走，即得最小元素；从根节点一直向右走，直至无右路可走，即得最大元素。二叉搜索树插入新元素，从根节点开始，遇到键值较大者就向左，遇到键值较小值就向右，一直到尾端，即为插入点。二叉搜索树移除旧节点A 如果A只有一个子节点或A为叶节点，直接将A的子节点连至A的父节点，并将A删除。 如果A有两个子节点，以右子树内的最小节点取代A。 平衡二叉搜索树 如果输入值不够随机，在经过某些插入和删除操作后，二叉搜索树可能失去平衡，造成搜索效率低落的情况。树的平衡没有绝对标准，大致意义：没有任何一个检点过深。 AVL tree(Adelson-Velskii-Landis tree) AVL树是“加上额外平衡条件”的二叉搜索树。平衡条件的建立是为了确保整棵树的深度为O(logN)。AVL-tree要求任何节点的左右子树高度相差最多1。AVL树插入节点可能会破坏AVL-tree的平衡条件，由于只有“插入点至根节点”路径上的各节点可能改变平衡条件，因此，只要调整其中最深的那个节点，便可使整棵树重新获得平衡。假设该最深节点为X，由于节点最多拥有两个子节点，“平衡被破坏”意味着X的左右两棵子树的高度相差2，因此有四种情况： 插入点位于X的左子节点的左子树——左左。 插入点位于X的左子节点的右子树——左右。 插入点位于X的右子节点的左子树——右左。 插入点位于X的右子节点的右子树——右右。 情况1、4彼此对称，称为外侧插入，采用单旋转操作调整解决。情况2、3彼此对称，称为内侧插入，采用双旋转操作调整解决。 单旋转(Single Rotation) 双旋转(Double Rotation) RB-tree红黑树 RB-tree不仅是二叉搜索树，而且必须满足以下规则： 每个节点不是红色就是黑色。 根节点为黑色。 如果节点为红色，其子节点必须为黑色。 任一节点到NULL(树尾端)的任何路径，所含黑节点数目必须相同。 根据规则4，新增节点必须为红色。根据规则3，新增节点父节点必须为黑色。如果根据二叉搜索树观测到达插入点，不满足上述条件，必须调整颜色并旋转树型。为了方便，将NULL视为黑节点。 插入节点 为特殊节点定义代名。新节点X，父节点P，祖父节点G，伯父节点S，增祖父节点GG。根据二叉搜索树规则，新节点X必为叶节点。根绝红黑树规则4，X必为红色。若P也是红色(违反规则3，必须调整树型)，则G必为黑色(因为原为RB-tree，必须遵循规则3)。根据X插入位置和外围节点(S和GG)的颜色，有四种情况： S为黑且X为外侧插入。先对P，G做一次单旋转，再更改P,G颜色，即可满足红黑树的规则3。 S为黑且X为内侧插入。先对P，X做一次单旋转并更改G、X颜色，在将结果对G做一次单旋转，集合再次满足红黑树规则3。 S为红色且X为外侧插入。先对P，G做一次单旋转，并改变X的颜色，如果GG为黑色，完成旋转修改。如果GG为红色，见状况4。 S为红色且X为外侧插入。先对P和G做一次单旋转，并改变X的颜色，如果GG为红色，持续向上做该操作，直到不再有父子连续为红色的情况。 从上向下，避免状况4 为了避免状况4“父子节点皆为红色”的情况持续向RB-tree的上层结构发展，形成处理时效上的瓶颈，可以用从上而下的方式避免：假设新增节点A，沿着A的路径，只要看到某节点X的两个子节点皆为黑色，就把X改为红色，并把两个子节点改为黑色。 RB-tree的节点设计 123456789101112131415161718192021222324252627282930313233343536typedef bool _Rb_tree_Color_type;const _Rb_tree_Color_type _S_rb_tree_red = false;const _Rb_tree_Color_type _S_rb_tree_black = true;struct _Rb_tree_node_base&#123; typedef _Rb_tree_Color_type _Color_type; typedef _Rb_tree_node_base* _Base_ptr; _Color_type _M_color; //节点颜色，非红即黑 _Base_ptr _M_parent; //父节点 _Base_ptr _M_left; //左子节点 _Base_ptr _M_right; //右子节点 //一直向左走得到最小值 static _Base_ptr _S_minimum(_Base_ptr __x) &#123; while (__x-&gt;_M_left != 0) __x = __x-&gt;_M_left; return __x; &#125; //一直向右走得到最大值 static _Base_ptr _S_maximum(_Base_ptr __x) &#123; while (__x-&gt;_M_right != 0) __x = __x-&gt;_M_right; return __x; &#125;&#125;;//RB-tree节点template &lt;class _Value&gt;struct _Rb_tree_node : public _Rb_tree_node_base&#123; typedef _Rb_tree_node&lt;_Value&gt;* _Link_type; _Value _M_value_field; //节点值&#125; RB-tree的迭代器 RB-tree的迭代器属于双向迭代器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//基层迭代器struct _Rb_tree_base_iterator&#123; typedef _Rb_tree_node_base::_Base_ptr _Base_ptr; typedef bidirectional_iterator_tag iterator_category; //双向迭代器 typedef ptrdiff_t difference_type; _Base_ptr _M_node; //用于实现operator++ void _M_increment() &#123; if (_M_node-&gt;_M_right != 0) &#123; //如果有右节点，状况1 _M_node = _M_node-&gt;_M_right; //向右走 while (_M_node-&gt;_M_left != 0) //然后一直往左子数走到底 _M_node = _M_node-&gt;_M_left; &#125; else &#123; //没有右子节点，状况2 _Base_ptr __y = _M_node-&gt;_M_parent; //找出父节点 while (_M_node == __y-&gt;_M_right) &#123; //如果现行节点本身是个右节点 _M_node = __y; //一直上溯，直到\"不为右节点\"为止 __y = __y-&gt;_M_parent; &#125; if (_M_node-&gt;_M_right != __y) //如果右子节点不等于此时的父节点 _M_node = __y; //则返回此时的父节点，状况3，否则返回此时的_M_node节点，状况4 &#125; &#125; //用来实现operator-- void _M_decrement() &#123; if (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp; _M_node-&gt;_M_parent-&gt;_M_parent == _M_node) //如果是红节点，且父节点的父节点等于自己， _M_node = _M_node-&gt;_M_right; //状况1，右子节点即为返回值 else if (_M_node-&gt;_M_left != 0) &#123; //如果有左子节点，状况2 _Base_ptr __y = _M_node-&gt;_M_left; //另y指向左子节点 while (__y-&gt;_M_right != 0) //当y有右子节点时 __y = __y-&gt;_M_right; //一直往右子节点走到底 _M_node = __y; //即得最后答案 &#125; else &#123; //即非根节点，也不是左子节点 _Base_ptr __y = _M_node-&gt;_M_parent; //状况3，找到父节点 while (_M_node == __y-&gt;_M_left) &#123; //当现行节点身为左子节点， _M_node = __y; //一直往上交替走，直到现行节点 __y = __y-&gt;_M_parent; //不为左子节点 &#125; _M_node = __y; //此时父节点即为答案 &#125; &#125;&#125;;// RB-tree 迭代器template &lt;class _Value, class _Ref, class _Ptr&gt;struct _Rb_tree_iterator : public _Rb_tree_base_iterator&#123; typedef _Value value_type; typedef _Ref reference; typedef _Ptr pointer; typedef _Rb_tree_iterator&lt;_Value, _Value&amp;, _Value*&gt; iterator; typedef _Rb_tree_iterator&lt;_Value, const _Value&amp;, const _Value*&gt; const_iterator; typedef _Rb_tree_iterator&lt;_Value, _Ref, _Ptr&gt; _Self; typedef _Rb_tree_node&lt;_Value&gt;* _Link_type; _Rb_tree_iterator() &#123;&#125; _Rb_tree_iterator(_Link_type __x) &#123; _M_node = __x; &#125; _Rb_tree_iterator(const iterator&amp; __it) &#123; _M_node = __it._M_node; &#125; reference operator*() const &#123; return _Link_type(_M_node)-&gt;_M_value_field; &#125;#ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125;#endif /* __SGI_STL_NO_ARROW_OPERATOR */ _Self&amp; operator++() &#123; _M_increment(); return *this; &#125; _Self operator++(int) &#123; _Self __tmp = *this; _M_increment(); return __tmp; &#125; _Self&amp; operator--() &#123; _M_decrement(); return *this; &#125; _Self operator--(int) &#123; _Self __tmp = *this; _M_decrement(); return __tmp; &#125;&#125;; RB-tree的数据结构 RB-tree的构造与内存管理 RB-tree的元素操作 为了简化根节点边界条件的处理，SGISTL特别为根节点再设计了一个父节点，名为header。RB-tree有两种插入操作：insert_unique()和insert_equal()，insert_unique()表示被插入节点的键值在整棵树中必须独一无二(因此，如果树中已存在相同的键值，插入操作就不会被真正的进行)，insert_equal()表示被插入节点的键值在整棵树中可以重复。 依次将10,7,8,15,5,6,11,13,12插入RB-tree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//参数__x为新值插入点，参数__y为插入点之父节点，参数v为新值template &lt;class _Key, class _Value, class _KeyOfValue, class _Compare, class _Alloc&gt;typename _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt; ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Value&amp; __v)&#123; _Link_type __x = (_Link_type) __x_; _Link_type __y = (_Link_type) __y_; _Link_type __z; if (__y == _M_header || __x != 0 || _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) &#123; __z = _M_create_node(__v); //产生新节点 _S_left(__y) = __z; //当y即为header时，leftmost() == z if (__y == _M_header) &#123; _M_root() = __z; _M_rightmost() = __z; &#125; else if (__y == _M_leftmost()) //如果y为最左节点 _M_leftmost() = __z; //维护_M_leftmost()，使其永远指向最左节点 &#125; else &#123; __z = _M_create_node(__v); //产生新节点 _S_right(__y) = __z; //令新节点成为插入点之父节点y的右子节点 if (__y == _M_rightmost()) _M_rightmost() = __z; //维护_M_rightmost()，使其永远指向最右节点 &#125; _S_parent(__z) = __y; //设定新节点的父节点 _S_left(__z) = 0; //设定新节点的左子节点 _S_right(__z) = 0; //设定新节点的右子节点 //新节点颜色在_Rb_tree_rebalance()设定并调整 参数1为新增节点 参数2为root _Rb_tree_rebalance(__z, _M_header-&gt;_M_parent); ++_M_node_count; //节点值累加 return iterator(__z);&#125;//全局函数，令树形平衡(改变颜色及旋转树形)//__x为新增节点 __root为rootinline void_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)&#123; __x-&gt;_M_color = _S_rb_tree_red; //新节点必为红 while (__x != __root &amp;&amp; __x-&gt;_M_parent-&gt;_M_color == _S_rb_tree_red) &#123; //父节点必为红 if (__x-&gt;_M_parent == __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left) &#123; //父节点为祖父节点之左子节点 _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_right; //令y为伯父节点 if (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123; //伯父节点存在，且为红 __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; //更改父节点为黑 __y-&gt;_M_color = _S_rb_tree_black; //更改伯父节点为黑 __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; //更改祖父节点为红 __x = __x-&gt;_M_parent-&gt;_M_parent; &#125; else &#123; //无伯父节点，或伯父节点为黑 if (__x == __x-&gt;_M_parent-&gt;_M_right) &#123; //如果新节点为父节点之右节点 __x = __x-&gt;_M_parent; _Rb_tree_rotate_left(__x, __root); //第一个参数为左旋点 &#125; __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; //改变颜色 __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; _Rb_tree_rotate_right(__x-&gt;_M_parent-&gt;_M_parent, __root); //第一个参数为右旋点 &#125; &#125; else &#123; //父节点为祖父节点之右子节点 _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left; //令y为伯父节点 if (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123; //右伯父节点，且为红 __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; //更改父节点为黑 __y-&gt;_M_color = _S_rb_tree_black; //更改伯父节点为黑 __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; //更改祖父节点为红 __x = __x-&gt;_M_parent-&gt;_M_parent; //继续往上层查 &#125; else &#123; //无伯父节点，或伯父节点为黑 if (__x == __x-&gt;_M_parent-&gt;_M_left) &#123; //如果新节点为父节点之左子节点 __x = __x-&gt;_M_parent; _Rb_tree_rotate_right(__x, __root); //第一个参数为右旋点 &#125; __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; //改变颜色 __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; _Rb_tree_rotate_left(__x-&gt;_M_parent-&gt;_M_parent, __root); //第一个参数为左旋点 &#125; &#125; &#125; //while 结束 __root-&gt;_M_color = _S_rb_tree_black; //根节点永远为黑&#125;//全局函数，新节点必为红节点，如果插入处的父节点也是红节点，违反红黑树规则，必须旋转树形inline void_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)&#123; //__x为旋转点 _Rb_tree_node_base* __y = __x-&gt;_M_right; //令__y为旋转点的右子节点 __x-&gt;_M_right = __y-&gt;_M_left; if (__y-&gt;_M_left !=0) __y-&gt;_M_left-&gt;_M_parent = __x; //设定父节点 __y-&gt;_M_parent = __x-&gt;_M_parent; //令__y完全顶替__x的地位 if (__x == __root) //__x为根节点 __root = __y; else if (__x == __x-&gt;_M_parent-&gt;_M_left) //__x为父节点的左子节点 __x-&gt;_M_parent-&gt;_M_left = __y; else //__x为父节点的右子节点 __x-&gt;_M_parent-&gt;_M_right = __y; __y-&gt;_M_left = __x; __x-&gt;_M_parent = __y;&#125;//全局函数，新节点必为红节点，如果插入处的父节点也是红节点，违反红黑树规则，必须旋转树形inline void_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)&#123; //__x为旋转点 _Rb_tree_node_base* __y = __x-&gt;_M_left; //令__y为旋转点的左子节点 __x-&gt;_M_left = __y-&gt;_M_right; if (__y-&gt;_M_right != 0) __y-&gt;_M_right-&gt;_M_parent = __x; //设定父节点 __y-&gt;_M_parent = __x-&gt;_M_parent; //令__y完全顶替__x的地位 if (__x == __root) //__x为根节点 __root = __y; else if (__x == __x-&gt;_M_parent-&gt;_M_right) //__x为父节点的右子节点 __x-&gt;_M_parent-&gt;_M_right = __y; else //__x为父节点的左子节点 __x-&gt;_M_parent-&gt;_M_left = __y; __y-&gt;_M_right = __x; __x-&gt;_M_parent = __y;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 slist 6","slug":"stl-slist-6","date":"2017-06-15T01:45:00.000Z","updated":"2020-04-12T04:56:35.930Z","comments":true,"path":"2017/06/15/stl-slist-6/","link":"","permalink":"http://www.casezheng.date/2017/06/15/stl-slist-6/","excerpt":"","text":"github源码分析仓库 slist 单链表 SGI STL提供单向链表(single linked list)，slist不在标准规格之内。slist和list的主要差别：slist迭代器是单向的Forward Iterator，list迭代器是双向的Bidirectional Iterator。slist消耗空间更小，某些操作更快。slist和list插入、移除、接合等操作不会造成原有迭代器失效。根据STL的习惯，插入操作会将新元素插入到指定位置之前，而slist由于没有方便的方法回头定位前一个位置，所以在插入新元素时，必须从头找起，效率低下。因此slist不提供push_back()，只提供push_front()。 slist节点 slist的节点和迭代器的设计架构 123456789101112//单向链表的节点基本结构struct _Slist_node_base&#123; _Slist_node_base* _M_next;&#125;;//单链表的节点结构template &lt;class _Tp&gt;struct _Slist_node : public _Slist_node_base&#123; _Tp _M_data;&#125;; slist迭代器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//slist迭代器基本结构struct _Slist_iterator_base&#123; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef forward_iterator_tag iterator_category; //单向 _Slist_node_base* _M_node; //指向节点基本结构 _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125; void _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125; //前进一个节点 bool operator==(const _Slist_iterator_base&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _Slist_iterator_base&amp; __x) const &#123; return _M_node != __x._M_node; &#125;&#125;;//slist迭代器结构template &lt;class _Tp, class _Ref, class _Ptr&gt;struct _Slist_iterator : public _Slist_iterator_base&#123; typedef _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt; iterator; typedef _Slist_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator; typedef _Slist_iterator&lt;_Tp, _Ref, _Ptr&gt; _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _Slist_node&lt;_Tp&gt; _Node; //在调用slist&lt;T&gt;::end()时会造成_Slist_iterator(0)会调用_Slist_iterator(_Node *__x) _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125; _Slist_iterator() : _Slist_iterator_base(0) &#123;&#125; _Slist_iterator(const iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125; reference operator*() const &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125; pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125; _Self&amp; operator++() &#123; _M_incr(); return *this; &#125; _Self operator++(int) &#123; _Self __tmp = *this; _M_incr(); return __tmp; &#125;&#125;; 两个list迭代器相等判断会调用__Slist_iterator_base::operator==，根据定义，两个slist迭代器是否相等，根据其__Slist_node_base *node是否相等而定。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 heap priority-queue 5","slug":"stl-heap-priority-queue-5","date":"2017-06-14T07:05:00.000Z","updated":"2020-04-12T04:56:35.929Z","comments":true,"path":"2017/06/14/stl-heap-priority-queue-5/","link":"","permalink":"http://www.casezheng.date/2017/06/14/stl-heap-priority-queue-5/","excerpt":"","text":"github源码分析仓库 heap 堆 heap允许用户以任意次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取。heap并不是STL容器组件，而是priority-queue的底层所使用的算法。而priority-queue底层缺省使用vector并搭配max-heap算法。根据元素排列方式heap分为max-heap和min-heap两种，max-heap每个节点的键值都大于或等于其子节点键值，min-heap每个节点的键值都小于或等于其子节点键值，因此max-heap最大值在根节点，min-heap最小值在根节点。STL提供max-heap。可以使用数组表示一颗完全二叉树，然后将数组第0位保留，当对完全二叉树位于数组的i处时，其左节点位于数组的2*i处，其右子节点必位于数组的2*i+1处，其父节点位于i/2处。 1. push_heap新加入的元素先放在最下层作为叶节点，因为是完全二叉树，所以一定放在最下层的最右边，即底层容器的end()处。然后为了满足max-heap的条件，将这个新节点，和父节点做比较，如果其键值大于父节点，父子节点对换位置，一直向上，直到不需要对换或到根节点为止。 2. pop_heap取走最大值(根节点)的操作，先将根节点和最底层最右边的叶节点对调，然后从上到下，用根节点和其左右两个子节点比较，当根节点小于其中任意一个的时候，取最大的那个和根节点对调，根节点作为其子节点，然后该子节点，作为子树的根节点再次判断，重复该过程，直到叶子或其比左右叶子节点都大的时候停止。然后底层容器的end()即为max-heap的最大值。 3. sort_heap堆排序，每次都取堆顶，放在底层容器的最后端，对整个堆做pop_heap操作，当堆为空时，便可得到递增排序好的序列。 4. make_heap排列一段现有数据为max-heap, 先找到第一个需要重排的子树头部，排列其成为一个最大堆，指针前移，再排列该树为最大堆，直到走完整个需要重新排列的元素为止。 priority-queue 优先级队列 priority-queue是一个拥有权值概念的queue，允许加入新元素、移除旧元素、查看元素值等功能，由于是queue，所以只允许从底端加入，从顶端取出。priority-queue其内部元素按照权值自动排序，权值高者在在前面。缺省情况下priority-queue利用max-heap完成。priority-queue没有迭代器。priority-queue的实现依靠底层容器的方法和heap的泛型算法。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 deque stack queue 4","slug":"stl-deque-stack-queue-4","date":"2017-06-13T11:04:00.000Z","updated":"2020-04-12T04:56:35.924Z","comments":true,"path":"2017/06/13/stl-deque-stack-queue-4/","link":"","permalink":"http://www.casezheng.date/2017/06/13/stl-deque-stack-queue-4/","excerpt":"","text":"github源码分析仓库 deque 双端队列vector是单向开口的连续线程空间，deque是双向开口的连续线性空间。deque支持常数事件内对起头端进行元素的插入和移除操作。deque没有容量的概念，因为它由动态分段连续空间组合而成，随时可以增加一段新空间并链接起来。deque提供RandomAccessIterator。deque是由一段一段的定量连续空间组成。一旦有必要在deque的前端或者尾端增加新空间，则需要配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在分段的定量连续空间上，维护其整体连续的假象，提供随机存取的接口，避开”重新配置、复制、释放”，代价则是复杂的迭代器构架。deque采用一块”map”(不是STL的map容器)作为主控，管理缓冲区(多块定量连续空间)。”map”是一小块连续空间，每个node都是指针，指向另一段连续线性空间，即缓冲区，缓冲区是deque的存储空间主体。SGI STL允许指定缓冲区大小，默认0表示使用512B缓冲区。 deque的结构设计中，map和node-buffer的关系 deque中控器、缓冲区、迭代器的相互关系 deque::begin()传回迭代器start, deque::end()传回迭代器finish deque的插入、删除操作会导致迭代器失效，需要注意。 stack 栈stack是种先进后出(FILO)的数据结构，只要一个出口，stack允许新增元素，移除元素，取得最顶端元素。stack不允许遍历行为，因此stack没有迭代器。SGI STL缺省使用deque作为stack的底部结构，因此stack是一种配接器(修改某物接口，形成另一种风貌)。stack也可以用list作为底层容器。 queue 队列queue是种先进先出(FIFO)的数据结构，只有一个入口，也只有一个入口，queue循序新增元素，移除元素，从最底端加入元素、取得最顶端元素。queue不允许遍历操作，因此queue没有迭代器。SGI STL缺省使用deque作为queue的底部结构，因此queue是一种配接器(修改某物接口，形成另一种风貌)。queue也可以用list作为底层容器。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 vector和list 3","slug":"stl-vector-list-3","date":"2017-06-10T05:34:00.000Z","updated":"2020-04-12T04:56:35.922Z","comments":true,"path":"2017/06/10/stl-vector-list-3/","link":"","permalink":"http://www.casezheng.date/2017/06/10/stl-vector-list-3/","excerpt":"","text":"github源码分析仓库 容器的介绍研究数据的特定排列方式，以便于搜寻或排序或其它特殊目的，这一专门学科称为数据结构。任何特定的数据结构都是为了实现某种特定的算法。STL容器将运用最广泛的的一些数据结构实现出来。常见数据结构：array(数组)、list(链表)、tree(树)、queue(队列)、hash table(散列表)、set(集合)、map(映射表)等。这些数据结构分为序列式和关联式两种。 序列式容器 array(build-in) C++内建 vector heap 以算法形式呈现(xxx_heap) 内部用vector实现 priority-queue 内部用heap实现 list slist 非标准 deque stack 配接器 内部用deque实现 queue 配接器 内部用deque实现 关联式容器 RB-tree 非公开 set 内部用RB-tree实现 map 内部用RB-tree实现 multiset 内部用RB-tree实现 multimap 内部用RB-tree实现 hashtable 非标准 hash_set 非标准 内部用hashtable实现 hash_map 非标准 内部用hashtable实现 hash_multiset 非标准 内部用hashtable实现 hash_multimap 非标准 内部用hashtable实现 vectorvector是STL提供的一种序列式容器。vector是动态空间，在加入元素时，如果空间不足，内部机制会自行扩充空间容纳新元素。vector在使用前需要包含&lt;vector&gt;，其内部实现位于&lt;stl_vector.h&gt;。vector使用一块连续线性空间存储元素，支持随机存储，提供Random Access Iterator。vector缺省使用alloc作为空间配置器。vector的容量永远大于等于其大小，如果容量等于大小，则满载，再新加元素，整个vector需要寻找一块更大的空间。vector支持动态增加大小，但并不是在原有空间之后接续新空间，而是以原大小的两倍另外配置一块较大空间，然后将原空间内容拷贝过来，在原内容之后构建新元素，并释放原空间。因此，对vector的任何操作，如果引起空间重配置，指向vector的所有迭代器将失效。 1234567891011121314151617181920int main()&#123; vector&lt;int&gt; vec(4, 5); // 5, 5, 5, 5 vec.push_back(6); // 5, 5, 5, 5, 6 vec.push_back(6); // 5, 5, 5, 5, 6, 6 for(vecotor&lt;int&gt;::iterator it = vec.begin(); it!=vec.end();) &#123; if(*it == 6) &#123; vec.erase(it); //++it; //错误 vector中删除一个元素，后面元素会整体前移一次，迭代器在删除当前元素后，实际已指向下一个元素了，如果再前移，则会少遍历一个元素。 &#125; else &#123; ++it; &#125; &#125;yiyiyyigels return 0;&#125; resize和reserveresize改变vector大小,引起vector容量的变化,会调用默认拷贝构造函数,会导致vector的size会增加.reserve改变vector容量,不改变size,只是配置空间,不调用拷贝构造函数.123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class A&#123;public: A() : m_i(0) &#123; cout &lt;&lt; \"construct A\" &lt;&lt; endl; &#125; A(const A&amp; a) &#123; cout &lt;&lt; \"copy construct A\" &lt;&lt; endl; m_i = a.m_i; &#125;private: int m_i;&#125;;int main()&#123; vector&lt;A&gt; va; cout &lt;&lt; string(\"va size:\") &lt;&lt; va.size() &lt;&lt; \" va capacity:\" &lt;&lt; va.capacity() &lt;&lt; endl; va.resize(10); cout &lt;&lt; string(\"va size:\") &lt;&lt; va.size() &lt;&lt; \" va capacity:\" &lt;&lt; va.capacity() &lt;&lt; endl; vector&lt;A&gt; vb; cout &lt;&lt; string(\"vb size:\") &lt;&lt; vb.size() &lt;&lt; \" vb capacity:\" &lt;&lt; vb.capacity() &lt;&lt; endl; vb.reserve(10); cout &lt;&lt; string(\"vb size:\") &lt;&lt; vb.size() &lt;&lt; \" vb capacity:\" &lt;&lt; vb.capacity() &lt;&lt; endl; return 0;&#125; 运行结果如下:123456789101112131415va size:0 va capacity:0construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Acopy construct Ava size:10 va capacity:10vb size:0 vb capacity:0vb size:0 vb capacity:10 listlist是STl提供的一种序列式容器，每次插入或删除一个元素，就会配置或释放一个元素空间。list对任何位置元素的插入和删除都是常数时间。list是一种双向链表，迭代器具备前移和后移能力，提供Bidirectional Iterator(双向迭代器)。list插入一个元素不会导致迭代器失效，而vector则可能引起空间重新配置，导致迭代器全部失效。list元素删除只是指向被删除元素的迭代器失效，其它迭代器不受影响。SGI STL是环状双向链表，只需要一个指针就可以完整表现整个链表。让该指针指向刻意安排在尾端的一个空白节点，便能符合STL“前闭后开”区间的要求。list缺省使用alloc作为空间配置器。由于list不是RandomAccessIterator，无法使用STL算法sort()，所以list自己实现了sort方法。使用了归并排序，时间复杂度为n*log(n)。1234567891011121314151617181920212223242526272829//排序 归并排序template &lt;class _Tp, class _Alloc&gt;void list&lt;_Tp, _Alloc&gt;::sort()&#123; // Do nothing if the list has length 0 or 1. // 如果是空链表或者只有一个元素，不需要排序。 if (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123; //新的lists，作为中介数据存储区 list&lt;_Tp, _Alloc&gt; __carry; list&lt;_Tp, _Alloc&gt; __counter[64]; int __fill = 0; while (!empty()) &#123; //直到当前list为空 __carry.splice(__carry.begin(), *this, begin()); //先将begin()节点移动到__carry中，放在__carry.begin()之前 int __i = 0; while(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123; //如果___i小于__fill 而且 __counter[__i]不为空 合并下 __counter[__i].merge(__carry); //合并__carry到__counter[__i] __carry变为空 __carry.swap(__counter[__i++]); //交换__counter[__i] 和 __carry __carry不为空 __counter[__i]为空 i自加1 &#125; __carry.swap(__counter[__i]); //交换__counter[__i] 和 __carry __carry置为空，而__counter[__i]不为空 if (__i == __fill) ++__fill; //如果__i已经和__fill相等 就将__fill自加1 &#125; //数据已经全部排序，并放在了__counter数组中，遍历数组，合并它们 for (int __i = 1; __i &lt; __fill; ++__i) __counter[__i].merge(__counter[__i-1]); //和排好序的新链表__counter[__fill-1]交换下 swap(__counter[__fill-1]); &#125;&#125; 如果需要排序21, 45, 1, 30, 52, 3, 58, 47, 22, 59, 0, 58。具体过程如下：取第1个数21，放入__carry中，没有需要合并的counter，交换``carry和counter[0]，fill``自加1等于1 __counter[0]:21 __counter[1]:NULL 取第2个数45，放入__carry中，和__counter[0]合并，合并后交换__counter[0]和__carry，__i自加1等于1，没有可合并的啦，交换__counter[1]和__carry __counter[0]:NULL __counter[1]:21, 45 取第3个数1，放入__carry中，没有需要合并的counter，交换``carry和__counter[0]`` __counter[0]:1 __counter[1]:21, 45 取第4个数30，放入__carry中，和__counter[0]合并，合并后交换__counter[0]和__carry，__i自加1等于1，发现还可以和__counter[1]合并，合并，__i自加1等于2了，交换__counter[2]和__carry，__fill自加1等于2 __counter[0]:NULL __counter[1]:NULL __counter[2]:1, 21, 30, 45 通过上面其实可以发现，__counter存放的节点数目按指数增长__counter[0]存放2个节点，__counter[1]存放4个节点，__counter[2]存放8个节点，… ，__counter[64]存放2^(64)个节点。当节点数目超过其存储的最大数时，便会和更高层的合并。再看下面的的排序情况： 取第5个数52，放入__counter[0] __counter[0]:52 __counter[1]:NULL __counter[2]:1, 21, 30, 45 取第6个数3，放入__counter[0], __counter[0]满了，转移到__counter[1] __counter[0]:NULL __counter[1]:3, 52 __counter[2]:1, 21, 30, 45 取第7个数58，放入__counter[0] __counter[0]:58 __counter[1]:3, 52 __counter[2]:1, 21, 30, 45 取第8个数47，放入__counter[0], __counter[0]满了，和__counter[1]合并，发现__counter[1]满了，然后再和__counter[2]合并，发现__counter[2]满了，最后转移到__counter[3] __counter[0]:NULL __counter[1]:NULL __counter[2]:NULL __counter[3]:1, 3, 21, 30, 45, 47, 52, 58 取第9个数22，放入__counter[0] __counter[0]:22 __counter[1]:NULL __counter[2]:NULL __counter[3]:1, 3, 21, 30, 45, 47, 52, 58 取第10个数59，放入__counter[0], 转移到__counter[1] __counter[0]:NULL __counter[1]:22, 59 __counter[2]:NULL __counter[3]:1, 3, 21, 30, 45, 47, 52, 58 取第11个数0，放入__counter[0] __counter[0]:0 __counter[1]:22, 59 __counter[2]:NULL __counter[3]:1, 3, 21, 30, 45, 47, 52, 58 取第12个数58，放入__counter[0],__counter[0]满了，和__counter[1]合并，__counter[1]满了，转移到__counter[2] __counter[0]:NULL __counter[1]:NULL __counter[2]:0, 22, 58, 59 __counter[3]:1, 3, 21, 30, 45, 47, 52, 58 现在所有的节点都加入了__counter，遍历__counter，合并它们，最后__counter[__fill-1]就是排序后的目标链表 参考资料 STL源码剖析(侯捷) http://blog.csdn.net/qq276592716/article/details/7932483 http://blog.csdn.net/lijun5635/article/details/23963707","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"SGI STL 标准库 迭代器与类型萃取 2","slug":"stl-iterators-traits-2","date":"2017-06-09T07:40:00.000Z","updated":"2020-04-12T04:56:35.921Z","comments":true,"path":"2017/06/09/stl-iterators-traits-2/","link":"","permalink":"http://www.casezheng.date/2017/06/09/stl-iterators-traits-2/","excerpt":"","text":"STL 迭代器 类型萃取github源码分析仓库迭代器是一种抽象设计概念，Iterator模式定义：提供一种方法，使之能够依次遍历某个容器所包含的各个元素，而不需要暴露该容器的内部表达方式。STL中心思想：将数据容器和算法分开，独立设计，再将其结合在一起使用。迭代器是一种智能指针，迭代器重载operator*和operator-&gt;操作符。算法在使用迭代器时可能需要其相应的类型，比如迭代器所指之物的类型。 利用函数模版的参数推导机制获取型别12345678910111213141516template &lt;class I, class T&gt;void func_impl(I iter, T t)&#123; T tmp; //T就是迭代器iter所指之物的类型 //func应该做的工作&#125;template &lt;class I&gt;inline void func(I iter)&#123; func_impl(iter, *iter); //func的工作移到func_impl&#125;int main()&#123; int i; func(&amp;i);&#125; 声明内嵌类型获得迭代器所指之物及其它需要的类型1234567891011121314151617template &lt;class T&gt;struct MyIter &#123; typedef T value_type; //内嵌类型声明 T *ptr; MyIter(T* p=0) : ptr(p) &#123;&#125; T &amp;operator*() const &#123; return *ptr; &#125; //...&#125;;template &lt;class I&gt;typename I::value_type func(I ite)&#123; return *ite;&#125;// ...MyIter&lt;int&gt; ite(new ine(8));cout&lt;&lt;func(ite); 利用在迭代器类内部内嵌类型声明，可以得到类内部所拥有的对象的各个类型，但迭代器还可以是原生指针，原生指针无法进行内嵌类型声明，需要使用C++模版偏特化，提供原生指针的特化版本解决问题。 12345template &lt;class T&gt;T func(T* ite)&#123; return *ite;&#125; 设计中间件萃取器获取迭代器所包含的类型1234567891011121314151617181920212223//萃取器template &lt;class I&gt;struct iterator_traits &#123; typedef typename I::value_type value_type;&#125;;template &lt;class I&gt;typename iterator_traits&lt;I&gt;::value_type fun(I ite) //返回值使用萃取器获取&#123; return *ite;&#125;//偏特化版本，用于迭代器是原生指针template &lt;class I&gt;struct iterator_traits&lt;I*&gt; &#123; typedef I value_type;&#125;;//偏特化版本，用于迭代器是const原生指针的情况template &lt;class I&gt;struct iterator_traits&lt;const I*&gt; &#123; typedef I value_type;&#125;; 通过iterator_traits可以方便的获取迭代器的相应类型。最常用的迭代器类型有五种：value_type、difference_type、pointer、reference、iterator_category。 12345678template &lt;class I&gt;struct iterator_traits &#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; typedef typename I::pointer pointer; typedef typename I::reference reference;&#125;; value_type即迭代器所指对象的类型。difference_type用来表示两个迭代器之间的距离。reference引用类型。pointer指针类型。iterator_category迭代器类型。 迭代器类型根据移动和可进行操作分为五种： input iterator: 该类型迭代器所指对象不允许外界改变，只读 单向移动 output iterator: 唯写 单向移动 forward iterator: 读写 单向移动 bidirectional iterator: 可双向移动迭代器 读写 random access iterator: 随机迭代器 读写 迭代器的分类和从属关系：1234567input iterator output iterator | | forward iterator | bidirectional iterator | random access iterator 它们的关系不是继承，而是概念和强化的关系。由于各种迭代器不尽相同，设计算法时，应尽量针对某种迭代器提供明确定义，并针对更强化的某种迭代器提供另一种定义，在不同情况下提供最大效率。在运行期根据迭代器类型选择不同算法版本，影响程序效率，利用重载函数机制，在编译器选择合适的版本。利用萃取器取出迭代器的类型，利用迭代器类型形成函数重载，在编译器确定运行的算法版本。定义五种迭代器类型作为标记用的型别：12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 使用class定义迭代器的标签，不仅促成重载机制成功运作，而且通过继承在调用函数时，如果不存在一个能力强的版本的函数，可以自动调用能力弱的版本。1234567891011121314template &lt;class I&gt;void func(I&amp; B, input_iterator_tag)&#123;&#125;void func(I&amp; B, bidirectional_iterator_tag)&#123;&#125;int main()&#123; func(1, input_iterator_tag()); //参数完全匹配 调用func(I&amp; B, input_iterator_tag) func(2, forward_iterator_tag()); //参数未能完全匹配 由于继承关系 调用func(I&amp; B, input_iterator_tag) func(3, bidirectional_iterator_tag()); //参数完全匹配 调用func(I&amp; B, bidirectional_iterator_tag) return 0;&#125; STL中模板参数命名以算法所能接受的最初级类型为迭代器型别参数命名。 std::iterator的保证STL中任何迭代器都应该提供五种内嵌相应型别，以利于traits萃取。STL提供iterator class使每个新设计的迭代器都继承它，保证符合STL规范。12345678910111213template &lt;class Category, class T, class Distance = ptrdff_t, class Pointer = T*, class Reference = T&amp;&gt;struct iterator&#123; typedef Category iterator_category; typedef T value_type; typedef Distance difference_type; typedef Pointer pointer; typedef Reference reference;&#125; 设置适当的相应类型，是迭代器的责任。设计适当的迭代器，是容器本身的责任。因为只有容器本身知道如何遍历自己。 SGI STL的__type_traitsSTL使用traits，对迭代器进行规范，制定出iterator_category。SGI将traits扩大到迭代器以外的其它地方, 即__type_traits，是SGI STL内部私有的东西，不在STL标准规范之外。iterator_category负责萃取迭代器特性，而__type_traits则负责萃取型别的特性。型别的特性是指其构造函数、拷贝构造函数、等号运算符重载函数、析构函数是否“没有价值”，如果答案为否定的，在对该型别进行构造、拷贝构造、析构、赋值时，可以采取效率更高的方法，直接对内存操作，不需要调用其构造、拷贝构造、析构、赋值函数。 123456789101112struct __true_type &#123;&#125;;struct __false_type &#123;&#125;;template &lt;class type&gt;struct __type_traits&#123; typedef __true_type this_dummy_member_must_be_first; typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_operator; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;; SGI STL将所有都定义为最保守的值__false_type。然后针对每一种标量类型设计合适的__type_traits特化版本。12345678910//举例template &lt;&gt;struct __type_traits&lt;char&gt;&#123; typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_operator; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type;&#125;; __type_traits在SGI STL中广泛使用。比如空间配置器中uninitialized_fill_n()函数、destroy()函数等。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"skynet","slug":"skynet","date":"2017-06-08T10:33:00.000Z","updated":"2020-04-12T04:56:35.919Z","comments":true,"path":"2017/06/08/skynet/","link":"","permalink":"http://www.casezheng.date/2017/06/08/skynet/","excerpt":"","text":"skynet配置文件说明简单配置文件示例root = &quot;./&quot; thread = 8 logger = nil harbor = 1 address = &quot;127.0.0.1:2526&quot; master = &quot;127.0.0.1:2013&quot; start = &quot;main&quot; -- main script bootstrap = &quot;snlua bootstrap&quot; -- The service for bootstrap standalone = &quot;0.0.0.0:2013&quot; luaservice = root..&quot;service/?.lua;&quot;..root..&quot;test/?.lua;&quot;..root..&quot;examples/?.lua&quot; lualoader = &quot;lualib/loader.lua&quot; snax = root..&quot;examples/?.lua;&quot;..root..&quot;test/?.lua&quot; cpath = root..&quot;cservice/?.so&quot; 必要配置项 thread 启动多少个工作线程。通常不要将它配置超过你实际拥有的 CPU 核心数。 bootstrap skynet 启动的第一个服务以及其启动参数。默认配置为 snlua bootstrap ，即启动一个名为 bootstrap 的 lua 服务。通常指的是 service/bootstrap.lua 这段代码。 cpath 用 C 编写的服务模块的位置，通常指 cservice 下那些 .so 文件。如果你的系统的动态库不是以 .so 为后缀，需要做相应的修改。这个路径可以配置多项，以 ; 分割。 bootstrap代码中用到的一些配置项 logger 它决定了 skynet 内建的 skynet_error 这个 C API 将信息输出到什么文件中。如果 logger 配置为 nil ，将输出到标准输出。你可以配置一个文件名来将信息记录在特定文件中。 logservice 默认为 “logger” ，你可以配置为你定制的 log 服务（比如加上时间戳等更多信息）。可以参考 service_logger.c 来实现它。注：如果你希望用 lua 来编写这个服务，可以在这里填写 snlua ，然后在 logger 配置具体的 lua 服务的名字。在 examples 目录下，有 config.userlog 这个范例可供参考。 logpath 配置一个路径，当你运行时为一个服务打开 log 时，这个服务所有的输入消息都会被记录在这个目录下，文件名为服务地址。 standalone 如果把这个 skynet 进程作为主进程启动（skynet 可以由分布在多台机器上的多个进程构成网络），那么需要配置standalone 这一项，表示这个进程是主节点，它需要开启一个控制中心，监听一个端口，让其它节点接入。 master 指定 skynet 控制中心的地址和端口，如果你配置了 standalone 项，那么这一项通常和 standalone 相同。 address 当前 skynet 节点的地址和端口，方便其它节点和它组网。注：即使你只使用一个节点，也需要开启控制中心，并额外配置这个节点的地址和端口。 harbor 可以是 1-255 间的任意整数。一个 skynet 网络最多支持 255 个节点。每个节点有必须有一个唯一的编号。如果 harbor 为 0 ，skynet 工作在单节点模式下。此时 master 和 address 以及 standalone 都不必设置。 start 这是 bootstrap 最后一个环节将启动的 lua 服务，也就是你定制的 skynet 节点的主程序。默认为 main ，即启动 main.lua 这个脚本。这个 lua 服务的路径由下面的 luaservice 指定。 集群服务用到的配置项 cluster 它决定了集群配置文件的路径。 lua 服务由 snlua 提供，它会查找一些配置项以加载 lua 代码 lualoader 用哪一段 lua 代码加载 lua 服务。通常配置为 lualib/loader.lua ，再由这段代码解析服务名称，进一步加载 lua 代码。snlua 会将下面几个配置项取出，放在初始化好的 lua 虚拟机的全局变量中。具体可参考实现。 SERVICE_NAME 第一个参数，通常是服务名。 LUA_PATH config 文件中配置的 lua_path 。 LUA_CPATH config 文件中配置的 lua_cpath 。 LUA_PRELOAD config 文件中配置的 preload 。 LUA_SERVICE config 文件中配置的 luaservice 。 luaservice lua 服务代码所在的位置。可以配置多项，以 ; 分割。 如果在创建 lua 服务时，以一个目录而不是单个文件提供，最终找到的路径还会被添加到 package.path 中。比如，在编写 lua 服务时，有时候会希望把该服务用到的库也放到同一个目录下。 lua_path 将添加到 package.path 中的路径，供 require 调用。 lua_cpath 将添加到 package.cpath 中的路径，供 require 调用。 preload 在设置完 package 中的路径后，加载 lua 服务代码前，loader 会尝试先运行一个 preload 制定的脚本，默认为空。 snax 用 snax 框架编写的服务的查找路径。 profile 默认为 true, 可以用来统计每个服务使用了多少 cpu 时间。在 DebugConsole 中可以查看。会对性能造成微弱的影响，设置为 false 可以关闭这个统计。 可以把一些配置选项配置在环境变量中。比如，你可以把 thread 配置在 SKYNET_THREAD 这个环境变量里。你可以在 config 文件中写：1thread=$SKYNET_THREAD 在 skynet 启动时，就会用 SKYNET_THREAD 这个环境变量的值替换掉 config 中的 $SKYNET_THREAD 了。 后台模式 daemon 配置 daemon = “./skynet.pid” 可以以后台模式启动 skynet 。注意，同时请配置 logger 项输出 log 。 skynet目录结构 3rd：第三方代码，主要生成一些给lua用的so动态库 lualib：lua库 lualib-src =&gt; luaclib：给lua用的c库 service：lua服务 service-src =&gt; cservice：c服务 skynet-src =&gt; skynet：主程序 Makefile client-src =&gt; client：测试客户端 examples：示例工程 skynet重要文件 skynet_server.c：管理服务 skynet_handle.c：管理服务唯一的handle skynet_module.c：启动c编写的so模块 skynet_monitor.c：监视服务死循环 skynet_mq.c：消息队列 skynet_timer.c：定时器 skynet_socket.c：Socket skynet_master.c：不同skynet节点服务名字中心服务 skynet_harbor.c：不同skynet节点通讯 skynet重要模块和服务 gate.so：为整个skynet提供socket功能 snlua.so：启动多个lua服务 launcher.lua：在lua中启动服务 skynet重要库 skynet.lua：lua常用功能封装 skynet.so：lua调用skynet功能","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/tags/other/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]},{"title":"SGI STL 标准库 空间配置器 1","slug":"stl-alloc-1","date":"2017-06-07T15:21:00.000Z","updated":"2020-04-12T04:56:35.918Z","comments":true,"path":"2017/06/07/stl-alloc-1/","link":"","permalink":"http://www.casezheng.date/2017/06/07/stl-alloc-1/","excerpt":"","text":"STL 空间配置器github源码分析仓库 STL实现了两个空间配置器，std::allocator和std::alloc，std::allocator是STL标准的空间配置器，是对C++的::operator new和::operator delete的简单封装。std::alloc是SGI自定义的特殊的空间配置器。std::alloc是SGI STL各个容器的缺省空间配置器。 C++ new和delete 在alloc中的分解C++内存配置操作和释放操作new和delte，分别包含两阶段操作：对new 调用::operator new分配空间 调用对象的构造函数 对delete 调用对象的析构函数 调用::operator delete释放空间 STL alloc将new与delete的两个阶段区分开来，内存配置操作alloc::allocate()，内存释放操作alloc::deallocate()，对象构造::construct()，对象析构::destroy() 构造和析构工具 construct()和destroy()源代码&lt;stl_construct.h&gt;的部分内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;new.h&gt;template &lt;class _T1, class _T2&gt;inline void _Construct(_T1* __p, const _T2&amp; __value) &#123; new ((void*) __p) _T1(__value); //调用 T1::T1(value) 在__p所指的内存空间上构造T1&#125;template &lt;class _T1&gt;inline void _Construct(_T1* __p) &#123; new ((void*) __p) _T1(); //调用 T1::T1() 在__p所指的内存空间上构造T1&#125;template &lt;class _Tp&gt;inline void _Destroy(_Tp* __pointer) &#123; __pointer-&gt;~_Tp(); //调用析构函数&#125;//需要调用析构函数 有non-trivial destrucotrtemplate &lt;class _ForwardIterator&gt;void__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)&#123; for ( ; __first != __last; ++__first) destroy(&amp;*__first);&#125;//不需要调用析构函数 有trivial destrucotrtemplate &lt;class _ForwardIterator&gt;inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) &#123;&#125;//判断元素的数值型别(value type)调用具体的函数template &lt;class _ForwardIterator, class _Tp&gt;inline void__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)&#123; typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor _Trivial_destructor; __destroy_aux(__first, __last, _Trivial_destructor());&#125;//接受两个迭代器，找出元素的数值型别，根据__type_traits&lt;&gt;调用最合适的函数template &lt;class _ForwardIterator&gt;inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) &#123; __destroy(__first, __last, __VALUE_TYPE(__first));&#125;//对内置类型的特化版本inline void _Destroy(char*, char*) &#123;&#125;inline void _Destroy(int*, int*) &#123;&#125;inline void _Destroy(long*, long*) &#123;&#125;inline void _Destroy(float*, float*) &#123;&#125;inline void _Destroy(double*, double*) &#123;&#125;inline void _Destroy(wchar_t*, wchar_t*) &#123;&#125;template &lt;class _T1, class _T2&gt;inline void construct(_T1* __p, const _T2&amp; __value) &#123; _Construct(__p, __value);&#125;template &lt;class _T1&gt;inline void construct(_T1* __p) &#123; _Construct(__p);&#125;template &lt;class _Tp&gt;inline void destroy(_Tp* __pointer) &#123; _Destroy(__pointer);&#125;template &lt;class _ForwardIterator&gt;inline void destroy(_ForwardIterator __first, _ForwardIterator __last) &#123; _Destroy(__first, __last);&#125; destroy(_Tp *)直接调用_Destroy(_Tp *)执行析构函数。destroy(_ForwardIterator, _ForwardIterator)有特化版本则直接调用，否则调用_Destroy(_ForwardIterator, _ForwardIterator)，通过__VALUE_TYPE()得到要析构对象的值类型，调用__destroy(_ForwardIterator __first，_ForwardIterator __last, _Tp )，使用类型萃取，通过_Trivial_destructor()区分调用__destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)或者调用__destroy_aux(_ForwardIterator, _ForwardIterator, __false_type)。 construct(_T1*, const _T2&amp;)调用_Construct(_T1* __p, const _T2&amp; __value)，执行new ((void*) __p) _T1(__value)，构造一个对象。construct(_T1*)调用_Construct(_T1* __p)，执行new ((void*) __p) _T1()，构造一个对象。 空间的配置和释放对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。C++的内存配置基本操作是::operator new()、内存释放操作是::operator delete()，相当于C的malloc()和free()函数，SGI用malloc()和free()完成内存的配置和释放。SGI设计双层空间配置器，解决小块内存可能造成的内存碎片问题，第一级配置器直接使用malloc()和free()，第二级配置器根据不同情况采用不同策略，当要配置的内存块大于128b，调用第一次配置器，当配置的内存块小于128b，则采用memory pool整理方式。__USE_MALLOC用来控制配置器的使用，如果定义了__USE_MALLOC则只开放第一级空间配置器。为了使配置器的接口符合STL规格，SGI为alloc包装了接口：1234567891011121314151617181920212223typedef __malloc_alloc_template&lt;0&gt; malloc_alloc;# ifdef __USE_MALLOC// 定义__USE_MALLOC则将__malloc_alloc_template定义为alloctypedef malloc_alloc alloc;# else// 否则将__default_alloc_template定义为alloctypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;# endiftemplate&lt;class _Tp, class _Alloc&gt;class simple_alloc &#123;public: static _Tp* allocate(size_t __n) &#123; return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); &#125; static _Tp* allocate(void) &#123; return (_Tp*) _Alloc::allocate(sizeof (_Tp)); &#125; static void deallocate(_Tp* __p, size_t __n) &#123; if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); &#125; static void deallocate(_Tp* __p) &#123; _Alloc::deallocate(__p, sizeof (_Tp)); &#125;&#125;; simplealloc的四个成员函数都是单纯的转调用，调用传递给配置器。同时将要配置元素的个数__n转化为要配置的空间大小``(__n*sizeof(_Tp))。实际使用时都调用simple_alloc``。 一级空间配置器 __malloc_alloc_template allocate()直接使用malloc()，deallocate()直接使用free() 模拟C++的set_new_handler()处理内存不足的情况 二级空间配置器 __default_alloc_template 维护16个自由链表，负责16种小块内存的配置，内存池用malloc配置，如果内存不足，调用一级空间配置器 如果需要配置的内存块大于128b，直接调用一级空间配置器 一级空间配置器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//没有template型别参数 非型别参数__inst未使用template &lt;int __inst&gt;class __malloc_alloc_template &#123;private: //函数指针 所代表的函数用来处理内存不足的情况 static void* _S_oom_malloc(size_t); static void* _S_oom_realloc(void*, size_t); static void (* __malloc_alloc_oom_handler)();public: static void* allocate(size_t __n) &#123; void* __result = malloc(__n); //一级配置器直接使用malloc() if (0 == __result) __result = _S_oom_malloc(__n); //内存不足，调用_S_oom_malloc return __result; &#125; static void deallocate(void* __p, size_t /* __n */) &#123; free(__p); //一级配置器直接使用free()释放空间 &#125; static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz) &#123; void* __result = realloc(__p, __new_sz); //一级配置器直接使用realloc() if (0 == __result) __result = _S_oom_realloc(__p, __new_sz); //空间不足，调用_S_oom_realloc() return __result; &#125; //设置out-of-memory handler 仿真C++ set_new_handler() static void (* __set_malloc_handler(void (*__f)()))() &#123; void (* __old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = __f; return(__old); &#125;&#125;;//初始值设为0template &lt;int __inst&gt;void (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = 0;template &lt;int __inst&gt;void*__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)&#123; void (* __my_malloc_handler)(); void* __result; //如果存在__malloc_alloc_oom_handler则不断调用，尝试释放、配置、再释放、再配置， //直到分配成功。 否则 抛出异常 或者 执行exit(1)退出程序。 for (;;) &#123; __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; (*__my_malloc_handler)(); __result = malloc(__n); if (__result) return(__result); &#125;&#125;template &lt;int __inst&gt;void* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(void* __p, size_t __n)&#123; void (* __my_malloc_handler)(); void* __result; //如果存在__malloc_alloc_oom_handler则不断调用，尝试释放、配置、再释放、再配置， //直到分配成功。 否则 抛出异常 或者 执行exit(1)退出程序。 for (;;) &#123; __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; (*__my_malloc_handler)(); __result = realloc(__p, __n); if (__result) return(__result); &#125;&#125;// 直接将参数inst指定为0typedef __malloc_alloc_template&lt;0&gt; malloc_alloc; 第一级空间配置器以malloc()、free()、realloc()等C函数执行实际的内存配置、释放、重配置操作，并实现类似C++ new-handler的机制。因为它未使用::operator new配置内存，所以不能直接运用C++ new-handler。C++ new-handler机制，要求系统在内存配置需求无法被满足时，调用一个指定的函数。 第二级空间配置器第二级空间配置器避免太多小内存块造成内存碎片。SGI第二级配置器，如果配置内存块大于128B时，调用第一级配置器处理，当配置内存块小于128B时，用内存池管理，即每次配置一大块内存，并维护对应的自由链表(free-list)，下次再分配相同大小的内存快时，从free-list拨出，释放小块内存则加入到free-list中。为了方便管理，SGI二级配置器，将任何小块内存调整为8的倍数，并维护16个free-list，各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128B的小块内存。free-list节点结构：1234union _Obj &#123; union _Obj* _M_free_list_link; char _M_client_data[1]; /* The client sees this. */&#125;; 使用union，从第一个字段看，_Obj可看做一个指针，指向相同形式的另一个_Obj，从第二个字段看，指向实际内存。不会为了维护联播所必须的指针造成内存的另一种浪费。空间配置函数allocate()首先判断申请内存块的大小，大于128B，调用第一级空间配置器，小于128B检查对应的free-list，如果free-list有可用内存块，直接拿来用，如果没有，将区块大小上调至8的倍数，调用_S_refill()重新为free-list重新填充空间。空间释放函数deallocate()首先判断内存块大小，大于128B调用第一级配置器，小于128B找到对应free-list将区块回收。填充操作和内存池的实现看下面代码(附注释)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//threads用于多线程环境template &lt;bool threads, int inst&gt;class __default_alloc_template &#123;private: enum &#123;_ALIGN = 8&#125;; enum &#123;_MAX_BYTES = 128&#125;; enum &#123;_NFREELISTS = 16&#125;; // _MAX_BYTES/_ALIGN //将__bytes上调至8的倍数 static size_t _S_round_up(size_t __bytes) &#123; return (((__bytes) + (size_t) _ALIGN-1) &amp; ~((size_t) _ALIGN - 1)); &#125; //free-lists的节点 union _Obj &#123; union _Obj* _M_free_list_link; //指向下一个可用的相同大小的内存块 char _M_client_data[1]; /* The client sees this. */ &#125;;private: // 16个free_lists static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; //根据要分配的内存块大小__bytes决定使用第n号free_lists。n从1起算。 static size_t _S_freelist_index(size_t __bytes) &#123; return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); &#125; // 返回一个大小为n的对象，并可能加入大小为__n的其它内存块到free_lists static void* _S_refill(size_t __n); // 配置一大块，可容纳__nobjs个大小为\"__size\"的内存块 // 如果配置__nobjs个内存块不足，可以减少数量 static char* _S_chunk_alloc(size_t __size, int&amp; __nobjs); static char* _S_start_free; //内存池起始位置，只在_S_chunk_alloc()中改变 static char* _S_end_free; //内存池结束位置，只在_S_chunk_alloc()中改变 static size_t _S_heap_size;public: /* __n must be &gt; 0 空间分配函数*/ static void* allocate(size_t __n) &#123; void* __ret = 0; // 大于128直接调用第一级空间配置器 if (__n &gt; (size_t) _MAX_BYTES) &#123; __ret = malloc_alloc::allocate(__n); &#125; else &#123; //寻找16个free_lists中适当的一个 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); //获取free_lists _Obj* __RESTRICT __result = *__my_free_list; if (__result == 0) //没有可用的free_lists，准备重新填充free_lists __ret = _S_refill(_S_round_up(__n)); else &#123; //有可用的，free_lists调整下 *__my_free_list = __result -&gt; _M_free_list_link; __ret = __result; &#125; &#125; return __ret; &#125;; /* __p may not be 0 空间释放函数*/ static void deallocate(void* __p, size_t __n) &#123; // 大于128直接调用艺集空间配置器 if (__n &gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else &#123; //寻找对应的free_lists _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; // 调整free_lists，回收内存块 __q -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; &#125; &#125; static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);&#125; ;typedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc;template &lt;bool __threads, int __inst&gt;inline bool operator==(const __default_alloc_template&lt;__threads, __inst&gt;&amp;, const __default_alloc_template&lt;__threads, __inst&gt;&amp;)&#123; return true;&#125;// 假设__size已经上调至8的倍数// __nobjs是期望获得的内存块个数，传引用，用来返回实际分配的内存块个数template &lt;bool __threads, int __inst&gt;char*__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(size_t __size, int&amp; __nobjs)&#123; char* __result; size_t __total_bytes = __size * __nobjs; //总共需要的内存块大小 size_t __bytes_left = _S_end_free - _S_start_free; //内存池剩余空间 if (__bytes_left &gt;= __total_bytes) &#123; //内存池剩余空间足够 __result = _S_start_free; _S_start_free += __total_bytes; //调整内存池起始位置 return(__result); &#125; else if (__bytes_left &gt;= __size) &#123; //内存池剩余空间不能完全满足需求量，但足够分配一个及以上的内存块 __nobjs = (int)(__bytes_left/__size); //计算可分配的内存块的个数 __total_bytes = __size * __nobjs; //重新计算分配出去的内存块大小 __result = _S_start_free; _S_start_free += __total_bytes; //调整内存池起始位置 return(__result); &#125; else &#123; //内存池剩余空间不足分配一个内存块 //计算重新申请内存池的大小 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4); // Try to make use of the left-over piece. if (__bytes_left &gt; 0) &#123; //内存池还有部分空间，尝试利用它们 将其加入free_lists _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; &#125; //直接调用malloc()申请内存空间 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free) &#123; //malloc()分配失败 size_t __i; _Obj* __STL_VOLATILE* __my_free_list; _Obj* __p; // 尝试从“尚未使用的内存块，且足够大”的free_lists中找一个内存块 // 作为新的内存池 for (__i = __size; __i &lt;= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) &#123; //得到free_lists __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; if (0 != __p) &#123; //free_lists有未使用的内存块 调整free_lists去除未使用的内存块 *__my_free_list = __p -&gt; _M_free_list_link; //将取出的内存块作为内存池 设置内存池的起始位置和结束位置 _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; //递归调用下，返回申请的空间 return(_S_chunk_alloc(__size, __nobjs)); &#125; &#125; //找不到合适的内存块 _S_end_free = 0; // In case of exception. //调用一级配置器，尝试out-of-memory _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); // 调用一级配置器，可以得到内存或者抛出异常(或直接结束程序) &#125; //分配到新的内存池，调整下大小，设置内存池结束为止 _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; //递归调用下，返回申请的空间，修正__nobjs return(_S_chunk_alloc(__size, __nobjs)); &#125;&#125;// 返回一个大小为_n的对象，并且适当的为free_lists增加节点 要求__n已适当上调为8的倍数template &lt;bool __threads, int __inst&gt;void*__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(size_t __n)&#123; int __nobjs = 20; //调用_S_chunk_alloc，尝试取得nobjs个内存块作为free_lists的新节点 //__nobjs传引用，返回获得节点的个数 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* __STL_VOLATILE* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; int __i; //如果只获取到一个内存块，返回给调用者使用，free_lists未新加节点 if (1 == __nobjs) return(__chunk); //调整free_lists新加节点 __my_free_list = _S_free_list + _S_freelist_index(__n); //在__chunk空间建立free_lists __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); for (__i = 1; ; __i++) &#123; __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); if (__nobjs - 1 == __i) &#123; __current_obj -&gt; _M_free_list_link = 0; break; &#125; else &#123; __current_obj -&gt; _M_free_list_link = __next_obj; &#125; &#125; return(__result);&#125;template &lt;bool threads, int inst&gt;void*__default_alloc_template&lt;threads, inst&gt;::reallocate(void* __p, size_t __old_sz, size_t __new_sz)&#123; void* __result; size_t __copy_sz; if (__old_sz &gt; (size_t) _MAX_BYTES &amp;&amp; __new_sz &gt; (size_t) _MAX_BYTES) &#123; return(realloc(__p, __new_sz)); &#125; if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p); __result = allocate(__new_sz); __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz; memcpy(__result, __p, __copy_sz); deallocate(__p, __old_sz); return(__result);&#125;//__default_alloc_template中static成员定于与初始值设定template &lt;bool __threads, int __inst&gt;char* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = 0;template &lt;bool __threads, int __inst&gt;char* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = 0;template &lt;bool __threads, int __inst&gt;size_t __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = 0;template &lt;bool __threads, int __inst&gt;typename __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[ __default_alloc_template&lt;__threads, __inst&gt;::_NFREELISTS] = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &#125;; 内存基本处理工具STL定义五个全局函数，construct()、destroy()、uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()，作用于内存空间。construct()用于构造，destroy()用于析构。uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()分别对应高层次函数copy()、fill()、fill_n()。uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()都具有要么产生所有必要元素，否则就不产生任何元素的机制。如果任何一个拷贝构造抛出异常，必须析构已产生的所有元素。POD(Plain Old Data)即标量类型或传统C struct类型。POD类型必然有无价值的(trivial) ctor/dtor/copy/assignment函数，因此对于POD类型采用最有效率的操作，对非POD类型调用其ctor/dtor/copy/assignment函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// POD类型，调用memcpy()template &lt;class _InputIter, class _ForwardIter&gt;inline _ForwardIter__uninitialized_copy_aux(_InputIter __first, _InputIter __last, _ForwardIter __result, __true_type)&#123; return copy(__first, __last, __result);&#125;// 非POD类型，逐个调用拷贝构造函数 如果构造过程中出错抛出异常，析构已构造的对象template &lt;class _InputIter, class _ForwardIter&gt;_ForwardIter__uninitialized_copy_aux(_InputIter __first, _InputIter __last, _ForwardIter __result, __false_type)&#123; _ForwardIter __cur = __result; __STL_TRY &#123; for ( ; __first != __last; ++__first, ++__cur) _Construct(&amp;*__cur, *__first); return __cur; &#125; __STL_UNWIND(_Destroy(__result, __cur));&#125;template &lt;class _InputIter, class _ForwardIter, class _Tp&gt;inline _ForwardIter__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result, _Tp*)&#123; //使用类型萃取，对POD类型使用memcpy()，非OPD类型逐个调用构造函数 typedef typename __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD; return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());&#125;//将[__first, __last)复制一份到[__result, __result+__last-__first)template &lt;class _InputIter, class _ForwardIter&gt;inline _ForwardIter uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)&#123; return __uninitialized_copy(__first, __last, __result, __VALUE_TYPE(__result));&#125;inline char* uninitialized_copy(const char* __first, const char* __last, char* __result) &#123; memmove(__result, __first, __last - __first); return __result + (__last - __first);&#125;inline wchar_t*uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result)&#123; memmove(__result, __first, sizeof(wchar_t) * (__last - __first)); return __result + (__last - __first);&#125;// uninitialized_copy_n (not part of the C++ standard)template &lt;class _InputIter, class _Size, class _ForwardIter&gt;pair&lt;_InputIter, _ForwardIter&gt;__uninitialized_copy_n(_InputIter __first, _Size __count, _ForwardIter __result, input_iterator_tag)&#123; _ForwardIter __cur = __result; __STL_TRY &#123; for ( ; __count &gt; 0 ; --__count, ++__first, ++__cur) _Construct(&amp;*__cur, *__first); return pair&lt;_InputIter, _ForwardIter&gt;(__first, __cur); &#125; __STL_UNWIND(_Destroy(__result, __cur));&#125;template &lt;class _RandomAccessIter, class _Size, class _ForwardIter&gt;inline pair&lt;_RandomAccessIter, _ForwardIter&gt;__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, random_access_iterator_tag) &#123; _RandomAccessIter __last = __first + __count; return pair&lt;_RandomAccessIter, _ForwardIter&gt;( __last, uninitialized_copy(__first, __last, __result));&#125;template &lt;class _InputIter, class _Size, class _ForwardIter&gt;inline pair&lt;_InputIter, _ForwardIter&gt;__uninitialized_copy_n(_InputIter __first, _Size __count, _ForwardIter __result) &#123; return __uninitialized_copy_n(__first, __count, __result, __ITERATOR_CATEGORY(__first));&#125;template &lt;class _InputIter, class _Size, class _ForwardIter&gt;inline pair&lt;_InputIter, _ForwardIter&gt;uninitialized_copy_n(_InputIter __first, _Size __count, _ForwardIter __result) &#123; return __uninitialized_copy_n(__first, __count, __result, __ITERATOR_CATEGORY(__first));&#125;// Valid if copy construction is equivalent to assignment, and if the// destructor is trivial.//对于POD类型调用memsettemplate &lt;class _ForwardIter, class _Tp&gt;inline void__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, __true_type)&#123; fill(__first, __last, __x);&#125;//对于非POD类型逐个调用构造函数 如果中途抛出异常，析构已经构造的对象template &lt;class _ForwardIter, class _Tp&gt;void__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, __false_type)&#123; _ForwardIter __cur = __first; __STL_TRY &#123; for ( ; __cur != __last; ++__cur) _Construct(&amp;*__cur, __x); &#125; __STL_UNWIND(_Destroy(__first, __cur));&#125;template &lt;class _ForwardIter, class _Tp, class _Tp1&gt;inline void __uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, _Tp1*)&#123; typedef typename __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD; __uninitialized_fill_aux(__first, __last, __x, _Is_POD()); &#125;//对[__first, __last)中迭代器所指向的内存，已__x为参数调用_Tp的拷贝构造函数template &lt;class _ForwardIter, class _Tp&gt;inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x)&#123; __uninitialized_fill(__first, __last, __x, __VALUE_TYPE(__first));&#125;//对于POD类型逐个执行赋值操作template &lt;class _ForwardIter, class _Size, class _Tp&gt;inline _ForwardIter__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp&amp; __x, __true_type)&#123; return fill_n(__first, __n, __x);&#125;//对于非POD类型逐个调用构造函数 如果中途抛出异常，析构已经构造的对象template &lt;class _ForwardIter, class _Size, class _Tp&gt;_ForwardIter__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n, const _Tp&amp; __x, __false_type)&#123; _ForwardIter __cur = __first; __STL_TRY &#123; for ( ; __n &gt; 0; --__n, ++__cur) _Construct(&amp;*__cur, __x); return __cur; &#125; __STL_UNWIND(_Destroy(__first, __cur));&#125;template &lt;class _ForwardIter, class _Size, class _Tp, class _Tp1&gt;inline _ForwardIter__uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp&amp; __x, _Tp1*)&#123; typedef typename __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD; return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());&#125;//从__first开始构造__n个_Tp对象，已__x为模版template &lt;class _ForwardIter, class _Size, class _Tp&gt;inline _ForwardIteruninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp&amp; __x)&#123; return __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));&#125;template &lt;class _InputIter1, class _InputIter2, class _ForwardIter&gt;inline _ForwardIter__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _ForwardIter __result)&#123; _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result); __STL_TRY &#123; return uninitialized_copy(__first2, __last2, __mid); &#125; __STL_UNWIND(_Destroy(__result, __mid));&#125;template &lt;class _ForwardIter, class _Tp, class _InputIter&gt;inline _ForwardIter__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp&amp; __x, _InputIter __first, _InputIter __last)&#123; uninitialized_fill(__result, __mid, __x); __STL_TRY &#123; return uninitialized_copy(__first, __last, __mid); &#125; __STL_UNWIND(_Destroy(__result, __mid));&#125;template &lt;class _InputIter, class _ForwardIter, class _Tp&gt;inline void__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1, _ForwardIter __first2, _ForwardIter __last2, const _Tp&amp; __x)&#123; _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2); __STL_TRY &#123; uninitialized_fill(__mid2, __last2, __x); &#125; __STL_UNWIND(_Destroy(__first2, __mid2));&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库 内存管理 weak_ptr intrusive_ptr 4","slug":"boost-weak-ptr","date":"2017-06-06T06:24:00.000Z","updated":"2020-04-12T04:56:35.916Z","comments":true,"path":"2017/06/06/boost-weak-ptr/","link":"","permalink":"http://www.casezheng.date/2017/06/06/boost-weak-ptr/","excerpt":"","text":"weak_ptrweak_ptr是为了配合shared_ptr而引入的一种智能指针，因为weak_ptr不具有普通指针的行为，没有重载operator*和operator-&gt;。weak_ptr的最大作用用来协助shared_ptr工作，观测资源的使用情况。 类摘要 用法weak_ptr被设计为与shared_ptr共同工作，可从一个shared_ptr或者weak_ptr对象构造，获得对象的观测权，但weak_ptr没有共享资源，weak_ptr不会引起指针引用计数的增加，weak_ptr析构也不会导致指针引用计数的减少。weak_ptr成员函数use_count()可以观测资源的引用计数。weak_ptr成员函数expired()的功能等价于use_count()==0，表示观测的资源已经不复存在，但expired的速度更快。weak_ptr没有重载operator*和-&gt;，不共享指针，不能操作资源。weak_ptr可以使用成员函数lock()从观测的shared_ptr获得可用的shared_ptr对象，操作资源，当expired()==true时，lock函数返回存储空指针的shared_ptr。 获得this的shared_ptrweak_ptr的一个重要用途是获得this指针的shared_ptr，使对象自己能够生产shared_ptr管理自己，对象使用weak_ptr观测this指针，在需要的时候调用lock()函数，返回符合要求的shared_ptr供外界使用。123456template&lt;class T&gt;class enable_shared_from_this&#123;public: shared_ptr&lt;T&gt; shared_from_this();&#125; 想被shared_ptr管理的类从enable_shared_from_this继承，成员函数shared_from_this()返回this的shared_ptr。不能从普通对象使用shared_from_this()获取shared_ptr，否则运行时会导致shared_ptr析构时企图删除一个栈上分配的对象。 intrusive_ptrintrusive_ptr是侵入式的引用计数型指针，应用于： 对内存占用的要求非常严格，要求必须与原始指针一样。 现存代码已经有了引用计数机制管理的对象。 Boost库不推荐使用intrusive_ptr，shared_ptr足够啦。 12345678910111213141516171819202122232425262728293031323334353637383940class H : public boost::enable_shared_from_this&lt;H&gt;&#123;public: H(int _n) : n(_n) &#123; cout&lt;&lt;\"H ctor\"&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;\"H n:\"&lt;&lt;n&lt;&lt;endl; &#125; int n;&#125;;void TestWeakPtr()&#123; boost::shared_ptr&lt;int&gt; sp1(new int(10)); cout&lt;&lt;\"sp1 use_count:\"&lt;&lt;sp1.use_count()&lt;&lt;endl; boost::weak_ptr&lt;int&gt; wp1(sp1); cout&lt;&lt;\"sp1 use_count:\"&lt;&lt;sp1.use_count()&lt;&lt;endl; cout&lt;&lt;\"wp1 use_count:\"&lt;&lt;wp1.use_count()&lt;&lt;endl; if(!wp1.expired()) &#123; boost::shared_ptr&lt;int&gt; sp2 = wp1.lock(); cout&lt;&lt;\"sp1 use_count:\"&lt;&lt;sp1.use_count()&lt;&lt;endl; cout&lt;&lt;\"sp2 use_count:\"&lt;&lt;sp2.use_count()&lt;&lt;endl; &#125; cout&lt;&lt;\"sp1 use_count:\"&lt;&lt;sp1.use_count()&lt;&lt;endl; sp1.reset(); cout&lt;&lt;\"wp1 use_count:\"&lt;&lt;wp1.use_count()&lt;&lt;endl; boost::shared_ptr&lt;H&gt; sh = boost::make_shared&lt;H&gt;(314); sh-&gt;print(); boost::shared_ptr&lt;H&gt; sh2 = sh-&gt;shared_from_this(); sh-&gt;n = 1000; sh2-&gt;print(); sh-&gt;print();&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"智能指针","slug":"智能指针","permalink":"http://www.casezheng.date/tags/智能指针/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库 内存管理 shared_ptr shared_array 3","slug":"boost-shared-ptr","date":"2017-06-05T06:52:00.000Z","updated":"2020-04-12T04:56:35.909Z","comments":true,"path":"2017/06/05/boost-shared-ptr/","link":"","permalink":"http://www.casezheng.date/2017/06/05/boost-shared-ptr/","excerpt":"","text":"shared_ptrshared_ptr包装new操作符从堆上分配的动态对象，实现引用计数型的智能指针，可以被自由地拷贝和赋值，在任意地方共享它，当引用计数未0时，删除被包装的动态分配对象，可以被安全地放在标准容器中。 1. 类摘要 2. 操作函数shared_ptr用来管理new动态分配对象，重载了*和-&gt;操作符模拟原始指针行为，提供隐式bool类型转化判断指针有效性，get()获得原始指针，未提供指针算数操作。shared_ptr有各种形式的构造函数 无参的shared_ptr()创建持有空指针的shared_ptr。 shared_ptr(Y *)获得指向类型T的指针p的管理权，同时引用计数置为1。要求Y类型必须能够转化为T类型。 shared_ptr(shared_ptr const &amp;r)从另一个shared_ptr获得指针的管理权，同时引用计数加1，两个shared_ptr共享一个指针的管理权。 shared_ptr(std::auto_ptr&lt;Y&gt; &amp;r)从一个auto_ptr获得指针管理权，引用计数置为1，auto_ptr自动失去管理权。 operator=赋值操作符从另一个shared_ptr或者auto_ptr获得指针管理权。 shared_ptr(Y *p, D d)，参数d指定析构时的定制删除器，而不是简单的delete。 shared_ptr的reset()函数将引用计数减1，停止对指针的共享，除非引用计数为0，否则不会发生删除操作。带参数的reset()对原指针引用计数减1，同时改为管理另一指针。shared_ptr中unique()和use_count()检查引用计数，unique()在shared_ptr是指针的唯一拥有者时返回true，use_count()返回当前指针的引用计数。use_count()不提供高效率的操作，有时候不可用(极少数情况)。unique()总是可用的，而且速度比use_count()==1速度更快。shared_ptr支持比较运算，等于、不等于、小于，基于内部保存的指针，shared_ptr可以被用于标准关联容器(set和map)。shared_ptr指针转化static_pointer_cast&lt;T&gt;()、const_pointer_cast&lt;T&gt;()、dynamic_pointer_cast&lt;T&gt;()，和标准的转型操作static_cast&lt;T&gt;、const_cast&lt;T&gt;、dynamic_cast&lt;T&gt;类似，但返回的是转型后的shared_ptr。shared_ptr支持流输出操作符operator&lt;&lt;，输出内部的指针值，方便调试。shared_ptr提供基本的线程安全保证。 3. 用法4. 工厂函数shared_ptr在&lt;boost/make_shared.hpp&gt;中提供了自由工厂函数make_shared&lt;T&gt;()，消除显示new的调用。12template&lt;class T, class... Argss&gt; shared_ptr&lt;T&gt; make_shared(Args &amp;&amp; .. args); make_shared()函数最多可以接受10个参数，传递给类型T的构造函数，创建shared_ptr&lt;T&gt;的对象并返回。make_shared()函数比直接创建shared_ptr对象的方式快且高效，因为它内部仅分配一次内存。allocate_shared()比make_shared()多接受一个定制的内存分配器类型参数，其它方面相同。 5. 应用于标准容器 将容器作为shared_ptr管理的对象。 将shared_ptr作为容器的元素。 6. 应用于桥接模式桥接模式(brideg)是一种结构型设计模式，把类的具体实现细节对用于隐藏起来，达到类之间的最小耦合关系。可以将头文件的依赖关系降到最小，减少编译事件，而且可以不使用虚函数实现多态。 7. 应用于工厂模式工厂模式是一种创建性设计模式，包装new操作符的使用，让对象的创建集中在工程类或者工厂函数中，更容易的适应变化。 8. 定制删除器shared_ptr(Y *p, D d)第一个参数是被管理的指针，第二个删除器参数d则告诉shared_ptr在析构时不是使用delete操作指针p，而是要用d来操作，即把delte p换成d(p)。删除器d可以是函数对象、函数指针，只要能够像函数一样调用使得d(p)成立即可。对删除器的要求是必须是可拷贝的，不能抛出异常。shared_ptr提供自由函数get_deleter(shared_ptr&lt;T&gt; const &amp;p)，返回删除器指针。有了删除器可以实现管理任意资源。只要该资源提供它的释放操作，shared_ptr保证自动释放。 9. 高级议题shared_ptrshared_ptr&lt;void&gt;可以存储void*的指针，而void*型指针可以指向任意类型，因此shared_ptr&lt;void&gt;拥有了容纳任意类型的能力。但将指针存储为void*会丧失原来的类型信息，在使用时使用转型函数转为原来的指针，但这设计运行时动态类型转换，使代码不够安全，建议不要这样使用。 删除器的高级用法基于shared_ptr&lt;void&gt;和定制删除器，shared_ptr可以实现退出作用域调用任意函数。 其它高级用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148class C //让C代理B，对B的方法做一次封装&#123;private: class B; boost::shared_ptr&lt;B&gt; p;public: C(); void print();&#125;;class C::B&#123;public: void print() &#123; cout&lt;&lt;\"B ctor :\"&lt;&lt;this&lt;&lt;endl; &#125;&#125;;C::C():p(new B)&#123;&#125;void C::print()&#123; p-&gt;print();&#125;class E&#123;public: E()&#123;cout&lt;&lt;\"E ctor\"&lt;&lt;endl;&#125; virtual void f() = 0; virtual void g() = 0;protected: virtual ~E() &#123; cout&lt;&lt;\"E dtor\"&lt;&lt;endl; &#125;&#125;;class F : public E&#123;public: virtual void f() &#123; cout&lt;&lt;\"class F f\"&lt;&lt;endl; &#125; virtual void g() &#123; cout&lt;&lt;\"class F g\"&lt;&lt;endl; &#125;&#125;;E* create1()&#123; return (E*)(new F);&#125;boost::shared_ptr&lt;E&gt; create2()&#123; return boost::shared_ptr&lt;E&gt;(new F);&#125;class G&#123;public: G() &#123; cout&lt;&lt;\"ctor G :\"&lt;&lt;this&lt;&lt;endl; &#125; ~G() &#123; cout&lt;&lt;\"dtor G :\"&lt;&lt;this&lt;&lt;endl; &#125;&#125;;void DeleteG(G *g)&#123; if(g != NULL) &#123; cout&lt;&lt;\"delete G :\"&lt;&lt;g&lt;&lt;endl; delete g; &#125;&#125;void AryF(void * p)&#123; cout&lt;&lt;\"AryF\"&lt;&lt;endl;&#125;void TestSharedPtr()&#123; boost::shared_ptr&lt;int&gt; sp1(new int(10)); cout&lt;&lt;\"sp1 unique :\"&lt;&lt;sp1.unique()&lt;&lt;endl; cout&lt;&lt;\"sp1 use_count :\"&lt;&lt;sp1.use_count()&lt;&lt;endl; boost::shared_ptr&lt;int&gt; sp2(sp1); cout&lt;&lt;\"sp1 unique :\"&lt;&lt;sp1.unique()&lt;&lt;endl; cout&lt;&lt;\"sp1 use_count :\"&lt;&lt;sp1.use_count()&lt;&lt;endl; cout&lt;&lt;\"sp2 unique :\"&lt;&lt;sp2.unique()&lt;&lt;endl; cout&lt;&lt;\"sp2 use_count :\"&lt;&lt;sp2.use_count()&lt;&lt;endl; sp2.reset(); cout&lt;&lt;\"sp2 reset after\"&lt;&lt;endl; cout&lt;&lt;\"sp1 unique :\"&lt;&lt;sp1.unique()&lt;&lt;endl; cout&lt;&lt;\"sp1 use_count :\"&lt;&lt;sp1.use_count()&lt;&lt;endl; cout&lt;&lt;\"sp2 unique :\"&lt;&lt;sp2.unique()&lt;&lt;endl; cout&lt;&lt;\"sp2 use_count :\"&lt;&lt;sp2.use_count()&lt;&lt;endl; boost::shared_ptr&lt;A&gt; spA1(new A()); cout&lt;&lt;\"spA :\"&lt;&lt;spA1.get()&lt;&lt;endl; //工厂函数 boost::shared_ptr&lt;A&gt; spA2 = boost::make_shared&lt;A&gt;(); boost::shared_ptr&lt;A&gt; spA3 = boost::make_shared&lt;A, int, int&gt;(1, 2); //应用于标准容器 vector&lt;boost::shared_ptr&lt;int&gt;&gt; v(3); int i = 0; for(auto&amp; it : v) &#123; it = boost::make_shared&lt;int&gt;(++i); cout&lt;&lt;*(it)&lt;&lt;endl; &#125; boost::shared_ptr&lt;int&gt; sp3 = v[2]; *sp3 = 100; cout&lt;&lt;*v[2]&lt;&lt;endl; //应用于桥接模式 C c; c.print(); &#123; //应用于工厂模式 E * E1 = create1(); boost::shared_ptr&lt;E&gt; E2 = create2(); delete (F*)E1; //E1必须手动调用delete 而E2在出作用域后自动调用 E的析构函数是protected的，所需需要转型为F再delete &#125; cout&lt;&lt;\"桥接模式结束\"&lt;&lt;endl; //定制删除器 boost::shared_ptr&lt;G&gt; pg(new G(), DeleteG); boost::shared_ptr&lt;void&gt; pv(NULL, AryF);&#125; shared_array包装new[]操作符在堆上分配的动态数组，使用引用计数机制为动态数组提供代理，可在程序的生命周期里长期存在，直到没有任何引用后才释放内存。 类摘要 shared_array构造函数接受的指针必须是new[]的结果 提供operator[]操作符重载 析构函数使用delete[]，释放资源 用法最好使用shared_ptr&lt;std::vector&gt; 或者 std::vector&lt;shared_ptr&gt;来替代","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"智能指针","slug":"智能指针","permalink":"http://www.casezheng.date/tags/智能指针/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库 内存管理 scoped_ptr scoped_array 2","slug":"boost-scoped-ptr","date":"2017-06-05T04:11:00.000Z","updated":"2020-04-12T04:56:35.907Z","comments":true,"path":"2017/06/05/boost-scoped-ptr/","link":"","permalink":"http://www.casezheng.date/2017/06/05/boost-scoped-ptr/","excerpt":"","text":"scoped_ptrscoped_ptr包装new操作符在堆上分配的动态对象，保证动态创建的对象在任何时候都可以被正确删除，scoped_ptr的所有权不能转让。 1. 类摘要1234567891011121314151617template&lt;class T&gt; class scoped_ptr // noncopyable&#123;private: T * px; scoped_ptr(scoped_ptr const &amp;); scoped_ptr &amp; operator=(scoped_ptr const &amp;); void operator==( scoped_ptr const&amp; ) const; void operator!=( scoped_ptr const&amp; ) const;public: explicit scoped_ptr( T * p = 0 ); ~scoped_ptr(); void reset(T * p = 0); T &amp; operator*() const; T * operator-&gt;() const; T * get() const; void swap(scoped_ptr &amp; b);&#125;; 2. 操作函数 构造函数接受类型为T*的指针p，创建scoped_ptr对象，并在内部保存指针参数p，p必须是一个new表达式动态分配的结果，或者是空指针(0)。当scoped_ptr生命周期结束，析构函数~scoped_ptr()会使用delete操作符自动销毁所保存的指针对象，回收资源。 scoped_ptr将靠白构造函数和赋值操作符声明为私有的，禁止对指针指针的复制操作，保证被它管理的指针不能被转让所有权。 reset()重置scoped_ptr，删除原来保存的指针，保存新的指针。reset()一般不应该被调用，因为违背了scoped_ptr一直由scoped_ptr自己自动管理的本意。 scoped_ptr用operator()和operator-&gt;()重载解引用操作符和箭头操作符-&gt;，模仿被代理的原始指针的行为。 swap()交换两个scoped_ptr保存的原始指针。 get()返回scoped_ptr内部保存的原始指针。 3. 使用123456789101112131415161718192021222324252627class A&#123;public: A() &#123; cout&lt;&lt;\"A ctor\"&lt;&lt;endl; &#125; ~ A() &#123; cout&lt;&lt;\"A dtor\"&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;\"A Print\"&lt;&lt;endl; &#125;&#125;;void TestScopedPtr()&#123; scoped_ptr&lt;A&gt; a1(new A()); cout&lt;&lt;a1.get()&lt;&lt;endl; //scoped_ptr&lt;A&gt; a2 = a1; //错误 a1-&gt;print(); (*a1).print();&#125; 4. 和auto_ptr的比较scoped_ptr不能作为容器的元素，因为不支持拷贝和赋值。 scoped_ptr和auto_ptr的根本区别在指针的所有权。auto_ptr被特意设计为指针的所有权是可以转移的，同一时刻只能有一个auto_ptr管理指针。scoped_ptr把拷贝构造函数和赋值函数声明为私有的，拒绝指针所有权的转让。 scoped_arrayscoped_array包装new[]操作符，在堆上动态分配数组，为动态数组提供代理，保证准确释放内存。 1. 类摘要123456789101112template&lt;class T&gt; class shared_array&#123;public: explicit shared_array( Y * p ); ~shared_array(); void reset(); T &amp; operator[] (std::ptrdiff_t i) const; T * get() const; void swap(shared_array&lt;T&gt; &amp; other);private: T * px;&#125;; 构造函数接受的指针p必须是new[]的结果; 析构函数使用delete[]释放资源，而不是delete; 提供operator[]操作符重载，可以像普通数组一样用下表访问元素。 2. 使用scoped_array和scoped_ptr设计思想相同，只能在被声明的作用域内使用，不能拷贝、赋值。 3. 建议scoped_array不能动态增长、没有迭代器支持、不能搭配STL算法，仅是纯粹的”裸”数组接口。在需要动态数组的时候使用std::vector会更好。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"智能指针","slug":"智能指针","permalink":"http://www.casezheng.date/tags/智能指针/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库 内存管理 智能指针概述 1","slug":"boost-smart-ptr-summary","date":"2017-06-05T03:11:00.000Z","updated":"2020-04-12T04:56:35.911Z","comments":true,"path":"2017/06/05/boost-smart-ptr-summary/","link":"","permalink":"http://www.casezheng.date/2017/06/05/boost-smart-ptr-summary/","excerpt":"","text":"智能指针库概述计算机系统中资源有很多种，内存、文件描述符、socket、数据库连接等，程序中申请资源后必须及时归还系统。 1. RAII机制C++程序员通常采用RAII机制(资源获取即初始化，Resource Acquisition Is Initialization)，在使用资源的构造函数中申请资源，使用后再析构函数中释放资源。栈上创建的局部对象，离开作用域后自动销毁，调用析构函数释放资源。用new从堆上创建的对象，必须明确地用对应的delete操作符销毁它。 2. 智能指针智能指针实践了代理模式，代理了原始的“裸”指针的行为，为它添加了更多更有用的特性。C++异常机制加入后，为了保证new对象在正确时机delete，必须编写大量的异常捕获代码释放资源，而智能指针能保证在退出作用域时，不论时正常流程或是异常退出，总调用delete析构堆上动态分配的对象，调用析构函数，释放资源。std::auto_ptr构造函数结构new操作符或者对象工厂创建出来的对象指针作为参数，代理原始指针，重载operator*和operator-&gt;，行为类似指针，可用在大多数普通指针可用的地方。当退出作用域时，C++语言保证auto_ptr对象销毁，调用auto_prt的析构函数，进而使用delete操作符删除原始指针释放资源。boost.smart_ptr提供六中智能指针：scoped_ptr、scoped_array、shared_ptr、shared_array、weak_ptr和intrusive_ptr，都是异常安全的。boost智能指针所指的类型T的唯一一个要求：析构函数不能抛出异常。boost智能指针位于名字空间boost 12#include &lt;boost/smart_ptr.hpp&gt;using namespace std 3. auto_ptr目前auto_ptr已不建议使用 auto_ptr不能共享所有权，即不能让两个auto_ptr指向同一个对象，在用auto_ptr给其它auto_ptr赋值时，原auto_ptr失去对裸指针的引用。 auto_ptr不能指向数组，因为auto_ptr在析构时只是调用delete，而数组应该调用delete[]。 auto_per不能作为容器对象，STL容器中的元素经常要支持拷贝、赋值操作，在拷贝和赋值时auto_ptr会转移所有权，原对象和拷贝的对象不等价。 使用auto_ptr作为成员变量，避免资源泄露。 123456789101112131415161718192021222324252627class A&#123;public: A() &#123; cout&lt;&lt;\"A ctor\"&lt;&lt;endl; &#125; ~ A() &#123; cout&lt;&lt;\"A dtor\"&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;\"A Print\"&lt;&lt;endl; &#125;&#125;;void TestAutoPtr()&#123; auto_ptr&lt;A&gt; a1(new A()); cout&lt;&lt;a1.get()&lt;&lt;endl; auto_ptr&lt;A&gt; a2 = a1; cout&lt;&lt;a1.get()&lt;&lt;endl; cout&lt;&lt;a2.get()&lt;&lt;endl;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"智能指针","slug":"智能指针","permalink":"http://www.casezheng.date/tags/智能指针/"},{"name":"stl","slug":"stl","permalink":"http://www.casezheng.date/tags/stl/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"fedora 安装配置记录","slug":"fedora25-to-configure","date":"2017-06-03T16:56:00.000Z","updated":"2020-04-12T04:56:35.906Z","comments":true,"path":"2017/06/04/fedora25-to-configure/","link":"","permalink":"http://www.casezheng.date/2017/06/04/fedora25-to-configure/","excerpt":"","text":"1.安装wget man手册12#yum install man-pages#yum install wget 2.安装yum源12345678# cd /etc/yum.repos.d# wget http://mirrors.163.com/.help/fedora-163.repo //(网易开源镜像)# wget http://mirrors.163.com/.help/fedora-updates-163.repo# wget http://mirrors.sohu.com/help/fedora-sohu.repo //(搜狐开源镜像)# wget http://mirrors.sohu.com/help/fedora-updates-sohu.repo# wget http://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/fedora?codeblock=0 //(中国科技大学开源镜像 下载后注意将名称更名为fedora-ustc.repo)# wget http://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/fedora?codeblock=1 //将名称改为fedora-updates-ustc.repo# yum makecache //(更新缓存) 3. 升级更新系统12345# yum update #升级所有包，改变软件设置和系统设置,系统版本内核都升级 刚开始软件系统配置都没有，选择第一种# yum upgrade #升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变（查看Linux版本的方法： #uname -r #查看当前linux系统的内核版本号 #uname -a #可以查看包括内核版本号、机器硬件信息、网络节点名、操作系统名字等信息 ） 4. 安装右键启动终端功能Nautilus-Open-Terminal 是一个让你随处都可以打开终端的nautilus插件。尤其是当你想在一个包含子目录的目录中对某个特定目录做命令行操作的时候，它特别有用。如果你安装了这个插件，那么你只需要做的就是右键点击这个目录，然后选择菜单项’在终端打开’。 1#yum install nautilus-open-terminal 5. 安装镜像选择工具，这个工具会从所有已配置的镜像中选择速度最快的下载fastestirror让yum在更新时先根据ping值进行判断，然后从最快响应的地址下载。 1#yum install yum-plugin-fastestmirror 注：安装priority yum的插件，用来设定安装软件时候软件仓库的优先级，一般是默认先从官方base或者镜像安装，然后从社区用户contribute的软件中安装，再从第三方软件仓库中安装。手动编辑 /etc/yum.repos.d/ 目录中后缀为.repo的文件来设置软件仓库的优先级， priority=N(N是整数，范围从1-99，数字越小代表优先级越高) 官方推荐配置是：[base], [addons], [updates], [extras] 这几部分 priority=1[centosplus],[contrib] 这几部分priority=21#yum install yum-priorities 6. 将用户添加到sudo用户组，取消sudo每次都输入密码的限制，需要root权限1# vim /etc/sudoers 找到root ALL=(ALL) ALL 在下一行加上 ‘username ALL=(ALL) ALL’ username 是要添加的用户名, 引号中的空格都为tab 每次sudo命令都提示是如根密码，移动到’#%wheel ALL=(ALL) ALL’ 这一行，去掉#注释，移动到’#%wheel ALL=(ALL)NOPASSWD:ALL’这一行，去掉#注释。保存后退出。 添加用户到wheel用户组1# usermod -G wheel username 7. 安装axelget插件axelget是一个多线程下载工具，yum本身是单线程下载, 安装方法： 1# yum install yum-axelget 注意：在YUM的时可能会遇到很长时间都没有速度的现象，可以Ctrl+C。终止从当前站点的下载，然后会自动选择其他站点下载，速度往往快很多。 8. 加入第三方源rpmfusion1234# wget http://download1.rpmfusion.org/free/Fedora/rpmfusion-free-release-stable.noarch.rpm# wget http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm#rpm -ivh rpmfusion-free-release-stable.noarch.rpm#rpm -ivh rpmfusion-nonfree-release-stable.noarch.rpm 9. 给LibreOffice安装中文字体1#yum install libreoffice-langpack-zh-Hans 10. 安装开发工具 vim gcc g++ cmake make python2 python3 lua cscope tags直接用yum安装 11. 创建SSH密钥 加入github 设置git1$ ssh-keygen -t rsa -C &quot;youremail&quot; 在~/.ssh下找到.pub文件，将其中的内容复制出来，打开github网站，并登陆，将其加入到github ssh keys中 测试下1$ ssh -T Git@github.com 再设置下github账户名和email 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 设置github参考另一篇文章’使git显示彩色’ 11.安装rz和sz命令1sudo yum install lrzsz 12.添加CentOS SCLo软件集合仓库1yum install centos-release-scl-rh centos-release-scl 13.安装man中文文档中文man手册1sudo yum install man-pages-zh-CN .bashrc加入别名alias cman=&#39;man -M /usr/share/man/zh_CN&#39; gnome扩展管理需要安装浏览器插件GNOME Shell integration，再使用yum安装chrome-gnome-shell，即可访问extensions.gnome.org/管理gnome插件1sudo yum install chrome-gnome-shell gnome扩展安装访问extensions.gnome.org/安装插件 gnome插件推荐 Applications Menu Coverflow Alt-Tab Dash to Dock Dynamic Top Bar NetSpeed System Monitor Window List AlternateTab Background Logo gnome优化插件1sudo yum install gnome-tweak-tool 可通过gnome优化工具打开窗口的最小化和最大化按钮可通过gnome优化工具管理安装的插件 参考资料 安装Fedora 20桌面版并配置（gnome桌面环境） Fedora 把用户添加到sudo用户组的方法 创建SSH密钥 Centos 7安装完成后需要做的事情 linux下man手册的安装和使用","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"boost 库实用工具singleton","slug":"boost-singleton","date":"2017-06-02T07:32:00.000Z","updated":"2020-04-12T04:56:35.903Z","comments":true,"path":"2017/06/02/boost-singleton/","link":"","permalink":"http://www.casezheng.date/2017/06/02/boost-singleton/","excerpt":"","text":"singletonsingleton即单件模式，单件模式的类在程序生命周期中只会存在一个且仅有一个实例。 Boost库没有专门的单件库，仅在其它库中有不完善的实现。 singlton_default的单件实现singlton_default泛型单件类。 12#include &lt;boost/container/detail/singleton.hpp&gt;using boost::container::container_detail::singleton_default; 类摘要123456template &lt;typename T&gt;struct singlton_default&#123; typedef T object_type; static object_type &amp; instance();&#125;; singlton_default把模版参数T实现为一个单件类，唯一实例只能通过静态成员函数instance()访问。在main()运行前创建单件。对类型T要求有缺省(无参)构造函数，构造和析构不能抛出异常，因为单件在main()前后构造和析构，发生异常无法捕获。 用法把想要成为单件的类作为singlton_default的模版参数。 12345678910111213141516171819202122232425using boost::container::container_detail::singleton_default;class TestSingletonDefault&#123;public: TestSingletonDefault() &#123; cout&lt;&lt;\"ctor\"&lt;&lt;endl; &#125; ~TestSingletonDefault() &#123; cout&lt;&lt;\"dtor\"&lt;&lt;endl; &#125; void print() &#123; cout&lt;&lt;\"singleton\"&lt;&lt;endl; &#125;&#125;;//singletonvoid TestSingleton()&#123; typedef singleton_default&lt;TestSingletonDefault&gt; origin; origin::instance().print(); return ;&#125; boost.serialzation的单件实现序列化库serialzation中单件实现类singleton。 12#include &lt;boost/serialization/singleton.hpp&gt;using boost::serialization::singleton; 类摘要1234567template &lt;typename T&gt;class singleton : public boost::noncopyable&#123;public: static const T&amp; get_const_instance(); static T&amp; get_mutable_instance();&#125;; singleton对模版参数要求有缺省构造函数，构造析构不抛异常。访问单件分为常对象和可变对象，常对象单件总是线程安全的，因为它不会改变内部状态，而可变对象则不是线程安全的，可能发生线程竞争问题。 用法 使用模版参数的方式。 通过继承的方法，把singleton作为单件类的基类，并把单件类作为singleton的模版参数。 1234567891011121314151617181920212223242526272829303132333435using boost::serialization::singleton;//singleton1void TestSingleton1()&#123; typedef singleton&lt;TestSingletonDefault&gt; origin; origin::get_const_instance().print(); //origin::get_mutable_instance().print(); return ;&#125;class TestSingletonClass: public singleton&lt;TestSingletonClass&gt;&#123;public: TestSingletonClass() &#123; cout&lt;&lt;\"ctor c\"&lt;&lt;endl; &#125; ~TestSingletonClass() &#123; cout&lt;&lt;\"dtor c\"&lt;&lt;endl; &#125; void print() const &#123; cout&lt;&lt;\"singleton\"&lt;&lt;endl; &#125;&#125;;//singleton2void TestSingleton2()&#123; TestSingletonClass::get_const_instance().print(); //TestSingletonClass::get_mutable_instance().print(); return ;&#125; 继承方式比模版方式实现单件更加彻底，使单件化的类成为真正的单件类，模版参数方式包装了被单件化的类，对原始类没任何影响。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库实用工具 swap","slug":"boost-swap","date":"2017-06-02T06:26:00.000Z","updated":"2020-04-12T04:56:35.904Z","comments":true,"path":"2017/06/02/boost-swap/","link":"","permalink":"http://www.casezheng.date/2017/06/02/boost-swap/","excerpt":"","text":"swapboost::swap是对标准库提供的std::swap的增强和泛化，未交换两个变量的值提供便捷的方法。 1#include &lt;boost/swap.hpp&gt; 原理std::swap()的经典实现。 1234567template&lt;typename T&gt;void swap(T&amp; a, T&amp; b)&#123; T tmp(a); a = b; b = tmp;&#125; std::swap()要求交换的对象必须是可拷贝构造和可拷贝赋值的，提供的是最通用效率最低的方法，需要进行一次拷贝构造和两次赋值操作。 boost::swap的工作原理: 直接利用函数重载，编写同名swap函数，调用类内部高效成员交换函数。 使用ADL(参数依赖查找)查找模版特化的swap。 boost::swap()函数声明:12template &lt;typename T1, typename T2&gt;void seap(T1 &amp;left, T2 &amp;right); 交换数组boost::swap交换数组使用for循环，对数组中每个元素调用但个元素版的boost::swap完成整个数组内容的交换。要求交换的数组必须具有相同长度，否则无法编译通过。 特化std::swap在std名字空间中添加自定义swap函数。 特殊ADL可找到的swapboost::swap会通过ADL规则找到特化的交换函数。 使用建议1234567891011121314151617181920212223242526272829303132333435363738class test&#123;public: void swap(test &amp;l) &#123; cout&lt;&lt;\"test swap\"&lt;&lt;endl; &#125;&#125;;void swap(test &amp;r, test &amp;l)&#123; r.swap(l);&#125;//swapvoid TestSwap()&#123; int x[10]; int y[10]; fill_n(x, 10, 5); fill_n(y, 10, 10); boost::swap(x, y); for_each(x, x+10, print&lt;int&gt;); for_each(y, y+10, print&lt;int&gt;); int x2[20]; int y2[10]; fill_n(x2, 20, 5); fill_n(y2, 10, 10); //boost::swap(x2, y2); //编译报错 test a; test b; std::swap(a, b); boost::swap(a, b); //会调用swap(test &amp;, test &amp;); return ;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库实用工具 assign","slug":"boost-assign","date":"2017-06-01T11:31:00.000Z","updated":"2020-04-12T04:56:35.888Z","comments":true,"path":"2017/06/01/boost-assign/","link":"","permalink":"http://www.casezheng.date/2017/06/01/boost-assign/","excerpt":"","text":"assignassign库重载赋值操作符、逗号操作符、括号操作符，用难以想象的简洁语法非常方便的对STL容器赋值或者初始化。 12#include &lt;boost/assign.hpp&gt;using namespace boost::assign; 1. 使用操作符+=向容器增加元素在使用assign库时必须使用using指示符，让重载的+=,等操作符在作用域内生效。+=操作符后可以接若干个可被容器容纳的元素，元素间用逗号分隔。对于map容器，必须用makr_pair()辅助函数生成容器元素。 2. 使用操作符()向容器增加元素assign库提供三个辅助函数insert()、push_front()、push_back(),可作用于同名成员函数的容器，接受容器变量作为参数，返回一个代理对象list_inserter,重载operator(),=等操作符实现向容器填入数据的功能。对于set和map只能使用assign::insert()。 3. 初始化容器元素list_of()函数返回一个匿名的列表，可以赋值给任意容器。map_list_of()和pair_list_of()，map_list_of()可以接受两个参数，自动构造std::pair对象插入map容器，pair_list_of和map_list_of用法功能完全相同。tuple_list_of()用于初始化元素类型为tuple的容器，tuple是Boost引入的一种新的容器/数据结构。 4. 减少重复输入repeat()将第二个参数作为要填入的值，重复第一个参数指定的次数。repeat_fun()将第二个参数作为要填入的值，重复第一个参数指定的次数，但第二个参数是无参的函数或函数对象，返回填入的数量。range()将一个序列全部或部分元素插入另一个序列里。 5. 与非标准容器工作assign支持8个STL标准容器(vector、string、deque、list、set、multiset、map、multimap)，也对STL中的适配器提供适当支持(stack、queue、priority_queue)。因为stack等容器适配器不符合容器定义，没有insert、push_back等成员函数，不能使用赋值方法填入元素，只能使用初始化的方式，并在list_of表达式最后使用to_adapter()成员函数来适配到非标准容器。如果使用逗号操作符需要把整个表达式用括号括起来，才能使用点号调用to_adapter()。assign支持部分不在STL中定期的非标准容器,因为它们符合容器的定义，用法和标准容器没什么区别。assign库从支持大部分Boost库容器，用法与标准容器类似。 6. 高级用法。list_of()的嵌套使用list_of()可以就地创建匿名列表，可以嵌套在assign库用法中，创建复杂的数据结构。 引用初始化列表ref_list_of()和cref_list_of()两个函数接受变量的引用作为参数创建初始化匿名列表。assign库支持Boost库中的指针容器，提供ptr_push_back()、ptr_list_of()等函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//assignvoid TestAssign()&#123; using namespace boost::assign; //向容器中增加元素 vector&lt;int&gt; v; v += 1, 2, 3, 4, 5, 6, 9*9; for_each(v.begin(), v.end(), print&lt;int&gt;); set&lt;string&gt; s; s += \"cpp\", \"md\"; for_each(s.begin(), s.end(), print&lt;string&gt;); map&lt;int, string&gt; m; m += make_pair(1, \"one\"), make_pair(2, \"two\"); for_each(m.begin(), m.end(), print&lt;pair&lt;int, string&gt;&gt;); push_back(v)(7)(8)(9); for_each(v.begin(), v.end(), print&lt;int&gt;); list&lt;string&gt; l; push_front(l)(\"cpp\")(\"java\"); for_each(l.begin(), l.end(), print&lt;string&gt;); set&lt;double&gt; sd; insert(sd)(1.1)(2.2)(3.3); for_each(sd.begin(), sd.end(), print&lt;double&gt;); insert(m)(3, \"t\")(4, \"f\"); for_each(m.begin(), m.end(), print&lt;pair&lt;int, string&gt;&gt;); push_back(v), 1, 2, 3, 4, 5; push_back(v)(6), 7, 8, (9), 10; for_each(v.begin(), v.end(), print&lt;int&gt;); //初始化容器元素 vector&lt;int&gt; vec = list_of(1)(2)(3)(4)(5); for_each(vec.begin(), vec.end(), print&lt;int&gt;); deque&lt;string&gt; deq = (list_of(\"one\")(\"two\"), \"t\", (\"f\")); for_each(deq.begin(), deq.end(), print&lt;string&gt;); map&lt;int, string&gt; mp = (list_of(make_pair(1, \"one\"))(make_pair(2, \"two\")), make_pair(3, \"t\")); for_each(mp.begin(), mp.end(), print&lt;pair&lt;int, string&gt;&gt;); map&lt;int, string&gt; mp2 = map_list_of(1, \"cpp\")(2, \"java\"); for_each(mp2.begin(), mp2.end(), print&lt;pair&lt;int, string&gt;&gt;); //减少重复输入 vector&lt;int&gt; v2 = list_of(1).repeat(3, 100).repeat(4, 1000); for_each(v2.begin(), v2.end(), print&lt;int&gt;); vector&lt;int&gt; v3; push_back(v3).range(v.begin(), v.begin()+5); for_each(v3.begin(), v3.end(), print&lt;int&gt;); stack&lt;int&gt; stk = (list_of(1), 2, 3).to_adapter(); queue&lt;string&gt; q = (list_of(\"java\")(\"md\")(\"c\")).to_adapter(); vector&lt;vector&lt;int&gt;&gt; vv; vv += list_of(5)(6), list_of(7)(8); int a = 1, b = 2, c = 3; vector&lt;int&gt; v4 = ref_list_of&lt;3&gt;(a)(b)(c); for_each(v4.begin(), v4.end(), print&lt;int&gt;); return ;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"C++11 初探","slug":"cplusplus11","date":"2017-06-01T11:11:00.000Z","updated":"2020-04-12T04:56:35.890Z","comments":true,"path":"2017/06/01/cplusplus11/","link":"","permalink":"http://www.casezheng.date/2017/06/01/cplusplus11/","excerpt":"","text":"C++11 列表初始化 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。 定义一个int变量并初始化 12345678910int a = 0;int a = &#123;0&#125;;int a(0);int a&#123;0&#125;;int b[] = &#123;1, 2, 3&#125;;int b[]&#123;1, 2, 3&#125;;int c(3.1234567); //警告, 编译器会有警告信息int c&#123;3.1234567&#125;; //错误，编译器会报错 初始化对象或者给对象赋新值，都可以使用一组由花括号括起来的初始值。 当用于内置类型的变量时，这种初始化方式存在一个重要特点：如果使用列表初始化且初始值存在丢失信息的风险，则编译器会报错。 C++11 constexpr 变量 将变量声明为constexpr类型以便由编译器来检验变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，这些类型称为”字面值类型” 算数类型、引用和指针都属于字面值类型。指针和引用定义为constexpr，它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 在constexpr定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。 12const int *p = nullptr; //p是一个指向整型常量的指针 *p不可改变 p可以改变constexpr int *q = nullptr; //q是一个指向整数的常量指针 等同于 int * const q = nullptr; *q可以改变 q不可改变 C++11 nullptr 空指针不指向任何对象。 生成空指针的方法： 1234int *p = nullptr;int *p = 0;//需要包含cstdlib头文件int *p = NULL; nullptr是一种特殊类型的字面值，可以被转化成任意其他的指针类型。 NULL欲处理变量在cstdlib中定义，实际值就是0，因此用NULL初始化指针和用0初始化是一样的。新标准下最好使用nullptr，同时尽量避免使用NULL。 C++11 类型别名 类型别名是一个名字，它是某种类型的同义词。使用类型别名可以使复杂的类型名字简单明了、易于理解和使用，有助于程序员清楚的知道使用该类型的真实目的。 两种定义类型别名的方法： typedef 别名声明 using12typedef double mydouble;using mydouble = double; 指针、常量和类型别名 123typedef char *pstring;const pstring cstr = 0; //cstr的类型为 char *const 而不是 const char*const pstring *ps; //ps的类型为 char *cosnt* 而不是 const char** C++11 auto auto类型说明符，让编译器分析表达式所属的类型。auto让编译器通过初始值类推算变量的类型。auto定义的变量必须有初始值。 使用引用其实是使用引用的对象，此时编译器以引用对象的类型做为auto的类型。 auto一般会忽略顶层const, 底层const则会保留下来。如果需要推断出的auto类型是一个顶层const，需要明确指出。 123456789101112131415161718int i = 0, &amp;r = i;auto a = r; // int aconst int ci = i, &amp;cr = ci;auto b = ci; // int b = ci;auto c = cr; // int c = cr;auto d = &amp;i; // int *d = &amp;i;auto e = &amp;ci; // const int *e = &amp;ci;const auto f = ci; // const int f = ci;auto &amp;g = ci; // const int &amp;g = ci;//auto &amp;h = 42; 错误，不能为非常量引用绑定字面值const auto &amp;j = 42; // const int &amp;j = 42;auto k = ci, &amp;l = i; // int k = ci, &amp;l = i;auto &amp;m = ci, *p = &amp;ci; // const int &amp;m = ci, *p = &amp;ci;//auto &amp;n = i, *p2 = &amp;ci; 错误，i的类型是int，而&amp;ci的类型为const int","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"Redis数据库对象大概介绍","slug":"redis-object-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.897Z","comments":true,"path":"2017/06/01/redis-object-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-object-note/","excerpt":"","text":"Redis 笔记 对象对象的类型与编码 Redis使用对象来表示数据库中的键和值。每次在Redis的数据库中新常见键值对时，至少会创建两个对象，一个对象用作键值对的键，另一个用作键值对的值。 Redis中每个对象都会由一个redisObject结构表示：1234567typedef struct redisObject &#123; unsigned type:4; //类型 unsigned encoding:4; //编码 unsigned lru:LRU_BITS; //对象最后一次被命令程序访问的时间 int refcount; //引用计数 void *ptr; //指向底层实现数据结构的指针&#125; robj; 类型 对象的type属性记录的对象的类型 12345#define OBJ_STRING 0 //字符串对象 string#define OBJ_LIST 1 //列表对象 list#define OBJ_SET 2 //哈希对象 hash#define OBJ_ZSET 3 //集合对象 set #define OBJ_HASH 4 //有序集合对象 zset 对于redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。 TYPE命令返回的结果为数据库键队形的值对象的类型，而不是键对应的类型。 编码和底层实现 对象的ptr指针指向对象的底层实现数据结构，数据结构由对象的encoding属性决定 使用OBJECT ENCODING命令可以查看一个数据库键的值的编码。 通过encoding属性设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大的提高了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码,从而优化在某个场景下的效率。1234567891011#define OBJ_ENCODING_RAW 0 /* 简单动态字符串 Raw representation */#define OBJ_ENCODING_INT 1 /* long类型的整数 Encoded as integer */#define OBJ_ENCODING_HT 2 /* 字典 Encoded as hash table */#define OBJ_ENCODING_ZIPMAP 3 /* Encoded as zipmap */#define OBJ_ENCODING_LINKEDLIST 4 /* 双端链表 Encoded as regular linked list */#define OBJ_ENCODING_ZIPLIST 5 /* 压缩列表 Encoded as ziplist */#define OBJ_ENCODING_INTSET 6 /* 整数集合 Encoded as intset */#define OBJ_ENCODING_SKIPLIST 7 /* 跳跃表和字典 Encoded as skiplist */#define OBJ_ENCODING_EMBSTR 8 /* embstr编码的简单动态字符串 Embedded sds string encoding */#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */ 字符串对象 字符串对象的编码可以是int，raw或者embstr 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串结构的pr属相里面(将void*转换为long)，并将字符串对象的编码设置为int。 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串来保存这个字符串值，变鬼将对象的编码设置为raw 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串数组将使用embstr编码的方式来保存这个字符串值。embstr是专门用来保存短字符串的一种优化编码方式，它和raw编码一样都是用redisObjct结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来得到一块连续的空间，空间中依次包含redisObjec和sdshdr两个结构。 1234|-------------------------------|------------------||---------redisObject-----------|-------sdshdr-----|| type | encoding | ptr | ... | free | len | buf ||-------------------------------|------------------| 使用embstr编码的字符串对象保存短字符串的好处： 分配内存次数由两次降低为1次 释放内存次数有两次降低为1次 数据在一个连续的内存里面，可以更改好地利用缓存带来的优势。 用long double类型表示的浮点数在Redis中做为字符串值来保存。保存一个浮点数到字符串对象里面，先把浮点数转化为字符串值，在保存转化的字符串。如果需要对保存的浮点数进行某种操作，先将其转化为浮点数，操作后再转化为字符串值，再保存到字符串对象中。 编码的转化 int编码和embstr编码的字符串对象在条件满足的条件下会被转化为raw编码的字符串对象。 embstr编码的字符串是只读的，对embstr编码的字符串进行任何修改命令时，程序先将编码从embstr转为raw，再执行修改命令。因此embstr编码的字符串对象在执行修改命令后，会变成一个raw编码的字符串对象。字符串命令的实现 因为字符串键的值为字符串对象，所有用于字符串键的所有命令都是针对字符串对象来构建的。 列表对象 列表对象的编码可以是ziplist或者linkedlist ziplist编码的列表对象使用压缩列表做为底层实现，每个压缩列表节点保存一个列表元素。 linkedlist编码的列表对象使用双端链表做为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表对象。 字符串对象是Redis五种类型的对象中唯一一个会被其他四种类型对象嵌套的对象。编码转换 当列表对象同时满足以下两个条件时，列表对象使用ziplist编码： 列表对象保存的所有字符串元素的长度都小于64字节； 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。 对于使用ziplist编码的列表对象，以上两个条件任意一个不被满足就会进行编码转化。列表命令的实现 因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的。 哈希对象 哈希对象的编码可以是ziplist或者hashtable ziplist编码的哈希对象使用压缩列表做为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了之的压缩列表节点推入到压缩列表表尾，因此：保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；先添加到哈希对象的键值对会被放在压缩列表的表头方向，而后面添加的哈希对象会被放在压缩列表的表尾方向。 hashtable编码的哈希对象使用字典做为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：字典的每个键都是一个字符串对象，对象中保存了键值对的键；字典中的每个值都是一个字符串对象，对象中保存了键值对的值。编码转化 当哈希对象同事满足以下两个条件时，哈希对象使用ziplist编码： 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节； 哈希对象保存的键值对数量小于512个； 不能满足这两个条件的哈希对象需要使用hashtable编码。 对使用ziplist编码的哈希对象来说，当以上两个条件任意一个不满足时，对象的编码转换操作就会被执行。哈希命令的实现 因为哈希键的值为哈希对象，所有用户哈希键的所有命令 集合对象 集合对象的编码可以是intset或者hashtable intset编码的集合对象使用整数集合做为底层实现，集合对象包含的所有元素都被保存在整数集合里面。 hashtable编码的集合对象使用字典做为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL编码转换 当集合对象同事满足以下两个条件时，对象使用intset编码： 集合对象保存的所有元素都是整数值 集合对象保存的额元素数量不超过512个。不满足这两个条件的集合对象需要使用hashtable编码 对使用intset编码的集合对象来说，当以上两个条件任意一个不满足时，对象的编码转换操作就会被执行。集合命令的实现 因为集合键的值为集合对象，所有用于集合键的所有命令都是针对集合对象来构建的。 有序集合对象 有序集合的编码可以是ziplist或者skiplist ziplist编码的压缩列表对象使用压缩列表做为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员, 第二个元素保存元素的分值。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。 skiplist编码的有序集合对象使用zset结构做为底层实现，一个zset结构同事包含一个字典和一个跳跃表 1234typedef struct zset &#123; dict *dict; zskiplist *zsl;&#125; zset; zset结构中的zsl跳跃表按照分值从小到大保存了所有结合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过跳跃表可以对有序集合进行范围型操作。 zset结构镇南关的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过字典。可以用O(1)复杂度查找给定成员的分值。 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。虽然zset结构同事使用跳跃表和字典保存有序集合元素，但这两种数据结构都会通过指针共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会浪费额外内存。 编码转换 当有序集合对象同事满足以下两个条件时。对象使用ziplist编码： 有序集合保存的元素数量小雨128个； 有序集合保存的所有元素成员的长度小于64字节； 不满足以上两个条件的有序集合对象使用skiplist编码。对于使用ziplist编码的有序集合对象，不满足以上任意一条时就会执行对象的编码转化操作。有序集合实现 因为有序集合键的值为哈希对象，所以对于有序集合键的所有命令都是针对哈希对象来构建的。 类型检查与命令多态 Redis中用于操作键的命令基本分为两种类型。 对任何类型的键操作 如:del、expire、type等 对特定类型的键操作 如:set、sadd、hdel等类型检查的实现 为了确保支队特定类型的键执行某些特定命令，在执行一个类型特定命令前，Redis会对键的类型进行检查。 类型特定命令进行的类型检查是通过redisObject结构的type属性来实现的。在执行一个类型特定命令前，服务器先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话服务器就对键执行指点的命令，否则服务器拒绝执行命令，并向客户端返回类型错误。多态命令的实现 Redis会根据值对象的编码方式，选择正确的命令实现代码来执行命令。 内存回收 Redis构建了一个引用计数技术实现的内存回收机制，在适当的时候自动释放对象并进行内存回收。 每个对象的引用计数信息由redisObject结构的refcount属性记录。 对象引用计数信息随着对象的使用状态而不断变化： 创建一个新对象，引用计数初始化为1 被新引用，引用计数新增1 不再被引用, 引用计数减1 引用计数为0时，对象被释放 对象共享 Redis只会对包含整数值的字符串对象进行共享。因为要共享一个对象先要检查给定对象和新创建的对象是否完全相同，而一个对象保存的值约复杂。验证共享对象与目标对象相同所需的复杂度就越高，消耗的CPU时间也就越多。 对象的空转时长 redisObject结构lru属性记录了对象最后一次被命令程序访问的时间。 OBJECT IDLETIME命令可以打印出给定键的空转时长。空转时长是通过当前时间减去对象的lru时间计算得出的。 OBJECT IDLETIME命令不会修改值对象的lru属性。 当服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，当服务器占用的内存超过maxmemory选项设置的上限值时，空转时长较高的那部分键会有限被服务器释放。","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库压缩列表大概介绍","slug":"redis-ziplist-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.902Z","comments":true,"path":"2017/06/01/redis-ziplist-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-ziplist-note/","excerpt":"","text":"Redis ziplist 笔记 压缩列表简介 压缩列表是列表键和哈希键的底层实现之一。 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。 当一个哈希键只包含少量列表项，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键键的底层实现。 压缩列表的构成 压缩列表是Redis为了节约内存而开发的，是一些列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。123|----------------------------------------------------------------------|| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend ||----------------------------------------------------------------------| zlbytes uint32_t 4字节 记录整个压缩列表所占的内存字节数:在对压缩列表进行内存重分配, 或者计算zlend的位置时使用。 zltail uint32_t 4字节 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 zllen uint16_t 2字节 记录压缩列表包含的节点数量：当这个属性小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量；当这个值等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表计算得出。 entryX 列表节点 不定 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。 zlend uint8_t 1字节 特殊值0xFF，用于标记压缩列表的末端。 压缩列表节点的构成 每个压缩列表节点可以保存一个字节数组或者一个整数值。 字节数组可以以下三种长度中的其中一种： 长度小于等于2^6-1字节的字节数组 长度小于等于2^14-1字节的字节数组 长度小于等于2^32-1字节的字节数组 整数值可以是以下6种长度中的其中一种： 4位长，介于0-12之间的无符号整型 1字节长的有符号整型 3字节长的有符号整型 int16_t类型整数 int32_t类型整数 int64_t类型整数123|--------------------------------------------|| previous_entry_length | encoding | content ||--------------------------------------------| previous_entry_length previous_entry_length属性以字节为单位，记录压缩列表中前一个节点的额长度。previous_entry_length属性的长度可以是1字节或者5字节。当前一个节点的长度小于254字节，previous_entry_length属性长度为1字节。当前一个节点的长度大于等于254字节，previous_entry_length属性长度为5字节，其中第一个字节设置为0xFE，后面四个字节保存前一节点长度。 encoding encoding记录节点的content属性所保存数据的类型以及长度 content content负责保存节点的值 连锁更新 添加新节点到压缩列表或者从压缩列表删除节点都可能引发连锁更新操作，但这种操作出现几率并不高。 ziplistPush、ziplistInsert、ziplistDeleteRange、ziplistDelete如果发生了连锁更新最坏时间复杂度为O(N^2), ziplistPush等命令平均时间复杂度为O(N)","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库链表大概介绍","slug":"redis-list-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.896Z","comments":true,"path":"2017/06/01/redis-list-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-list-note/","excerpt":"","text":"Redis list 笔记链表和链表节点的实现 在adlist.h中listNode结构表示链表节点 123456typedef struct listNode&#123; struct listNode *prev; //前置节点 struct listNode *next; //后置节点 void *value; //节点的值&#125;listNode; 在adlist.h中list结构表示链表头 123456789typedef struct list&#123; listNode *head; //表头节点 listNode *tail; //表尾节点 void *(*dup)(void *ptr); //节点值复制函数 void (*free)(void *ptr); //节点值释放函数 int (*match)(void *ptr, void *key); //节点值对比函数 unsigned long len; //链表所含节点数量&#125;list; Redis链表的特点 双端:链表节点有前后指针，找到一个节点前置节点和后置节点的复杂度都是O(1) 无环:表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 表头保存了表头指针和表尾指针，程序获取链表头节点和尾节点的复杂度为O(1) 表头保存了链表长度，获取链表长度的操作复杂度为O(1) 通过(void*) 保存节点值，可以保存不同类型的值，带有dup，free，match属性，为节点值设置类型特定函数。","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库跳跃表大概介绍","slug":"redis-skiplist-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.898Z","comments":true,"path":"2017/06/01/redis-skiplist-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-skiplist-note/","excerpt":"","text":"Redis skiplist 跳跃表 笔记跳跃表简介 skiplist 是一种有序数据结构, 通过在每个节点维持多个指向其它节点的指针，达到快速访问节点的目的。 skiplist 支持平均O(logN)、最坏O(N)复杂度的节点查找。大部分情况下和平衡树相媲美，并且比平衡树实现简单。 redis使用skiplist做为有序集合键的底层实现之一。 跳跃表实现1234567891011121314151617181920212223242526typedef struct zskiplistNode &#123; //跳跃表节点 robj *obj; //所保存的成员对象 在同一个跳跃表中，各个节点保存的成员对象 //必须是唯一的，但各个节点保存的分值却可以是相同的，分值相同 //的节点按成员对象在字典序中的大小来进行排序。 double score; //分值 跳跃表中，节点按各自所保存的分值从小到大排列 struct zskiplistNode *backward; //后退指针，指向位于当前节点的前一个节点。 //后退指针在程序从表尾向表头遍历时使用 struct zskiplistLevel &#123; struct zskiplistNode *forward; //前进指针, 用于从表头向表尾方向访问节点。 unsigned int span; //跨度, 用于记录两个节点之间的距离。两个节点之间的跨 //度越大，他们相聚得就越远。指向NULL的所有前进指针的 //跨度都为0, 因为它们没有连向任何节点。跨度用于计算 //排位，在查找某个节点的过程中，将沿途访问过的所有曾 //的跨度累计起来，得到的结果就是目标节点在跳跃表中的排名。 &#125; level[]; //层 包含多个元素，每个元素包含一个指向其它节点的指针， //程序可以通过这些层加快访问其它节点的速度, 一般来说，层 //的数量越多，访问其它节点的速度就越快。每次创建新跳跃表 //节点的时候，程序根据幂次定律随机生成一个介于1到32之间的值 //做为levle数组的大小，这个大小就是层的\"高度\"&#125; zskiplistNode;typedef struct zskiplist &#123; //跳跃表节点相关信息 struct zskiplistNode *header, *tail; //指向跳跃表表头节点和表尾节点 unsigned long length; //跳跃表的长度，即跳跃表目前包含节点的数量 int level; //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)&#125; zskiplist;","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库整数集合大概介绍","slug":"redis-intset-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.894Z","comments":true,"path":"2017/06/01/redis-intset-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-intset-note/","excerpt":"","text":"Redis intset 整数集合 笔记 整数集合是集合键的底层实现之一，当一个集合值包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合做为集合键的底层实现。 整数集合的实现 整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。 每个intset.h/intset结构表示一个整数集合： 123456789#define INTSET_ENC_INT16 (sizeof(int16_t))#define INTSET_ENC_INT32 (sizeof(int32_t))#define INTSET_ENC_INT64 (sizeof(int64_t))typedef struct intset &#123; uint32_t encoding; //编码方式 uint32_t length; //集合包含的元素数量 即contents数组的长度 int8_t contents[]; //保存元素的数组 整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大排序，并且数组中不包含任何重复项。&#125; intset; contents结构类型声明为int8_t，但实际上contents不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值。encoding的值可以是INTSET_ENC_INT16,INTSET_ENC_INT32,INTSET_ENC_INT64。 升级 当添加一个新元素到整数集合里面，并且新的类型比集合现有所有元素的类型都长时，整数集合需要升级，然后将新元素添加到整数集合里面。 升级整数集合三步进行 根据新元素类型，扩展整数集合底层数组空间大小，并为新元素分配空间 将底层数组现有元素转换成与新元素相同的类型，并将类型转化后的元素放在争取的位上，在放置元素的过程中，需要继续维持底层数组的有序性质不变。 将新元素添加到底层数组里面。 想整数集合添加新元素的时间复杂度为O(N) 升级的好处1. 提高数组集合操作的灵活性, C语言为静态类型语言，为了避免类型错误，通常不会将两种不同类型的值放在同一个数据结构中。整数集合通过自动升级底层数组来适应新元素，所以我们可以随意将int16_t, int32_t, int64_t类型的整数添加到集合中，而不必担心类型错误。 2. 尽可能节约内存 整数数组不支持降级，一旦对数组进行了升级，编码会一直保持升级后的状态。","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库string SDS大概介绍","slug":"redis-string-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.900Z","comments":true,"path":"2017/06/01/redis-string-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-string-note/","excerpt":"","text":"Redis string 笔记 简单动态字符串SDS简介 Redis没有使用C语言传统的字符串(以空格结尾的字符串数组)表示，而是自己构建了一种简单动态字符串(SDS)的抽象类型，并将SDS作为Redis的默认字符串表示。 Redis中C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方。当Redis需要的是一个可以修改的字符串值时，Redis会使用SDS来表示字符串值。 SDS定义 在sds.h中每一个sdshdr结构体表示一个SDS值。 1234567struct sdshdr&#123; uint32_t len; //字符串长度 uint32_t alloc; //分配的buf长度 unsigned char flag; //sds标记 低三位用于标记sds类型 高五位未使用 char buf[]; //保存C字符串 会在末尾处加&apos;\\0&apos;&#125;; SDS和字符串的区别常数复杂度获取字符串长度 C字符串不记录字符串长度，获取字符串长度时需要遍历,时间复杂度O(N)。SDS记录了字符串长度，获取字符串长度时间复杂度为O(1)。 杜绝缓冲区溢出 C字符串不记录字符串长度，那么字符串拼接等操作不会检查缓冲区的大小，而SDS会检查缓冲区大小，如果不足会自动扩充，防止缓冲区溢出。C字符串API不安全可能会造成缓冲区溢出，SDS API是安全的。 减少修改字符串时带来的内存重分配次数 C字符串每次增长或缩短都会牵扯到内存的重新分配和释放。SDS通过生成字符串时预分配空间、惰性释放空间对其进行优化。C字符串修改N次字符串长度必然执行N次内存分配，SDS修改字符串长度N次最多执行N次内存分配。 二进制安全 C字符串只能保存文本数据，不能保存用空字符分割多个单词的特殊数据结构。SDS保存的是二进制数据。 兼容部分C字符串函数 SDS在保存数据时总是多分配一个字节存放’\\0’，让保存文本数据的SDS重用一部分C字符串库函数，避免代码重复。","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"Redis数据库字典大概介绍","slug":"redis-dict-note","date":"2017-06-01T10:52:00.000Z","updated":"2020-04-12T04:56:35.893Z","comments":true,"path":"2017/06/01/redis-dict-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/redis-dict-note/","excerpt":"","text":"Redis dict 笔记字典的实现 Redis的字典使用哈希表作为底层实现。 hash表 Redis的hash表有dict.h中的dictht结构定义。1234567typedef struct dictht&#123; dictEntry **table; //哈希表数组 unsigned long size; //哈希表大小 unsigned long sizemask; //哈希表大小掩码 用于计算索引值 总是等于size-1 unsigned long used; //表示已有节点的数量&#125; hash表节点 Redis的hash表节点在dict.h中定义1234567891011typedef stuct dictEntry&#123; void *key; //键 union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; //值 struct dictEntry *next; //指向下一个hash表节点 形成链表 开链法解决hash冲突&#125; 字典 Redis中的字典在dict.h中由dict结构表示12345678910111213141516171819202122typedef struct dict &#123; dictType *type; //类型特点函数 void *privdata; //私有数据 保存需要传给类型特定函数的可选参数 dictht ht[2]; //hash表 一般使用ht[0] ht[1]用于rehash long rehashidx; //rehash索引 记录rehash进度 当rehash不在进行时,值为-1 int iterators; // number of iterators currently running&#125; dict;//保存用于操作特定类型键值对的函数typedef struct dictType &#123; //hash值计算函数 unsigned int (*hashFunction)(const void *key); //复制键函数 void *(*keyDup)(void *privdata, const void *key); //复制值函数 void *(*valDup)(void *privdata, const void *obj); //对比键函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); //销毁键函数 void (*keyDestructor)(void *privdata, void *key); //销毁值函数 void (*valDestructor)(void *privdata, void *obj);&#125; dictType; 哈希算法 键位冲突 rehash 先使用hashFunction函数算出hash值，再由hash值算出索引值，索引冲突使用开链法解决。当字典被用作数据库的底层实现或hash键的底层实现时，Redis使用MurmurHash算法计算键的hash值 该算法优点在于即使输入的键有规律, 仍然可以给出很好的随机分布性, 并且算法的计算速度也很快。 hash表保存的值会随操作不断变大或变小，为了让hash表的负载因子在合理范围，需要对hash表rehash。扩展操作后的大小为 第一次大于等于used*2的2^n（2的n次幂）。缩小操作后的大小为 第一次大于等于used的2^n（2的n次幂） rehash 在ht[0]和ht[1]中渐进进行，即每次操作时才rehash ht[0]中的键到ht[1]等ht[0]空了 就可以将ht[0]释放将ht[1]设置ht[0],然后为ht[1]重新生成空hash表,为下次rehash做准备. hash表负载因子计算 负载因子=ht[0].used/ht[0].size hash表扩展操作 当服务器当前没有执行BGSAVE命令或者BGREWRITEAOF命令, 并且hash表的负载大于等于1 当服务器当前执行BGSAVE命令或者BGREWRITEAOF命令, 并且hash表的负载大于等于5 hash表收缩操作 hash表负载因子小于0.1","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"redis数据库详细介绍","slug":"db-redis-note","date":"2017-06-01T10:51:00.000Z","updated":"2020-04-12T04:56:35.892Z","comments":true,"path":"2017/06/01/db-redis-note/","link":"","permalink":"http://www.casezheng.date/2017/06/01/db-redis-note/","excerpt":"","text":"Redis是key-value数据库 Redis优势 高性能,数据存在内存 支持多种数据结构(字符串,列表,哈希表,集合,有序集合) 单个操作和多个操作(MULTI和EXEC执行包裹)均支持事物,即原子性 支持发布订阅 支持key过期(秒和毫秒),过期key删除有惰性删除和定期删除两种策略 支持持久化(数据保存到磁盘), RDB(保存快照,有数据丢失风险,但恢复快,文件小,性能消耗低(会fork子进程进行备份,对父进程性能无影响))和AOF(保存操作日志,数据完整,但恢复慢,文件大(有优化策略,可能合并多个操作),性能消耗大) 支持主从 服务器中的数据库 Redis服务器将所有数据库保存在服务器状态server.h/redisServer结构的db数组中，db数组中每个项是一个server.h/redisDb结构，每个redisDb结构代表一个数据库。 1234567struct redisServer &#123; //... redisDb *db; // 一个数组，保存着服务器中的所有数据库 数组大小为dbnum //... int dbnum; // 服务器的数据库数量 由服务器配置的database选项决定 默认情况下该值为16 //...&#125;; 初始化服务器时，程序更具服务器状态的dbnum属性决定创建多少个数据库。dbnum属性的值有服务器配置的database选项决定。该值默认是16，所以Redis数据库默认情况下会创建16个数据库。 切换数据库 每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或读命令的时候，目标数据库就会成为这些命令的操作对象。 默认情况下，Redis客户端的目标数据库为0号数据库。使用SELECT命令切换数据库。在客户端状态client结构的db属性中记录了客户端当前的目标数据库。client.db指针指向redisServer.db数组中的其中一个元素，被指向的元素就是客户端的目标数据库。通过修改client.db指针，让它指向服务器中的不同数据库，实现切换目标是数据库的功能，这就是SELECT命令的实现原理。 12345typedef struct client &#123; //... redisDb *db; // 记录客户端目前的目标数据库 //...&#125; client; Redis没有返回客户端目标数据库的命令。如果使用多数据库，那么最好每次在执行危险操作时，先显示地切换到指定的数据库，然后才执行别的命令。 数据库键空间 Redis是一个键值对数据库服务器，服务器中的每个数据库都由server.h/redisDb结构表示。redisDb结构的dict字典保存了数据库中的所有键值对, 称为键空间。 键空间和用户所见的数据库直接对应： 键空间的键即数据库的键，每个键都是一个字符串对象。 键空间的值即数据库的值，每个值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象中的任意一种Redis对象。 添加新键 添加一个新键值对到数据库，实际就是将一个新键值对添加到键空间字典里面。 删除键 删除数据库中的一个键，实际上就是在键空间里面删除键对应的键值对对象。 更新键 对一个数据库键进行更新，实际上是对键空间里面键对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也有所不同。 对键取值 对一个数据库键取值，实际就是去除键所对应的值对象，根据值对象的类型不同，具体的取值方法也不同。 其它键空间操作读写键空间时的维护操作 当使用Redis命令对数据库进行读写操作时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作： 读取一个键之后(读操作和写操作)，服务器会根据键释放存在来更新服务器的键空间命中次数和不命中次数，这两个值在INFO stats命令的keyspace_hits属性和keyspace_misses属性中可查看。 读取一个键之后，服务器会更新键的LRU(最后一次使用)时间，用于计算键的闲置时间，使用OBJECT idletime 命令可以查看键的闲置时间。 服务器读取一个键，发现这个键过期了，会先删除这个过期键，在执行余下的操作。 如果客户端使用WATCH命令监视了某个键，服务器会对被监视的键进行修改后标记为脏，让事物注意到这个键已经被修改。 服务器每修改一次键，都会对脏键计数器的值增1，该计数器会触发服务器的持久化以及复制操作。 如果服务器开启了数据库通知功能，那么键更新后服务器会按照配置发送相应的数据库通知。 设置键的生存时间或过期时间 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间(TTL)，在经过指定时间后，服务器会自动删除生存时间为0的键。 通过EXPIREAT命令或者PEXPIREAT命令，客户端可以以秒或者毫秒精度给数据库中的某个键设置过期时间，过期时间是一个UNIX时间戳，当键的过期时间来临，服务器就会自动删除这个键。 TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，即该键被服务器自动删除还有多长时间。 设置过期时间 Redis有四个不同命令用于设置键的生存时间或过期时间。 EXPIPE 命令用于键key的生存是假设置为ttl秒 PEXPIPE 命令用于键key的生存是假设置为ttl毫秒 EXPIPEAT 命令用于将键key的过期时间设置为timestamp所制定的秒数时间戳 PEXPIPEAT 命令用于将键key的过期时间设置为timestamp所制定的毫秒数时间戳 EXPIPE、PEXPIPE、EXPIPEAT最终都会转化为PEXPIPEAT命令。 保存过期时间 redisDb结构的expires字典保存了数据库中所有键的过期时间，称为过期字典 过期字典的键是一个指针，指向键空间中的某个键对象 过期字典的值是一个long long类型的整数，保存了键所指向的数据库键的过期时间(一个毫秒精度的UNIX时间戳)。 当客户端执行PEXPIREAT命令(或其它三个命令)为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。 移除过期时间 PERSIST命令移除一个键的过期时间，PERSIST命令是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。 计算并返回剩余生存时间 TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间，这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。 过期键的判定 通过过期字典，1.检查给定键是否存在于过期字典，如果存在，取得键的过期时间，2.检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则键未过期。 Redis的过期键删除策略 Redis实际使用惰性删除和定期删除两种过期键删除策略。 惰性删除策略的实现 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：1.如果输入键已经过期，expireIfNeeded函数将输入键从数据库中删除。2.如果输入键未过期，expireIfNeeded函数不做动作。定期删除策略的实现 过期键的定期删除策略由server.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作server.c/serverCron函数执行时，activeExpireCycle函数就会被调用，在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。 activeExpireCycle函数的工作模式如下： 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键 全局变量current_db记录当前activeExpireCycle函数检查的进度，并在下次activeExpireCycle函数调用时从上次的进度进行处理。 当服务器中所有数据库都被检查一遍，current_db变量重置为0，然后再开始下一轮的检查。 AOF、RDB和复制功能对过期键的处理生成RDB文件 执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。 载入RDB文件 启动服务器时，如果服务器开启RDB功能，服务器将对RDB文件进行载入 服务器以主服务器模式运行，载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入数据库，过期键会被忽略。 服务器以从服务器模式运行，载入RDB文件时，文件中保存的所有键都会被载入数据库。因为主从服务器进行数据同步时，从服务器数据库会被清空，所以过期键对载入RDB文件的从服务器不会造成影响。 AOF文件写入 当服务器以AOF持久化模式运行时，如果数据中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或定期删除后，程序会向AOF文件追加一条DEL命令，来显示记录该键已被删除。 AOF重写 在执行AOF重写的过程中，程序对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。 复制 当服务器运行在复制模式下时，从夫妻的过期键删除动作由主服务器控制： 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。 从服务器在执行客户端发送的读命令时，即使碰到过期键也不删除，而是继续像处理未过期键一样来处理过期键。 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。 数据库通知 该功能让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。 关注某个键执行了什么命令的通知称为键空间通知。 关注某个命令被什么键执行了的通知成为键事件通知。 参考资料 Redis 教程 Redis两种持久化方式(RDB&amp;AOF) Redis 命令参考","categories":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://www.casezheng.date/categories/redis/"}]},{"title":"boost 实用工具 optional学习","slug":"boost-optional","date":"2017-06-01T01:35:00.000Z","updated":"2020-04-12T04:56:35.889Z","comments":true,"path":"2017/06/01/boost-optional/","link":"","permalink":"http://www.casezheng.date/2017/06/01/boost-optional/","excerpt":"","text":"optional12#include&lt;boost/optional.hpp&gt;using namespace boost; “无意义”的值函数正确执行，结果不一定是有效的返回值，也可能是“无意义”的值。例如，求一个值得倒数，传入参数为0。 类摘要optional像一个仅能存放一个元素的容器，实现“未初始化”的概念：如果元素未初始化，容器就是空的，否则，容器内就是有效的、已经初始化的值。 操作函数optional的模版类型参数T可以是任何类型，但必须是可拷贝构造的。创建optional对象的方法： 无参optional()或者optional(boost::none)构造未初始化optional对象。boost::none是一个类似空指针的none_t类型常量，表示未初始化。 optional(v)构造一个已初始化的optional对象，其值未v的拷贝。如果模版类型为T&amp;，optional内部持有对引用的包装。 optional(condition, v)根据条件condition来构造optional对象，如果条件成立则初始化为v，否则为未初始化。 optional支持拷贝构造和赋值操作，可以从另一个optional对象构造。可以给optional对象赋none值，恢复初未初始化状态。 optional采用指针语义来访问内部保存的额元素，因此optional未初始化的行为就像一个空指针。optional重载了operator*和operator-&gt;实现与指针相同的操作，get()和get_ptr()可以以函数形式获得元素的引用的指针。 成员函数get_value_or(default)是一个特别的访问函数，保证返回一个有效值，如果optional已初始化，返回内部元素，否则返回default。 optional用隐式类型转换进行bool测试(用于条件判断)，就像对一个指针的判断。 optional支持比较运算，包括==、!=、&lt;、&gt;、&lt;=、&gt;=。optional进行”深比较”，同时加入对未初始化的判断。 用法1234567891011121314151617181920212223242526272829303132333435363738optional&lt;double&gt; calc(int x)&#123; return optional&lt;double&gt;(x!=0, 1.0/x);&#125;//optionalvoid TestOptional()&#123; optional&lt;int&gt; op0; optional&lt;int&gt; op1(op0); assert(!op0); assert(op0==op1); assert(op1.get_value_or(253) == 253); optional&lt;string&gt; ops(\"test\"); cout&lt;&lt;*ops&lt;&lt;endl; vector&lt;int&gt; v(10); optional&lt;vector&lt;int&gt; &amp;&gt; opv(v); assert(opv); opv-&gt;push_back(5); assert(opv-&gt;size() == 11); opv = none; assert(!opv); optional&lt;double&gt; d = calc(10); if(d) &#123; cout&lt;&lt;*d&lt;&lt;endl; &#125; BOOST_AUTO(x, make_optional(5)); //工厂函数 cout&lt;&lt;*x&lt;&lt;endl; return ;&#125; 工厂函数optional提供工厂函数make_optional()，根据参数类型自动推导optional的类型，辅助创建optional对象。 12optional&lt;T&gt; make_optional(T const &amp;v);optional&lt;T&gt; make_optional(bool condition, T const &amp;v); make_optional()无法推导T引用类型的optional对象，如果需要一个optional的对象，不能使用make_optional函数。 高级议题异常optional同STL容器一样，值提供基本的异常保证，不会超过被包装的类型T,它自身不会抛出任何异常，只有在T构造时可能会抛出异常。 就地创建optional要求类型T具有拷贝语义，因为optional内部会保存值得拷贝，但很多复杂对象的拷贝代价很高，而仅仅是个拷贝的临时用途，因此optional库提出“就地创建”的概念，可以不要求类型具有拷贝语义，直接用构造函数所需的参数创建对象。boost库in_place_factory。 引用类型optional的模版参数类型可以是引用(T&amp;)，在很多方面和原始类型T有不同(无法使用就地创建、就地赋值，可以声明时不指定初值、在赋值时转移包装的对象，而不是对原包装的对象赋值)，","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost库 typeof 实用工具学习","slug":"boost-typeof","date":"2017-05-31T11:16:00.000Z","updated":"2020-04-12T04:56:35.884Z","comments":true,"path":"2017/05/31/boost-typeof/","link":"","permalink":"http://www.casezheng.date/2017/05/31/boost-typeof/","excerpt":"","text":"typeoftypeof库使用宏模拟C++0x新增加的typeof和auto关键字，减轻书写烦琐的变量声明工作，简化代码。 1#include &lt;boost/typeof/typeof.hpp&gt; 动机C++是静态强类型语言，所有变量在使用前必须声明类型，让C++具有运行速度快，代码规范等很多优点，但在引入名词空间特性后会导致烦琐的类型声明。C++0x中typeof/auto关键字，可以让C++编译器在运行时自动推导表达式的类型。 用法头文件中定义的两个宏:BOOST_TYPEOF和BOOST_AUTO,分别仿真C++新标准的typeof和auto关键字，在编译器自动推导表达式类型，不仅能够推导C++语言内建类型，也支持标准库中的容器类型。BOOST_TYPEOF和BOOST_AUTO完全模仿typeof和auto关键词。 宏的简要声明如下： 123#define BOOST_TYPEOF(Expr)\\ boost::type_of::decode_begin&lt;BOOST_TYPEOF_ENCODED_VECTOR(Expr) &gt;::type#define BOOST_AUTO(Var, Expr) BOOST_TYPEOF(Expr) Var = Expr BOOST_TYPEOF使用一个表达式作为宏的参数，推导Expr的类型。BOOST_AUTO实际调用BOOST_TYPEOF，因此BOOST_AUTO不仅可以声明普通变量，也可以在变量名前加&amp;或者*修饰，声明引用或者指针变量。 12345678910111213141516171819202122//typeofvoid TestTypeof()&#123; //typeof(1) tint = 1; //typeof(1&gt;0) tbool = 1&gt;0; auto tint1 = 1; auto tbool1 = 1&gt;0; cout&lt;&lt;tint1&lt;&lt;endl; cout&lt;&lt;tbool1&lt;&lt;endl; BOOST_TYPEOF(1) tint2 = 1; BOOST_TYPEOF(3.14) tdouble2 = 3.14; cout&lt;&lt;tint2&lt;&lt;endl; cout&lt;&lt;tdouble2&lt;&lt;endl; BOOST_AUTO(tdp, new double[20]); BOOST_AUTO(tpair, make_pair(1, \"string\")); cout&lt;&lt;tpair.second&lt;&lt;endl; return ;&#125; 向typeof库注册自定义类typeof库支持C++内建的基本类型和STL中的大多数类型，但并不能支持所有类型，如果用户自定义类向应用于typeof库，需要使用库提供的一组宏注册。向typeof库注册类型，先使用以下语句开始 #include BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP() 后面注册类型使用宏BOOST_TYPEOF_REGISTER_TYPE，必须在全局名字空间使用，宏的参数是类型的完全名称，包括名字空间限定。 高级议题为BOOST_AUTO更名BOOST_AUTO名字有点长，书写不便，可以用auto_t代替BOOST_AUTO 1#define auto_t BOOST_AUTO 模版类型自动推导typeof库不仅能推导一般表达式的类型，也能推导带有模版的复杂表达式。在模版语境中需要时使用BOOST_TYPEOF_TPL和BOOST_AUTO_TPL。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 实用工具 noncopyable学习","slug":"boost-noncopyable","date":"2017-05-31T10:02:00.000Z","updated":"2020-04-12T04:56:35.883Z","comments":true,"path":"2017/05/31/boost-noncopyable/","link":"","permalink":"http://www.casezheng.date/2017/05/31/boost-noncopyable/","excerpt":"","text":"noncopyable noncopyable允许程序轻松地实现一个禁止复制的类。 1234//包含noncopyable#include&lt;boost/noncopyable.hpp&gt;//或者包含utility，utility包含数个小工具的实现#include&lt;boost/utility.hpp&gt; 原理在C++中定义一个类，如果不明确定义拷贝构造函数和拷贝复制操作符，编译器会自动生成。 如果不需要类的复制语义，希望禁止复制类的实例，只需要私有化拷贝构造函数和复制操作符。 用法noncopyable为实现不可拷贝的类提供了简单清晰的解决方案，从boost::noncopyable派生即可。 继承使用默认的私有继承是允许的，显示写出private或者public修饰符，效果是一样的。使用noncopyable明确表达类设计者的意图，对用户友好，与其它boost库配合良好。 1234class do_not_copy : boost::noncopyable&#123; //...&#125;;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库学习 bind","slug":"002-bind-note","date":"2017-05-31T08:10:00.000Z","updated":"2020-04-12T04:56:35.880Z","comments":true,"path":"2017/05/31/002-bind-note/","link":"","permalink":"http://www.casezheng.date/2017/05/31/002-bind-note/","excerpt":"","text":"boost库 bind学习 boost_1_63 bind是C++98标准库中函数适配器bind1st/bind2nd的泛化和增强，可以适配任意的可调用对象，包含函数指针、函数引用、成员函数指针和函数对象。bind最多可以绑定9个函数参数，而且对绑定对象的要求很低，可以在没有result_type内部类型定义的情况下完成对函数对象的绑定。 bind位于名词空间boost，使用bind组件需包含头文件&lt;boost/bind.hpp&gt;, 即: 12#include &lt;boost/bind.hpp&gt;using namespace boost; 1. 工作原理 bind并不是单独的类或函数，是非常庞大的家族，依据绑定的参数个数和要绑定的调用对象类型，有数十种不同形式，名字都叫做bind，编译器会根据具体的绑定代码自动确定要使用的正确形式。 bind接受的第一个参数必须是一个可调用对象，包括函数指针、函数引用、函数对象和成员函数指针，bind接受最多九个参数。参数数量必须与可调用对象的参数数量相等，这些参数将被传递给可调用对象作为输入参数。 绑定完成后，bind返回一个函数对象，内部保存了可调用对象的拷贝，具有operator(),返回值类型自动推导为可调用对象的返回值类型，在发生调用时，函数对象把之前存储的参数转发给可调用对象完成调用。 bind占位符被定义为_1、_2、_3一直到_9，位于一个匿名名词空间。占位符可以取代bind中参数的位置，在发生函数调用时才接受真正的参数。 bind占位符的名字代表它在调用式中的顺序，而在绑定表达式中没有顺序的要求。 2. 绑定普通函数 bind可以绑定普通函数，包括函数、函数指针。 必须在绑定表达式中提供函数要求的所有参数，无论是真实参数还是占位符均可以。 12345678910111213141516171819202122232425262728293031323334353637383940414243int f2(int a, int b)&#123; cout&lt;&lt;\"a:\"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;\"b:\"&lt;&lt;b&lt;&lt;endl; return a+b;&#125;int f3(int a, int b, int c)&#123; return a+b+c;&#125;struct f4: public std::binary_function&lt;int,int,int&gt;&#123; int operator()(int x, int y) const&#123; return (x + y); &#125;&#125;;//绑定普通函数int main(int argc, char* argv[])&#123; cout&lt;&lt;boost::bind(f2, 1, 2)()&lt;&lt;endl; //相当于f2(1, 2) cout&lt;&lt;boost::bind(f3, 1, 2, 3)()&lt;&lt;endl; //相当于f3(1, 2, 3) cout&lt;&lt;boost::bind(f2, _1, 9)(4)&lt;&lt;endl; //相当于f2(4, 4) cout&lt;&lt;bind2nd(f4(), 9)(4)&lt;&lt;endl; cout&lt;&lt;boost::bind(f2, _1, _2)(4, 5)&lt;&lt;endl; //f2(4, 5) cout&lt;&lt;boost::bind(f2, _2, _1)(4, 5)&lt;&lt;endl; //f2(5, 4) cout&lt;&lt;boost::bind(f2, _1, _1)(5, 4)&lt;&lt;endl; //f2(5, 5) cout&lt;&lt;boost::bind(f3, _1, 8, _2)(5, 4)&lt;&lt;endl; //f3(5, 8, 4) cout&lt;&lt;boost::bind(f3, _3, _2, _2)(1, 2, 3)&lt;&lt;endl; //f3(3, 2, 2) typedef int (*f2_type)(int, int); typedef int (*f3_type)(int, int, int); f2_type pf2 = f2; f3_type pf3 = f3; cout&lt;&lt;boost::bind(pf2, 1, 2)()&lt;&lt;endl; //相当于*pf2(1, 2) cout&lt;&lt;boost::bind(pf3, 1, 2, 3)()&lt;&lt;endl; //相当于*pf3(1, 2, 3) return 0;&#125; 3. 绑定成员函数 bind可以绑定类的成员函数。类的成员函数指针不能直接调用operator()，必须绑定一个对象或者函数，通过this指针调用成员函数。因此bind需要用一个占位符的位置让用户提供一个类的实例、引用或者指针，通过对象作为第一个参数来调用成员函数。所以使用成员函数最多只能绑定8个参数。 bind可以代替标准库中的mem_fun和mem_fun_ref帮顶起，用来配合标准算法操作容器中对象。 bind同样支持绑定虚拟成员函数，用法与非虚函数相同，虚函数的行为将由实际调用发生时的实例来决定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct Test&#123;public: int x;public: Test():x(0)&#123;&#125; Test(int _x):x(_x)&#123;&#125; ~Test()&#123;&#125; int f2(int a, int b) const &#123; cout&lt;&lt;\"a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; return a+b; &#125; void print() &#123; cout&lt;&lt;x&lt;&lt;\" \"; &#125;&#125;;void print_test(Test &amp;t)&#123; t.print();&#125;void print_test_p(Test *t)&#123; if(NULL != t) &#123; t-&gt;print(); &#125;&#125;//绑定成员函数int main(int argc, char* argv[])&#123; Test t; Test &amp;yt = t; Test *pt = &amp;t; cout&lt;&lt;boost::bind(&amp;Test::f2, t, _1, 10)(10)&lt;&lt;endl; cout&lt;&lt;boost::bind(&amp;Test::f2, yt, 9, 10)()&lt;&lt;endl; cout&lt;&lt;boost::bind(&amp;Test::f2, pt, _1, _2)(20, 10)&lt;&lt;endl; cout&lt;&lt;boost::bind(&amp;Test::f2, pt, _2, _1)(20, 10)&lt;&lt;endl; vector&lt;Test&gt; vecTest; vecTest.push_back(Test(1)); vecTest.push_back(Test(2)); vecTest.push_back(Test(3)); vecTest.push_back(Test(4)); for_each(vecTest.begin(), vecTest.end(), print_test); cout&lt;&lt;endl; for_each(vecTest.begin(), vecTest.end(), mem_fun_ref(&amp;Test::print)); //mem_fun_ref用于容器存储对象实体时 cout&lt;&lt;endl; for_each(vecTest.begin(), vecTest.end(), boost::bind(&amp;Test::print, _1)); cout&lt;&lt;endl; vector&lt;Test*&gt; vecTest_p; vecTest_p.push_back(new Test(5)); vecTest_p.push_back(new Test(6)); vecTest_p.push_back(new Test(7)); for_each(vecTest_p.begin(), vecTest_p.end(), print_test_p); cout&lt;&lt;endl; for_each(vecTest_p.begin(), vecTest_p.end(), mem_fun(&amp;Test::print)); //mem_fen用于容器存储对象指针时 cout&lt;&lt;endl; for_each(vecTest_p.begin(), vecTest_p.end(), boost::bind(&amp;Test::print, _1)); cout&lt;&lt;endl; return 0;&#125; 4. 绑定成员变量 bind可以绑定public成员变量 12345678910111213141516171819202122int main(int argc, char *argv[])&#123; vector&lt;Test&gt; v; v.push_back(Test(1)); v.push_back(Test(2)); v.push_back(Test(3)); v.push_back(Test(4)); for_each(v.begin(), v.end(), boost::bind(&amp;Test::print, _1)); cout&lt;&lt;endl; vector&lt;int&gt; v2(10); transform(v.begin(), v.end(), v2.begin(), bind(&amp;Test::x, _1)); //bind取出Test对象的成员变量x，transform算法调用bind表达式操作容器v，逐个吧变量填入到v2中 for_each(v2.begin(), v2.end(), boost::bind(print_test_int, _1)); cout&lt;&lt;endl; typedef pair&lt;int, string&gt; pair_t; pair_t p(123, \"bind\"); cout&lt;&lt;boost::bind(&amp;pair_t::first, p)()&lt;&lt;endl; cout&lt;&lt;boost::bind(&amp;pair_t::second, p)()&lt;&lt;endl; return 0;&#125; 5. 绑定函数对象 bind可以绑定函数对象，包括标准库中的所有预定义的函数对象 如果函数对象有内部定义result_type,bind可以自动推导出返回值类型，如果函数对象未定义result_type,则需要用模版参数指明返回值类型。 标准库和boost库大部分函数对象都具有result_type定义。 123456789101112131415161718192021222324struct f&#123; int operator()(int x, int y) &#123; return x + y; &#125;&#125;;struct g&#123; typedef int result_type; int operator()(int x, int y) &#123; return x + y; &#125;&#125;;//绑定函数对象int main(int argc, char *argv[])&#123; cout&lt;&lt;boost::bind(greater&lt;int&gt;(), _1, 10)(13)&lt;&lt;endl; //标准库 具有result_type类型定义 cout&lt;&lt;boost::bind&lt;int&gt;(f(), _1, _2)(10, 15)&lt;&lt;endl; //自定义函数对象，可以通过模版制定返回值类型 cout&lt;&lt;boost::bind(g(), _1, _2)(15, 15)&lt;&lt;endl; //自定义函数对象，定义result_type return 0;&#125; 6. 使用ref库 bind采用拷贝的方式存储绑定对象和参数，如果函数对象或值参数很大、拷贝代价很高，或者无法拷贝，bind的使用会受到限制。因此bind可以搭配ref库，ref库包装对象的引用，让bind存储对象引用的拷贝，降低拷贝的代价。 使用ref传对象引用时，必须保证bind被调用时引用时有效的。 12345678910111213141516171819202122232425int main(int argc, char *argv[])&#123; //使用ref库 int x = 10; int y = 20; cout&lt;&lt;boost::bind(greater&lt;int&gt;(), _1, cref(x))(13)&lt;&lt;endl; g gf; cout&lt;&lt;boost::bind(ref(gf), _1, 20)(10)&lt;&lt;endl; BOOST_AUTO(r, ref(x)); &#123; int *y = new int(5); r = ref(*y); cout&lt;&lt;r&lt;&lt;endl; cout&lt;&lt;bind(f3, r, 1, 1)()&lt;&lt;endl; delete y; &#125; int *w = new int(8); cout&lt;&lt;bind(f3, r, 1, 1)()&lt;&lt;endl; return 0;&#125; 7. 高级议题为占位符更名 最简单的方法：为原占位符使用引用创建别名，可以使用BOOST_AUTO，无需关心占位符的真实类型，将推导的工作交给编译器。存储bind表达式 bind表达式生成的函数对象类型声明非常复杂，可以使用typedef库BOOST_AUTO宏辅助，也可以用function库。嵌套绑定 bind可以嵌套，一个bind表达式生成的函数对象可以被另一个bind再绑定，实现类似f(g(x))的形式。bind嵌套要特别小心，不容易写正确和理解。操作符重载 bind重载了比较操作符和逻辑非操作符,可以将多个bind绑定组合起来，形成复杂的逻辑表达式，配合标准库实现语法简单但语义复杂的操作。绑定非标准函数 有的非标准函数bind无法推导出返回值，必须显式地指定bind的返回值类型。 bind不支持使用了不同调用方式(如__stdcall、__fastcall、extern &quot;C&quot;)的函数，bind将它们看做函数对象，需要显式指定bind的返回值类型。或者在&lt;boost/bind.hpp&gt;之前加上BOOST_BIND_ENABLE_STDCALL、BOOST_BIND_ENABLE_FASTCALL、BOOST_BIND_ENABLE_PASCAL等宏，明确告诉bind支持这些调用。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"boost 库学习 asio","slug":"001-asio-note","date":"2017-05-31T08:10:00.000Z","updated":"2020-04-12T04:56:35.879Z","comments":true,"path":"2017/05/31/001-asio-note/","link":"","permalink":"http://www.casezheng.date/2017/05/31/001-asio-note/","excerpt":"","text":"boost库 asio学习 boost_1_63高性能服务器程序框架 基础知识复习 （书籍 Linux高性能服务器编程） 按照服务器一般原理，可将服务器解构为以下三个主要模块： I/O处理单元。 逻辑单元。 存储单元。 1 服务器模型1.1 C/S模型 C/S(客户端/服务器)模型：所有客户端都通过访问服务器来获取所需的资源。 C/S模型适合资源相对集中的场合，其实现也很简单，缺点明显：服务器是通信的中心，当访问量很大时，所有客户都讲得到很慢的响应。 1.2 P2P模型 P2P(点对点)模型摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。P2P模型让每台机器在消耗服务的同时也在给别人提供服务，让资源充分、自由地共享。缺点：当用户之间传输的请求过多时，网络的负载将加重。P2P模式通常带有一个专门的发现服务器，提供查找服务甚至提供内容服务，让每个客户尽快地找到自己需要的资源。P2P模型可以看做C/S模型的扩展：每台主机既是客户端，也是服务器。 2 服务器编程框架 服务器基本框架都一样，不同在于逻辑处理。 I/O处理单元是服务器管理客户连接的模块。主要工作：1.等待并接受新的客户连接;2.接收客户数据;3.将服务器响应的数据返回客户端。对于服务器集群，I/O处理单元是一个专门的接入服务器，实现负载均衡，在所有逻辑服务器中选取负荷最小的一台为新客户服务。 一个逻辑单元是一个进程或线程，主要工作：分析并处理客户数据，并将结果传递给I/O处理单元或者直接发送给客户端。对服务器集群，一个逻辑单元就是一台逻辑服务器，服务器通常拥有多个逻辑单元，实现对多个客户任务的并行处理。 网络存储单元可以是数据库、缓存和文件，甚至一台独立服务器，但它不是必须的。 请求队列是各个单元间通信方式的抽象。对服务器集群，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接，该TCP连接提高服务器间交换数据的效率，避免动态建立TCP连接的额外的系统开销。 3 I/O模型 阻塞I/O，系统调用可能无法立即完成而被操作系统挂起，直到等待的事件发生为止。socket在创建时默认是阻塞的。通过给socket系统调用第二个参数传递SOCK_NONBLOCK标志，或通过fcntl系统调用的F_SETFL命令，可将socket设置为非阻塞的。对非阻塞I/O的系统调用总是立即返回，而不管事件是否已经发生。非阻塞I/O只有在事件已经发生的情况下操作，才能提高程序效率，因此非阻塞I/O通常和其它I/O通知机制一起使用。 I/O复用，应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。 SIGIO信号，为一个目标文件描述符指定宿主进程，被指定的宿主进程将捕获到SIGIO信号。当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发。 理论上：阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。因为在以上三种模型中，I/O的读写操作都是在I/O事件发生之后，由应用程序来完成的。 对于POSIX规范定义的异步I/O模型，用户可以直接对I/O执行读写操作，读写操作告诉内核用户读写缓冲区的位置，以及I/O操作完成后内核通知应用程序的方式，异步I/O的读写总是立即返回，不论I/O是否阻塞，因为真正的读写操作由内核接管。同步I/O模型要求用户代码自执行I/O操作，而异步I/O由内核来执行I/O操作。同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向引用程序通知的是I/O完成事件。 4 两种高效的事件处理模式 服务器通常需要处理三类事件:I/O事件、信号及定时器事件。 同步I/O模型通常用于Reactor模式，异步I/O模型则用于实现Proactor模式。 4.1 Reactor模式 4.2 Proactor模式 Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此，Proactor模式更加符合服务器基本框架。 4.3 模拟Proactor模式 使用同步I/O方式模拟Proactor模式，原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成时间”。从工作线程角度，直接获得了数据读写的结果，下面只是对读写的结果进行逻辑处理。 Boost.Asio 学习 asio库基于操作系统提供的异步机制，采用前摄器设计模式(Proactor)实现可移植的异步或者同步IO操作，并且并不要求使用多线程和锁定，有效避免多线程编程带来的诸多有害副作用(如条件竞争、死锁等)。 Boost.Asio是一个跨平台、主要用于网络和其他一些底层输入/输出编程的C++库。 Boost.Asio在网络通信、COM串行端口和文件上成功地抽象了输入输出的概念。 Boost.Asio依赖如下库： Boost.System:为Boost库提供操作系统支持。 Boost.Regex(可选的):以便重载Read_until()或者async_read_until()是使用boost::regex参数。 Boost.DateTime(可选的):以便使用Boost.Asio中的计时器。 OpenSSL(可选的):以便使用Boost.Asio提供的SSL支持。 asio 位于名字空间boost::asio ,需要包含头文件如下: 12345#define BOOST_REGEX_NO_LIB#define BOOST_DATE_TIME_SOURCE#define BOOST_SYSTEM_NO_LIB#include &lt;boost/asio.hpp&gt;using namespace boost::asio; 1. 概述 asio库基于Proactor封装了操作系统的select、poll/epoll、kqueue、overlappedI/O等机制，实现异步IO模型。 asio的核心类是io_service, 相当于前摄器模式中的Proactor角色，asio的任何操作都需要io_service的参与。 同步模式下，程序发起一个I/O操作，向io_service提交请求，io_service把操作转交给操作系统，同步等待，等I/O操作完成，操作系统通知io_service，然后io_service将结果发回程序，完成整个同步流程。 异步模式下，程序除了发起I/O操作，还需要定义一个用于回调的完成处理函数。io_service同样把IO操作转交给操作系统，但不同步等待，而是立即返回，调用io_service的run()成员函数等待异步操作完成，当异步操作完成时io_service从操作系统获取执行结果，调用完成处理函数。 asio不直接使用操作系统提供的线程，而是定义了一个自己的线程概念：stand，保证多线程环境中代码可以正确执行，而无需使用互斥量。io_service::stand::wrap()函数可以包装一个函数在strand中执行。 asio专门用两个类mutable_buffer和const_buffer来封装缓存区，它们可以安全的应用到异步的读写当中,使用自由函数buffer()可以包装常用的C++容器类型(array,vector,string等),用read()、write()函数读取缓存区。 asio使用system库的error_code和system_error表示程序运行错误。基本所有函数有两种重载，一是有error_code的输出参数，调用后检查这个参数验证错误，二是没有error_code参数，发生错误则抛出system_error异常, 调用代码用try-catch块捕获错误。 2. 定时器 定时器功能的主要类是deadline_timer 定时器deadline_timer有两种形式的构造函数，都要求有io_service对象，用于提交IO请求，另一个参数是posix_time的绝对时间点或者是自当前时间开始的时间长度。 定时器对象创建，立即开始计时，可用成员函数wait()同步等待定时器终止，或使用async_wait()异步等待，当定时器终止时会调用handler函数。 如果创建定时器不制定终止时间，定时器不会工作，可用成员函数expires_at()和expires_from_now()分别设定定时器终止的绝对时间和相对时间，然后调用wait()或async_wait()等待。expires_at()和expires_from_now()的无参重载形式可以获得定时器的终止时间。 定时器cancel()函数。通知所有异步操作取消，转而等待定时器终止。 3. 定时器用法同步定时器123456789101112131415161718//同步定时器int main(int argc, char *argv[])&#123; io_service service; //所有asio程序必须有一个io_service对象 cout&lt;&lt;time(0)&lt;&lt;endl; deadline_timer t(service, //定时器，io_service作为构造函数的参数。 boost::posix_time::seconds(2)); //2s后定时器终止。 cout&lt;&lt;t.expires_at()&lt;&lt;endl; //查看定时器停止时的绝对时间 t.wait(); //调用wait()同步等待。 cout&lt;&lt;time(0)&lt;&lt;endl; cout&lt;&lt;\"timer over\"&lt;&lt;endl; return 0;&#125; io_service对象，是前摄器中最重要的proactor角色。异步定时器 12345678910111213141516171819202122232425//异步定时器static void handle(const boost::system::error_code &amp;e) //异步定时器回调函数 asio库要求回调函数只能有一个参数，而且必须是const asio::error_code &amp;类型。&#123; cout&lt;&lt;time(0)&lt;&lt;endl; cout&lt;&lt;\"timer over\"&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl;&#125;int main(int argc, char *argv[])&#123; io_service service; //所有asio程序必须有一个io_service对象 cout&lt;&lt;time(0)&lt;&lt;endl; deadline_timer t(service, //定时器，io_service作为构造函数的参数。 boost::posix_time::seconds(2)); //2s后定时器终止。 cout&lt;&lt;t.expires_at()&lt;&lt;endl; //查看定时器停止时的绝对时间 t.async_wait(handle); //调用wait()异步等待，传入回调函数。 service.run(); //启动前摄器的事件处理循环，阻塞等待所有的操作完成并分派事件。 cout&lt;&lt;\"not wait\"&lt;&lt;endl; return 0;&#125; 异步绑定器使用bind 由于async_wait()接受的回调函数类型是固定的，必须使用bind库来绑定参数以适配它的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void print_t()&#123; cout&lt;&lt;\"print\"&lt;&lt;endl;&#125;class timer_test&#123;private: int count; int count_max; function&lt;void()&gt; f; deadline_timer t;public: template&lt;typename F&gt; timer_test(io_service &amp;ios, int x, F func): f(func), count_max(x), count(0),t(ios, posix_time::millisec(500)) &#123; t.async_wait(bind(&amp;timer_test::call_func, this, boost::asio::placeholders::error)); &#125; void call_func(const system::error_code &amp;) &#123; if(count &gt;= count_max) &#123; return; &#125; ++count; f(); t.expires_at(t.expires_at() + posix_time::millisec(500)); t.async_wait(bind(&amp;timer_test::call_func, this, boost::asio::placeholders::error)); &#125;&#125;;int main(int argc, char *argv[])&#123; io_service service; //所有asio程序必须有一个io_service对象 cout&lt;&lt;time(0)&lt;&lt;endl; deadline_timer t(service, //定时器，io_service作为构造函数的参数。 boost::posix_time::seconds(2)); //2s后定时器终止。 cout&lt;&lt;t.expires_at()&lt;&lt;endl; //查看定时器停止时的绝对时间 t.async_wait(handle); //调用wait()异步等待，传入回调函数。 timer_test tt(service, 6, print_t); service.run(); //启动前摄器的事件处理循环，阻塞等待所有的操作完成并分派事件。 cout&lt;&lt;\"not wait\"&lt;&lt;endl; return 0;&#125; 4.网络通信简述 asio库支持TCP、UDP和TCMP通信协议。 boost::asio::ip名字空间提供网络通信方面的函数和类，封装原始的Berkeley Socket API。 ip::tcp类是asio网络通信(TCP)部分主要的类，其中定义了用于TCP通信的typedef类型，用于协作完成网络通信。typedef包括端点类endpoint、套接字类socket、流类iostream、接受器acceptor、解析器resolver等。 5. IP地址和端点 IP地址独立于TCP、UDP等通信协议，asio库使用类ip::address来表示IP地址，可以同时支持ipv4和ipv6两种地址。 address类最重要的方法是静态成员函数from_string()，是工厂函数，可以从字符串产生ip地址，地址的版本可以用is_v4()和is_v6()来检测。address成员函数to_string()把ip地址转化为字符串。 端口在asio库中用ip::tcp::endpoint类来表示。主要用法是通过构造函数创建一个用于socket通信的端口对象，端口地址和端口号用address()和port()获得。 123456789101112131415161718int main(int argc, char *argv[])&#123; ip::address addr; addr = addr.from_string(\"127.0.0.1\"); cout&lt;&lt;addr.is_v4()&lt;&lt;endl; cout&lt;&lt;addr.is_v6()&lt;&lt;endl; cout&lt;&lt;addr.to_string()&lt;&lt;endl; addr = addr.from_string(\"ab::12:13:14\"); cout&lt;&lt;addr.is_v4()&lt;&lt;endl; cout&lt;&lt;addr.is_v6()&lt;&lt;endl; cout&lt;&lt;addr.to_string()&lt;&lt;endl; ip::tcp::endpoint epp(addr, 8000); cout&lt;&lt;epp.address()&lt;&lt;endl; cout&lt;&lt;epp.port()&lt;&lt;endl; return 0;&#125; 6. 同步socket处理 ip::tcp的内部类型socket、acceptor和resolver是asio库TCP通信中最核心的一组类，封装了socket的连接、断开、数据收发。 socket类是TCP通信的基本类。调用成员函数connect()可以连接到一个指定的通信端口，连接成功后用local_endpoint()和remote_endpoint()获得连接两端的端点信息，用read_some()和write_some()阻塞读写数据，当操作完成后使用close()函数关闭socket。如果不关闭socket，在socket析构时会自动调用close()关闭。 acceptor类用于服务器端，对用socket API的accept()函数功能，用于服务器端，在指点的端口号接受连接，必须配合socket类才能完成通信。 resolver类用于客户端解析网址获得可用的IP地址，解析到的IP地址可以使用socket对象连接。对应socket API的getaddrinfo()系列函数。 buffer()函数可以包装很多种类的容器成为asio组件可用的缓冲区类型，通常不能直接把数组、vector等容器作为asio的读写参数，必须要buffer()函数包装。 7. 异步socket处理 异步程序的处理流程与同步程序基本相同，需要将同步调用函数换成异步调用函数，并增加回调函数，在回调函数中再启动一个异步调用。 8. 查询网络地址 resolver类通过域名获得可用的IP，实现与IP版本无关的网址解析。 resolver使用内部类query和iterator共同完成查询IP地址的工作：首先使用网址和服务名创建queruy对象，然后由resolve()函数生成iterator对象，它代表了查询到的ip端点，使用socket对象尝试连接，知道找到一个可用的为止。 resolver不仅能够解析域名，也支持使用IP和服务名。 1234567891011121314151617int main(int argc, char *argv[])&#123; io_service service; ip::tcp::resolver rlv(service); ip::tcp::tcp::endpoint endpoint; ip::tcp::resolver::query qry(\"www.google.com\", \"http\"); ip::tcp::resolver::iterator iter = rlv.resolve(qry); ip::tcp::resolver::iterator end; system::error_code ec = error::host_not_found; for(;ec &amp;&amp; iter!=end; ++iter) &#123; endpoint = *iter; cout&lt;&lt;endpoint.address().to_string()&lt;&lt;endl; &#125; return 0;&#125; 7.高级议题超时处理 使用定时器，在网络通信中实现超时处理，在异步调用后声明一个deadline_timer对象，然后设定等待时间和回调函数。 流操作 对于有连接的TCP协议，asio库专门提供了一个ip::tcp::iostream类贱货socket通信，ip::tcp::iostream是std::basic_iostream的子类，可以像标准流一样操作，内部集成了resolver的域名解析功能和acceptor的接受连接功能。 UDP协议通信 asio的udp和tcp处理流程相似，由于udp协议无连接，故不需要建立连接，使用send_to()和receive_from()直接通过端点发送数据。 串口通信","categories":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"asio","slug":"asio","permalink":"http://www.casezheng.date/tags/asio/"}],"keywords":[{"name":"网络库","slug":"网络库","permalink":"http://www.casezheng.date/categories/网络库/"}]},{"title":"boost 库学习 ref","slug":"003-ref-note","date":"2017-05-31T08:10:00.000Z","updated":"2020-04-12T04:56:35.881Z","comments":true,"path":"2017/05/31/003-ref-note/","link":"","permalink":"http://www.casezheng.date/2017/05/31/003-ref-note/","excerpt":"","text":"boost库 ref学习 boost_1_63 STL和Boost中的算法和函数大量使用函数对象作为判断式或谓词参数，这些参数都是传值语义，算法和函数在内部保留函数对象的拷贝并使用。 特殊情况下作为参数的函数对象拷贝代价过高或者不希望拷贝对象或者拷贝是不可行的。boost.ref应用代理模式，引入对象引用的包装器概念解决这个问题，为了使用ref需要包含头文件: 1#include &lt;boost/ref.hpp&gt; 1. 类摘要 ref库定义了一个很小很简单的引用类型的包装器，reference_wrapper, 12345678910template&lt;class T&gt; class reference_wrapper&#123;public: explicit reference_wrapper(T&amp; t): t_(&amp;t) &#123;&#125; operator T&amp; () const &#123; return *t_; &#125; T&amp; get() const &#123; return *t_; &#125; T* get_pointer() const &#123; return t_; &#125;private: T* t_;&#125;; reference_wrapper的构造函数接受类型T的引用类型，内部使用指针存储t的引用，构造出一个reference_wrapper对象，包装了引用。get()和get_pointer()这两个函数分别返回存储的引用和指针，相当于揭开对t的包装。 2. 基本用法 reference_wrapper只在使用T的语境下才会执行隐式转换，其它情况下需要调用类型转换函数或者get()函数得到真正操作被包装对象。 123456789101112131415161718192021int main(int argc, char *argv[])&#123; int x = 10; reference_wrapper&lt;int&gt; rw(x); cout&lt;&lt;(x==rw)&lt;&lt;endl; (int &amp;)rw = 100; cout&lt;&lt;(100==rw)&lt;&lt;endl; reference_wrapper&lt;int&gt; rw2(rw); cout&lt;&lt;(rw2.get()==100)&lt;&lt;endl; string str; reference_wrapper&lt;string&gt; rws(str); *rws.get_pointer() = \"ref\"; cout&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;rws.get().size()&lt;&lt;endl; return 0;&#125; 3. 工厂函数 ref库提供了两个便捷的工厂函数ref()和cref()，通过参数类型推导构造reference_wrapper对象。 12reference_wrapper&lt;T&gt; ref(T&amp; t);reference_wrapper&lt;T const&gt; cref(T const&amp; t); ref可以根据参数类型自动推导正确的reference_wrapper&lt;T&gt;对象，ref()产生类型为T，cref()产生类型为T const。 reference_wrapper支持拷贝，因此ref()和cref()可以直接总在需要拷贝语义的函数参数中。 12345678910111213int main(int argc, char *argv[])&#123; double x = 2.12345; BOOST_AUTO(rw, cref(x)); cout&lt;&lt;typeid(rw).name()&lt;&lt;endl; string str = \"hahahahah\"; BOOST_AUTO(rws, ref(str)); cout&lt;&lt;typeid(rws).name()&lt;&lt;endl; cout&lt;&lt;sqrt(ref(x))&lt;&lt;endl; return 0;&#125; 4. 操作包装 ref库运用模版元编程技术提供两个特征类is_reference_wrapper和unwrap_reference，用于检测reference_wrapper对象。is_reference_wrapper&lt;T&gt;的bool成员变量value可以判断T是否为一个reference_wrapper。unwrap_reference&lt;T&gt;的内部定义type表明了T的真实类型，无论它是否经过reference_wrapper包装。 unwrap_ref()利用unwrap_reference&lt;T&gt;直接解开reference_wrapper的包装(如果有的话)，返回被包装对象的引用。直接对一个未包装的对象使用unwrap_ref()直接返回对象自身的引用。unwrap_ref()可以安全地用在泛型代码中，而不必关心对象的包装特性，总能够正确地操作对象。 123456789101112131415161718192021222324252627int main(int argc, char *argv[])&#123; vector&lt;int&gt; v(10, 2); BOOST_AUTO(rw, ref(v)); cout&lt;&lt;is_reference_wrapper&lt;BOOST_TYPEOF(rw)&gt;::value&lt;&lt;endl; cout&lt;&lt;is_reference_wrapper&lt;BOOST_TYPEOF(v)&gt;::value&lt;&lt;endl; cout&lt;&lt;typeid(unwrap_reference&lt;BOOST_TYPEOF(rw)&gt;::type).name()&lt;&lt;endl; cout&lt;&lt;typeid(unwrap_reference&lt;BOOST_TYPEOF(v)&gt;::type).name()&lt;&lt;endl; int x = (int)2.12345; BOOST_AUTO(rwd, cref(x)); cout&lt;&lt;is_reference_wrapper&lt;BOOST_TYPEOF(rwd)&gt;::value&lt;&lt;endl; cout&lt;&lt;is_reference_wrapper&lt;BOOST_TYPEOF(x)&gt;::value&lt;&lt;endl; cout&lt;&lt;typeid(unwrap_reference&lt;BOOST_TYPEOF(rwd)&gt;::type).name()&lt;&lt;endl; cout&lt;&lt;typeid(unwrap_reference&lt;BOOST_TYPEOF(x)&gt;::type).name()&lt;&lt;endl; unwrap_ref(rw).push_back(4); cout&lt;&lt;unwrap_ref(rw)[10]&lt;&lt;endl; string str(\"hahaha\"); BOOST_AUTO(rws, cref(str)); cout&lt;&lt;unwrap_ref(rws)&lt;&lt;endl; return 0;&#125; 5. 为ref增加函数调用功能 ref将对象包装为引用语义，降低了复制成本，使引用的行为更像对象，可以让容器安全地持有被包装的引用对象，可以称为”智能引用” ref库没有实现TR1的全部定义，不能提供函数调用操作operator(),无法包装一个函数对象的引用并传递给标准库算法。可以修改boost::ref库添加函数调用功能。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}],"tags":[{"name":"boost","slug":"boost","permalink":"http://www.casezheng.date/tags/boost/"},{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/tags/cpp/"},{"name":"asio","slug":"asio","permalink":"http://www.casezheng.date/tags/asio/"}],"keywords":[{"name":"cpp","slug":"cpp","permalink":"http://www.casezheng.date/categories/cpp/"}]},{"title":"linux命令","slug":"liunx-cmd","date":"2017-05-27T10:20:00.000Z","updated":"2018-10-15T15:48:00.000Z","comments":true,"path":"2017/05/27/liunx-cmd/","link":"","permalink":"http://www.casezheng.date/2017/05/27/liunx-cmd/","excerpt":"","text":"dfdf可显示磁盘的文件系统与使用情形 常用参数 -a 包含所有文件系统 -h 以较高可读性显示信息 -i 显示inode的信息 -l 显示本地端的文件系统 -m 以m为单位显示 free显示内存状态 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 参数 -b 以byte为单位显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以m为单位显示内存使用情况 -o 不显示缓存起调节列 -t 显示内存总和列 -s&lt;间隔秒数&gt; 持续观察内存使用情况 第一部分Mem行解释 total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 Shared:多个进程共享的内存总额。 Buffers/cached:磁盘缓存的大小 关系：total = used + free 第二部分(-/+ buffers/cache) (-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached (+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached 可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数。 第三部分第三部分是指交换分区 tcpdump1、常用选项 -i 指定监听的网络接口 “-i any”表示抓取所有网卡接口上的数据包。 -t 不打印时间戳。 -e 显示以太网帧头部信息。 -n 使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称。 -c 仅抓取指定数量的数据报 -v 输出稍微详细点的信息，例如，显示IP数据包中的TTL和TOS信息。 -vv 输出详细报文信息。 -x 以十六进制显示数据包的内容，单步显示包中以太网帧的头部信息。 -X 与-x类似，不过还打印每个十六进制对应的ASCII字符。 -XX 与-X相同，不过还打印以太网帧的头部信息。 -S 以绝对值来显示TCP报文段的序号，而不是相对值。 -w 将tcpdump的输出以特殊的格式定向到某个文件。 -r 从文件中读取数据报信息并显示。 2、包的过滤tcpdump支持用表达式进一步过滤数据包。tcpdump的操作数分为3种：类型（type）、方向（dir）、协议（proto）类型，解释后面跟着的参数的含义。tcpdump支持的类型包括host（主机名或ip地址）、net（用CIDR方法表示的网络地址）、port（端口号）和portrange（端口范围）。 方向，src指定数据包的发送端，dst指定数据报的目的端。 协议，指定目标协议。 tcpdump支持的逻辑操作符。and（或&amp;&amp;），or（或||），not（或!）如果表达式比较复杂，可以使用括号将它们分组。不过使用括号时，需要使用“\\”对它转义，或者用单引号“’”将其括住，避免齐备shell所解释。","categories":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://www.casezheng.date/tags/shell/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/categories/linux/"}]},{"title":"git的使用","slug":"git","date":"2017-05-27T10:20:00.000Z","updated":"2018-11-19T03:37:00.000Z","comments":true,"path":"2017/05/27/git/","link":"","permalink":"http://www.casezheng.date/2017/05/27/git/","excerpt":"","text":"git色彩显示git默认不显示色彩 进行全局设置12345git config --global color.diff autogit config --global color.status autogit config --global color.branch autogit config --global color.interactive autogit config --global color.ui auto 或者在.gitconfig写入配置12345[color] diff = auto branch = auto status = auto interactive = auto 查看自己配置1git config --list Git status乱码设置core.quotepath为false123456789$ git status... ... &quot;source/Picture/\\350\\277\\233\\347\\250\\213\\347\\212\\266\\346\\200\\201\\345\\233... ...$git config --global core.quotepath false$ git status... ... source/Picture/进程状态图.jpg... ... Git组成创建 克隆现有仓库 git clone ssh://user@domain.com/repo.git 创建一个新的本地仓库 git init 本地修改 查看本地仓库已更改文件信息 git status 查看对已版本控制文件的修改 git diff 添加当前工作空间所有修改到暂存区 git add . 添加单一文件修改到暂存区 git add -p &lt;file&gt; 将所有修改(工作空间和暂存区，工作空间修改可以省略git add)提交到当前分支 git commit -a 提交暂存区修改到当前分支 git commit Change the last commit. Don‘t amend published commits! git commit --amend 提交历史查看 显示所有提交历史记录，从最新的开始 git log 显示特定文件详细的修改历史 git log -p &lt;file&gt; 查看历史提交历史，只显示commit_id和注释 git log --pretty=oneline 逐行显示当前文件修改内容和修改时间 git blame &lt;file&gt; 一条综合信息展示的git log命令1git log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen (%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit -- 分支和标签 列出所有现有分支 git branch -av 选择分支 git checkout &lt;branch&gt; 基于当前分支，创建一个新分支 git branch &lt;new-branch&gt; 创建一个分支，并切换过去 git checkout -b &lt;new-branch&gt; 基于远程分支，创建一个新的分支 git checkout --track &lt;remote/branch&gt; 删除本地分支 git branch -d &lt;branch&gt; 创建一个标签 git tag &lt;tag-name&gt; 跟新和发布 列出远程库的名称 加-v显示详细信息 git remote -v 显示特定远程库的信息 git remote show &lt;remote&gt; 添加一个远程库 git remote add &lt;shortname&gt; &lt;url&gt; 从远程库获取所有更新，但不合并 git fetch &lt;remote&gt; 从远程库获取所有更新，并合并到指定分支 git pull &lt;remote&gt; &lt;branch&gt; 将branch分支推送到远程库remote git push &lt;remote&gt; &lt;branch&gt; 从远程库删除一个分支 git branch -dr &lt;remote/branch&gt; 推送所有本地新增的标签 git push --tags 合并 合并某个分支到当前分支 git merge &lt;branch&gt; 撤销 丢弃工作环境中的所有本地修改 git reset --hard HEAD 丢弃特定文件中的本地修改 git checkout HEAD &lt;file&gt; Revert a commit (by producing a new commit with contrary changes) git revert &lt;commit&gt; 将头指针指向commit提交，并放弃所有修改 git reset --hard &lt;commit&gt; 将一个git仓库同时推送到两个源配置在.git下找到config文件编辑，加入以下以下内容123456... ...# 仓库名[remote &quot;blog&quot;] # 要推送到仓库地址 可以填多个 url = git@github.com:CaseZheng/CaseZheng.github.io.git url = git@git.coding.net:CaseZheng/Blog.git Git碰到问题fatal: no submodule mapping found in .gitmodules for path ‘xxx/xxx’1git rm --cached xxx/xxx 参考文档 git status 显示中文和解决中文乱码","categories":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.casezheng.date/tags/git/"},{"name":"linux","slug":"linux","permalink":"http://www.casezheng.date/tags/linux/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.casezheng.date/categories/other/"}]}]}