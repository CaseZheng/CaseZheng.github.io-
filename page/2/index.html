<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F14AAB2D4C842CB9F200D0A80DA8CB2F">
  <meta name="baidu-site-verification" content="GNlbaIvRtqlfiBfg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.casezheng.date","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CaseZheng的博客网站">
<meta property="og:type" content="website">
<meta property="og:title" content="CaseZheng">
<meta property="og:url" content="http://www.casezheng.date/page/2/index.html">
<meta property="og:site_name" content="CaseZheng">
<meta property="og:description" content="CaseZheng的博客网站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CaseZheng">
<meta name="twitter:description" content="CaseZheng的博客网站">

<link rel="canonical" href="http://www.casezheng.date/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CaseZheng</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f1686055a927fa7bf1a09bc1143b57c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CaseZheng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CaseZheng Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/03/01/coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/01/coroutine/" class="post-title-link" itemprop="url">协程库学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 18:49:52" itemprop="dateCreated datePublished" datetime="2019-03-01T18:49:52+08:00">2019-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络库/" itemprop="url" rel="index"><span itemprop="name">网络库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="协程简介"><a href="#协程简介" class="headerlink" title="协程简介"></a>协程简介</h1><p><a href="https://www.casezheng.date/2019/02/27/process-thread-coroutine/">进程、线程、协程</a></p>
<h1 id="libco简介"><a href="#libco简介" class="headerlink" title="libco简介"></a>libco简介</h1><p>libco是腾讯开源的一个协程库.<br>主要结构和方法介绍:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co_routine.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutine_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stShareStack_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutineAttr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> stack_size;</span><br><span class="line">	stShareStack_t*  share_stack;</span><br><span class="line">	stCoRoutineAttr_t()</span><br><span class="line">	&#123;</span><br><span class="line">		stack_size = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">		share_stack = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoEpoll_t</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">pfn_co_eventloop_t</span>)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(*<span class="keyword">pfn_co_routine_t</span>)( <span class="keyword">void</span> * );</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.co_routine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新协程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> 	<span class="title">co_create</span><span class="params">( stCoRoutine_t **co,<span class="keyword">const</span> stCoRoutineAttr_t *attr,<span class="keyword">void</span> *(*routine)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"><span class="comment">//执行一个协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">co_resume</span><span class="params">( stCoRoutine_t *co )</span></span>;</span><br><span class="line"><span class="comment">//让某个协程yield(让出时间片)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">co_yield</span><span class="params">( stCoRoutine_t *co )</span></span>;</span><br><span class="line"><span class="comment">//让当前协程yield</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">co_yield_ct</span><span class="params">()</span></span>; <span class="comment">//ct = current thread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">co_release</span><span class="params">( stCoRoutine_t *co )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">stCoRoutine_t *<span class="title">co_self</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>		<span class="title">co_poll</span><span class="params">( stCoEpoll_t *ctx,struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout_ms )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">co_eventloop</span><span class="params">( stCoEpoll_t *ctx,<span class="keyword">pfn_co_eventloop_t</span> pfn,<span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.specific</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> 	<span class="title">co_setspecific</span><span class="params">( <span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *	<span class="title">co_getspecific</span><span class="params">( <span class="keyword">pthread_key_t</span> key )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.event</span></span><br><span class="line"></span><br><span class="line"><span class="function">stCoEpoll_t * 	<span class="title">co_get_epoll_ct</span><span class="params">()</span></span>; <span class="comment">//ct = current thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.hook syscall ( poll/read/write/recv/send/recvfrom/sendto )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">co_enable_hook_sys</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">co_disable_hook_sys</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> 	<span class="title">co_is_enable_sys_hook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.sync</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoCond_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">stCoCond_t *<span class="title">co_cond_alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">co_cond_free</span><span class="params">( stCoCond_t * cc )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">co_cond_signal</span><span class="params">( stCoCond_t * )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">co_cond_broadcast</span><span class="params">( stCoCond_t * )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">co_cond_timedwait</span><span class="params">( stCoCond_t *,<span class="keyword">int</span> timeout_ms )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.share stack</span></span><br><span class="line"><span class="function">stShareStack_t* <span class="title">co_alloc_sharestack</span><span class="params">(<span class="keyword">int</span> iCount, <span class="keyword">int</span> iStackSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.init envlist for hook get/set env</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_set_env_list</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name[],<span class="keyword">size_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_log_err</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *fmt,... )</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/Tencent/libco" target="_blank" rel="noopener">libco github仓库</a></li>
<li><a href="https://blog.csdn.net/u011579138/article/details/81839840" target="_blank" rel="noopener">libco简介</a></li>
<li><a href="https://blog.csdn.net/qq_25424545/article/details/81529717" target="_blank" rel="noopener">C/C++协程学习笔记</a></li>
<li><a href="https://my.oschina.net/yyzybb/blog/1817226" target="_blank" rel="noopener">Why c++ coroutine？Why libgo？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/02/27/process-thread-communication-synchronize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/27/process-thread-communication-synchronize/" class="post-title-link" itemprop="url">Linux进程/线程间同步与通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-27 22:29:19" itemprop="dateCreated datePublished" datetime="2019-02-27T22:29:19+08:00">2019-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程-线程间通信方式"><a href="#进程-线程间通信方式" class="headerlink" title="进程/线程间通信方式"></a>进程/线程间通信方式</h1><ol>
<li><p>管道 (进程和线程) 基于流,半双工,数据只能向一个方向流动,双方通信时需要建立两个管道,管道缓存区有限</p>
<ol>
<li><p>无名管道 可用于具有亲缘关系的进程间通信</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fildes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有名管道 可用于无血缘关系的进程间通信</p>
</li>
</ol>
</li>
<li><p>信号 (进程) </p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列 (进程和线程) 消息的链表,存放在内核,有消息队列标识符标识.不需要同步机制.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享内存 (进程和线程) 多个进程可以访问同一块内存空间,和其它通信机制结合使用,达到进程间的同步和互斥 速度快</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">//用来创建共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;    <span class="comment">//将共享内存段连接到进程地址空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>; <span class="comment">//将共享内存段与当前进程脱离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;   <span class="comment">//用于控制共享内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量 (进程和线程) 进程间或线程间同步 一个计数器,每次调用wait将使信号量值减一,如果信号量值为0,则wait将阻塞.每次调用post操作将使信号量值加1</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>socket套接字 (进程和线程) 基于流 跨服务器</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *client_addr, <span class="keyword">socklen_t</span> *len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock_fd, struct sockaddr *serv_addr,<span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>互斥量 (线程) 线程同步方式 互斥锁,访问共享资源前加锁,访问完后释放互斥量,一次只能由一个线程运行 需要注意死锁</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;  <span class="comment">//互斥量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>; <span class="comment">//互斥量销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//解锁</span></span><br><span class="line">PTHREAD_MUTEX_NORMAL		一种标准互斥量类型，不做任何特殊的错误检查或死锁检测。</span><br><span class="line">PTHREAD_MUTEX_ERRORCHECK	此互斥量类型提供错误检查。</span><br><span class="line">PTHREAD_MUTEX_RECURSIVE		此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。</span><br><span class="line">PTHREAD_MUTEX_DEFAULT		此互斥量类型可以提供默认特性和行为。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;    <span class="comment">//得到互斥量类型属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;   <span class="comment">//设置互斥量类型属性</span></span><br></pre></td></tr></table></figure>
<ol>
<li>预防死锁:破环死锁产生的四个必要条件:互斥条件,不可剥夺条件,请求和保持条件,循环等待条件</li>
<li>避免死锁:每次资源分配前,应该计算此次分配资源的安全性,如果此次资源分配不会导致系统进入不安全状态,则分配资源,否则等待.算法:<strong>银行家算法</strong></li>
<li>检查死锁:检测到死锁后通过资源剥夺,撤销进程,进程回退等方法解除死锁.</li>
</ol>
</li>
<li><p>自旋锁 (线程) 线程同步方式 自旋锁不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等待阻塞状态(占用CPU),用于锁持有时间短,并且线程不希望在重新调度上花费大量成本的情况下</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;   <span class="comment">//初始化锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; <span class="comment">//销毁锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;  <span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;  <span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件变量 (线程) 常和互斥锁一起使用,使用时,条件变量被用来阻塞一个线程,当条件不满足时,线程解开相应的互斥锁并等待条件发生变化,一旦其它线程改变了条件变量,条件变量将唤醒一个或多个被此条件变量阻塞的线程,这些线程重新锁定互斥锁并重新测试条件是否满足.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv,<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *cattr)</span></span>;  <span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv,<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//等待条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv, <span class="keyword">pthread_mutex_t</span> *mp, <span class="keyword">const</span> structtimespec * abstime)</span></span>; <span class="comment">//等待条件变量到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv)</span></span>; <span class="comment">//通知条件变量的单个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv)</span></span>; <span class="comment">//通知条件变量的多个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cv)</span></span>; <span class="comment">//销毁条件变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读写锁 (线程) 线程同步方式 三种状态 1.读模式加锁 2.写模式加锁 3.不加锁 一次只能有一个线程占用写模式的读写锁 但可以有多个线程同时占有读模式的读写锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;   <span class="comment">//销毁锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; <span class="comment">//初始化锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;    <span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;    <span class="comment">//读加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;    <span class="comment">//写加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程信号量 (线程) </p>
</li>
<li>全局变量 (线程)</li>
</ol>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><img src="/Picture/pipe.png" alt="管道"></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><img src="/Picture/消息队列msg.png" alt="消息队列"></p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p><img src="/Picture/信号量sem.png" alt="信号量"></p>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p><img src="/Picture/共享内存shm.png" alt="共享内存"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/02/27/process-thread-coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/27/process-thread-coroutine/" class="post-title-link" itemprop="url">进程、线程、协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-27 21:34:22" itemprop="dateCreated datePublished" datetime="2019-02-27T21:34:22+08:00">2019-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统进行资源分配和资源调度的基本单位.<br>进程有独立的资源.<br>不同进程通过进程间通信来通信.<br>进程的上下文切换开销大.<br><img src="/Picture/进程状态转移图.png" alt="进程状态转移图"><br><img src="/Picture/进程状态图.jpg" alt="进程状态图"><br>新进程由父进程fork而来,fork结束后并不立即复制父进程的内容,等真正使用的时候再复制,即<strong>写时拷贝(copy-on-write COW)</strong>.为了效率,子进程一般会先父进程一步进行调用.<br>孤儿进程:父进程先退出,子进程还没退出,那么子进程将被托孤给init进程,此时的子进程就是孤儿进程.<br>僵死进程:在每个进程退出的时候,内核释放该进程所有的资源(包括打开的文件、占用的内存等),但是仍然为其保留一定的信息(包括进程号,退出状态,运行时间等),直到父进程通过外wait/waitpid来取时才释放.此时该进程处于僵死状态.<br>守护进程:守护进程是后台常驻内存的一种特殊进程,不和任何终端关联.守护进程是一个孤儿进程.守护进程的标准输入输出和错误输出都会被丢到<code>/dev/null</code>中.守护进程一般用作服务器进程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取进程自身PID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取进程自身父进程的ID PPID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个子进程</span></span><br><span class="line"><span class="comment">//返回值有两次  1.子进程返回0   2.父进程返回子进程的PID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个子进程,但子进程共享父进程的空间.返回值有两次,子进程返回0,父进程返回子进程的进程号.vfork创建子进程后,父进程阻塞,直到子进程执行exec()或exit().</span></span><br><span class="line"><span class="comment">//vfork最初因为fork没有COW机制,而很多情况下fork后会紧接着执行exec,而exec的执行相当于之前fork复制的空间做了无用功,所以设计了vfork.</span></span><br><span class="line"><span class="comment">//fork有了COW机制后,唯一的代价仅仅是复制父进程页表的代价,所以vfork渐渐被废弃</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><ol>
<li>主动<ol>
<li><code>main</code>函数的自然返回 注意:main返回return不是结束,只是main函数结束,main函数结束后还需要调用全局变量、静态局部变量和main函数的局部变量的析构函数.</li>
<li>调用<code>exit</code>函数,标准函数 退出时会检查文件的打开情况,把文件缓冲区内容写回文件</li>
<li>调用<code>_exit</code>函数,系统调用函数 不会检测文件打开情况,直接退出</li>
<li>调用<code>abort</code>函数,产生<code>SIGABRT</code>信号</li>
</ol>
</li>
<li>被动<ol>
<li>收到信号</li>
</ol>
</li>
</ol>
<p><code>vfork</code>创建的子进程中在<code>main</code>函数中<code>return</code>会导致进程异常结束,而调用<code>exit</code>则不会正是由于子进程和父进程公用栈空间,子进程<code>return</code>后导致栈空间被释放,而<code>exit</code>不会释放栈空间.</p>
<h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信方式:</p>
<ol>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
<li>有名管道</li>
<li>无名管道</li>
<li>信号</li>
<li>socket</li>
<li>文件</li>
</ol>
<h3 id="守护进程的创建"><a href="#守护进程的创建" class="headerlink" title="守护进程的创建"></a>守护进程的创建</h3><p>Linux有一个daemon函数用来创建守护进程.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br><span class="line">nochdir 如果为<span class="number">0</span>,将当前工作目录切换到根目录/,否则工作目录不改变</span><br><span class="line">noclose 如果为<span class="number">0</span>,将<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>重定向到/dev/null,否则不变</span><br></pre></td></tr></table></figure></p>
<p>守护进程的创建过程</p>
<ol>
<li>屏蔽控制终端操作信号</li>
<li>处理SIGCHLD信号</li>
<li>后台运行(调用fork函数,然后让父进程退出运行,子进程继续在后台运行)</li>
<li>脱离控制终端,登陆会话和进程组<code>setsid()</code></li>
<li>禁止会话重新打开控制终端(子进程调用fork函数,然后让子进程退出运行孙进程继续在后台运行)</li>
<li>重设文件创建掩码<code>umask(0)</code></li>
<li>关闭打开的文件描述符</li>
<li>改变当前工作目录<code>chdir(&quot;/&quot;)</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//屏蔽控制终端操作信号</span></span><br><span class="line">    signal(SIGTTOU, SIG_IGN);</span><br><span class="line">    signal(SIGTTIN, SIG_IGN);</span><br><span class="line">    signal(SIGTSTP, SIG_IGN);</span><br><span class="line">    signal(SIGHUP,  SIG_IGN);</span><br><span class="line"></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);    <span class="comment">//忽略子进程结束信号，避免僵死进程产生</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(); <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">"父进程:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">"退出"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);        <span class="comment">//父进程退出,子进程继续运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    setsid();       <span class="comment">//子进程脱离控制终端,登陆会话和进程组,成为无终端的会话组长</span></span><br><span class="line">    pid = fork();       <span class="comment">//创建孙进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">"子进程:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">"退出"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);        <span class="comment">//让子进程退出,孙进程继续运行,孙进程不再是会话组长,禁止程序重新打开控制终端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">"孙进程:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">"继续运行"</span> &lt;&lt; <span class="string">" PPID:"</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    chdir(<span class="string">"/"</span>);     <span class="comment">//改变工作目录</span></span><br><span class="line">    umask(<span class="number">0</span>);       <span class="comment">//重设文件创建掩码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        close(i);       <span class="comment">//关闭标准输入,标准输出,标准错误输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">"关闭标准输入,标准输出,标准错误输出"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程-轻量级进程"><a href="#线程-轻量级进程" class="headerlink" title="线程(轻量级进程)"></a>线程(轻量级进程)</h2><p>线程是CPU调度和分派的基本单位.<br>一个进程中可以有多个线程(最少一个线程).它们共享代码空间和数据空间(全局变量和静态变量),文件描述符,信号,malloc分配的内存.<br>每个线程有自己独立的栈空间和程序计数器.<br>同进程内线程上下文切换快,资源消耗少.<br>线程的实现调用clone系统调用.</p>
<p>线程相关函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程的创建</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//等待线程结束 返回等待线程的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line"><span class="comment">//终止线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">//获取线程自身id</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//将指定线程转变为detach状态</span></span><br><span class="line"><span class="comment">//1. 线程缺省情况下是joinable,其线程ID和退出状态将留给另一个线程对它调用pthread_join</span></span><br><span class="line"><span class="comment">//2. detach线程在终止时,所有资源将自动释放</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>linux下获取线程Id有两种方式</p>
<ol>
<li>gettid</li>
<li>pthread_self<br>gettid获取的是内核中线程Id,pthread_self获取的是posix描述的线程Id</li>
</ol>
<p>对于单线程的进程,内核中tid和pid相等,对于多线程的进程,它们的pid相等,tid则不相同.tid用于描述内核中真实的pid和tid信息.<br>pthread_self返回的是posix定义的线程Id,只是用来区分某个进程中不同的线程,当一个线程退出后,新创建的线程可以复用原来的id.pthread_self返回的线程控制块TCB首地址相对于进程数据段的偏移(pthread_create也是返回该值),只是用来描述同一进程中的不同线程.</p>
<p><img src="/Picture/pthread_create.png" alt="线程创建函数调用图"><br><img src="/Picture/线程状态图.jpg" alt="线程状态图"></p>
<h3 id="线程间通信和同步方式"><a href="#线程间通信和同步方式" class="headerlink" title="线程间通信和同步方式"></a>线程间通信和同步方式</h3><ol>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
<li>有名管道</li>
<li>无名管道</li>
<li>socket</li>
<li>文件</li>
<li>互斥量</li>
<li>自旋锁</li>
<li>条件变量</li>
<li>读写锁</li>
<li>线程信号</li>
<li>全局变量</li>
</ol>
<h2 id="协程-微线程"><a href="#协程-微线程" class="headerlink" title="协程(微线程)"></a>协程(微线程)</h2><p>协程是用户态的轻量级线程.<br>协程调度完全由用户控制,上下文切换比线程快,占用资源少.<br>协程不需要多线程的锁机制,执行效率比多线程高.</p>
<h2 id="进程学习代码"><a href="#进程学习代码" class="headerlink" title="进程学习代码"></a>进程学习代码</h2><p><a href="https://github.com/CaseZheng/Study/blob/master/Concurrent/process_study.cpp" target="_blank" rel="noopener">代码Git地址</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"start fork"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> iPid = fork();</span><br><span class="line">    <span class="keyword">if</span>(iPid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iPid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"child process"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">" PPID:"</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent process"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./process_study</span><br><span class="line">start fork PID:12128</span><br><span class="line">parent process PID:12128</span><br><span class="line">child process PID:12129 PPID:12128</span><br><span class="line"></span><br><span class="line">$ pstree -p -a</span><br><span class="line">... ...</span><br><span class="line">  ├─sshd,724 -D</span><br><span class="line">  │   ├─sshd,609</span><br><span class="line">  │   │   └─sshd,611</span><br><span class="line">  │   │       └─bash,620</span><br><span class="line">  │   │           └─process_study,12128</span><br><span class="line">  │   │               └─process_study,12129</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"start fork"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> iPid = fork();</span><br><span class="line">        <span class="keyword">if</span>(iPid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iPid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"child process"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">" PPID:"</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent process"</span> &lt;&lt; <span class="string">" PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ ./process_study </span><br><span class="line">start fork PID:16030</span><br><span class="line">parent process PID:16030</span><br><span class="line">parent process PID:16030</span><br><span class="line">parent process PID:16030</span><br><span class="line">child process PID:16033 PPID:16030</span><br><span class="line">child process PID:16032 PPID:16030</span><br><span class="line">parent process PID:16032</span><br><span class="line">child process PID:16031 PPID:16030</span><br><span class="line">parent process PID:16031</span><br><span class="line">parent process PID:16031</span><br><span class="line">child process PID:16034 PPID:16032</span><br><span class="line">child process PID:16036 PPID:16031</span><br><span class="line">child process PID:16035 PPID:16031</span><br><span class="line">parent process PID:16035</span><br><span class="line">child process PID:16037 PPID:16035</span><br><span class="line"></span><br><span class="line">$ pstree -p -a</span><br><span class="line">... ...</span><br><span class="line">  │   │           └─process_study,16030</span><br><span class="line">  │   │               ├─process_study,16031</span><br><span class="line">  │   │               │   ├─process_study,16035</span><br><span class="line">  │   │               │   │   └─process_study,16037</span><br><span class="line">  │   │               │   └─process_study,16036</span><br><span class="line">  │   │               ├─process_study,16032</span><br><span class="line">  │   │               │   └─process_study,16034</span><br><span class="line">  │   │               └─process_study,16033</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></p>
<p>分析流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID:16030 --fork--&gt; PID:16030   --fork--&gt; PID:16030 --fork--&gt; PID:16030</span><br><span class="line">                                                              PID:16033</span><br><span class="line">                                          PID:16032 --fork--&gt; PID:16032</span><br><span class="line">                                                              PID:16034</span><br><span class="line">                    PID:16031   --fork--&gt; PID:16031 --fork--&gt; PID:16031</span><br><span class="line">                                                              PID:16036</span><br><span class="line">                                          PID:16035 --fork--&gt; PID:16035</span><br><span class="line">                                                              PID:16037</span><br></pre></td></tr></table></figure></p>
<h2 id="线程学习代码"><a href="#线程学习代码" class="headerlink" title="线程学习代码"></a>线程学习代码</h2><p><a href="https://github.com/CaseZheng/Study/blob/master/Concurrent/thread_study.cpp" target="_blank" rel="noopener">代码Git地址</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Print</span><span class="params">(<span class="keyword">void</span> *pArg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pCount = (<span class="keyword">int</span>*)pArg;</span><br><span class="line">    <span class="keyword">for</span>(;*pCount&lt;<span class="number">10</span>;++(*pCount))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">" TID:"</span> &lt;&lt; pthread_self() &lt;&lt; <span class="string">"  "</span> &lt;&lt; *pCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    <span class="keyword">pthread_t</span> t2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t1, <span class="literal">NULL</span>, Print, &amp;iCount) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread create error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t2, <span class="literal">NULL</span>, Print, &amp;iCount) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread create error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./thread_study </span><br><span class="line">PID:31384 TID:140122741049088  0</span><br><span class="line">PID:31384 TID:140122749441792  0</span><br><span class="line">PID:31384 TID:140122741049088  1</span><br><span class="line">PID:31384 TID:140122749441792  2</span><br><span class="line">PID:31384 TID:140122741049088  3</span><br><span class="line">PID:31384 TID:140122749441792  4</span><br><span class="line">PID:31384 TID:140122741049088  5</span><br><span class="line">PID:31384 TID:140122749441792  6</span><br><span class="line">PID:31384 TID:140122741049088  7</span><br><span class="line">PID:31384 TID:140122749441792  8</span><br><span class="line">PID:31384 TID:140122741049088  9</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/chrono.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/ref.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1</span><span class="params">(<span class="keyword">int</span> *pCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;(*pCount)&lt;<span class="number">10</span>;++(*pCount))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">" TID:"</span> &lt;&lt; pthread_self() &lt;&lt; <span class="string">"  "</span> &lt;&lt; *pCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        boost::this_thread::sleep_for(boost::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print2</span><span class="params">(<span class="keyword">int</span> &amp;count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;<span class="number">10</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"PID:"</span> &lt;&lt; getpid() &lt;&lt; <span class="string">" TID:"</span> &lt;&lt; pthread_self() &lt;&lt; <span class="string">"  "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        boost::this_thread::sleep_for(boost::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function">boost::thread <span class="title">t1</span><span class="params">(Print1, &amp;count)</span></span>;</span><br><span class="line">    <span class="function">boost::thread <span class="title">t2</span><span class="params">(Print2, boost::ref(count))</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./thread_study </span><br><span class="line">PID:11311 TID:140043269957376  1</span><br><span class="line">PID:11311 TID:140043278350080  1</span><br><span class="line">PID:11311 TID:140043269957376  2</span><br><span class="line">PID:11311 TID:140043278350080  3</span><br><span class="line">PID:11311 TID:140043269957376  4</span><br><span class="line">PID:11311 TID:140043278350080  5</span><br><span class="line">PID:11311 TID:140043269957376  6</span><br><span class="line">PID:11311 TID:140043278350080  7</span><br><span class="line">PID:11311 TID:140043269957376  8</span><br><span class="line">PID:11311 TID:140043278350080  9</span><br></pre></td></tr></table></figure></p>
<h2 id="协程学习代码"><a href="#协程学习代码" class="headerlink" title="协程学习代码"></a>协程学习代码</h2><p>C++协程库基于两种方案:</p>
<ol>
<li>利用汇编代码控制协程的上下文切换 (libco, Boost.context)</li>
<li>利用操作系统提供的API来实现协程上下文切换</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.cnblogs.com/wanghuaijun/p/7953481.html" target="_blank" rel="noopener">linux进程、调度、线程、进程上下文等几点理解</a></li>
<li><a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">进程、线程和协程之间的区别和联系</a></li>
<li><a href="https://blog.csdn.net/ivalue/article/details/81945616" target="_blank" rel="noopener">关于进程，线程，协程，一点心得</a></li>
<li><a href="https://blog.csdn.net/runner668/article/details/80512664" target="_blank" rel="noopener">linux进程-线程-协程上下文环境的切换与实现</a></li>
<li><a href="https://www.cnblogs.com/1932238825qq/p/7373443.html" target="_blank" rel="noopener">fork和vfork</a></li>
<li><a href="https://blog.csdn.net/gogokongyin/article/details/51178257" target="_blank" rel="noopener">fork()、vfork()、clone()的区别</a></li>
<li><a href="https://blog.csdn.net/qq_39835338/article/details/81778446" target="_blank" rel="noopener">pthread_detach</a></li>
<li><a href="https://blog.csdn.net/z961968549/article/details/80189737" target="_blank" rel="noopener">linux进程相关函数(获取、销毁、切换···)</a></li>
<li><a href="https://blog.csdn.net/rsyp2008/article/details/45150621" target="_blank" rel="noopener">gettid和pthread_self区别</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/02/24/linux-ram/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/24/linux-ram/" class="post-title-link" itemprop="url">Linux内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-24 01:54:42" itemprop="dateCreated datePublished" datetime="2019-02-24T01:54:42+08:00">2019-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><p>只有内核可以访问物理内存<br>内核给每个进程提供独立虚拟地址空间,虚拟地址空间连续,进程通过访问虚拟地址空间访问内存<br>虚拟地址空间分为<strong>内核空间和用户空间</strong><br><img src="/Picture/Linux内存分布.png" alt="Linux内存分布"><br>进程在用户态只能访问用户空间内存,只有进入内核态后,才能访问内核空间内存.<br>每个进程的地址空间都包含内核空间,但各个进程的内核空间其实关联的是相同的物理内存,当进程切换到内核态后,可以很方便地访问内核空间内存.<br>虚拟内存通过<strong>内存映射</strong>来管理,只有实际使用的虚拟内存才会分配物理内存.<br>内存映射将<strong>虚拟内存地址映射到物理内存地址</strong>,内核为每个进程维护一张页表,记录虚拟内存与物理地址的映射关系<br><img src="/Picture/linux_ram_1.png" alt="linux虚拟内存和物理内存的映射"><br>页面实际存储在CPU的<strong>内存管理单元MMU</strong>中<br>当进程直接访问的虚拟内存在页表中查不到时,系统产生<strong>缺页异常</strong>,进入内核空间分配物理内存,更新进程页表,最后返回用户空间,恢复进程运行.<br>TLB是MMU中页表的高速缓存,由于进程的虚拟内存地址独立,TLB的访问速度比MMU快,通过减少进程的上下文切换,减少TLB的刷新次数,提供TLB缓存的使用率,提高CPU访问内存的性能.<br>MMU以页(通常为4K)为内存映射的最小单位,每次内存映射都需要关联4KB或4KB整数倍的内存空间.<br>页的大小只有4K,导致页表非常大,Linux使用多级页表和大页解决这个问题.<br>多级页表:把内存分为区块来管理,将原来的映射关系改为区块索引和区块的偏移.<br>Linux使用四级页表管理内存页.虚拟内存分为5个部分<br><img src="/Picture/linux_ram_2.png" alt="linux多级页表"><br>大页:比普通页更大的内存块,常见大小2MB和1GB.大页使用在大量内存的进程上,比如Oracle,DPDK等.</p>
<h1 id="虚拟内存空间分布"><a href="#虚拟内存空间分布" class="headerlink" title="虚拟内存空间分布"></a>虚拟内存空间分布</h1><p>虚拟内存空间用户空间内存,从低到高分别是五种不同的内存段</p>
<ol>
<li>只读段,包括代码和常量等</li>
<li>数据段,包括全局变量等</li>
<li>堆,包括动态分配的内存,从低地址开始向上增长</li>
<li>文件映射段,包括动态库,共享内存等,从高地址向低地址向下增长</li>
<li>栈,包括局部变量和函数调用上下文等.栈的大小是固定的,一般为8MB,从高地址向低地址向下增长</li>
</ol>
<p>堆和文件映射段的内存是动态分配的.</p>
<h1 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h1><p>malloc()是C标准库提供的内存分配函数,对应系统调用brk()和mmap().<br>小块内存(小于128K)用brk()分配,通过移动堆顶的位置来分配内存,内存释放后不立即归还系统,先缓存起来,重复利用.<br>大块内存(大于128K)用mmap()分配,直接用内存映射mmap()来分配,在文件映射段找一块空闲分配出来.<br>brk()方式缓存可以减少缺页异常的发生,提高内存访问效率.由于内存未归还系统,在内存工作繁忙时,频繁的内存分配和释放会造成内存碎片.<br>mmap()方式释放直接归还系统,但mmap()都会发生缺页异常,内存工作繁忙时,频繁的内存分配会导致大量的缺页异常,使内核的管理负担增大.<br>当brk()和mmap()被调用时,其实并没有分配内存,只有首次访问这些内存时才分配,即通过缺页异常进入内核,再有内核来分配内存.<br>Linux使用伙伴系统管理内存.伙伴系统以页为单位管理内存,并通过相邻页的合并减少内存碎片.<br>Linux内核通过slab分配器管理小内存,主要作用是分配和释放内核中的小对象.<br>内存只分配不释放会造成内存泄漏,甚至耗尽系统内存,在应用程序使用完内存后,需要调用free()或unmap()释放不用的内存.</p>
<p>系统在发现内存紧张时会通过一系列机制回收内存:</p>
<ol>
<li>回收缓存</li>
<li>回收不常使用内存,把不常使用的内存通过交换分区(Swap)写到磁盘.Swap是把一块磁盘当作内存使用,把进程暂时不用的数据写入磁盘(换出),当进程访问这些内存时,再从磁盘读取数据到内存(换入).Swap使系统可用内存变大了,只有内存不足时才会发生Swap交换,由于磁盘读写速度远慢于内存,Swap会导致严重内存性能问题.</li>
<li>杀死进程,内存紧张时系统通过OOM(Out of Memory)直接杀死占用大量内存的进程.OOM是一种内核保护机制,监控进程内存使用情况,使用oom_soure为每个进程内存使用情况评分.  1. 进程消耗内存越大,oom_soure越大 2. 进程运行占用CPU越多,oom_soure就越小. oom_soure越大表示占用内存越多,越容易被OOM杀死.进程的oom_soure可以在/proc/PID/oom_soure进行查看,可以手动修改/proc/PId/oom_adj进行调整,oom_adj范围为[-17,15],-17表示禁用OOM.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ll /proc/15571/oom_*</span><br><span class="line">-rw-r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_adj</span><br><span class="line">-r--r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_score</span><br><span class="line">-rw-r--r-- 1 root root 0 Feb 26 13:20 /proc/15571/oom_score_adj</span><br><span class="line">$ cat /proc/15571/oom_*</span><br><span class="line">0</span><br><span class="line">16</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/Picture/Linux内存管理.jpg" alt="Linux内存管理"><br><img src="/Picture/Linux内存管理2.gif" alt="Linux内存管理2"><br><img src="/Picture/缺页处理程序流程图.png" alt="缺页处理程序流程图"><br><img src="/Picture/缺页异常处理程序的总体方案.png" alt="缺页异常处理程序的总体方案"><br><!--![分区页框分配器的组成](/Picture/分区页框分配器的组成.png)--><br><!--![虚存管理数据结构联系图](/Picture/虚存管理数据结构联系图.png)--></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/liukuan73/article/details/43238623" target="_blank" rel="noopener">Linux内核OOM机制的详细分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/02/18/firefox-addons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/18/firefox-addons/" class="post-title-link" itemprop="url">firefox配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-18 21:59:14" itemprop="dateCreated datePublished" datetime="2019-02-18T21:59:14+08:00">2019-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>AutoCopy</li>
<li>LastPass</li>
<li>New Tab Override</li>
<li>uBlock Origin</li>
<li>Hoxx VPN Proxy</li>
<li>Saka Key</li>
<li>网页截图</li>
</ol>
<h1 id="HTTPS证书检查禁用"><a href="#HTTPS证书检查禁用" class="headerlink" title="HTTPS证书检查禁用"></a>HTTPS证书检查禁用</h1><p>进入 <code>about:config</code><br>更改<code>security.enterprise_roots.enabled</code>的值为true</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/01/24/hadoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/24/hadoop/" class="post-title-link" itemprop="url">Hadoop概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-24 13:03:28" itemprop="dateCreated datePublished" datetime="2019-01-24T13:03:28+08:00">2019-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hadoop是一个能够<strong>对大量数据进行分布式处理的软件框架</strong>，具有<strong>可靠，高效，可伸缩</strong>的特点</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/01/24/hadoop/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/01/21/data-warehouse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/21/data-warehouse/" class="post-title-link" itemprop="url">数据仓库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-21 22:48:42" itemprop="dateCreated datePublished" datetime="2019-01-21T22:48:42+08:00">2019-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><p>数据仓库(Data Warehouse)是一个面向主题的、集成的、随时间变化的、但信息本身相对稳定的数据存储集合，用于对企业管理决策过程的支持。</p>
<ol>
<li>面向主题:数据仓库针对某个主题来进行组织</li>
<li>集成:需要整合多个数据源的数据</li>
<li>稳定:数据一般只进行查询操作</li>
<li>随时间变化:定期接收新的集成数据,反应最新的数据变化</li>
</ol>
<p><strong>面向分析的存储系统</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/01/21/data-warehouse/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2019/01/20/database-modeing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/20/database-modeing/" class="post-title-link" itemprop="url">数据库建模</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-20 18:57:04" itemprop="dateCreated datePublished" datetime="2019-01-20T18:57:04+08:00">2019-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ER建模"><a href="#ER建模" class="headerlink" title="ER建模"></a>ER建模</h1><p>数据库建设最重要的一步:<strong>需求分析阶段(ER建模阶段)</strong><br>ER建模阶段:数据库开发人员协同需求方以ER图的方式对业务需求进行可视化展现</p>
<ol>
<li>实体(entity):表示客观世界中的众多概念 ER图中矩形表示</li>
<li>属性(attribute):每个实体都有属性 ER图中椭圆表示</li>
<li>联系(relation):实体和实体之间通常具有某种联系 ER图中菱形表示<ol>
<li>一对一</li>
<li>一对多</li>
<li>多对多</li>
</ol>
</li>
</ol>
<h1 id="ER模型到关系表的映射-逻辑模型建模或者关系建模"><a href="#ER模型到关系表的映射-逻辑模型建模或者关系建模" class="headerlink" title="ER模型到关系表的映射(逻辑模型建模或者关系建模)"></a>ER模型到关系表的映射(逻辑模型建模或者关系建模)</h1><h2 id="数据库设计三大范式"><a href="#数据库设计三大范式" class="headerlink" title="数据库设计三大范式"></a>数据库设计三大范式</h2><p><strong>有效避免数据冗余导致的更新异常</strong></p>
<ol>
<li>第一范式(1NF)<br> 每个列都是不可再分的属性值,确保每一列的原子性(确保每列保持原子性)</li>
<li>第二范式(2NF)<br> 在满足第一范式的基础上,必须有主键,没有包含在主键中的列必须完全依赖于主键,而不能只依赖主键的一部分(确保表中的每列都和主键相关)</li>
<li>第三范式(3NF)<br> 在满足第二范式的基础上,非主键必须直接依赖于主键(确保每列都和主键列直接相关，而不是间接相关)</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>数据库设计入门经典</li>
<li><a href="https://blog.csdn.net/hanxueyu666/article/details/81587199" target="_blank" rel="noopener">数据库三大范式详解（通俗易懂）</a></li>
<li><a href="https://www.cnblogs.com/1906859953Lucas/p/8299959.html" target="_blank" rel="noopener">数据库设计三大范式（简单易懂）</a></li>
<li><a href="https://www.cnblogs.com/muchen/p/5265305.html" target="_blank" rel="noopener">数据库关系建模</a></li>
<li><a href="http://www.cnblogs.com/muchen/p/5258197.html" target="_blank" rel="noopener">数据库需求与ER建模</a></li>
<li><a href="https://www.cnblogs.com/muchen/p/5272620.html" target="_blank" rel="noopener">更新异常与规范化设计</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2018/12/08/linux-performance-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/08/linux-performance-optimization/" class="post-title-link" itemprop="url">linux性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-08 00:11:35" itemprop="dateCreated datePublished" datetime="2018-12-08T00:11:35+08:00">2018-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-23 23:45:35" itemprop="dateModified" datetime="2019-12-23T23:45:35+08:00">2019-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>linux性能优化学习</p>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><p><strong>高并发和响应快</strong> 两个核心指标:<strong>吞吐和延时</strong>,从<strong>应用负载视角</strong>考察性能,直接影响产品终端的用户体验,相对应的从<strong>系统资源</strong>出发的指标(资源使用率,饱和度等)<br><img src="/Picture/linux-performance-optimization_1.png" alt="性能指标两个角度"><br>性能问题的本质:系统资源到达瓶颈,请求处理不够快,无法支撑更多请求<br>性能分析:找出应用或系统的瓶颈,并设法避免或缓解,更高效的利用系统资源处理更多请求<br><img src="/Picture/linux-performance-optimization_2.png" alt="Linux性能工具图谱"><br><img src="/Picture/linux-performance-optimization_3.png" alt="Linux性能优化思维导图"></p>
<h1 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h1><p>使用<code>uptime</code>可以查看系统负载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 00:38:27 up 62 days, 14 min,  2 users,  load average: 0.00, 0.04, 0.07</span><br></pre></td></tr></table></figure></p>
<p>显示内容说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00:38:27                           系统当前时间</span><br><span class="line">up 62 days, 14 min                 主机已运行时间</span><br><span class="line">2 users                            用户连接数</span><br><span class="line">load average: 0.00, 0.04, 0.07     系统平均负载,统计最近1,5,15分钟的系统平均负载</span><br></pre></td></tr></table></figure></p>
<p>系统平均负载:指单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数, 即<strong>平均活跃进程数</strong><br>可运行状态:正在使用CPU和正在等待CPU的进程(使用ps命令看到的处于R状态的进程)<br>不可中断状态:正处于内核态不可被打断的关键流程中的进程(不可中断状态是系统对进程和硬件设备的一种保护机制)<br>平均活跃进程不仅包括正在使用CPU的进程也包括等待CPU和等待I/O的进程,因此平均负载高不一定是CPU使用率高,也可能是I/O更繁忙了</p>
<p>系统逻辑CPU核心数可以使用<a href="http://man.linuxde.net/top" target="_blank" rel="noopener">top</a>命令或者从文件/proc/cpuinfo中读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;model name&apos; /proc/cpuinfo | wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>uptime命令会显示1分钟,5分钟,15分钟的平均负载,可以用来分析<strong>系统负载趋势</strong><br>系统负载异常需要结合历史数据,判断负载的变化趋势,当负载有明显升高趋势时再分析调查</p>
<ol>
<li><p>stress命令是Linux系统压力测试工具 —cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，—timeout 执行时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 1 --timeout 600  CPU密集型进程 模拟一个CPU使用率100%的场景 持续600s</span><br><span class="line">stress -i 1 --timeout 600 I/O密集型进程 模拟I/O压力 持续600s</span><br><span class="line">stress -c 8 --timeout 600 大量进程的场景 模拟8个进程 持续600s</span><br></pre></td></tr></table></figure>
</li>
<li><p>sysstat包,包含了常用的Linux性能工具,用来监控和分析系统性能</p>
<ol>
<li><p><a href="http://man.linuxde.net/mpstat" target="_blank" rel="noopener">mpstat</a>多核CPU性能分析工具,用来实时查看每个CPU的性能指标和所有CPU的平均指标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ mpstat -P ALL 5 3 显示所有CPU的指标,并每间隔5s输出一组数据,一共输出3组</span><br><span class="line">Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos)    01/03/2019  _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">01:41:06 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">01:41:11 PM  all    0.20    0.00    0.20    0.20    0.00    0.00    0.00    0.00    0.00   99.40</span><br><span class="line">01:41:11 PM    0    0.20    0.00    0.20    0.20    0.00    0.00    0.00    0.00    0.00   99.40</span><br><span class="line"></span><br><span class="line">01:41:11 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">01:41:16 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">01:41:16 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line"></span><br><span class="line">01:41:16 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">01:41:21 PM  all    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">01:41:21 PM    0    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line"></span><br><span class="line">Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">Average:     all    0.13    0.00    0.07    0.07    0.00    0.00    0.00    0.00    0.00   99.73</span><br><span class="line">Average:       0    0.13    0.00    0.07    0.07    0.00    0.00    0.00    0.00    0.00   99.73</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://linux.51yip.com/search/pidstat" target="_blank" rel="noopener">pidstat</a>进程性能分析工具,用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5 1 每5s输出一组数据</span><br><span class="line">Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos)    01/03/2019  _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">01:46:19 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">01:46:24 PM  1000     21765    0.20    0.00    0.00    0.20     0  vim</span><br><span class="line">01:46:24 PM  1000     22625    0.00    0.20    0.00    0.20     0  pidstat</span><br><span class="line">01:46:24 PM   994     28861    0.00    0.20    0.00    0.20     0  redis-server</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:     1000     21765    0.20    0.00    0.00    0.20     -  vim</span><br><span class="line">Average:     1000     22625    0.00    0.20    0.00    0.20     -  pidstat</span><br><span class="line">Average:      994     28861    0.00    0.20    0.00    0.20     -  redis-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><a href="http://man.linuxde.net/watch" target="_blank" rel="noopener">watch</a>以周期性的方式执行给定的指令，指令输出以全屏方式显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d uptime</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h1><h2 id="CPU上下文切换的工作原理"><a href="#CPU上下文切换的工作原理" class="headerlink" title="CPU上下文切换的工作原理"></a>CPU上下文切换的工作原理</h2><p>CPU寄存器是CPU内置的容量小,但速度极快的内存. 程序计数器(PC)是用来存储CPU正在执行的指令位置,或者即将执行的下一条指令位置. CPU寄存器和程序计数器都是CPU在运行任何任务之前,必须的依赖环境.CPU寄存器和程序计数器被称为CPU上下文.<br><img src="/Picture/cpu_1.png" alt="CPU上下文切换"><br>CPU上下文切换:把前一个任务的CPU上下文保存起来,然后加载新任务的上下文到CPU寄存器和程序计数器中,最后再跳转到程序计数器所指的新位置,运行新任务.保存下来的上下文,存储在系统内核中,在系统再次调度执行时再次加载进来,保证任务原先的状态不受影响,让任务看起来还是连续运行的.</p>
<p>CPU上下文切换根据任务不同,分为3个不同场景:进程上下文切换,线程上下文切换,中断上下文切换</p>
<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux按照特权等级把进程的运行空间分为内核空间和用户空间.</p>
<ul>
<li>内核空间具有最高权限,可以访问所有资源</li>
<li>用户空间只能访问受限资源,不能直接访问内存等硬件设备,必须通过系统调用陷入到内核中,才能访问这些资源</li>
</ul>
<p>即:进程既可以在用户空间运行,又可以在内核空间运行,进程在用户空间运行称为进程的用户态,陷入到内核空间的时候,称为进程的内核态<br>从用户态到内核态的转变,需要通过系统调用完成.<br><strong>系统调用会发生2次CPU上下文的切换</strong>,从用户态到内核态,CPU寄存器里用户态的指令位置需要先保存起来,CPU寄存器再更新为内核态指令的新位置,最后跳到内核态运行内核任务.系统调用后,CPU寄存器需要恢复原来保存用户态,然后再切换到用户空间,继续运行程序.<br><strong>系统调用过程不涉及虚拟内存等进程用户态的资源,也不切换进程</strong></p>
<ul>
<li>进程上下文切换是指从一个进程切换到另一个进程运行</li>
<li>系统调用过程一直在同一个进程运行</li>
</ul>
<p>进程是由内核来管理和调度,进程的切换只能发生在内核态,进程的上下文包括虚拟内存,栈,全局变量等用户空间的资源和内核堆栈,寄存器等内核空间的状态<br>进程的上下文切换:在保存当前进程的内核状态和CPU寄存器之前,需要将该进程的虚拟内存,栈等保存下来,加载了下一个进程的内核态后,需要刷下进程的虚拟内存和用户栈<br><img src="/Picture/cpu_2.png" alt="进程上下文切换"><br>进程上下文切换频繁,很容易导致CPU将大量时间耗费在寄存器,内核栈以及虚拟内存等资源的保存和恢复上,缩短了真正运行进程的时间,导致平均负载升高<br>Linux通过TLB(快表,虚拟地址到物理地址的转换表)管理虚拟内存到物理内存的映射关系,当虚拟内存更新后,TLB也需要更新,内存访问也会随之变慢.多处理器系统,缓存被多个处理器共享,刷新缓存不仅影响当前处理器的进程,也影响共享缓存其它处理器的进程.<br>进程上下文切换的时机:</p>
<ol>
<li>进程时间片耗尽</li>
<li>系统资源不足,进程被挂起,先执行其他进程,等资源满足时再运行</li>
<li>进程sleep主动挂起</li>
<li>有更高优先级进程时</li>
<li>有硬件中断时,CPU上进程被挂起,转而执行内核中的中断服务程序</li>
</ol>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程和进程的最大区别:<strong>线程是调度的基本单位,进程是资源拥有的基本单位</strong></p>
<ul>
<li>当进程只有一个线程时,可以认为进程就等于线程</li>
<li>当进程拥有多个线程时,这些线程共享相同的虚拟内存和全局变量资源,这些资源在上下文切换中不需要修改</li>
<li>线程也有自己的私有数据(例如栈和寄存器等),在上下文切换时需要保存</li>
</ul>
<p>线程上下文切换:</p>
<ol>
<li>两个线程数据不同进程,资源不共享,上下文切换过程与进程上下文切换一样</li>
<li>两个线程属于同一个进程,有许多共享资源,切换时,虚拟内存等共享资源保持不动,只切换线程的私有数据,寄存器等不共享资源.</li>
</ol>
<h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p><strong>中断处理会打断进程的正常调度和执行</strong>,转而调用中断处理程序,响应设备事件<br>中断上下文切换不涉及进程的用户态,中断上下文只包括内核态中断服务程序处理所必须的状态,包括CPU寄存器,内核堆栈,硬件中断参数等</p>
<h2 id="系统上下文切换情况的查看"><a href="#系统上下文切换情况的查看" class="headerlink" title="系统上下文切换情况的查看"></a>系统上下文切换情况的查看</h2><p><a href="http://man.linuxde.net/vmstat" target="_blank" rel="noopener">vmstat</a>主要用来分析系统内存使用情况,也可分析CPU上下文切换和中断次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#每隔5s输出一次数据</span><br><span class="line">$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0    520 894220 230456 519308    0    0     2    29   33   53  0  0 99  0  0</span><br><span class="line"> 0  0    520 893940 230460 519348    0    0     0    13   46   66  0  0 99  0  0</span><br></pre></td></tr></table></figure></p>
<ul>
<li>cs(context switch)是每秒上下文切换次数</li>
<li>in(interrupt)是每秒中断次数</li>
<li>r(Running or Runnable)是就绪队列长度(正在运行或等待CPU的进程数)</li>
<li>b(Blocked)是处于不可中断睡眠状态的进程数</li>
</ul>
<p>vmstat给出系统总体的上下文切换情况,每个进程的详细情况,需要使用pisstat查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#每隔5s输出一组数据 -w参数报告任务切换情况</span><br><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 	01/15/2019 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">11:55:15 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">11:55:20 PM     0         3      0.80      0.00  ksoftirqd/0</span><br><span class="line">11:55:20 PM     0         9      9.38      0.00  rcu_sched</span><br><span class="line">11:55:20 PM     0        11      0.20      0.00  watchdog/0</span><br><span class="line">11:55:20 PM     0        31      0.20      0.00  khugepaged</span><br><span class="line">11:55:20 PM     0       219      0.80      0.00  kworker/0:1H</span><br><span class="line">11:55:20 PM     0       221      0.20      0.00  kworker/u2:2</span><br><span class="line">11:55:20 PM     0       249      0.80      0.00  jbd2/vda1-8</span><br><span class="line">11:55:20 PM     0       698      1.20      0.00  smbd</span><br><span class="line">11:55:20 PM     0      1306      0.40      0.00  cleanupd</span><br><span class="line">11:55:20 PM  1000     25163      1.00      0.00  python36</span><br><span class="line">11:55:20 PM  1000     25355      0.40      0.00  sshd</span><br><span class="line">11:55:20 PM  1000     25634      0.20      0.00  sshd</span><br><span class="line">11:55:20 PM     0     26461      1.20      0.00  kworker/0:0</span><br><span class="line">11:55:20 PM  1000     26575      0.20      0.00  pidstat</span><br></pre></td></tr></table></figure></p>
<ul>
<li>cswch 每秒自愿上下文切换的次数 指进程无法获取所需资源,导致的上下文切换</li>
<li>nvcswch 每秒非自愿上下文切换的次数 指进程由于时间片已到等原因,被系统强制调度,进而发生的上下文切换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#-wt参数输出线程的上下文切换指标</span><br><span class="line">$ pidstat -wt 5</span><br><span class="line">Linux 3.10.0-862.14.4.el7.x86_64 (VM_187_252_centos) 	01/16/2019 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">12:10:12 AM   UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">12:10:17 AM     0         3         -      0.40      0.00  ksoftirqd/0</span><br><span class="line">12:10:17 AM     0         -         3      0.40      0.00  |__ksoftirqd/0</span><br><span class="line">12:10:17 AM     0         9         -      0.80      0.00  rcu_sched</span><br><span class="line">12:10:17 AM     0         -         9      0.80      0.00  |__rcu_sched</span><br><span class="line">12:10:17 AM     0        11         -      0.40      0.00  watchdog/0</span><br><span class="line">12:10:17 AM     0         -        11      0.40      0.00  |__watchdog/0</span><br><span class="line">12:10:17 AM     0        31         -      0.20      0.00  khugepaged</span><br><span class="line">12:10:17 AM     0         -        31      0.20      0.00  |__khugepaged</span><br><span class="line">12:10:17 AM     0       219         -      0.80      0.00  kworker/0:1H</span><br><span class="line">12:10:17 AM     0         -       219      0.80      0.00  |__kworker/0:1H</span><br><span class="line">12:10:17 AM     0       221         -      0.20      0.00  kworker/u2:2</span><br><span class="line">12:10:17 AM     0         -       221      0.20      0.00  |__kworker/u2:2</span><br><span class="line">12:10:17 AM     0       249         -      0.60      0.00  jbd2/vda1-8</span><br><span class="line">12:10:17 AM     0         -       249      0.60      0.00  |__jbd2/vda1-8</span><br><span class="line">12:10:17 AM     0         -      1308      1.00      0.00  |__tuned</span><br><span class="line">12:10:17 AM     0         -       901      1.20      0.00  |__in:imjournal</span><br><span class="line">12:10:17 AM    27         -      1278      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1279      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1280      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1281      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1282      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1283      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1284      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1285      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1286      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1287      1.99      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1289      1.00      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1290      1.00      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1291      0.20      0.00  |__mysqld</span><br><span class="line">12:10:17 AM    27         -      1292      0.20      0.00  |__mysqld</span><br></pre></td></tr></table></figure>
<h1 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h1><ul>
<li>user(us),用户态CPU时间,不包含nice时间,包括了guest时间</li>
<li>nice(ni),低优先级用户态时间,即进程优先级被调整为1-19(nice取值范围为-20到19,数值越大优先级反而越低)之间时的CPU时间</li>
<li>system(sys),内核态CPU时间</li>
<li>idle(id),空闲时间,不包括等待I/O的时间(iowait)</li>
<li>iowait(wa),等待I/O的CPU时间</li>
<li>irq(hi),处理硬中断的CPU时间</li>
<li>softirq(si),处理软中断的CPU时间</li>
<li>steal(st),当系统运行在虚拟机中的时候,被其他虚拟机占用的CPU时间</li>
<li>guest(guest),代表通过虚拟化运行其他操作系统的时间(运行虚拟机的CPU时间)</li>
<li>guest_nice(gnice),代表以低优先级运行虚拟机的时间</li>
</ul>
<p><strong>CPU使用率:除了空闲时间外的其他时间占总CPU时间的百分比</strong><br>性能工具计算CPU使用率取一段时间的两次值,做差后,再计算这段时间内的平均CPU使用率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均CPU使用率=1-((空闲时间new-空间时间old)/(总CPU时间new-总CPU时间old))</span><br></pre></td></tr></table></figure></p>
<p>由于性能工具给出的都是一段时间平均CPU使用率,所以要注意间隔时间的设置.(多个性能工具对比分析时,要保证它们用的相同的间隔)</p>
<h2 id="CPU使用率查看"><a href="#CPU使用率查看" class="headerlink" title="CPU使用率查看"></a>CPU使用率查看</h2><ul>
<li>top显示系统总体的CPU和内存使用情况,以及各个进程的资源使用情况</li>
<li>ps只显示各个进程的资源使用情况</li>
<li>pidstat专门分析每个进程占用系统资源的工具</li>
</ul>
<h2 id="CPU使用过高使用perf分析"><a href="#CPU使用过高使用perf分析" class="headerlink" title="CPU使用过高使用perf分析"></a>CPU使用过高使用perf分析</h2><p><a href="http://linux.51yip.com/search/perf" target="_blank" rel="noopener">perf</a>是Linux下的性能分析工具,能够进行函数与指令级的热点查找</p>
<ul>
<li>perf top实时显示占用CPU时钟最多的函数或指令,用来查找热点函数或者指令</li>
<li>perf record提供保存数据功能</li>
<li>perf report解析展示record的数据</li>
</ul>
<p>perf top和perf record添加<code>-g</code>参数开启调用关系采样,方便根据调用链分析性能问题</p>
<h2 id="常规方法无法找到CPU使用率问题"><a href="#常规方法无法找到CPU使用率问题" class="headerlink" title="常规方法无法找到CPU使用率问题"></a>常规方法无法找到CPU使用率问题</h2><ol>
<li>应用直接调用了其他二进制程序,运行时间较短,通过top等工具不易发现</li>
<li>应用本身不断崩溃重启,启动过程资源初始化,很可能占用相当多的CPU</li>
</ol>
<p>可以通过<a href="http://man.linuxde.net/pstree" target="_blank" rel="noopener">pstree</a>找到进程的父进程,再从父进程所在应用入手,排查问题根源</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ol>
<li>R(Running或Runnable)表示进程在CPU的就绪队列中,正在运行或正在等待运行</li>
<li>D(Disk Sleep)<strong>不可中断睡眠状态</strong>,一般表示进程正在跟硬件交互,并且交互过程不允许被其他进程或中断打断</li>
<li>Z(Zombie)<strong>僵尸进程</strong>,进程实际已经结束了,但父进程还没有回收它的资源</li>
<li>S(Interruptible Sleep)可中断睡眠状态,表示进程因为等待某个事件而被系统挂起.当进程等待的事件发生时,它将被唤醒并进入R状态</li>
<li>I(Idle)空闲状态,用在不可中断睡眠的内核线程上.</li>
<li>T或t(Stopped或Traced),表示进程处于暂停或者跟踪状态</li>
<li>X(Dead)表示进程已经消亡(top或者ps命令中不会看到它)</li>
</ol>
<p><a href="http://man.linuxde.net/dstat" target="_blank" rel="noopener">dstat</a>是一个全能系统信息统计工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ dstat </span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  9   2  72  17   0   0|6902k   88k|   0     0 |1550B   22k| 501   500 </span><br><span class="line"> 96   4   0   0   0   0|   0     0 |  54B  154B|   0     0 |1120   450 </span><br><span class="line"> 96   4   0   0   0   0|   0     0 | 164B 1188B|   0     0 |1163   462 </span><br><span class="line"> 88  12   0   0   0   0|   0     0 | 164B  456B|   0     0 |1156   579 </span><br><span class="line"> 23   4  70   3   0   0|  12k  192k| 164B  456B|   0     0 | 503   631 </span><br><span class="line">  1   2  95   2   0   0| 116k    0 |1090B 1300B|   0     0 | 267   353</span><br></pre></td></tr></table></figure></p>
<p>僵尸进程使用pstree找出其父进程,在父进程中解决        </p>
<h1 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h1><p>中断是一种<strong>异步的事件处理机制</strong>,可以提高系统的并发处理能力<br>中断处理程序会打断其他进程的进行,所以,<strong>中断处理程序需要尽可能快的运行,减少对正常进程运行调度的影响</strong><br>Linux将中断过程分为两个阶段,解决中断处理程序执行过长和中断丢失的问题</p>
<ul>
<li>上半部:快速处理中断,在中断禁止模式运行,主要处理跟硬件紧密相关的或时间敏感的工作,<strong>直接处理硬件请求,硬中断,快速执行</strong></li>
<li>下半部:延迟处理上半部未完成的工作,通常以内核线程的方式运行,<strong>由内核触发,软中断,延迟执行</strong></li>
</ul>
<h2 id="软中断和内核线程查看"><a href="#软中断和内核线程查看" class="headerlink" title="软中断和内核线程查看"></a>软中断和内核线程查看</h2><p>/proc/softirqs 软中断运行情况<br>/proc/interrupts 硬中断运行情况</p>
<p>软中断内核线程 ksoftirqd/CPU 编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep ksoftirqd | grep -v grep</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    Feb19   0:08 [ksoftirqd/0]</span><br></pre></td></tr></table></figure></p>
<h1 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h1><h2 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h2><p><img src="/Picture/cpu_3.png" alt="CPU性能指标"></p>
<h2 id="CPU性能工具"><a href="#CPU性能工具" class="headerlink" title="CPU性能工具"></a>CPU性能工具</h2><h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">性能指标</th>
<th style="text-align:left">工具</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">平均负载</td>
<td style="text-align:left">uptime top</td>
<td style="text-align:left">uptime最简单; top提供更全的指标</td>
</tr>
<tr>
<td style="text-align:left">系统整体CPU使用率</td>
<td style="text-align:left">vmstat mpstat top sar /proc/stat</td>
<td style="text-align:left">top vmstat mpstat只可以动态查看,sar可以记录历史数据 /proc/stat是其它性能工具的数据来源</td>
</tr>
<tr>
<td style="text-align:left">进程CPU使用率</td>
<td style="text-align:left">top pidstat ps htop atop</td>
<td style="text-align:left">top和ps可以按CPU使用率给进程排序,而pidstat只显示实际用了CPU的进程 htop和atop以不同颜色显示更直观</td>
</tr>
<tr>
<td style="text-align:left">系统上下文切换</td>
<td style="text-align:left">vmstat</td>
<td style="text-align:left">除了系统上下文切换数,还提供运行状态和不可中断状态进程数量</td>
</tr>
<tr>
<td style="text-align:left">进程上下文切换</td>
<td style="text-align:left">pidstat</td>
<td style="text-align:left">-w参数</td>
</tr>
<tr>
<td style="text-align:left">软中断</td>
<td style="text-align:left">top /proc/softirqs mpstat</td>
<td style="text-align:left">top提供软中断CPU使用率 /proc/softirqs和mpstat提供各种软中断在每个CPU上的运行次数</td>
</tr>
<tr>
<td style="text-align:left">硬中断</td>
<td style="text-align:left">vmstat /proc/interrupts</td>
<td style="text-align:left">vmstat提供总的中断次数 /proc/interrupts提供各个中断在每个CPU上运行的基类次数</td>
</tr>
<tr>
<td style="text-align:left">网络</td>
<td style="text-align:left">dstat sar tcpdump</td>
<td style="text-align:left">dstat sar提供总的网络接收和发送情况 tcpdump动态抓取正在进行的网络通信</td>
</tr>
<tr>
<td style="text-align:left">I/O</td>
<td style="text-align:left">dstat sar</td>
<td style="text-align:left">dstat和sar都提供了I/O的整体情况</td>
</tr>
<tr>
<td style="text-align:left">CPU个数</td>
<td style="text-align:left">/proc/cpuinfo lscpu</td>
<td style="text-align:left">lscpu更直观</td>
</tr>
<tr>
<td style="text-align:left">事件剖析</td>
<td style="text-align:left">perf execsnoop</td>
<td style="text-align:left">perf可以用来分析CPU的缓存以及内核调用链,execsnoop用来监控短时进程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">性能指标</th>
<th style="text-align:left">CPU性能指标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">uptime</td>
<td style="text-align:left">平均负载</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">平均负载、运行队列、整体的CPU使用率以及每个进程的状态和CPU使用率</td>
</tr>
<tr>
<td style="text-align:left">htop</td>
<td style="text-align:left">top增强版,以不同颜色区分不同类型的进程,更直观</td>
</tr>
<tr>
<td style="text-align:left">atop</td>
<td style="text-align:left">CPU/内存/磁盘/网络等各种资源的全面监控</td>
</tr>
<tr>
<td style="text-align:left">vmstat</td>
<td style="text-align:left">系统整体的CPU使用率/上下文切换次数/中断次数,包括处于运行和不可中断状态的进程数量</td>
</tr>
<tr>
<td style="text-align:left">mpstat</td>
<td style="text-align:left">每个CPU的使用率和软中断次数</td>
</tr>
<tr>
<td style="text-align:left">pidstat</td>
<td style="text-align:left">进程和线程的CPU使用率/中断上下文切换次数</td>
</tr>
<tr>
<td style="text-align:left">/proc/softirqs</td>
<td style="text-align:left">软中断类型和在每个CPU上的累计中断次数</td>
</tr>
<tr>
<td style="text-align:left">/proc/interrupts</td>
<td style="text-align:left">硬中断类型和在每个CPU上的累计中断次数</td>
</tr>
<tr>
<td style="text-align:left">ps</td>
<td style="text-align:left">每个进程的状态和CPU使用率</td>
</tr>
<tr>
<td style="text-align:left">pstree</td>
<td style="text-align:left">进程的父子关系</td>
</tr>
<tr>
<td style="text-align:left">dstat</td>
<td style="text-align:left">系统整体的CPU使用率</td>
</tr>
<tr>
<td style="text-align:left">sar</td>
<td style="text-align:left">系统整体CPU使用率,包括可配置的历史数据</td>
</tr>
<tr>
<td style="text-align:left">strace</td>
<td style="text-align:left">进程的系统调用</td>
</tr>
<tr>
<td style="text-align:left">perf</td>
<td style="text-align:left">CPU性能事件剖析,调用链/CPU缓存/CPU调度等</td>
</tr>
<tr>
<td style="text-align:left">execsnoop</td>
<td style="text-align:left">监控短时进程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><img src="/Picture/cpu_4.png" alt="CPU性能分析"></p>
<h2 id="CPU性能优化"><a href="#CPU性能优化" class="headerlink" title="CPU性能优化"></a>CPU性能优化</h2><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><ol>
<li>应用程序优化<ol>
<li>编译器优化,编译器优化选项 例如:gcc优化选项-O2</li>
<li>算法优化</li>
<li>异步处理</li>
<li>多线程代替多进程</li>
<li>善用缓存</li>
</ol>
</li>
<li>系统优化<ol>
<li>CPU绑定</li>
<li>CPU独占</li>
<li>优先级调整</li>
<li>为进程设置资源限制</li>
<li>NUMA(Non-Uniform Memory Access)优化</li>
<li>中断负载均衡</li>
</ol>
</li>
</ol>
<h2 id="Linux内存"><a href="#Linux内存" class="headerlink" title="Linux内存"></a>Linux内存</h2><h3 id="Linux内存原理"><a href="#Linux内存原理" class="headerlink" title="Linux内存原理"></a>Linux内存原理</h3><p><a href="https://www.casezheng.date/2019/02/24/linux-ram/#more">Linux内存简介</a></p>
<h3 id="Linux内存使用情况查看"><a href="#Linux内存使用情况查看" class="headerlink" title="Linux内存使用情况查看"></a>Linux内存使用情况查看</h3><p><a href="http://man.linuxde.net/free" target="_blank" rel="noopener">free</a>命令可以查看系统内存使用情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1882860      589828      387196         112      905836     1090592</span><br><span class="line">Swap:       2047996      105736     1942260</span><br><span class="line">$ free -m</span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1838         576         377           0         885        1064</span><br><span class="line">Swap:       1999         103        1896</span><br></pre></td></tr></table></figure></p>
<p>Mem物理内存使用情况,Swap交换分区使用情况</p>
<ol>
<li>total总内存大小</li>
<li>used已使用内存大小,包含共享内存</li>
<li>free未使用内存大小</li>
<li>shared共享内存大小</li>
<li>buff/cache缓存和缓冲区大小</li>
<li>available新进程可用内存大小,不仅包含未使用内存,也包括可回收的缓存,一般会比未使用内存大,但并不是所有缓存都可以被回收.</li>
</ol>
<p>free显示整个系统内存使用情况,进程内存使用情况用<a href="http://man.linuxde.net/top" target="_blank" rel="noopener">top</a>或ps等工具查看.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tasks:  88 total,   1 running,  87 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.7 us,  0.7 sy,  0.0 ni, 97.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1882860 total,   384436 free,   590704 used,   907720 buff/cache</span><br><span class="line">KiB Swap:  2047996 total,  1942260 free,   105736 used.  1089708 avail Mem </span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">22272 root      20   0 3438356 326068   6172 S  0.3 17.3  27:45.68 java</span><br><span class="line">16200 root      20   0 2488224  55908   6636 S  0.3  3.0   8:51.48 java</span><br><span class="line">  538 CaseZhe+  20   0  945436  52264   7216 S  0.3  2.8   1:31.74 vim</span><br><span class="line">  547 CaseZhe+  20   0 1113148  51592  25008 S  0.0  2.7   0:00.80 python36</span><br></pre></td></tr></table></figure></p>
<ol>
<li>VIRT进程虚拟内存大小,只要是进程申请过的内存,即使还没有真正分配物理内存,也计算在内</li>
<li>RES常驻进程内存大小,进程实际使用的物理内存大小,但不包括Swap和共享内存</li>
<li>SHR共享内存大小(和其他进程共同使用的共享内存/加载的动态链接库/程序代码段等)</li>
<li>%MEM进程使用物理内存占系统总内存的百分比</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://time.geekbang.org/column/140" target="_blank" rel="noopener">Linux性能优化实战</a></li>
<li><a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a></li>
<li><a href="http://linux.51yip.com/" target="_blank" rel="noopener">Linux命令手册</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2018/11/20/nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/20/nginx/" class="post-title-link" itemprop="url">nginx学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-20 09:50:37" itemprop="dateCreated datePublished" datetime="2018-11-20T09:50:37+08:00">2018-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高性能服务器/" itemprop="url" rel="index"><span itemprop="name">高性能服务器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="nginx介绍"><a href="#nginx介绍" class="headerlink" title="nginx介绍"></a>nginx介绍</h1><p>轻量级,高性能,跨平台Web服务器,基于REST架构风格,以统一资源描述符(URI)或统一资源定位符(URL)作为沟通依据,通过HTTP为浏览器等客户端程序提供各种网络服务.</p>
<h1 id="nginx特性"><a href="#nginx特性" class="headerlink" title="nginx特性"></a>nginx特性</h1><ol>
<li>更快<ol>
<li>单次请求得到更快的响应</li>
<li>高并发下比其它web服务器更快地响应请求</li>
</ol>
</li>
<li>高扩展性</li>
<li>高可靠性</li>
<li>低内存消耗</li>
<li>高并发</li>
<li>热部署 不停服升级nginx,不停服更新配置,不停服更快日志文件等</li>
<li>开源(BSD许可)</li>
</ol>
<p>核心:支持高并发的同时保持高效的服务</p>
<h1 id="nginx编译安装"><a href="#nginx编译安装" class="headerlink" title="nginx编译安装"></a>nginx编译安装</h1><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx官网</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.15.6.tar.gz</span><br><span class="line">tar zxvf nginx-1.15.6.tar.gz</span><br><span class="line">cd nginx-1.15.6</span><br></pre></td></tr></table></figure></p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>configure命令检测操作系统内核,检测已安装软件,参数解析,中间目录生成,根据参数生成C源码文件和Makefile文件<br>make执行configure命令生成的Makefile文件编译nginx工程,并生成目标文件和最终的二进制文件<br>make install根据configure执行时的参数将nginx部署到指定的安装目录,包括相关目录的建立和二进制文件,配置文件的复制</p>
<h1 id="nginx命令"><a href="#nginx命令" class="headerlink" title="nginx命令"></a>nginx命令</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>默认配置文件<code>/usr/local/nginx/conf/nginx.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>-c</code>参数指定配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -c /etc/nginx.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="测试配置文件信息是否有错误"><a href="#测试配置文件信息是否有错误" class="headerlink" title="测试配置文件信息是否有错误"></a>测试配置文件信息是否有错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>
<h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p>stop强制停止nginx服务<br>quit处理完所有当前请求再停止服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">/usr/local/nginx/sbin/nginx -s quit</span><br></pre></td></tr></table></figure></p>
<h2 id="重读配置并生效"><a href="#重读配置并生效" class="headerlink" title="重读配置并生效"></a>重读配置并生效</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="日志文件回滚"><a href="#日志文件回滚" class="headerlink" title="日志文件回滚"></a>日志文件回滚</h2><p>先将当前日志文件改名或转移到别的地址,再执行下面命令生成新的日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reopen</span><br></pre></td></tr></table></figure></p>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h2 id="nginx进程"><a href="#nginx进程" class="headerlink" title="nginx进程"></a>nginx进程</h2><p>在生产环境部署nginx都是采用一个master进程管理多个worker进程的模式.一般情况下,woker进程的数量和服务器上的CPU核心数相等即可(最好每个worker进程都绑定特定的CPU核心,让进程间切换的代价最小).<br>woker进程提供正在的互联网服务,master进程负责监控woker进程(当worker进程意外退出立即启动新的worker进程继续提供服务),为管理员提供命令行服务(启动服务,停止服务,重新载入配置,平滑升级程序等)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                     |--&gt; worker进程 ------HTTP请求---- Client</span><br><span class="line">                     |</span><br><span class="line">                     |--&gt; worker进程 ------HTTP请求---- Client</span><br><span class="line">                     |                 |</span><br><span class="line">master进程 ---管理----                  |---HTTP请求---- Client</span><br><span class="line">                     |</span><br><span class="line">                     |--&gt; worker进程 ------HTTP请求---- Client</span><br><span class="line">                     |</span><br><span class="line">                     |--&gt; worker进程 ------HTTP请求---- Client</span><br></pre></td></tr></table></figure></p>
<h2 id="nginx配置-1"><a href="#nginx配置-1" class="headerlink" title="nginx配置"></a>nginx配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line">#块配置项由一个块配置项名和一对大括号组成 events http server location upstream等都是块配置项</span><br><span class="line">#块配置项一定会用大括号把所属的一系列所属的配置项包含进来,表示大括号内的配置项同时生效</span><br><span class="line">#块配置项可以嵌套,内层块直接继承外层块</span><br><span class="line"></span><br><span class="line">#配置项单位 空间: K或者k千字节 M或m兆字节  时间:ms(毫秒),s(秒),m(分钟),h(小时),d(天),w(周),M(月),y(年)</span><br><span class="line"></span><br><span class="line">#以守护进程方式运行Nginx  默认on</span><br><span class="line">daemon on;</span><br><span class="line"></span><br><span class="line">#以mater/worker(一个master进程管理多个worker进程)方式工作,如果关闭就不会fork出worker子进程,而是master进程自身来处理请求  默认on</span><br><span class="line">master_process on;</span><br><span class="line"></span><br><span class="line">#error日志设置 语法: error_log /path/file level;</span><br><span class="line">#/path/file是一个具体文件, /path/file也可以设置为/dev/null,不再输出任何日志(关闭error日志的唯一手段)</span><br><span class="line">#level是日志等级 debug info notice warn error crit alert emerg 从左到右等级依次增大 如果想把日志等级设置为debug,必须在configure时加入--with-debug配置项</span><br><span class="line">error_log  /var/log/nginx/error.log error;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#限制coredump核心转储文件的大小,防止core文件过大占满了磁盘 语法: worker_rlimit_core size;</span><br><span class="line">worker_rlimit_core 1024M;</span><br><span class="line"></span><br><span class="line">#指定coredump文件生成目录,worker进程的工作目录,该配置的唯一用途是设置coredump文件防止的目录,协助定位问题,需要确保worke进程有权限向working_directory指定目录写入文件 语法: working_directory path;</span><br><span class="line">working_directory /data/nginx;</span><br><span class="line"></span><br><span class="line">#定义环境变量 语法: env VAR|VAR=VALUE; 该配置让用户直接操作操作系统上的环境变量</span><br><span class="line">#嵌入其他配置文件 语法: inclue /path/file; 将其它配置文件嵌入到当前的nginx.conf文件中,参数可以是绝对路径也可以是相对路径(相对nginx配置目录)</span><br><span class="line">#include nginx.d/http/server.casezheng.com.conf</span><br><span class="line">#include nginx.d/*.conf</span><br><span class="line"></span><br><span class="line">#pid文件路径 保存master进程ID的pid文件存储路径.默认和configure设置的--pid-path所指定位置相同,需要确认nginx有权在相应目录中建立pid文件</span><br><span class="line">pid        /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#ningx worker进程运行的用户及用户组</span><br><span class="line">user  nginx;</span><br><span class="line"></span><br><span class="line">#设置一个nginx worker进程可以打开的最大文件描述符个数</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#限制信号队列 设置每个用户发往nginx的信号队列的大小,当某个用户的信号队列满了,该用户发送的信号量将被丢弃</span><br><span class="line">#worker_rlimit_sigpending limit;</span><br><span class="line"></span><br><span class="line">#nginx worker进程个数 在master/worker运行方式下,定义worker进程的个数</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">#绑定nginx worker进程到指定的CPU内核 语法: worker_cpu_affinity cpumask [cpumask...]; 该配置仅针对Linux操作系统有效</span><br><span class="line"></span><br><span class="line">#SSL硬件加速 如果服务器上有SSL硬件加速设备,可以进行配置加快SSL协议的处理速度.用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备: openssl engine -t</span><br><span class="line">#ssl_engine device;</span><br><span class="line"></span><br><span class="line">#nginx worker进程的优先级设置, 优先级有静态优先级和进程执行情况共同决定.这里设置的是静态优先级. 语法: worker_priority nice;   nice -20 ~ +19, -20最高优先级 +19最低优先级 希望nginx占用更多系统资源可以将其设置小点,但不建议比内核进程的nice(-5)小.</span><br><span class="line">#worker_priority 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    #对指定的客户端输出debug级别的日志 语法: debug_connection [IP|CIDR];  该配置属于事件类配置,必须放在events配置块中才有效,值可以是IP地址或CIDR地址 可以用于高并发请求下定位问题</span><br><span class="line">    debug_connection 127.0.0.1;</span><br><span class="line">    debug_connection 127.0.0.0/24;</span><br><span class="line">    </span><br><span class="line">    #accept锁 accept_mutex是Nginx的负载均衡锁,让多个worker进程轮流的,序列化地与新的客户端建立TCP连接,当一个worker进程建立的连接达到worker_connections配置的最大连接数的7/8时,大大减少该worker进程试图建立新TCP连接的机会,以此实现所有worker进程上处理的客户端请求数尽量接近. accept锁默认打开,关闭后建立TCP连接的耗时会更短,但worker进程间的负载会不均衡,因此不建议关闭它</span><br><span class="line">    accept_mutex on;</span><br><span class="line"></span><br><span class="line">    #使用accept锁后真正建立连接的延迟时间 语法: accept_mutext_delay Nms;    在使用accept锁后,同一时间只有一个worker进程可以获取到accept锁,accept锁不是阻塞锁,如果获取不到会立即返回.如果有一个worker进程试图获取accept锁而没有获取到,至少要等accept_mutex_delay定义的时间间隔后才能再次试图获取锁.</span><br><span class="line"></span><br><span class="line">    #批量建立新连接 当事件模型通知有新连接时,尽可能对本次调度中客户端发起的所有TCP请求都建立连接. 语法: multi_accept [on|off];</span><br><span class="line">    multi_accept off;</span><br><span class="line"></span><br><span class="line">    #选择事件模型 语法: use [kququ | rtsig | epoll | /dev/poll | select | poll | eventport]; nginx默认会选择最合适的事件模型</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    #每个worker可以处理的最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #内存和磁盘资源的分配</span><br><span class="line">    #client_body_in_file_only HTTP包体只存储在磁盘空间中 语法:client_body_in_file_only on|clean|off; 默认off; 适用于配置块:http,server,location 当非off值时,用户请求中的HTTP包体一律存储到磁盘文件中,即使只有0字节也会存储为文件.当请求结束时如果配置为on,则该文件不会被删除(一般用于调试定位问题),若配置为clean,则会删除该文件</span><br><span class="line">    client_body_in_file_only off;</span><br><span class="line">    #client_body_in_single_buffer on|off; HTTP包体尽量写到一个内存buffer中.如果HTTP包体的大小超过了client_body_buffer_size设置的值,包体还是会写入到磁盘文件中 适用于配置块:http,server,location</span><br><span class="line">    client_body_in_single_buffer off;</span><br><span class="line">    #client_header_buffer_size size; 存储HTTP头部的内存buffer大小 配置块:http,server 存储HTTP头部的内存buffer大小 定义了正常情况下Nginx接收用户请求中HTTP header部分(包括HTTP行和HTTP头部)时分配的内存buffer大小.如果请求中的HTTP header部分超过client_header_buffer_size,large_client_header_buffers将会生效</span><br><span class="line">    client_header_buffer_size 1K;</span><br><span class="line">    #large_client_header_buffers number size; 配置块:http,server large_client_header_buffers定义了nginx接收超大HTTP头部请求的buffer个数和每个buffer的大小.如果HTTP请求行的大小超过单个buffer,则返回&quot;Request URI toolager&quot;(414).请求中一般有多个header,每个header的大小也不能超过单个buffer的大小.否则返回&quot;Bad request&quot;(400).请求行和请求头部的总和也不可以超过buffer个数和*buffer大小</span><br><span class="line">    large_client_header_buffers 4 8K;</span><br><span class="line">    #client_body_buffer_size size; 配置块:http,server,location 存储HTTP包体的内存buffer大小 定义了nginx接收HTTP包体的内存缓冲区大小 即HTTP包体会先接收到指定的这块内存中,之后才决定是否写入磁盘.</span><br><span class="line">    #如果用户请求中包含HTTP头部Content-Length,并且其标识长度小于定义的buffer长度,nginx会自动降低本次请求所使用的内存buffer,降低内存消耗.</span><br><span class="line">    client_body_buffer_size 16k;</span><br><span class="line">    #client_body_temp_path dir-path [level1[level2[level3]]]; 配置块:http,server,location 定义HTTP包体存放的临时目录.在请求HTTP包体时,如果包体大小大于client_body_buffer_size,则会以一个递增的整数命名并存放到client_body_temp_path所指定的目录中.其后跟随的level1,level2,level3是为了防止一个目录下文件太多导致性能下降,因此使用level参数,按照临时文件名最多再加三层目录.</span><br><span class="line">    client_body_temp_path client_body_temp 1 2;</span><br><span class="line">    #connection_pool_size size; 配置块:http,server nginx对每个建立的TCP连接会预先分配一个内存池,size指定该内存池的初始大小,用于减少内核对小块内存的分配次数,需谨慎设置.过大的size会使服务器消耗内存增多,更小的size会引发更多的内存分配次数.</span><br><span class="line">    connection_pool_size 256;</span><br><span class="line">    #request_pool_size size; 配置块:http,server nginx开始处理HTTP请求时,会为每个请求分配一个内存池,size配置项指定该内存池的初始大小,用于减少内核对小块内存的分配次数.TCP连接关闭时会销毁connection_pool_size指定的连接池,HTTP请求结束时会销毁request_pool_size指定的HTTP请求内存池.但TCP连接内存池和HTTP请求内存池的创建和销毁时间并不一致,因为一个TCP连接可能被复用于多个HTTP请求.</span><br><span class="line">    request_pool_size 4k;</span><br><span class="line"></span><br><span class="line">    #网络连接的设置</span><br><span class="line">    #client_header_timeout time(默认单位s); 配置块:http,server,location 读取HTTP头部的超时时间 客户端和服务器建立连接后开始接收HTTP头部,如果在一个时间间隔内没有读取到客户端发来的字节,则认为超时,并向客户端返回408(&quot;Request timed out&quot;)响应.</span><br><span class="line">    client_header_timeout 60;</span><br><span class="line">    #client_body_timeout time(默认单位s); 配置块:http,server,location 读取HTTP包体的超时时间</span><br><span class="line">    client_body_timeout 60;</span><br><span class="line">    #send_timeout time; 配置块:http,server,location 发送响应的超时时间 nginx服务器向客户端发送数据包,但客户端一直没有去接收这个数据包.如果某个连接超过send_timeout定义的超时时间,nginx将关闭这个连接</span><br><span class="line">    send_timeout 60;</span><br><span class="line">    #reset_timedout_connection on|off; 配置块:http,server,location 连接超时后将通过向客户端发送RST包来直接重置连接.该选项打开后,nginx会在某个连接超时后,不是使用正常情况下的四次挥手关闭TCP连接,而是直接向用户发送RST重置包,不在等待用户的应答,直接使用nginx服务器上关于该套接字的所有缓存,与正常关闭方式相比,使得服务器避免了产生更多处于FIN_WAIT_1,FIN_WAIT_2,TIME_WAIT状态的TCP连接. 但是,使用RST重置包关闭连接会带来一些问题,默认情况下不会开启.</span><br><span class="line">    reset_timedout_connection off;</span><br><span class="line">    #lingering_close off|on|always; 配置块:http,server,location 控制nginx关闭用户连接的方式.always表示关闭用户连接前必须无条件地处理连接上所有用户发送的请求.off表示关闭连接时完全不管连接上是否有已经准备就绪的来自用户的数据.on是中间值,一般情况下在关闭前都会处理l连接上用户发送的数据,除了有些情况下在业务上认定之后的数据是不必要的.</span><br><span class="line">    lingering_close on;</span><br><span class="line">    #lingering_time time; 配置块:http,server,location lingering_close启用后,对上传大文件很有用,当用户上传的Content-Length大于max_client_body_size时,nginx服务器向用户发送413(Request entity too large)响应,如果客户端不管413返回值继续上传HTTP body,经过lingering_time设置的时间后,nginx将不管用户是否仍在上传,都将连接关闭掉</span><br><span class="line">    lingering_time 30s;</span><br><span class="line">    #lingering_timeout time; 配置块:http,server,location lingering_close生效后,在关闭连接前,会检测是否有用户发送的数据到达服务器,如果超过了lingering_timeout还没有数据可读,就直接关闭连接,否则,必须在读取完连接缓冲区上的数据并丢弃后才能关闭连接</span><br><span class="line">    lingering_timeout 5s;</span><br><span class="line">    #keepalive_disable [msie6|safari|none...]; 配置块:http,server,location HTTP请求的keepalive功能让多个请求复用一个HTTP长连接,对服务器的性能提高很有帮助,但有的浏览器对keepalive功能的POST请求有功能项问题,因此可以对特定浏览器禁用keepalive功能</span><br><span class="line">    keepalive_disable msie6 safari;</span><br><span class="line">    #keepalive_timeout time(秒); 配置块:http,server,location  一个httpalive在闲置一定时间后,服务器和浏览器都会去关闭这个连接,keepalive_timeout配置项用来约束nginx服务器,nginx会按照规范将keepalive_timeout传给浏览器,但每个浏览器对keepalive的策略有可能不同</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    #keepalive_requests n; 配置块:http,server,location 一个keepalive长连接上允许的请求最大数 即一个keepalive连接上最多只能发送n个请求</span><br><span class="line">    keepalive_requests 100;</span><br><span class="line">    #tcp_nodelay on|off; 配置块:http,server,location 确定对keepalive连接是否使用TCP_NODELAY选项</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    #tcp_nopush on|off; 配置块:http,server,location 在打开sendfile选项时,确认是否开启FreeBSD系统的TCP_NOPUSH或Linux系统上的TCP_CORK功能,打开tcp_nopush后,将在发送响应时把真个响应头放在一个TCP包中发送.</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    </span><br><span class="line">    #MIME类型的设置</span><br><span class="line">    #MIME type与文件扩展的映射 语法: type &#123;...&#125;; 配置块:http,server,location  定义MIME type到文件拓展名的映射.多个拓展名可映射到同一个MIME type.</span><br><span class="line">    #默认MIME type 语法:default_type MIME-type; 配置块:http,server,location 当找不到相应的MIME type与文件扩展名之间的映射时使用默认的MIME type作为HTTP header中的Content-Type.</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    #types_hash_bucket_size size; 默认type_hash_bucket_size 32|64|128; 配置块:http,server,location 为了快速查找相应MIME type,nginx使用散列表来存储MIME type与文件扩展名.types_hash_bucket_size设置了每个散列桶占用内存大小</span><br><span class="line">    types_hash_bucket_size 64;</span><br><span class="line">    #types_hash_max_size size; 配置块:http,server,location  影响散列表的冲突率,types_hash_max_size越大,消耗内存越大,打散列表的冲突率会降低,检索速度会更快,types_hash_max_size越小,消耗内存越少,但散列表冲突率会上升.</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    #文件操作的优化</span><br><span class="line">    #sendfile系统调用 sendfile on|off; 配置块:http,server,location 启用Linux上的sendfile系统调用来发送文件,减少系统内核和用户态之间的两次内存复制,从磁盘中直接读取文件后直接在内核态发送到网卡设备.提高发送文件的效率.</span><br><span class="line">    #sendfile off;</span><br><span class="line">    #AIO系统调用 aio on|off; 配置块:http,server,location 表示是否在FreeBSD或Linux系统上启用内核级别的异步文件I/O功能.该配置和sendfile功能互斥</span><br><span class="line">    aio on;</span><br><span class="line">    #directio size|off; 配置块:http,server,location 在FreeBSD和Linux系统上使用O_DIRECT选项来读文件,缓冲区大小为size,通常对大文件的读取速度有优化功能,与sendfile功能相斥.</span><br><span class="line">    directio off;</span><br><span class="line">    #directio_alignment size; 配置块:http,server,location 与directio配合使用,指定以directio方式读取文件时的对齐方式.</span><br><span class="line">    directio_alignment 512;</span><br><span class="line">    #打开文件缓存 open_file_cache max=N[inactive=time]|off; 配置块:http,server,location 文件缓存会在内存中存储3种信息:1.文件句柄,文件大小和上次修改时间 2.已经打开过的目录结构 3.没有找到的或者没有操作权限的文件信息</span><br><span class="line">    #open_file_cache 后面跟3个参数.max表示在内存中存储元素的最大个数,当达到最大值后,将采用LRU算法从缓存中淘汰最近最少使用的元素.inactive表示在inactive指定的时间段内没有被访问过的元素将被淘汰.默认时间为60秒.off关闭缓存功能</span><br><span class="line">    open_file_cache off;</span><br><span class="line">    #open_file_cache max=100 inactive=20s;</span><br><span class="line">    #缓存打开文件错误的信息 open_file_cache_errors on|off; 配置块:http,server,location</span><br><span class="line">    open_file_cache_errors off;</span><br><span class="line">    #不被淘汰的最小访问次数 open_file_cache_min_uses number; 配置块:http,server,location 与open_file_cache中的inactive参数配合使用.如果在inactive指定时间段内,访问次数超过了open_file_cache_min_uses指定的最小次数,那么将不会被淘汰出缓存.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    #检查缓存中元素有效性的频率. open_file_cache_valid time; 配置块:http,server,location</span><br><span class="line">    open_file_cache_valid 60s;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    include             /etc/nginx/default.d/*.conf;</span><br><span class="line">    include             /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    #server_names_hash_bucket_size设置nginx存储server_name的散列表每个散列桶占用的内存大小 适用于配置块:http,server,location 取值32,64,128</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line">    #server_names_hash_max_size影响散列表的冲突率,值越大消耗内存越多,散列key的冲突率约低,检索速度越快 适用于配置块:http,server,location</span><br><span class="line">    server_names_hash_max_size 512;</span><br><span class="line"></span><br><span class="line">    #对客户端请求的特殊处理</span><br><span class="line">    #忽略不合法的HTTP头部 ignore_invalid_headers on|off; 配置块:http,server 如果将其设置为off,当出现不合法的HTTP头部时,ngin将拒绝服务,并直接想用户发送400(Bad Request)错误,如果设置为on,则将忽略此HTTP头部.</span><br><span class="line">    ignore_invalid_headers on;</span><br><span class="line">    #HTTP头部允许下划线 underscores_in_headers on|off; 配置块:http,server 默认off,表示HTTP头部名称中不允许带&quot;_&quot;</span><br><span class="line">    underscores_in_headers off;</span><br><span class="line">    #If-Modified-Since头部的处理策略 if_modified_since [off|exact|before]; 配置块:http,server,location Web浏览器一般会缓存文件到本地,并存储当时获取的时间,下次向Web服务器获取缓存过的资源时,使用If-Modified-Since头部把上次获取的时间捎带上,而if_modified_since将根据后面的参数决定如何处理If-Modified-Since头部.</span><br><span class="line">    #off: 直接忽略用户请求中的If-Modified-Since头部,如果获取一个文件,会正常返回文件内容,HTTP响应吗通常为200</span><br><span class="line">    #exact: 将If-Modified-Since头部包含的时间和将要返回的文件上次修改时间做精准比较,如果没有匹配上则返回200和文件实际内容,如果匹配上了,则表示浏览器缓存的已经是最新的啦,没有必要再返回文件浪费时间和宽带,返回304 Not Modified,浏览器收到后会直接读取自己的本地缓存</span><br><span class="line">    #before: 比exact更宽松,只要文件上次修改时间等于或早于用户请求中的If-Modified-Since头部的时间,会向客户端返回304Not Modified.</span><br><span class="line">    if_modified_since exact;</span><br><span class="line">    #文件未找到时记录到error日志 log_not_found on|off; 配置块:http,server,location 表示当处理用户请求且需要访问文件时,如果未找到文件,是否将错误记录到error.log日志.可用于定位问题.</span><br><span class="line">    log_not_found on;</span><br><span class="line">    #merge_slashes on|off; 配置块:http,server,location 合并相邻的&quot;/&quot;.</span><br><span class="line">    merge_slashes on;</span><br><span class="line">    #DNS解析地址 resolver address ...; 配置块:http,server,location 设置DNS名字解析服务器地址.</span><br><span class="line">    #DNS解析超时时间 resolver_timeout time; 配置块:http,server,location</span><br><span class="line">    resolver_timeout 30s;</span><br><span class="line">    #server_tokens on|off; 返回错误页面时是否在Server中注明nginx版本 配置块:http,server,location 方便定位问题</span><br><span class="line">    server_tokens on;</span><br><span class="line"></span><br><span class="line">    #server块 虚拟主机定义</span><br><span class="line">    server &#123;</span><br><span class="line">        #监听端口 默认监听80端口 listen决定nginx服务如何监听端口.在listen后面可以只加IP地址,端口或主机名</span><br><span class="line">        #listen 127.0.0.1:8080;</span><br><span class="line">        #listen 127.0.0.1;  #不写端口时,默认监听80端口</span><br><span class="line">        #listen *:80;</span><br><span class="line">        #listen localhost:80;</span><br><span class="line">        #listen后面也可以加其他参数</span><br><span class="line">        #1. default/default_server: 将这个server块作为整个Web服务的默认server块.未设置则将nginx解析配置时找到的第一个server块作为默认块,当一个请求无法匹配配置文件中所有主机域名时,选择默认的虚拟主机.</span><br><span class="line">        #2. backlog=num: 表示TCP中backlog队列的大小,默认为-1,表示不予设置.在TCP三次握手的工程中,进程还没有开始处理监听句柄,这时backlog队列会放置这些新连接.如果backlog队列已满,新的客户端试图建立新连接将会失败.</span><br><span class="line">        #3. rcvbuf=size: 设置监听句柄的SO_RCVBUF参数 </span><br><span class="line">        #4. sndbuf=size: 设置监听句柄的SO_SNDBUF参数</span><br><span class="line">        #5. accept_filter: 设置accept过滤器,只对FreeBSD操作系统有效</span><br><span class="line">        #6. deferred: 设置该参数,若用户发起建立连接请求,并且完成TCP的三次握手,内核也不会调度worker进程来处理这个连接,当用户真的发送请求数据时,内核才会调度worker进程处理这个连接,这个参数适合大并发的情况下,减轻worker进程的负担</span><br><span class="line">        #7. bind: 绑定当前端口/地址对, 只有同时对一个端口监听多个地址才会生效</span><br><span class="line">        #8. ssl: 在当前监听的端口上建立的连接必须基于SSL协议</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        #主机名称 server_name可以跟多个主机名称</span><br><span class="line">        #server_name  localhost test.casezheng.date;</span><br><span class="line">        #server_name  localhost 127.0.0.1;</span><br><span class="line">        #当nginx处理一个HTTP请求时,nginx取出header头中的host,与每个server中的server_name匹配.匹配规则如下:</span><br><span class="line">        #1. 完全匹配server_name</span><br><span class="line">        #2. 通配符在前面的server_name</span><br><span class="line">        #3. 通配符在后面的server_name</span><br><span class="line">        #4. 正则表达式才匹配的server_name</span><br><span class="line">        #5. 前面都未匹配到,找listen配置项后加了default或default_server的server块</span><br><span class="line">        #6. 前面都未匹配到,找匹配listen端口的第一个server块</span><br><span class="line">        #server_name后面跟空字符串表示匹配没有host这个HTTP头部的请求</span><br><span class="line">        server_name  localhost test.casezheng.date;</span><br><span class="line"></span><br><span class="line">        #server_name_in_redirect 重定向主机名称 配合server_name使用,当打开时表示重定向请求时会使用server_name里配置的第一个主机名代替原先请求中的Host头部,关闭时表示在重定向请求时使用请求本身的Host头部. 适用于配置块:http,server,location  默认on</span><br><span class="line">        server_name_in_redirect on;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #location 语法: location [=|~|~*|^~|@]/uri/ &#123; ... &#125; 适用于配置块:server  location尝试根据用户请求中的URI来匹配/uri表达式,如果可以匹配,就选择location块中的配置处理用户请求, 匹配规则如下:</span><br><span class="line">        #1. =表示把URI作为字符串,以便与参数中的uri做完全匹配</span><br><span class="line">        #2. ~表示匹配URI时是大小写敏感的</span><br><span class="line">        #3. ~*表示匹配URI时忽略字母大小写问题</span><br><span class="line">        #4. ^~表示匹配URI时只需要其前半部分与uri参数匹配即可</span><br><span class="line">        #5. @表示仅用于nginx服务内部请求之间的重定向</span><br><span class="line">        #在uri参数中可以使用正则表达式进行匹配</span><br><span class="line">        #location存在顺序,当一个请求有可能匹配多个location时,该请求将被第一个location处</span><br><span class="line">        </span><br><span class="line">        root /data/nginx/;</span><br><span class="line"></span><br><span class="line">        #对客户端请求的限制</span><br><span class="line">        #对HTTP方法名限制用户请求 limit_except method ... &#123; ... &#125; 配置块:location   nginx通过limit_except后面指定的方法名来限制用户请求.方法名取值包括:GET,HEAD,POST,PUT,DELETE,MKCOL,COPY,MOVE,OPTIONS,PROPFIND,PROPPATCH,LOCK,UNLOCK或者PATCH.</span><br><span class="line">        #请求包体的最大值 client_max_body_size size; 配置块:http,server,location 浏览器发送含较大HTTP包体的请求时,其头部有Content-Length字段,client_max_body_size是用来限制Content-Length所示值的大小的.nginx在接受到包头后,发现Content-Length的值大于client_max_body_size,直接发送403(&quot;Request Entity Too Large&quot;)响应给客户端</span><br><span class="line">        client_max_body_size 1m;</span><br><span class="line"></span><br><span class="line">        #对请求的限制 limit_rate speed; 配置块:http,server,location,if 对客户端请求限制每秒传输的字节数. 0表示不限速.</span><br><span class="line">        limit_rate 0;</span><br><span class="line">        #limit_rate_after length; 表示nginx向客户端发送的请求长度超过limit_rate_after后才开始限速.</span><br><span class="line">        limit_rate_after 100m;</span><br><span class="line"></span><br><span class="line">        location = /test_root &#123;</span><br><span class="line">            #以root方式设置资源路径 适用于配置块:http,server,location,if  root根据完整的URI请求来映射</span><br><span class="line">            #root /data/nginx/;</span><br><span class="line">            limit_except GET &#123;</span><br><span class="line">                allow 192.168.1.0/32;</span><br><span class="line">                deny all;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /test_alias &#123;</span><br><span class="line">            #以alias方式设置资源路径 适用于配置块:location alias在URI向实际文件路径的映射过程中,会丢弃掉location后面配置的那部分uri</span><br><span class="line">            alias /data/nginx/test_alias/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            #访问首页   语法: index file ...; 用ngx_http_index_module模块提供的index配置实现返回网站首页,nginx按照配置的顺序访问index后配置的文件</span><br><span class="line">            root   /data/nginx;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page code [code...][=|=answer-code]uri|@named_location  适用于配置块:http,server,location,if</span><br><span class="line">        #当某个请求返回错误码时,如果匹配上了erro_page中设置的code,则重定向到新的URI中.</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line">        #error_page  404 =200         /404.html;    #重定向后返回的错误码还是原来的,可以通过=更改返回的错误码</span><br><span class="line">        #error_page  404 =            /404.html;    #也可以不指定确切的返回码,由重定向后实际处理的真实结果决定</span><br><span class="line">        #如果不行修改URI,只是将错误请求重定向到另一个location处理,可以如下配置,将错误请求代理到http://test.casezheng.date/test_root上游服务器处理</span><br><span class="line">        location /test_error_fallback &#123;</span><br><span class="line">            error_page 404 @fallback;</span><br><span class="line">        &#125;</span><br><span class="line">        location @fallback &#123;</span><br><span class="line">            proxy_pass http://test.casezheng.date;</span><br><span class="line">        &#125;</span><br><span class="line">        #递归使用error_page  recursive_error_pages [on|off]</span><br><span class="line">        recursive_error_pages off;  #默认不允许递归定义error_page</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   /data/nginx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ^~ /test_try_files &#123;</span><br><span class="line">            #try_files后跟若干路径,最后必须有uri参数. nginx尝试按顺序访问每个路径,如果可以有效访问则返回,否则继续读取下一个.如果所有路径都读取不到则重定向到最后的参数uri上.因此最后的uri参数必须存在而且是可以重定向的.</span><br><span class="line">            #try_files适用于server,location配置块</span><br><span class="line">            try_files /test_try1 /test_try2 /test_try3 @fallback;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx配置反向代理服务器"><a href="#nginx配置反向代理服务器" class="headerlink" title="nginx配置反向代理服务器"></a>nginx配置反向代理服务器</h2><p>反向代理(reverse proxy)方式指用代理服务器接受Internet上的连接请求,然后将请求转发给内部网络中的上游服务器,并将从上游服务器得到的结果返回给Internet上请求连接的客户端.反向代理服务器必须能够能支持大量并发请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                      Nginx</span><br><span class="line">            ---静态文件请求---&gt;</span><br><span class="line">                                  静态Web服务器</span><br><span class="line">            &lt;---文件内容-------    </span><br><span class="line">Web浏览器                                 </span><br><span class="line">            ---静态文件请求---&gt;                   ---转发动态请求---&gt;</span><br><span class="line">                                  反向代理服务器                      处理复杂业务的动态Web服务器</span><br><span class="line">            &lt;---转发动态应答---                   &lt;----动态应答------</span><br></pre></td></tr></table></figure>
<p>nginx的反向代理特点</p>
<ul>
<li>2 用户发来的请求将会完整地缓存到nginx代理服务器,之后才会向后端服务器转发</li>
<li>3 nginx反向代理服务器可以按照多种方案从上游服务器的集群中选择一台.负载均衡方案包括按IP地址做散列等</li>
<li>5 如果上游服务器返回内容,则不会先完整缓存到nginx代理服务器再发给客户端,而是边接收边转发到客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                    2----&gt; 缓存的HTTP包体                   上游服务器</span><br><span class="line">                                    |</span><br><span class="line">            --------1------&gt;        |               ---------3---------&gt; </span><br><span class="line">客户端                         nginx反向代理服务器                              上游服务器</span><br><span class="line">            &lt;-------5-------                        &lt;--------4----------</span><br><span class="line"></span><br><span class="line">                                                                            上游服务器</span><br></pre></td></tr></table></figure>
<p>nginx的反向代理方案主要是为了降低上游服务器的并发压力.缺点是:延长了一个请求的处理时间,并增加了用于缓存请求内容的内存和磁盘空间,增加了nginx的压力.</p>
<h2 id="负载均衡和反向代理的基本配置"><a href="#负载均衡和反向代理的基本配置" class="headerlink" title="负载均衡和反向代理的基本配置"></a>负载均衡和反向代理的基本配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">http &#123;</span><br><span class="line">	... ...</span><br><span class="line">    #upstream name &#123;...&#125; 配置块:http upstream块定义一个上游服务器的集群,便于反向代理中proxy_pass使用.</span><br><span class="line">    #server name [parameters]; 配置块:upstream server配置项指定了一个上游服务器的名字,可以是域名,IP地址端口,UNIX句柄等,其后可跟如下参数</span><br><span class="line">    #1. weight=number:设置向这台上游服务器转发的权重,默认为1</span><br><span class="line">    #2. max_fails=number:与fail_timeout配合使用,指在fail_timeout时间段内,如果向当前的上游服务器转发失败次数超过number,则认为在当前的fail_timeout时间段内这台上游服务器不可用,max_fails默认为1,设置为0表示不检查失败次数</span><br><span class="line">    #3. fail_timeout:表示该时间段内转发失败多少次后就认为上游服务器暂时不可用,用于优化反向代理功能.该值与向上游服务器建立连接的超时时间,读取上游服务器的响应超时时间等完全无关.fail_timeout默认为10s</span><br><span class="line">    #4. down:表示所在的上游服务器永久下线,只在使用ip_hash配置项时才有用</span><br><span class="line">    #5. backup:在使用ip_hash配置时无效,表示所在的上游服务器只是备份服务器,当所有非备份上游服务器都失效后,才会向所在的上游服务器转发请求</span><br><span class="line">    #ip_hash; 配置块:upstream 按ip hash转发,确保同一个客户端的请求只转发到指定的上游服务器, ip_hash不可与weight配置同时使用. 当upstream集群有一台上游服务器不可用时不可直接删除该配置,而是用down参数标识,确保转发的一致性.</span><br><span class="line">    upstream backend1 &#123;</span><br><span class="line">        server example1.casezheng.date weight=5;</span><br><span class="line">        server example2.casezheng.date max_fails=2 fail_timeout=30s;</span><br><span class="line">        server example3.casezheng.date down;</span><br><span class="line">        server example4.casezheng.date;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream backend2 &#123;</span><br><span class="line">        ip_hash;    </span><br><span class="line">        server example1.casezheng.date;</span><br><span class="line">        server example2.casezheng.date;</span><br><span class="line">        server example3.casezheng.date down;</span><br><span class="line">        server example4.casezheng.date;</span><br><span class="line">    &#125;</span><br><span class="line">    #proxy_pass URL; 配置块:location, if 将当前请求反向代理到URL参数指定的服务器上,URL可以是主机名或IP加端口或直接使用upstream块 默认情况下反向代理不转发请求中的Host头部,如果需要转发,需要加上 proxy_set_header Host $host;</span><br><span class="line">    #proxy_method method; 配置块:http,server,location 表示转发时的协议方法名</span><br><span class="line">    #proxy_hide_header the_header; 配置块:http,server,location nginx将上游服务器的响应转发给客户端,但默认不转发以下HTTP头部字段:Data,Server,X-Pad和X-Accel-*.使用proxy_hide_header后k而已任意指定哪些HTTP头部字段不能被转发</span><br><span class="line">    #proxy_pass_header the_header; 配置块:http,server,location 与proxy_hide_header相反,将原本被禁止的header设置为允许转发.</span><br><span class="line">    #proxy_pass_request_body on|off; 配置块:http,server,location 向上游服务器发送HTTP包体</span><br><span class="line">    #proxy_pass_request_headers on|off; 配置块:http,server,location 向上游服务器发送HTTP包头</span><br><span class="line">    #proxy_redirect [default|off|redirect reqlacement]; 配置块:http,server,location</span><br><span class="line">    #proxy_next_upstream [error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off]; 配置块:http,server,location  表示当向一台上游服务器转发请求错误时,继续换一台上游服务器处理这个请求</span><br><span class="line">    server  &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name exampel.casezheng.date;</span><br><span class="line"></span><br><span class="line">        proxy_method POST;</span><br><span class="line">        proxy_pass_request_body on;</span><br><span class="line">        proxy_pass_request_headers on;</span><br><span class="line">        #proxy_redirect default;</span><br><span class="line">        proxy_next_upstream error timeout;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nginx-http模块调用的简化流程"><a href="#nginx-http模块调用的简化流程" class="headerlink" title="nginx http模块调用的简化流程"></a>nginx http模块调用的简化流程</h1><p><img src="/Picture/simplified_flow_of_nginx_http_module_calls.svg" alt="nginx http模块调用的简化流程"></p>
<h1 id="nginx基础架构"><a href="#nginx基础架构" class="headerlink" title="nginx基础架构"></a>nginx基础架构</h1><h1 id="nginx数据结构"><a href="#nginx数据结构" class="headerlink" title="nginx数据结构"></a>nginx数据结构</h1><h2 id="ngx-list-t"><a href="#ngx-list-t" class="headerlink" title="ngx_list_t"></a>ngx_list_t</h2><p><img src="/Picture/nginx_ngx_list_t.png" alt="nginx ngx_list_t链表结构内存分布"></p>
<h1 id="nginx源码阅读"><a href="#nginx源码阅读" class="headerlink" title="nginx源码阅读"></a>nginx源码阅读</h1><p><a href="https://github.com/CaseZheng/nginx" target="_blank" rel="noopener">nginx-1.15.6源码阅读注释</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>深入理解Nginx模块开发与架构解析第2版</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CaseZheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CaseZheng</p>
  <div class="site-description" itemprop="description">CaseZheng的博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CaseZheng" title="GitHub → https://github.com/CaseZheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:764307915@qq.com" title="E-Mail → mailto:764307915@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CaseZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">717k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
