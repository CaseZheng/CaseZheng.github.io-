<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F14AAB2D4C842CB9F200D0A80DA8CB2F">
  <meta name="baidu-site-verification" content="GNlbaIvRtqlfiBfg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.casezheng.date","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CaseZheng的博客网站">
<meta property="og:type" content="website">
<meta property="og:title" content="CaseZheng">
<meta property="og:url" content="http://www.casezheng.date/page/11/index.html">
<meta property="og:site_name" content="CaseZheng">
<meta property="og:description" content="CaseZheng的博客网站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CaseZheng">
<meta name="twitter:description" content="CaseZheng的博客网站">

<link rel="canonical" href="http://www.casezheng.date/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CaseZheng</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f1686055a927fa7bf1a09bc1143b57c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CaseZheng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CaseZheng Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/13/stl-deque-stack-queue-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/13/stl-deque-stack-queue-4/" class="post-title-link" itemprop="url">SGI STL 标准库 deque stack queue 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-13 19:04:00" itemprop="dateCreated datePublished" datetime="2017-06-13T19:04:00+08:00">2017-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/CaseZheng/SourceCodeAnalysis" target="_blank" rel="noopener">github源码分析仓库</a></p>
<h1 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h1><p>vector是单向开口的连续线程空间，deque是双向开口的连续线性空间。<br>deque支持常数事件内对起头端进行元素的插入和移除操作。deque没有容量的概念，因为它由动态分段连续空间组合而成，随时可以增加一段新空间并链接起来。<br>deque提供RandomAccessIterator。<br>deque是由一段一段的定量连续空间组成。一旦有必要在deque的前端或者尾端增加新空间，则需要配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在分段的定量连续空间上，维护其整体连续的假象，提供随机存取的接口，避开”重新配置、复制、释放”，代价则是复杂的迭代器构架。<br>deque采用一块”map”(不是STL的map容器)作为主控，管理缓冲区(多块定量连续空间)。”map”是一小块连续空间，每个node都是指针，指向另一段连续线性空间，即缓冲区，缓冲区是deque的存储空间主体。SGI STL允许指定缓冲区大小，默认0表示使用512B缓冲区。</p>
<h2 id="deque的结构设计中，map和node-buffer的关系"><a href="#deque的结构设计中，map和node-buffer的关系" class="headerlink" title="deque的结构设计中，map和node-buffer的关系"></a>deque的结构设计中，map和node-buffer的关系</h2><p><img src="/Picture/STL-deque_map_node-buffer.jpg" alt="deque的结构设计中，map和node-buffer的关系"></p>
<h2 id="deque中控器、缓冲区、迭代器的相互关系"><a href="#deque中控器、缓冲区、迭代器的相互关系" class="headerlink" title="deque中控器、缓冲区、迭代器的相互关系"></a>deque中控器、缓冲区、迭代器的相互关系</h2><p><img src="/Picture/STL-deque_map_node-buffer.jpg" alt="deque中控器、缓冲区、迭代器的相互关系"></p>
<h2 id="deque-begin-传回迭代器start-deque-end-传回迭代器finish"><a href="#deque-begin-传回迭代器start-deque-end-传回迭代器finish" class="headerlink" title="deque::begin()传回迭代器start, deque::end()传回迭代器finish"></a>deque::begin()传回迭代器start, deque::end()传回迭代器finish</h2><p><img src="/Picture/STL-deque-map_buffer_iterator_start_finish.jpg" alt="deque::begin()传回迭代器start, deque::end()传回迭代器finish"></p>
<p><strong>deque的插入、删除操作会导致迭代器失效</strong>，需要注意。</p>
<h1 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h1><p>stack是种先进后出(FILO)的数据结构，只要一个出口，stack允许新增元素，移除元素，取得最顶端元素。stack不允许遍历行为，因此stack没有迭代器。<br>SGI STL缺省使用deque作为stack的底部结构，因此stack是一种配接器(修改某物接口，形成另一种风貌)。<br>stack也可以用list作为底层容器。</p>
<h1 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h1><p>queue是种先进先出(FIFO)的数据结构，只有一个入口，也只有一个入口，queue循序新增元素，移除元素，从最底端加入元素、取得最顶端元素。queue不允许遍历操作，因此queue没有迭代器。<br>SGI STL缺省使用deque作为queue的底部结构，因此queue是一种配接器(修改某物接口，形成另一种风貌)。<br>queue也可以用list作为底层容器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/10/stl-vector-list-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/10/stl-vector-list-3/" class="post-title-link" itemprop="url">SGI STL 标准库 vector和list 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-10 13:34:00" itemprop="dateCreated datePublished" datetime="2017-06-10T13:34:00+08:00">2017-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/CaseZheng/SourceCodeAnalysis" target="_blank" rel="noopener">github源码分析仓库</a></p>
<h1 id="容器的介绍"><a href="#容器的介绍" class="headerlink" title="容器的介绍"></a>容器的介绍</h1><p>研究数据的特定排列方式，以便于搜寻或排序或其它特殊目的，这一专门学科称为数据结构。任何特定的数据结构都是为了实现某种特定的算法。STL容器将运用最广泛的的一些数据结构实现出来。常见数据结构：array(数组)、list(链表)、tree(树)、queue(队列)、hash table(散列表)、set(集合)、map(映射表)等。这些数据结构分为序列式和关联式两种。</p>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><ul>
<li>array(build-in) C++内建</li>
<li>vector<ul>
<li>heap 以算法形式呈现(<code>xxx_heap</code>) 内部用vector实现<ul>
<li>priority-queue 内部用heap实现</li>
</ul>
</li>
</ul>
</li>
<li>list</li>
<li>slist 非标准</li>
<li>deque<ul>
<li>stack 配接器 内部用deque实现</li>
<li>queue 配接器 内部用deque实现</li>
</ul>
</li>
</ul>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><ul>
<li>RB-tree 非公开<ul>
<li>set 内部用RB-tree实现</li>
<li>map 内部用RB-tree实现</li>
<li>multiset 内部用RB-tree实现</li>
<li>multimap 内部用RB-tree实现</li>
</ul>
</li>
<li>hashtable 非标准<ul>
<li><code>hash_set</code> 非标准 内部用hashtable实现</li>
<li><code>hash_map</code> 非标准 内部用hashtable实现</li>
<li><code>hash_multiset</code> 非标准 内部用hashtable实现</li>
<li><code>hash_multimap</code> 非标准 内部用hashtable实现</li>
</ul>
</li>
</ul>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector是STL提供的一种序列式容器。vector是动态空间，在加入元素时，如果空间不足，内部机制会自行扩充空间容纳新元素。<br>vector在使用前需要包含<code>&lt;vector&gt;</code>，其内部实现位于<code>&lt;stl_vector.h&gt;</code>。<br>vector使用一块连续线性空间存储元素，支持随机存储，提供Random Access Iterator。<br>vector缺省使用alloc作为空间配置器。<br>vector的容量永远大于等于其大小，如果容量等于大小，则满载，再新加元素，整个vector需要寻找一块更大的空间。<br>vector支持动态增加大小，但并不是在原有空间之后接续新空间，而是以原大小的<strong>两倍</strong>另外配置一块较大空间，然后将原空间内容拷贝过来，在原内容之后构建新元素，并释放原空间。因此，对vector的任何操作，如果引起空间重配置，<strong>指向vector的所有迭代器将失效</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;      <span class="comment">// 5, 5, 5, 5</span></span><br><span class="line">    vec.push_back(<span class="number">6</span>);           <span class="comment">// 5, 5, 5, 5, 6</span></span><br><span class="line">    vec.push_back(<span class="number">6</span>);           <span class="comment">// 5, 5, 5, 5, 6, 6</span></span><br><span class="line">    <span class="keyword">for</span>(vecotor&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin();</span><br><span class="line">        it!=vec.end();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.erase(it);</span><br><span class="line">            <span class="comment">//++it;               //错误 vector中删除一个元素，后面元素会整体前移一次，迭代器在删除当前元素后，实际已指向下一个元素了，如果再前移，则会少遍历一个元素。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;yiyiyyigels</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resize和reserve"><a href="#resize和reserve" class="headerlink" title="resize和reserve"></a>resize和reserve</h2><p>resize改变vector大小,引起vector容量的变化,会调用默认拷贝构造函数,会导致vector的size会增加.<br>reserve改变vector容量,不改变size,只是配置空间,不调用拷贝构造函数.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_i(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_i = a.m_i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;A&gt; va;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="string">"va size:"</span>) &lt;&lt; va.size() &lt;&lt; <span class="string">" va capacity:"</span> &lt;&lt; va.capacity() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    va.resize(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="string">"va size:"</span>) &lt;&lt; va.size() &lt;&lt; <span class="string">" va capacity:"</span> &lt;&lt; va.capacity() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;A&gt; vb;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="string">"vb size:"</span>) &lt;&lt; vb.size() &lt;&lt; <span class="string">" vb capacity:"</span> &lt;&lt; vb.capacity() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    vb.reserve(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="string">"vb size:"</span>) &lt;&lt; vb.size() &lt;&lt; <span class="string">" vb capacity:"</span> &lt;&lt; vb.capacity() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">va size:0 va capacity:0</span><br><span class="line">construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">copy construct A</span><br><span class="line">va size:10 va capacity:10</span><br><span class="line">vb size:0 vb capacity:0</span><br><span class="line">vb size:0 vb capacity:10</span><br></pre></td></tr></table></figure></p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list是STl提供的一种序列式容器，每次插入或删除一个元素，就会配置或释放一个元素空间。list对任何位置元素的插入和删除都是常数时间。<br>list是一种双向链表，迭代器具备前移和后移能力，提供Bidirectional Iterator(双向迭代器)。<br>list插入一个元素不会导致迭代器失效，而vector则可能引起空间重新配置，导致迭代器全部失效。<br>list元素删除只是指向被删除元素的迭代器失效，其它迭代器不受影响。<br>SGI STL是环状双向链表，只需要一个指针就可以完整表现整个链表。让该指针指向刻意安排在尾端的一个空白节点，便能符合STL“前闭后开”区间的要求。<br>list缺省使用alloc作为空间配置器。<br>由于list不是RandomAccessIterator，无法使用STL算法sort()，所以list自己实现了sort方法。使用了<strong>归并排序</strong>，时间复杂度为<code>n*log(n)</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序 归并排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:sort()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do nothing if the list has length 0 or 1.</span></span><br><span class="line">  <span class="comment">// 如果是空链表或者只有一个元素，不需要排序。</span></span><br><span class="line">  <span class="keyword">if</span> (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123;</span><br><span class="line">    <span class="comment">//新的lists，作为中介数据存储区</span></span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __carry;</span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> __fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!empty()) &#123;      <span class="comment">//直到当前list为空</span></span><br><span class="line">      __carry.splice(__carry.begin(), *<span class="keyword">this</span>, begin());  <span class="comment">//先将begin()节点移动到__carry中，放在__carry.begin()之前</span></span><br><span class="line">      <span class="keyword">int</span> __i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123;  <span class="comment">//如果___i小于__fill 而且 __counter[__i]不为空 合并下</span></span><br><span class="line">        __counter[__i].merge(__carry);                  <span class="comment">//合并__carry到__counter[__i]  __carry变为空</span></span><br><span class="line">        __carry.swap(__counter[__i++]);                 <span class="comment">//交换__counter[__i] 和 __carry  __carry不为空 __counter[__i]为空     i自加1</span></span><br><span class="line">      &#125;</span><br><span class="line">      __carry.swap(__counter[__i]);                     <span class="comment">//交换__counter[__i] 和 __carry  __carry置为空，而__counter[__i]不为空</span></span><br><span class="line">      <span class="keyword">if</span> (__i == __fill) ++__fill;                      <span class="comment">//如果__i已经和__fill相等 就将__fill自加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据已经全部排序，并放在了__counter数组中，遍历数组，合并它们</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> __i = <span class="number">1</span>; __i &lt; __fill; ++__i)</span><br><span class="line">      __counter[__i].merge(__counter[__i<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//和排好序的新链表__counter[__fill-1]交换下</span></span><br><span class="line">    swap(__counter[__fill<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要排序21, 45, 1, 30, 52, 3, 58, 47, 22, 59, 0, 58。<br>具体过程如下：<br>取第1个数21，放入<code>__carry</code>中，没有需要合并的<strong>counter，交换``</strong>carry<code>和</code><strong>counter[0]<code>，</code></strong>fill``自加1等于1</p>
<ul>
<li><code>__counter[0]</code>:21</li>
<li><code>__counter[1]</code>:NULL</li>
</ul>
<p>取第2个数45，放入<code>__carry</code>中，和<code>__counter[0]</code>合并，合并后交换<code>__counter[0]</code>和<code>__carry</code>，<code>__i</code>自加1等于1，没有可合并的啦，交换<code>__counter[1]</code>和<code>__carry</code></p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:21, 45</li>
</ul>
<p>取第3个数1，放入<code>__carry</code>中，没有需要合并的<strong>counter，交换``</strong>carry<code>和</code>__counter[0]``</p>
<ul>
<li><code>__counter[0]</code>:1</li>
<li><code>__counter[1]</code>:21, 45</li>
</ul>
<p>取第4个数30，放入<code>__carry</code>中，和<code>__counter[0]</code>合并，合并后交换<code>__counter[0]</code>和<code>__carry</code>，<code>__i</code>自加1等于1，发现还可以和<code>__counter[1]</code>合并，合并，<code>__i</code>自加1等于2了，交换<code>__counter[2]</code>和<code>__carry</code>，<code>__fill</code>自加1等于2</p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:NULL</li>
<li><code>__counter[2]</code>:1, 21, 30, 45</li>
</ul>
<p>通过上面其实可以发现，<code>__counter</code>存放的节点数目按指数增长<code>__counter[0]</code>存放2个节点，<code>__counter[1]</code>存放4个节点，<code>__counter[2]</code>存放8个节点，… ，<code>__counter[64]</code>存放2^(64)个节点。当节点数目超过其存储的最大数时，便会和更高层的合并。再看下面的的排序情况：</p>
<p>取第5个数52，放入<code>__counter[0]</code></p>
<ul>
<li><code>__counter[0]</code>:52</li>
<li><code>__counter[1]</code>:NULL</li>
<li><code>__counter[2]</code>:1, 21, 30, 45</li>
</ul>
<p>取第6个数3，放入<code>__counter[0]</code>, <code>__counter[0]</code>满了，转移到<code>__counter[1]</code></p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:3, 52</li>
<li><code>__counter[2]</code>:1, 21, 30, 45</li>
</ul>
<p>取第7个数58，放入<code>__counter[0]</code></p>
<ul>
<li><code>__counter[0]</code>:58</li>
<li><code>__counter[1]</code>:3, 52</li>
<li><code>__counter[2]</code>:1, 21, 30, 45</li>
</ul>
<p>取第8个数47，放入<code>__counter[0]</code>, <code>__counter[0]</code>满了，和<code>__counter[1]</code>合并，发现<code>__counter[1]</code>满了，然后再和<code>__counter[2]</code>合并，发现<code>__counter[2]</code>满了，最后转移到<code>__counter[3]</code></p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:NULL</li>
<li><code>__counter[2]</code>:NULL</li>
<li><code>__counter[3]</code>:1, 3, 21, 30, 45, 47, 52, 58</li>
</ul>
<p>取第9个数22，放入<code>__counter[0]</code></p>
<ul>
<li><code>__counter[0]</code>:22</li>
<li><code>__counter[1]</code>:NULL</li>
<li><code>__counter[2]</code>:NULL</li>
<li><code>__counter[3]</code>:1, 3, 21, 30, 45, 47, 52, 58</li>
</ul>
<p>取第10个数59，放入<code>__counter[0]</code>, 转移到<code>__counter[1]</code></p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:22, 59</li>
<li><code>__counter[2]</code>:NULL</li>
<li><code>__counter[3]</code>:1, 3, 21, 30, 45, 47, 52, 58</li>
</ul>
<p>取第11个数0，放入<code>__counter[0]</code></p>
<ul>
<li><code>__counter[0]</code>:0</li>
<li><code>__counter[1]</code>:22, 59</li>
<li><code>__counter[2]</code>:NULL</li>
<li><code>__counter[3]</code>:1, 3, 21, 30, 45, 47, 52, 58</li>
</ul>
<p>取第12个数58，放入<code>__counter[0]</code>,<code>__counter[0]</code>满了，和<code>__counter[1]</code>合并，<code>__counter[1]</code>满了，转移到<code>__counter[2]</code></p>
<ul>
<li><code>__counter[0]</code>:NULL</li>
<li><code>__counter[1]</code>:NULL</li>
<li><code>__counter[2]</code>:0, 22, 58, 59</li>
<li><code>__counter[3]</code>:1, 3, 21, 30, 45, 47, 52, 58</li>
</ul>
<p>现在所有的节点都加入了<code>__counter</code>，遍历<code>__counter</code>，合并它们，最后<code>__counter[__fill-1]</code>就是排序后的目标链表</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>STL源码剖析(侯捷)</li>
<li><a href="http://blog.csdn.net/qq276592716/article/details/7932483" target="_blank" rel="noopener">http://blog.csdn.net/qq276592716/article/details/7932483</a></li>
<li><a href="http://blog.csdn.net/lijun5635/article/details/23963707" target="_blank" rel="noopener">http://blog.csdn.net/lijun5635/article/details/23963707</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/09/stl-iterators-traits-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/09/stl-iterators-traits-2/" class="post-title-link" itemprop="url">SGI STL 标准库 迭代器与类型萃取 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-09 15:40:00" itemprop="dateCreated datePublished" datetime="2017-06-09T15:40:00+08:00">2017-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL-迭代器-类型萃取"><a href="#STL-迭代器-类型萃取" class="headerlink" title="STL 迭代器 类型萃取"></a>STL 迭代器 类型萃取</h1><p><a href="https://github.com/CaseZheng/SourceCodeAnalysis" target="_blank" rel="noopener">github源码分析仓库</a><br>迭代器是一种抽象设计概念，Iterator模式定义：提供一种方法，使之能够依次遍历某个容器所包含的各个元素，而不需要暴露该容器的内部表达方式。<br>STL中心思想：将数据容器和算法分开，独立设计，再将其结合在一起使用。<br>迭代器是一种智能指针，迭代器重载<code>operator*</code>和<code>operator-&gt;</code>操作符。<br>算法在使用迭代器时可能需要其相应的类型，比如迭代器所指之物的类型。</p>
<h2 id="利用函数模版的参数推导机制获取型别"><a href="#利用函数模版的参数推导机制获取型别" class="headerlink" title="利用函数模版的参数推导机制获取型别"></a>利用函数模版的参数推导机制获取型别</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func_impl</span>(<span class="title">I</span> <span class="title">iter</span>, <span class="title">T</span> <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T tmp;      <span class="comment">//T就是迭代器iter所指之物的类型</span></span><br><span class="line">    <span class="comment">//func应该做的工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">func</span>(<span class="title">I</span> <span class="title">iter</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    func_impl(iter, *iter);     <span class="comment">//func的工作移到func_impl</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明内嵌类型获得迭代器所指之物及其它需要的类型"><a href="#声明内嵌类型获得迭代器所指之物及其它需要的类型" class="headerlink" title="声明内嵌类型获得迭代器所指之物及其它需要的类型"></a>声明内嵌类型获得迭代器所指之物及其它需要的类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;           <span class="comment">//内嵌类型声明</span></span><br><span class="line">    T *ptr;</span><br><span class="line">    MyIter(T* p=<span class="number">0</span>) : ptr(p) &#123;&#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:<span class="function">value_type <span class="title">func</span><span class="params">(I ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">MyIter&lt;<span class="keyword">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> ine(<span class="number">8</span>))</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;func(ite);</span><br></pre></td></tr></table></figure>
<p>利用在迭代器类内部内嵌类型声明，可以得到类内部所拥有的对象的各个类型，但迭代器还可以是原生指针，原生指针无法进行内嵌类型声明，需要使用C++模版偏特化，提供原生指针的特化版本解决问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">func</span>(<span class="title">T</span>* <span class="title">ite</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计中间件萃取器获取迭代器所包含的类型"><a href="#设计中间件萃取器获取迭代器所包含的类型" class="headerlink" title="设计中间件萃取器获取迭代器所包含的类型"></a>设计中间件萃取器获取迭代器所包含的类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//萃取器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:<span class="function">value_type <span class="title">fun</span><span class="params">(I ite)</span> <span class="comment">//返回值使用萃取器获取</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本，用于迭代器是原生指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;I*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> I value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本，用于迭代器是const原生指针的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const I*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> I value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过iterator<code>_traits</code>可以方便的获取迭代器的相应类型。<br>最常用的迭代器类型有五种：<code>value_type</code>、<code>difference_type</code>、<code>pointer</code>、<code>reference</code>、<code>iterator_category</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category   iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type     difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer             pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference           reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>value_type</code>即迭代器所指对象的类型。<br><code>difference_type</code>用来表示两个迭代器之间的距离。<br><code>reference</code>引用类型。<br><code>pointer</code>指针类型。<br><code>iterator_category</code>迭代器类型。</p>
<p>迭代器类型根据移动和可进行操作分为五种：</p>
<ul>
<li>input iterator: 该类型迭代器所指对象不允许外界改变，只读 单向移动</li>
<li>output iterator: 唯写 单向移动</li>
<li>forward iterator: 读写 单向移动</li>
<li>bidirectional iterator: 可双向移动迭代器 读写</li>
<li>random access iterator: 随机迭代器 读写</li>
</ul>
<p>迭代器的分类和从属关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input iterator      output iterator</span><br><span class="line">        |               |</span><br><span class="line">        forward iterator</span><br><span class="line">              |</span><br><span class="line">      bidirectional iterator</span><br><span class="line">              |</span><br><span class="line">      random access iterator</span><br></pre></td></tr></table></figure></p>
<p>它们的关系不是继承，而是概念和强化的关系。<br>由于各种迭代器不尽相同，设计算法时，应尽量针对某种迭代器提供明确定义，并针对更强化的某种迭代器提供另一种定义，在不同情况下提供最大效率。<br>在运行期根据迭代器类型选择不同算法版本，影响程序效率，利用重载函数机制，在编译器选择合适的版本。<br>利用萃取器取出迭代器的类型，利用迭代器类型形成函数重载，在编译器确定运行的算法版本。<br>定义五种迭代器类型作为标记用的型别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用class定义迭代器的标签，不仅促成重载机制成功运作，而且通过继承在调用函数时，如果不存在一个能力强的版本的函数，可以自动调用能力弱的版本。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">I</span>&amp; <span class="title">B</span>, <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(I&amp; B, bidirectional_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">1</span>, input_iterator_tag());          <span class="comment">//参数完全匹配 调用func(I&amp; B, input_iterator_tag)</span></span><br><span class="line">    func(<span class="number">2</span>, forward_iterator_tag());        <span class="comment">//参数未能完全匹配 由于继承关系 调用func(I&amp; B, input_iterator_tag)</span></span><br><span class="line">    func(<span class="number">3</span>, bidirectional_iterator_tag());  <span class="comment">//参数完全匹配 调用func(I&amp; B, bidirectional_iterator_tag)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL中模板参数命名以算法所能接受的最初级类型为迭代器型别参数命名。</p>
<h2 id="std-iterator的保证"><a href="#std-iterator的保证" class="headerlink" title="std::iterator的保证"></a>std::iterator的保证</h2><p>STL中任何迭代器都应该提供五种内嵌相应型别，以利于traits萃取。STL提供iterator class使每个新设计的迭代器都继承它，保证符合STL规范。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdff_t</span>,</span></span><br><span class="line"><span class="class">            <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">            <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Category        iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T               value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance        difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer         pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference       reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置适当的相应类型，是迭代器的责任。设计适当的迭代器，是容器本身的责任。因为只有容器本身知道如何遍历自己。</p>
<h2 id="SGI-STL的-type-traits"><a href="#SGI-STL的-type-traits" class="headerlink" title="SGI STL的__type_traits"></a>SGI STL的<code>__type_traits</code></h2><p>STL使用traits，对迭代器进行规范，制定出iterator_category。SGI将traits扩大到迭代器以外的其它地方, 即<code>__type_traits</code>，是SGI STL内部私有的东西，不在STL标准规范之外。<br><code>iterator_category</code>负责萃取迭代器特性，而<code>__type_traits</code>则负责萃取型别的特性。型别的特性是指其构造函数、拷贝构造函数、等号运算符重载函数、析构函数是否“没有价值”，如果答案为否定的，在对该型别进行构造、拷贝构造、析构、赋值时，可以采取效率更高的方法，直接对内存操作，不需要调用其构造、拷贝构造、析构、赋值函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SGI STL将所有都定义为最保守的值<code>__false_type</code>。然后针对每一种标量类型设计合适的<code>__type_traits</code>特化版本。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type     has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type     has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type     has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type     has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type     is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>__type_traits</code>在SGI STL中广泛使用。比如空间配置器中uninitialized_fill_n()函数、destroy()函数等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/08/skynet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/08/skynet/" class="post-title-link" itemprop="url">skynet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-08 18:33:00" itemprop="dateCreated datePublished" datetime="2017-06-08T18:33:00+08:00">2017-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="skynet配置文件说明"><a href="#skynet配置文件说明" class="headerlink" title="skynet配置文件说明"></a>skynet配置文件说明</h1><h2 id="简单配置文件示例"><a href="#简单配置文件示例" class="headerlink" title="简单配置文件示例"></a>简单配置文件示例</h2><pre><code>root = &quot;./&quot;
thread = 8
logger = nil
harbor = 1
address = &quot;127.0.0.1:2526&quot;
master = &quot;127.0.0.1:2013&quot;
start = &quot;main&quot;  -- main script
bootstrap = &quot;snlua bootstrap&quot;   -- The service for bootstrap
standalone = &quot;0.0.0.0:2013&quot;
luaservice = root..&quot;service/?.lua;&quot;..root..&quot;test/?.lua;&quot;..root..&quot;examples/?.lua&quot;
lualoader = &quot;lualib/loader.lua&quot;
snax = root..&quot;examples/?.lua;&quot;..root..&quot;test/?.lua&quot;
cpath = root..&quot;cservice/?.so&quot;
</code></pre><h2 id="必要配置项"><a href="#必要配置项" class="headerlink" title="必要配置项"></a>必要配置项</h2><ul>
<li>thread 启动多少个工作线程。通常不要将它配置超过你实际拥有的 CPU 核心数。</li>
<li>bootstrap skynet 启动的第一个服务以及其启动参数。默认配置为 snlua bootstrap ，即启动一个名为 bootstrap 的 lua 服务。通常指的是 service/bootstrap.lua 这段代码。</li>
<li>cpath 用 C 编写的服务模块的位置，通常指 cservice 下那些 .so 文件。如果你的系统的动态库不是以 .so 为后缀，需要做相应的修改。这个路径可以配置多项，以 ; 分割。</li>
</ul>
<h2 id="bootstrap代码中用到的一些配置项"><a href="#bootstrap代码中用到的一些配置项" class="headerlink" title="bootstrap代码中用到的一些配置项"></a>bootstrap代码中用到的一些配置项</h2><ul>
<li>logger 它决定了 skynet 内建的 skynet_error 这个 C API 将信息输出到什么文件中。如果 logger 配置为 nil ，将输出到标准输出。你可以配置一个文件名来将信息记录在特定文件中。</li>
<li>logservice 默认为 “logger” ，你可以配置为你定制的 log 服务（比如加上时间戳等更多信息）。可以参考 service_logger.c 来实现它。注：如果你希望用 lua 来编写这个服务，可以在这里填写 snlua ，然后在 logger 配置具体的 lua 服务的名字。在 examples 目录下，有 config.userlog 这个范例可供参考。</li>
<li>logpath 配置一个路径，当你运行时为一个服务打开 log 时，这个服务所有的输入消息都会被记录在这个目录下，文件名为服务地址。</li>
<li>standalone 如果把这个 skynet 进程作为主进程启动（skynet 可以由分布在多台机器上的多个进程构成网络），那么需要配置standalone 这一项，表示这个进程是主节点，它需要开启一个控制中心，监听一个端口，让其它节点接入。</li>
<li>master 指定 skynet 控制中心的地址和端口，如果你配置了 standalone 项，那么这一项通常和 standalone 相同。</li>
<li>address 当前 skynet 节点的地址和端口，方便其它节点和它组网。注：即使你只使用一个节点，也需要开启控制中心，并额外配置这个节点的地址和端口。</li>
<li>harbor 可以是 1-255 间的任意整数。一个 skynet 网络最多支持 255 个节点。每个节点有必须有一个唯一的编号。如果 harbor 为 0 ，skynet 工作在单节点模式下。此时 master 和 address 以及 standalone 都不必设置。</li>
<li>start 这是 bootstrap 最后一个环节将启动的 lua 服务，也就是你定制的 skynet 节点的主程序。默认为 main ，即启动 main.lua 这个脚本。这个 lua 服务的路径由下面的 luaservice 指定。</li>
</ul>
<h2 id="集群服务用到的配置项"><a href="#集群服务用到的配置项" class="headerlink" title="集群服务用到的配置项"></a>集群服务用到的配置项</h2><ul>
<li>cluster 它决定了集群配置文件的路径。</li>
</ul>
<h2 id="lua-服务由-snlua-提供，它会查找一些配置项以加载-lua-代码"><a href="#lua-服务由-snlua-提供，它会查找一些配置项以加载-lua-代码" class="headerlink" title="lua 服务由 snlua 提供，它会查找一些配置项以加载 lua 代码"></a>lua 服务由 snlua 提供，它会查找一些配置项以加载 lua 代码</h2><ul>
<li>lualoader 用哪一段 lua 代码加载 lua 服务。通常配置为 lualib/loader.lua ，再由这段代码解析服务名称，进一步加载 lua 代码。snlua 会将下面几个配置项取出，放在初始化好的 lua 虚拟机的全局变量中。具体可参考实现。<ul>
<li>SERVICE_NAME 第一个参数，通常是服务名。</li>
<li>LUA_PATH config 文件中配置的 lua_path 。</li>
<li>LUA_CPATH config 文件中配置的 lua_cpath 。</li>
<li>LUA_PRELOAD config 文件中配置的 preload 。</li>
<li>LUA_SERVICE config 文件中配置的 luaservice 。</li>
</ul>
</li>
<li>luaservice lua 服务代码所在的位置。可以配置多项，以 ; 分割。 如果在创建 lua 服务时，以一个目录而不是单个文件提供，最终找到的路径还会被添加到 package.path 中。比如，在编写 lua 服务时，有时候会希望把该服务用到的库也放到同一个目录下。</li>
<li>lua_path 将添加到 package.path 中的路径，供 require 调用。</li>
<li>lua_cpath 将添加到 package.cpath 中的路径，供 require 调用。</li>
<li>preload 在设置完 package 中的路径后，加载 lua 服务代码前，loader 会尝试先运行一个 preload 制定的脚本，默认为空。</li>
<li>snax 用 snax 框架编写的服务的查找路径。</li>
<li>profile 默认为 true, 可以用来统计每个服务使用了多少 cpu 时间。在 DebugConsole 中可以查看。会对性能造成微弱的影响，设置为 false 可以关闭这个统计。</li>
</ul>
<p>可以把一些配置选项配置在环境变量中。比如，你可以把 thread 配置在 SKYNET_THREAD 这个环境变量里。你可以在 config 文件中写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread=$SKYNET_THREAD</span><br></pre></td></tr></table></figure></p>
<p>在 skynet 启动时，就会用 SKYNET_THREAD 这个环境变量的值替换掉 config 中的 $SKYNET_THREAD 了。</p>
<h2 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h2><ul>
<li>daemon 配置 daemon = “./skynet.pid” 可以以后台模式启动 skynet 。注意，同时请配置 logger 项输出 log 。</li>
</ul>
<h1 id="skynet目录结构"><a href="#skynet目录结构" class="headerlink" title="skynet目录结构"></a>skynet目录结构</h1><ol>
<li>3rd：第三方代码，主要生成一些给lua用的so动态库</li>
<li>lualib：lua库</li>
<li>lualib-src =&gt; luaclib：给lua用的c库</li>
<li>service：lua服务</li>
<li>service-src =&gt; cservice：c服务</li>
<li>skynet-src =&gt; skynet：主程序</li>
<li>Makefile</li>
<li>client-src =&gt; client：测试客户端</li>
<li>examples：示例工程</li>
</ol>
<h1 id="skynet重要文件"><a href="#skynet重要文件" class="headerlink" title="skynet重要文件"></a>skynet重要文件</h1><ol>
<li>skynet_server.c：管理服务</li>
<li>skynet_handle.c：管理服务唯一的handle</li>
<li>skynet_module.c：启动c编写的so模块</li>
<li>skynet_monitor.c：监视服务死循环</li>
<li>skynet_mq.c：消息队列</li>
<li>skynet_timer.c：定时器</li>
<li>skynet_socket.c：Socket</li>
<li>skynet_master.c：不同skynet节点服务名字中心服务</li>
<li>skynet_harbor.c：不同skynet节点通讯</li>
</ol>
<h1 id="skynet重要模块和服务"><a href="#skynet重要模块和服务" class="headerlink" title="skynet重要模块和服务"></a>skynet重要模块和服务</h1><ol>
<li>gate.so：为整个skynet提供socket功能</li>
<li>snlua.so：启动多个lua服务</li>
<li>launcher.lua：在lua中启动服务</li>
</ol>
<h1 id="skynet重要库"><a href="#skynet重要库" class="headerlink" title="skynet重要库"></a>skynet重要库</h1><ol>
<li>skynet.lua：lua常用功能封装</li>
<li>skynet.so：lua调用skynet功能</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/07/stl-alloc-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/07/stl-alloc-1/" class="post-title-link" itemprop="url">SGI STL 标准库 空间配置器 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-07 23:21:00" itemprop="dateCreated datePublished" datetime="2017-06-07T23:21:00+08:00">2017-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL-空间配置器"><a href="#STL-空间配置器" class="headerlink" title="STL 空间配置器"></a>STL 空间配置器</h1><p><a href="https://github.com/CaseZheng/SourceCodeAnalysis" target="_blank" rel="noopener">github源码分析仓库</a></p>
<p>STL实现了两个空间配置器，<code>std::allocator</code>和<code>std::alloc</code>，<code>std::allocator</code>是STL标准的空间配置器，是对C++的<code>::operator new</code>和<code>::operator delete</code>的简单封装。<code>std::alloc</code>是SGI自定义的特殊的空间配置器。<code>std::alloc</code>是SGI STL各个容器的缺省空间配置器。</p>
<h2 id="C-new和delete-在alloc中的分解"><a href="#C-new和delete-在alloc中的分解" class="headerlink" title="C++ new和delete 在alloc中的分解"></a>C++ new和delete 在alloc中的分解</h2><p>C++内存配置操作和释放操作new和delte，分别包含两阶段操作：<br>对new</p>
<ol>
<li>调用<code>::operator new</code>分配空间</li>
<li>调用对象的构造函数</li>
</ol>
<p>对delete</p>
<ol>
<li>调用对象的析构函数</li>
<li>调用<code>::operator delete</code>释放空间</li>
</ol>
<p>STL alloc将new与delete的两个阶段区分开来，内存配置操作<code>alloc::allocate()</code>，内存释放操作<code>alloc::deallocate()</code>，对象构造<code>::construct()</code>，对象析构<code>::destroy()</code></p>
<h2 id="构造和析构工具-construct-和destroy"><a href="#构造和析构工具-construct-和destroy" class="headerlink" title="构造和析构工具 construct()和destroy()"></a>构造和析构工具 construct()和destroy()</h2><p>源代码<code>&lt;stl_construct.h&gt;</code>的部分内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);   <span class="comment">//调用 T1::T1(value) 在__p所指的内存空间上构造T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>) &#123;</span></span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1();          <span class="comment">//调用 T1::T1() 在__p所指的内存空间上构造T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">  __pointer-&gt;~_Tp();                <span class="comment">//调用析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要调用析构函数 有non-trivial destrucotr</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    destroy(&amp;*__first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要调用析构函数 有trivial destrucotr</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断元素的数值型别(value type)调用具体的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, _<span class="title">Tp</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor</span><br><span class="line">          _Trivial_destructor;</span><br><span class="line">  __destroy_aux(__first, __last, _Trivial_destructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受两个迭代器，找出元素的数值型别，根据__type_traits&lt;&gt;调用最合适的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对内置类型的特化版本</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">char</span>*, <span class="keyword">char</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">int</span>*, <span class="keyword">int</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">long</span>*, <span class="keyword">long</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">float</span>*, <span class="keyword">float</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">double</span>*, <span class="keyword">double</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  _Construct(__p, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>) &#123;</span></span><br><span class="line">  _Construct(__p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">  _Destroy(__pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  _Destroy(__first, __last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>destroy(_Tp *)</code>直接调用<code>_Destroy(_Tp *)</code>执行析构函数。<br><code>destroy(_ForwardIterator, _ForwardIterator)</code>有特化版本则直接调用，否则调用<code>_Destroy(_ForwardIterator, _ForwardIterator)</code>，通过<code>__VALUE_TYPE()</code>得到要析构对象的值类型，调用<code>__destroy(_ForwardIterator __first，_ForwardIterator __last, _Tp )</code>，使用类型萃取，通过<code>_Trivial_destructor()</code>区分调用<code>__destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)</code>或者调用<code>__destroy_aux(_ForwardIterator, _ForwardIterator, __false_type)</code>。</p>
<p><code>construct(_T1*, const _T2&amp;)</code>调用<code>_Construct(_T1* __p, const _T2&amp; __value)</code>，执行<code>new ((void*) __p) _T1(__value)</code>，构造一个对象。<br><code>construct(_T1*)调用_Construct(_T1* __p)</code>，执行<code>new ((void*) __p) _T1()</code>，构造一个对象。</p>
<h2 id="空间的配置和释放"><a href="#空间的配置和释放" class="headerlink" title="空间的配置和释放"></a>空间的配置和释放</h2><p>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责。C++的内存配置基本操作是<code>::operator new()</code>、内存释放操作是<code>::operator delete()</code>，相当于C的<code>malloc()</code>和<code>free()</code>函数，SGI用<code>malloc()</code>和<code>free()</code>完成内存的配置和释放。<br>SGI设计双层空间配置器，解决小块内存可能造成的内存碎片问题，第一级配置器直接使用<code>malloc()</code>和<code>free()</code>，第二级配置器根据不同情况采用不同策略，当要配置的内存块大于<strong>128b</strong>，调用第一次配置器，当配置的内存块小于128b，则采用memory pool整理方式。<code>__USE_MALLOC</code>用来控制配置器的使用，如果定义了<code>__USE_MALLOC</code>则只开放第一级空间配置器。<br>为了使配置器的接口符合STL规格，SGI为alloc包装了接口：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"><span class="comment">// 定义__USE_MALLOC则将__malloc_alloc_template定义为alloc</span></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 否则将__default_alloc_template定义为alloc</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::allocate(__n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::allocate(<span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::deallocate(__p, __n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::deallocate(__p, <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>simple<em>alloc的四个成员函数都是单纯的转调用，调用传递给配置器。同时将要配置元素的个数<code>__n</code>转化为要配置的空间大小``(__n*sizeof(_Tp</em>))<code>。实际使用时都调用</code>simple_alloc``。</p>
<p>一级空间配置器 <code>__malloc_alloc_template</code></p>
<ol>
<li><code>allocate()</code>直接使用<code>malloc()</code>，<code>deallocate()</code>直接使用<code>free()</code></li>
<li>模拟C++的<code>set_new_handler()</code>处理内存不足的情况</li>
</ol>
<p>二级空间配置器 <code>__default_alloc_template</code></p>
<ol>
<li>维护16个自由链表，负责16种小块内存的配置，内存池用malloc配置，如果内存不足，调用一级空间配置器</li>
<li>如果需要配置的内存块大于128b，直接调用一级空间配置器</li>
</ol>
<h2 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有template型别参数 非型别参数__inst未使用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">//函数指针 所代表的函数用来处理内存不足的情况</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);       <span class="comment">//一级配置器直接使用malloc()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);   <span class="comment">//内存不足，调用_S_oom_malloc</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);      <span class="comment">//一级配置器直接使用free()释放空间</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);        <span class="comment">//一级配置器直接使用realloc()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);    <span class="comment">//空间不足，调用_S_oom_realloc()</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置out-of-memory handler 仿真C++ set_new_handler()</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始值设为0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="comment">//如果存在__malloc_alloc_oom_handler则不断调用，尝试释放、配置、再释放、再配置，</span></span><br><span class="line">    <span class="comment">//直到分配成功。 否则 抛出异常 或者 执行exit(1)退出程序。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果存在__malloc_alloc_oom_handler则不断调用，尝试释放、配置、再释放、再配置，</span></span><br><span class="line">    <span class="comment">//直到分配成功。 否则 抛出异常 或者 执行exit(1)退出程序。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将参数inst指定为0</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>
<p>第一级空间配置器以malloc()、free()、realloc()等C函数执行实际的内存配置、释放、重配置操作，并实现类似C++ new-handler的机制。因为它未使用<code>::operator new</code>配置内存，所以不能直接运用C++ new-handler。C++ new-handler机制，要求系统在内存配置需求无法被满足时，调用一个指定的函数。</p>
<h2 id="第二级空间配置器"><a href="#第二级空间配置器" class="headerlink" title="第二级空间配置器"></a>第二级空间配置器</h2><p>第二级空间配置器避免太多小内存块造成内存碎片。<br>SGI第二级配置器，如果配置内存块大于128B时，调用第一级配置器处理，当配置内存块小于128B时，用内存池管理，即每次配置一大块内存，并维护对应的自由链表(free-list)，下次再分配相同大小的内存快时，从free-list拨出，释放小块内存则加入到free-list中。为了方便管理，SGI二级配置器，将任何小块内存调整为8的倍数，并维护16个free-list，各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128B的小块内存。<br>free-list节点结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> _Obj &#123;</span><br><span class="line">    <span class="keyword">union</span> _Obj* _M_free_list_link;</span><br><span class="line">    <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用union，从第一个字段看，_Obj可看做一个指针，指向相同形式的另一个_Obj，从第二个字段看，指向实际内存。不会为了维护联播所必须的指针造成内存的另一种浪费。<br>空间配置函数allocate()首先判断申请内存块的大小，大于128B，调用第一级空间配置器，小于128B检查对应的free-list，如果free-list有可用内存块，直接拿来用，如果没有，将区块大小上调至8的倍数，调用_S_refill()重新为free-list重新填充空间。<br>空间释放函数deallocate()首先判断内存块大小，大于128B调用第一级配置器，小于128B找到对应free-list将区块回收。<br>填充操作和内存池的实现看下面代码(附注释)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//threads用于多线程环境</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line">  <span class="comment">//将__bytes上调至8的倍数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//free-lists的节点</span></span><br><span class="line">  <span class="keyword">union</span> _Obj &#123;</span><br><span class="line">        <span class="keyword">union</span> _Obj* _M_free_list_link;      <span class="comment">//指向下一个可用的相同大小的内存块</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 16个free_lists</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];</span><br><span class="line">    <span class="comment">//根据要分配的内存块大小__bytes决定使用第n号free_lists。n从1起算。</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个大小为n的对象，并可能加入大小为__n的其它内存块到free_lists</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// 配置一大块，可容纳__nobjs个大小为"__size"的内存块</span></span><br><span class="line">  <span class="comment">// 如果配置__nobjs个内存块不足，可以减少数量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;   <span class="comment">//内存池起始位置，只在_S_chunk_alloc()中改变</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;     <span class="comment">//内存池结束位置，只在_S_chunk_alloc()中改变</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0 空间分配函数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 大于128直接调用第一级空间配置器</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::allocate(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//寻找16个free_lists中适当的一个</span></span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">//获取free_lists</span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//没有可用的free_lists，准备重新填充free_lists</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有可用的，free_lists调整下</span></span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 空间释放函数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 大于128直接调用艺集空间配置器</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::deallocate(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//寻找对应的free_lists</span></span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line">      <span class="comment">// 调整free_lists，回收内存块</span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> __default_alloc_template&lt;__threads, __inst&gt;&amp;,</span><br><span class="line">                       <span class="keyword">const</span> __default_alloc_template&lt;__threads, __inst&gt;&amp;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设__size已经上调至8的倍数</span></span><br><span class="line"><span class="comment">// __nobjs是期望获得的内存块个数，传引用，用来返回实际分配的内存块个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,</span><br><span class="line">                                                            <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//总共需要的内存块大小</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;    <span class="comment">//内存池剩余空间足够</span></span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;     <span class="comment">//调整内存池起始位置</span></span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;</span><br><span class="line">        <span class="comment">//内存池剩余空间不能完全满足需求量，但足够分配一个及以上的内存块</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);   <span class="comment">//计算可分配的内存块的个数</span></span><br><span class="line">        __total_bytes = __size * __nobjs;       <span class="comment">//重新计算分配出去的内存块大小</span></span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;         <span class="comment">//调整内存池起始位置</span></span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//内存池剩余空间不足分配一个内存块</span></span><br><span class="line">        <span class="comment">//计算重新申请内存池的大小</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get =</span><br><span class="line">          <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//内存池还有部分空间，尝试利用它们 将其加入free_lists</span></span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接调用malloc()申请内存空间</span></span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;</span><br><span class="line">            <span class="comment">//malloc()分配失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	        _Obj* __p;</span><br><span class="line">            <span class="comment">// 尝试从“尚未使用的内存块，且足够大”的free_lists中找一个内存块</span></span><br><span class="line">            <span class="comment">// 作为新的内存池</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                <span class="comment">//得到free_lists</span></span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    <span class="comment">//free_lists有未使用的内存块 调整free_lists去除未使用的内存块</span></span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    <span class="comment">//将取出的内存块作为内存池 设置内存池的起始位置和结束位置</span></span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="comment">//递归调用下，返回申请的空间</span></span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找不到合适的内存块</span></span><br><span class="line">	        _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            <span class="comment">//调用一级配置器，尝试out-of-memory</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get);</span><br><span class="line">            <span class="comment">// 调用一级配置器，可以得到内存或者抛出异常(或直接结束程序)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分配到新的内存池，调整下大小，设置内存池结束为止</span></span><br><span class="line">        _S_heap_size += __bytes_to_get;</span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">        <span class="comment">//递归调用下，返回申请的空间，修正__nobjs</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个大小为_n的对象，并且适当的为free_lists增加节点 要求__n已适当上调为8的倍数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//调用_S_chunk_alloc，尝试取得nobjs个内存块作为free_lists的新节点</span></span><br><span class="line">    <span class="comment">//__nobjs传引用，返回获得节点的个数</span></span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只获取到一个内存块，返回给调用者使用，free_lists未新加节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    <span class="comment">//调整free_lists新加节点</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在__chunk空间建立free_lists</span></span><br><span class="line">    __result = (_Obj*)__chunk;</span><br><span class="line">    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">      __current_obj = __next_obj;</span><br><span class="line">      __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);</span><br><span class="line">      <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</span><br><span class="line">        __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::reallocate(<span class="keyword">void</span>* __p,</span><br><span class="line">                                                    <span class="keyword">size_t</span> __old_sz,</span><br><span class="line">                                                    <span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line">    __result = allocate(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz);</span><br><span class="line">    deallocate(__p, __old_sz);</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//__default_alloc_template中static成员定于与初始值设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[</span><br><span class="line">    __default_alloc_template&lt;__threads, __inst&gt;::_NFREELISTS</span><br><span class="line">] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义五个全局函数，construct()、destroy()、uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()，作用于内存空间。<br>construct()用于构造，destroy()用于析构。<br><code>uninitialized_copy()</code>、<code>uninitialized_fill()</code>、<code>uninitialized_fill_n()</code>分别对应高层次函数<code>copy()</code>、<code>fill()</code>、<code>fill_n()</code>。<br><code>uninitialized_copy()</code>、<code>uninitialized_fill()</code>、<code>uninitialized_fill_n()</code>都具有要么产生所有必要元素，否则就不产生任何元素的机制。如果任何一个拷贝构造抛出异常，必须析构已产生的所有元素。<br>POD(Plain Old Data)即标量类型或传统C struct类型。POD类型必然有无价值的(trivial) ctor/dtor/copy/assignment函数，因此对于POD类型采用最有效率的操作，对非POD类型调用其ctor/dtor/copy/assignment函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POD类型，调用memcpy()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_aux</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                         __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> copy(__first, __last, __result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非POD类型，逐个调用拷贝构造函数 如果构造过程中出错抛出异常，析构已构造的对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_aux</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                         __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __result;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last; ++__first, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, *__first);</span><br><span class="line">    <span class="keyword">return</span> __cur;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__result, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter</span> __<span class="title">result</span>, _<span class="title">Tp</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//使用类型萃取，对POD类型使用memcpy()，非OPD类型逐个调用构造函数</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy_aux(__first, __last, __result, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将[__first, __last)复制一份到[__result, __result+__last-__first)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">  <span class="title">uninitialized_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter</span> __<span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy(__first, __last, __result,</span><br><span class="line">                              __VALUE_TYPE(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* __first, <span class="keyword">const</span> <span class="keyword">char</span>* __last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">char</span>* __result)</span> </span>&#123;</span><br><span class="line">  memmove(__result, __first, __last - __first);</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">wchar_t</span>*</span><br><span class="line">uninitialized_copy(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* __first, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* __last,</span><br><span class="line">                   <span class="keyword">wchar_t</span>* __result)</span><br><span class="line">&#123;</span><br><span class="line">  memmove(__result, __first, <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) * (__last - __first));</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uninitialized_copy_n (not part of the C++ standard)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_InputIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_n</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">count</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __result;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __count &gt; <span class="number">0</span> ; --__count, ++__first, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, *__first);</span><br><span class="line">    <span class="keyword">return</span> pair&lt;_InputIter, _ForwardIter&gt;(__first, __cur);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__result, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_RandomAccessIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_n</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">count</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __last = __first + __count;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_RandomAccessIter, _ForwardIter&gt;(</span><br><span class="line">                 __last,</span><br><span class="line">                 uninitialized_copy(__first, __last, __result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_InputIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_n</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">count</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy_n(__first, __count, __result,</span><br><span class="line">                                __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_InputIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">uninitialized_copy_n</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">count</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy_n(__first, __count, __result,</span><br><span class="line">                                __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Valid if copy construction is equivalent to assignment, and if the</span></span><br><span class="line"><span class="comment">// destructor is trivial.</span></span><br><span class="line"><span class="comment">//对于POD类型调用memset</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  fill(__first, __last, __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于非POD类型逐个调用构造函数 如果中途抛出异常，析构已经构造的对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __cur != __last; ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, __x);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__first, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">uninitialized_fill</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  __uninitialized_fill_aux(__first, __last, __x, _Is_POD());</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[__first, __last)中迭代器所指向的内存，已__x为参数调用_Tp的拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">uninitialized_fill</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __uninitialized_fill(__first, __last, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于POD类型逐个执行赋值操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于非POD类型逐个调用构造函数 如果中途抛出异常，析构已经构造的对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, __x);</span><br><span class="line">    <span class="keyword">return</span> __cur;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__first, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从__first开始构造__n个_Tp对象，已__x为模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class"><span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_copy</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">ForwardIter</span> __<span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">return</span> uninitialized_copy(__first2, __last2, __mid);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__result, __mid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">InputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_copy</span>(_<span class="title">ForwardIter</span> __<span class="title">result</span>, _<span class="title">ForwardIter</span> __<span class="title">mid</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uninitialized_fill(__result, __mid, __x);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">return</span> uninitialized_copy(__first, __last, __mid);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__result, __mid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_fill</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    uninitialized_fill(__mid2, __last2, __x);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_Destroy(__first2, __mid2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/06/boost-weak-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/06/boost-weak-ptr/" class="post-title-link" itemprop="url">boost 库 内存管理 weak_ptr intrusive_ptr 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-06 14:24:00" itemprop="dateCreated datePublished" datetime="2017-06-06T14:24:00+08:00">2017-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为weak_ptr不具有普通指针的行为，没有重载<code>operator*</code>和<code>operator-&gt;</code>。weak_ptr的最大作用用来协助shared_ptr工作，观测资源的使用情况。</p>
<h2 id="类摘要"><a href="#类摘要" class="headerlink" title="类摘要"></a>类摘要</h2><p><img src="/Picture/weak_ptr_class_summary.jpg" alt="weak_ptr类摘要"></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>weak_ptr被设计为与shared_ptr共同工作，可从一个shared_ptr或者weak_ptr对象构造，获得对象的观测权，但weak_ptr没有共享资源，weak_ptr不会引起指针引用计数的增加，weak_ptr析构也不会导致指针引用计数的减少。<br>weak_ptr成员函数use_count()可以观测资源的引用计数。weak_ptr成员函数expired()的功能等价于use_count()==0，表示观测的资源已经不复存在，但expired的速度更快。<br>weak_ptr没有重载<code>operator*</code>和<code>-&gt;</code>，不共享指针，不能操作资源。weak_ptr可以使用成员函数lock()从观测的shared_ptr获得可用的shared_ptr对象，操作资源，当<code>expired()==true</code>时，lock函数返回存储空指针的shared_ptr。</p>
<h2 id="获得this的shared-ptr"><a href="#获得this的shared-ptr" class="headerlink" title="获得this的shared_ptr"></a>获得this的shared_ptr</h2><p>weak_ptr的一个重要用途是获得this指针的shared_ptr，使对象自己能够生产shared_ptr管理自己，对象使用weak_ptr观测this指针，在需要的时候调用lock()函数，返回符合要求的shared_ptr供外界使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想被shared_ptr管理的类从enable_shared_from_this继承，成员函数shared_from_this()返回this的shared_ptr。不能从普通对象使用shared_from_this()获取shared_ptr，否则运行时会导致shared_ptr析构时企图删除一个栈上分配的对象。</p>
<h1 id="intrusive-ptr"><a href="#intrusive-ptr" class="headerlink" title="intrusive_ptr"></a>intrusive_ptr</h1><p>intrusive_ptr是侵入式的引用计数型指针，应用于：</p>
<ul>
<li>对内存占用的要求非常严格，要求必须与原始指针一样。</li>
<li>现存代码已经有了引用计数机制管理的对象。</li>
</ul>
<p>Boost库不推荐使用intrusive_ptr，shared_ptr足够啦。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> :</span> <span class="keyword">public</span> boost::enable_shared_from_this&lt;H&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    H(<span class="keyword">int</span> _n) : n(_n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"H ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"H n:"</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestWeakPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count:"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">boost::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count:"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"wp1 use_count:"</span>&lt;&lt;wp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!wp1.expired())</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = wp1.lock();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count:"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 use_count:"</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count:"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sp1.reset();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"wp1 use_count:"</span>&lt;&lt;wp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;H&gt; sh = boost::make_shared&lt;H&gt;(<span class="number">314</span>);</span><br><span class="line">    sh-&gt;print();</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;H&gt; sh2 = sh-&gt;shared_from_this();</span><br><span class="line">    sh-&gt;n = <span class="number">1000</span>;</span><br><span class="line">    sh2-&gt;print();</span><br><span class="line">    sh-&gt;print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/05/boost-shared-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/05/boost-shared-ptr/" class="post-title-link" itemprop="url">boost 库 内存管理 shared_ptr shared_array 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-05 14:52:00" itemprop="dateCreated datePublished" datetime="2017-06-05T14:52:00+08:00">2017-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>shared_ptr包装new操作符从堆上分配的动态对象，实现引用计数型的智能指针，可以被自由地拷贝和赋值，在任意地方共享它，当引用计数未0时，删除被包装的动态分配对象，可以被安全地放在标准容器中。</p>
<h2 id="1-类摘要"><a href="#1-类摘要" class="headerlink" title="1. 类摘要"></a>1. 类摘要</h2><p><img src="/Picture/shared_ptr_class_summary.jpg" alt="shared_ptr类摘要"></p>
<h2 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h2><p>shared_ptr用来管理new动态分配对象，重载了*和-&gt;操作符模拟原始指针行为，提供隐式bool类型转化判断指针有效性，get()获得原始指针，未提供指针算数操作。<br>shared_ptr有各种形式的构造函数</p>
<ul>
<li>无参的shared_ptr()创建持有空指针的shared_ptr。</li>
<li><code>shared_ptr(Y *)</code>获得指向类型T的指针p的管理权，同时引用计数置为1。要求Y类型必须能够转化为T类型。</li>
<li><code>shared_ptr(shared_ptr const &amp;r)</code>从另一个shared_ptr获得指针的管理权，同时引用计数加1，两个shared_ptr共享一个指针的管理权。</li>
<li><code>shared_ptr(std::auto_ptr&lt;Y&gt; &amp;r)</code>从一个<code>auto_ptr</code>获得指针管理权，引用计数置为1，<code>auto_ptr</code>自动失去管理权。</li>
<li>operator=赋值操作符从另一个shared_ptr或者<code>auto_ptr</code>获得指针管理权。</li>
<li><code>shared_ptr(Y *p, D d)</code>，参数d指定析构时的定制删除器，而不是简单的delete。</li>
</ul>
<p>shared_ptr的<code>reset()</code>函数将引用计数减1，停止对指针的共享，除非引用计数为0，否则不会发生删除操作。带参数的<code>reset()</code>对原指针引用计数减1，同时改为管理另一指针。<br>shared_ptr中<code>unique()</code>和<code>use_count()</code>检查引用计数，<code>unique()</code>在shared_ptr是指针的唯一拥有者时返回true，<code>use_count()</code>返回当前指针的引用计数。<code>use_count()</code>不提供高效率的操作，有时候不可用(极少数情况)。<code>unique()</code>总是可用的，而且速度比<code>use_count()==1</code>速度更快。<br>shared_ptr支持比较运算，等于、不等于、小于，基于内部保存的指针，shared_ptr可以被用于标准关联容器(set和map)。<br>shared_ptr指针转化<code>static_pointer_cast&lt;T&gt;()</code>、<code>const_pointer_cast&lt;T&gt;()</code>、<code>dynamic_pointer_cast&lt;T&gt;()</code>，和标准的转型操作<code>static_cast&lt;T&gt;</code>、<code>const_cast&lt;T&gt;</code>、<code>dynamic_cast&lt;T&gt;</code>类似，但返回的是转型后的shared_ptr。<br>shared_ptr支持流输出操作符<code>operator&lt;&lt;</code>，输出内部的指针值，方便调试。<br>shared_ptr提供基本的线程安全保证。</p>
<h2 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h2><h2 id="4-工厂函数"><a href="#4-工厂函数" class="headerlink" title="4. 工厂函数"></a>4. 工厂函数</h2><p>shared_ptr在<code>&lt;boost/make_shared.hpp&gt;</code>中提供了自由工厂函数<code>make_shared&lt;T&gt;()</code>，消除显示new的调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Argss</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">shared_ptr</span>&lt;T&gt; <span class="title">make_shared</span>(<span class="title">Args</span> &amp;&amp; .. <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure></p>
<p><code>make_shared()</code>函数最多可以接受10个参数，传递给类型T的构造函数，<code>创建shared_ptr&lt;T&gt;</code>的对象并返回。<code>make_shared()</code>函数比直接创建shared_ptr对象的方式快且高效，因为它内部仅分配一次内存。<br><code>allocate_shared()</code>比<code>make_shared()</code>多接受一个定制的内存分配器类型参数，其它方面相同。</p>
<h2 id="5-应用于标准容器"><a href="#5-应用于标准容器" class="headerlink" title="5. 应用于标准容器"></a>5. 应用于标准容器</h2><ul>
<li>将容器作为shared_ptr管理的对象。</li>
<li>将shared_ptr作为容器的元素。</li>
</ul>
<h2 id="6-应用于桥接模式"><a href="#6-应用于桥接模式" class="headerlink" title="6. 应用于桥接模式"></a>6. 应用于桥接模式</h2><p>桥接模式(brideg)是一种结构型设计模式，把类的具体实现细节对用于隐藏起来，达到类之间的最小耦合关系。可以将头文件的依赖关系降到最小，减少编译事件，而且可以不使用虚函数实现多态。</p>
<h2 id="7-应用于工厂模式"><a href="#7-应用于工厂模式" class="headerlink" title="7. 应用于工厂模式"></a>7. 应用于工厂模式</h2><p>工厂模式是一种创建性设计模式，包装new操作符的使用，让对象的创建集中在工程类或者工厂函数中，更容易的适应变化。</p>
<h2 id="8-定制删除器"><a href="#8-定制删除器" class="headerlink" title="8. 定制删除器"></a>8. 定制删除器</h2><p><code>shared_ptr(Y *p, D d)</code>第一个参数是被管理的指针，第二个删除器参数d则告诉shared_ptr在析构时不是使用delete操作指针p，而是要用d来操作，即把delte p换成d(p)。删除器d可以是函数对象、函数指针，只要能够像函数一样调用使得d(p)成立即可。对删除器的要求是必须是可拷贝的，不能抛出异常。shared_ptr提供自由函数<code>get_deleter(shared_ptr&lt;T&gt; const &amp;p)</code>，返回删除器指针。有了删除器可以实现管理任意资源。只要该资源提供它的释放操作，shared_ptr保证自动释放。</p>
<h2 id="9-高级议题"><a href="#9-高级议题" class="headerlink" title="9. 高级议题"></a>9. 高级议题</h2><h3 id="shared-ptr-1"><a href="#shared-ptr-1" class="headerlink" title="shared_ptr"></a>shared_ptr<void></void></h3><p><code>shared_ptr&lt;void&gt;</code>可以存储<code>void*</code>的指针，<code>而void*</code>型指针可以指向任意类型，因此<code>shared_ptr&lt;void&gt;</code>拥有了容纳任意类型的能力。但将指针存储为<code>void*</code>会丧失原来的类型信息，在使用时使用转型函数转为原来的指针，但这设计运行时动态类型转换，使代码不够安全，建议不要这样使用。</p>
<h3 id="删除器的高级用法"><a href="#删除器的高级用法" class="headerlink" title="删除器的高级用法"></a>删除器的高级用法</h3><p>基于<code>shared_ptr&lt;void&gt;</code>和定制删除器，shared_ptr可以实现退出作用域调用任意函数。</p>
<h3 id="其它高级用法"><a href="#其它高级用法" class="headerlink" title="其它高级用法"></a>其它高级用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>     //让<span class="title">C</span>代理<span class="title">B</span>，对<span class="title">B</span>的方法做一次封装</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;B&gt; p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span>:B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B ctor :"</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C::C():p(<span class="keyword">new</span> B)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    E()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"E ctor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~E()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"E dtor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> :</span> <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"class F f"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"class F g"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">E* <span class="title">create1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E*)(<span class="keyword">new</span> F);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">boost::<span class="built_in">shared_ptr</span>&lt;E&gt; <span class="title">create2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> boost::<span class="built_in">shared_ptr</span>&lt;E&gt;(<span class="keyword">new</span> F);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    G()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ctor G :"</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~G()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"dtor G :"</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteG</span><span class="params">(G *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"delete G :"</span>&lt;&lt;g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AryF</span><span class="params">(<span class="keyword">void</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"AryF"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 unique :"</span>&lt;&lt;sp1.unique()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count :"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 unique :"</span>&lt;&lt;sp1.unique()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count :"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 unique :"</span>&lt;&lt;sp2.unique()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 use_count :"</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sp2.reset();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 reset after"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 unique :"</span>&lt;&lt;sp1.unique()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp1 use_count :"</span>&lt;&lt;sp1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 unique :"</span>&lt;&lt;sp2.unique()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sp2 use_count :"</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">spA1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"spA :"</span>&lt;&lt;spA1.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工厂函数</span></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;A&gt; spA2 = boost::make_shared&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;A&gt; spA3 = boost::make_shared&lt;A, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应用于标准容器</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : v)</span><br><span class="line">    &#123;</span><br><span class="line">        it = boost::make_shared&lt;<span class="keyword">int</span>&gt;(++i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*(it)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3 = v[<span class="number">2</span>];</span><br><span class="line">    *sp3 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*v[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应用于桥接模式</span></span><br><span class="line">    C c;</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//应用于工厂模式</span></span><br><span class="line">        E * E1 = create1();</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;E&gt; E2 = create2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> (F*)E1;              <span class="comment">//E1必须手动调用delete 而E2在出作用域后自动调用 E的析构函数是protected的，所需需要转型为F再delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"桥接模式结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制删除器</span></span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;G&gt; <span class="title">pg</span><span class="params">(<span class="keyword">new</span> G(), DeleteG)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; <span class="title">pv</span><span class="params">(<span class="literal">NULL</span>, AryF)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="shared-array"><a href="#shared-array" class="headerlink" title="shared_array"></a>shared_array</h1><p>包装<code>new[]</code>操作符在堆上分配的动态数组，使用引用计数机制为动态数组提供代理，可在程序的生命周期里长期存在，直到没有任何引用后才释放内存。</p>
<h2 id="类摘要"><a href="#类摘要" class="headerlink" title="类摘要"></a>类摘要</h2><p><img src="/Picture/shared_array_class_summary.jpg" alt></p>
<ul>
<li>shared_array构造函数接受的指针必须是new[]的结果</li>
<li>提供operator[]操作符重载</li>
<li>析构函数使用delete[]，释放资源</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>最好使用<code>shared_ptr&lt;std::vector&gt;</code> 或者 <code>std::vector&lt;shared_ptr&gt;</code>来替代</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/05/boost-scoped-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/05/boost-scoped-ptr/" class="post-title-link" itemprop="url">boost 库 内存管理 scoped_ptr scoped_array 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-05 12:11:00" itemprop="dateCreated datePublished" datetime="2017-06-05T12:11:00+08:00">2017-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h1><p>scoped_ptr包装new操作符在堆上分配的动态对象，保证动态创建的对象在任何时候都可以被正确删除，<strong>scoped_ptr的所有权不能转让</strong>。</p>
<h2 id="1-类摘要"><a href="#1-类摘要" class="headerlink" title="1. 类摘要"></a>1. 类摘要</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">scoped_ptr</span> // <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * px;</span><br><span class="line">    scoped_ptr(scoped_ptr <span class="keyword">const</span> &amp;);</span><br><span class="line">    scoped_ptr &amp; <span class="keyword">operator</span>=(scoped_ptr <span class="keyword">const</span> &amp;);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>==( scoped_ptr <span class="keyword">const</span>&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>!=( scoped_ptr <span class="keyword">const</span>&amp; ) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">( T * p = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~scoped_ptr();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T * p = <span class="number">0</span>)</span></span>;</span><br><span class="line">    T &amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T * <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function">T * <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(scoped_ptr &amp; b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h2><ul>
<li>构造函数接受类型为T*的指针p，创建scoped_ptr对象，并在内部保存指针参数p，p必须是一个new表达式动态分配的结果，或者是空指针(0)。当scoped_ptr生命周期结束，析构函数~scoped_ptr()会使用delete操作符自动销毁所保存的指针对象，回收资源。</li>
<li>scoped_ptr将靠白构造函数和赋值操作符声明为私有的，禁止对指针指针的复制操作，保证被它管理的指针不能被转让所有权。</li>
<li>reset()重置scoped_ptr，删除原来保存的指针，保存新的指针。reset()一般不应该被调用，因为违背了scoped_ptr一直由scoped_ptr自己自动管理的本意。</li>
<li>scoped_ptr用operator<em>()和operator-&gt;()重载解引用操作符</em>和箭头操作符-&gt;，模仿被代理的原始指针的行为。</li>
<li>swap()交换两个scoped_ptr保存的原始指针。</li>
<li>get()返回scoped_ptr内部保存的原始指针。</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A dtor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A Print"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestScopedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">scoped_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a1.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//scoped_ptr&lt;A&gt; a2 = a1;  //错误</span></span><br><span class="line">    a1-&gt;print();</span><br><span class="line">    (*a1).print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-和auto-ptr的比较"><a href="#4-和auto-ptr的比较" class="headerlink" title="4. 和auto_ptr的比较"></a>4. 和auto_ptr的比较</h2><p>scoped_ptr不能作为容器的元素，因为不支持拷贝和赋值。</p>
<p>scoped_ptr和auto_ptr的根本区别在指针的所有权。auto_ptr被特意设计为指针的所有权是可以转移的，同一时刻只能有一个auto_ptr管理指针。scoped_ptr把拷贝构造函数和赋值函数声明为私有的，拒绝指针所有权的转让。</p>
<h1 id="scoped-array"><a href="#scoped-array" class="headerlink" title="scoped_array"></a>scoped_array</h1><p>scoped_array包装new[]操作符，在堆上动态分配数组，为动态数组提供代理，保证准确释放内存。</p>
<h2 id="1-类摘要-1"><a href="#1-类摘要-1" class="headerlink" title="1. 类摘要"></a>1. 类摘要</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">shared_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_array</span><span class="params">( Y * p )</span></span>;</span><br><span class="line">    ~shared_array();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    T &amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span> i) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function">T * <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(shared_array&lt;T&gt; &amp; other)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * px;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数接受的指针p必须是new[]的结果;</li>
<li>析构函数使用delete[]释放资源，而不是delete;</li>
<li>提供operator[]操作符重载，可以像普通数组一样用下表访问元素。</li>
</ul>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>scoped_array和scoped_ptr设计思想相同，只能在被声明的作用域内使用，不能拷贝、赋值。</p>
<h2 id="3-建议"><a href="#3-建议" class="headerlink" title="3. 建议"></a>3. 建议</h2><p>scoped_array不能动态增长、没有迭代器支持、不能搭配STL算法，仅是纯粹的”裸”数组接口。在需要动态数组的时候使用std::vector会更好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/05/boost-smart-ptr-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/05/boost-smart-ptr-summary/" class="post-title-link" itemprop="url">boost 库 内存管理 智能指针概述 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-05 11:11:00" itemprop="dateCreated datePublished" datetime="2017-06-05T11:11:00+08:00">2017-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="智能指针库概述"><a href="#智能指针库概述" class="headerlink" title="智能指针库概述"></a>智能指针库概述</h1><p>计算机系统中资源有很多种，内存、文件描述符、socket、数据库连接等，程序中申请资源后必须及时归还系统。</p>
<h2 id="1-RAII机制"><a href="#1-RAII机制" class="headerlink" title="1. RAII机制"></a>1. RAII机制</h2><p>C++程序员通常采用RAII机制(资源获取即初始化，Resource Acquisition Is Initialization)，在使用资源的构造函数中申请资源，使用后再析构函数中释放资源。<br>栈上创建的局部对象，离开作用域后自动销毁，调用析构函数释放资源。用new从堆上创建的对象，必须明确地用对应的delete操作符销毁它。</p>
<h2 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2. 智能指针"></a>2. 智能指针</h2><p>智能指针实践了代理模式，代理了原始的“裸”指针的行为，为它添加了更多更有用的特性。<br>C++异常机制加入后，为了保证new对象在正确时机delete，必须编写大量的异常捕获代码释放资源，而智能指针能保证在退出作用域时，不论时正常流程或是异常退出，总调用delete析构堆上动态分配的对象，调用析构函数，释放资源。<br>std::auto_ptr构造函数结构new操作符或者对象工厂创建出来的对象指针作为参数，代理原始指针，重载operator*和operator-&gt;，行为类似指针，可用在大多数普通指针可用的地方。当退出作用域时，C++语言保证auto_ptr对象销毁，调用auto_prt的析构函数，进而使用delete操作符删除原始指针释放资源。<br>boost.smart_ptr提供六中智能指针：<code>scoped_ptr</code>、<code>scoped_array</code>、<code>shared_ptr</code>、<code>shared_array</code>、<code>weak_ptr</code>和<code>intrusive_ptr</code>，都是异常安全的。<br>boost智能指针所指的类型T的唯一一个要求：析构函数不能抛出异常。<br>boost智能指针位于名字空间boost</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br></pre></td></tr></table></figure>
<h2 id="3-auto-ptr"><a href="#3-auto-ptr" class="headerlink" title="3. auto_ptr"></a>3. auto_ptr</h2><p><strong>目前auto_ptr已不建议使用</strong></p>
<ol>
<li>auto_ptr不能共享所有权，即不能让两个auto_ptr指向同一个对象，在用auto_ptr给其它auto_ptr赋值时，原auto_ptr失去对裸指针的引用。</li>
<li>auto_ptr不能指向数组，因为auto_ptr在析构时只是调用delete，而数组应该调用delete[]。</li>
<li>auto_per不能作为容器对象，STL容器中的元素经常要支持拷贝、赋值操作，在拷贝和赋值时auto_ptr会转移所有权，原对象和拷贝的对象不等价。</li>
<li>使用auto_ptr作为成员变量，避免资源泄露。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A dtor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A Print"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a1.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;A&gt; a2 = a1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a1.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a2.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/06/04/fedora25-to-configure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/04/fedora25-to-configure/" class="post-title-link" itemprop="url">fedora 安装配置记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-04 00:56:00" itemprop="dateCreated datePublished" datetime="2017-06-04T00:56:00+08:00">2017-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:35" itemprop="dateModified" datetime="2020-04-12T12:56:35+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-安装wget-man手册"><a href="#1-安装wget-man手册" class="headerlink" title="1.安装wget man手册"></a>1.安装wget man手册</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#yum install man-pages</span><br><span class="line">#yum install wget</span><br></pre></td></tr></table></figure>
<h1 id="2-安装yum源"><a href="#2-安装yum源" class="headerlink" title="2.安装yum源"></a>2.安装yum源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/yum.repos.d</span><br><span class="line"># wget http://mirrors.163.com/.help/fedora-163.repo //(网易开源镜像)</span><br><span class="line"># wget http://mirrors.163.com/.help/fedora-updates-163.repo</span><br><span class="line"># wget http://mirrors.sohu.com/help/fedora-sohu.repo //(搜狐开源镜像)</span><br><span class="line"># wget http://mirrors.sohu.com/help/fedora-updates-sohu.repo</span><br><span class="line"># wget http://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/fedora?codeblock=0 //(中国科技大学开源镜像 下载后注意将名称更名为fedora-ustc.repo)</span><br><span class="line"># wget http://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/fedora?codeblock=1 //将名称改为fedora-updates-ustc.repo</span><br><span class="line"># yum makecache //(更新缓存)</span><br></pre></td></tr></table></figure>
<h1 id="3-升级更新系统"><a href="#3-升级更新系统" class="headerlink" title="3. 升级更新系统"></a>3. 升级更新系统</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># yum update   #升级所有包，改变软件设置和系统设置,系统版本内核都升级 刚开始软件系统配置都没有，选择第一种</span><br><span class="line"># yum upgrade   #升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变</span><br><span class="line">（查看Linux版本的方法：</span><br><span class="line">      #uname -r        #查看当前linux系统的内核版本号</span><br><span class="line">      #uname -a       #可以查看包括内核版本号、机器硬件信息、网络节点名、操作系统名字等信息     ）</span><br></pre></td></tr></table></figure>
<h1 id="4-安装右键启动终端功能"><a href="#4-安装右键启动终端功能" class="headerlink" title="4. 安装右键启动终端功能"></a>4. 安装右键启动终端功能</h1><p>Nautilus-Open-Terminal 是一个让你随处都可以打开终端的nautilus插件。尤其是当你想在一个包含子目录的目录中对某个特定目录做命令行操作的时候，它特别有用。如果你安装了这个插件，那么你只需要做的就是右键点击这个目录，然后选择菜单项’在终端打开’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum install nautilus-open-terminal</span><br></pre></td></tr></table></figure>
<p><img src="/Picture/linux-nautilus-open-terminal.jpg" alt="效果图"></p>
<h1 id="5-安装镜像选择工具，这个工具会从所有已配置的镜像中选择速度最快的下载"><a href="#5-安装镜像选择工具，这个工具会从所有已配置的镜像中选择速度最快的下载" class="headerlink" title="5. 安装镜像选择工具，这个工具会从所有已配置的镜像中选择速度最快的下载"></a>5. 安装镜像选择工具，这个工具会从所有已配置的镜像中选择速度最快的下载</h1><p>fastestirror让yum在更新时先根据ping值进行判断，然后从最快响应的地址下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum install yum-plugin-fastestmirror</span><br></pre></td></tr></table></figure>
<p>注：安装priority yum的插件，用来设定安装软件时候软件仓库的优先级，一般是默认先从官方base或者镜像安装，然后从社区用户contribute的软件中安装，再从第三方软件仓库中安装。手动编辑 /etc/yum.repos.d/ 目录中后缀为.repo的文件来设置软件仓库的优先级， priority=N(N是整数，范围从1-99，数字越小代表优先级越高) 官方推荐配置是：[base], [addons], [updates], [extras] 这几部分 priority=1<br>[centosplus],[contrib] 这几部分priority=2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum install yum-priorities</span><br></pre></td></tr></table></figure></p>
<h1 id="6-将用户添加到sudo用户组，取消sudo每次都输入密码的限制，需要root权限"><a href="#6-将用户添加到sudo用户组，取消sudo每次都输入密码的限制，需要root权限" class="headerlink" title="6. 将用户添加到sudo用户组，取消sudo每次都输入密码的限制，需要root权限"></a>6. 将用户添加到sudo用户组，取消sudo每次都输入密码的限制，需要root权限</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>找到root ALL=(ALL) ALL 在下一行加上 ‘username ALL=(ALL) ALL’ username 是要添加的用户名, 引号中的空格都为tab</p>
<p>每次sudo命令都提示是如根密码，移动到’#%wheel ALL=(ALL) ALL’ 这一行，去掉#注释，移动到’#%wheel ALL=(ALL)NOPASSWD:ALL’这一行，去掉#注释。保存后退出。</p>
<p>添加用户到wheel用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -G wheel username</span><br></pre></td></tr></table></figure></p>
<h1 id="7-安装axelget插件"><a href="#7-安装axelget插件" class="headerlink" title="7. 安装axelget插件"></a>7. 安装axelget插件</h1><p>axelget是一个多线程下载工具，yum本身是单线程下载, 安装方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install yum-axelget</span><br></pre></td></tr></table></figure>
<p>注意：在YUM的时可能会遇到很长时间都没有速度的现象，可以Ctrl+C。终止从当前站点的下载，然后会自动选择其他站点下载，速度往往快很多。</p>
<h1 id="8-加入第三方源rpmfusion"><a href="#8-加入第三方源rpmfusion" class="headerlink" title="8. 加入第三方源rpmfusion"></a>8. 加入第三方源rpmfusion</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># wget http://download1.rpmfusion.org/free/Fedora/rpmfusion-free-release-stable.noarch.rpm</span><br><span class="line"># wget http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm</span><br><span class="line">#rpm -ivh rpmfusion-free-release-stable.noarch.rpm</span><br><span class="line">#rpm -ivh rpmfusion-nonfree-release-stable.noarch.rpm</span><br></pre></td></tr></table></figure>
<h1 id="9-给LibreOffice安装中文字体"><a href="#9-给LibreOffice安装中文字体" class="headerlink" title="9. 给LibreOffice安装中文字体"></a>9. 给LibreOffice安装中文字体</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum install libreoffice-langpack-zh-Hans</span><br></pre></td></tr></table></figure>
<h1 id="10-安装开发工具-vim-gcc-g-cmake-make-python2-python3-lua-cscope-tags"><a href="#10-安装开发工具-vim-gcc-g-cmake-make-python2-python3-lua-cscope-tags" class="headerlink" title="10. 安装开发工具 vim gcc g++ cmake make python2 python3 lua cscope tags"></a>10. 安装开发工具 vim gcc g++ cmake make python2 python3 lua cscope tags</h1><p>直接用yum安装</p>
<h1 id="11-创建SSH密钥-加入github-设置git"><a href="#11-创建SSH密钥-加入github-设置git" class="headerlink" title="11. 创建SSH密钥 加入github 设置git"></a>11. 创建SSH密钥 加入github 设置git</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>在~/.ssh下找到.pub文件，将其中的内容复制出来，打开github网站，并登陆，将其加入到github ssh keys中</p>
<p>测试下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T Git@github.com</span><br></pre></td></tr></table></figure></p>
<p>再设置下github账户名和email</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>设置github参考另一篇文章’使git显示彩色’</p>
<h1 id="11-安装rz和sz命令"><a href="#11-安装rz和sz命令" class="headerlink" title="11.安装rz和sz命令"></a>11.安装rz和sz命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install lrzsz</span><br></pre></td></tr></table></figure>
<h1 id="12-添加CentOS-SCLo软件集合仓库"><a href="#12-添加CentOS-SCLo软件集合仓库" class="headerlink" title="12.添加CentOS SCLo软件集合仓库"></a>12.添加CentOS SCLo软件集合仓库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl-rh centos-release-scl</span><br></pre></td></tr></table></figure>
<h1 id="13-安装man中文文档"><a href="#13-安装man中文文档" class="headerlink" title="13.安装man中文文档"></a>13.安装man中文文档</h1><p><a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">中文man手册</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install man-pages-zh-CN</span><br></pre></td></tr></table></figure></p>
<p><code>.bashrc</code>加入别名<code>alias cman=&#39;man -M /usr/share/man/zh_CN&#39;</code></p>
<h1 id="gnome扩展管理"><a href="#gnome扩展管理" class="headerlink" title="gnome扩展管理"></a>gnome扩展管理</h1><p>需要安装浏览器插件GNOME Shell integration，再使用yum安装chrome-gnome-shell，即可访问<a href="https://extensions.gnome.org/" target="_blank" rel="noopener">extensions.gnome.org/</a>管理gnome插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install chrome-gnome-shell</span><br></pre></td></tr></table></figure></p>
<h2 id="gnome扩展安装"><a href="#gnome扩展安装" class="headerlink" title="gnome扩展安装"></a>gnome扩展安装</h2><p>访问<a href="https://extensions.gnome.org/" target="_blank" rel="noopener">extensions.gnome.org/</a>安装插件</p>
<h1 id="gnome插件推荐"><a href="#gnome插件推荐" class="headerlink" title="gnome插件推荐"></a>gnome插件推荐</h1><ol>
<li>Applications Menu</li>
<li>Coverflow Alt-Tab</li>
<li>Dash to Dock</li>
<li>Dynamic Top Bar</li>
<li>NetSpeed</li>
<li>System Monitor</li>
<li>Window List</li>
<li>AlternateTab</li>
<li>Background Logo</li>
</ol>
<h2 id="gnome优化插件"><a href="#gnome优化插件" class="headerlink" title="gnome优化插件"></a>gnome优化插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gnome-tweak-tool</span><br></pre></td></tr></table></figure>
<p>可通过gnome优化工具打开窗口的最小化和最大化按钮<br>可通过gnome优化工具管理安装的插件</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.csdn.net/zhanghuoding/article/details/39999547" target="_blank" rel="noopener">安装Fedora 20桌面版并配置（gnome桌面环境）</a></li>
<li><a href="http://www.jquerycn.cn/a_7441" target="_blank" rel="noopener">Fedora 把用户添加到sudo用户组的方法</a></li>
<li><a href="http://blog.csdn.net/makenothing/article/details/8450417" target="_blank" rel="noopener">创建SSH密钥 </a></li>
<li><a href="https://blog.csdn.net/jack_nichao/article/details/77967159?locationNum=5&amp;fps=1" target="_blank" rel="noopener">Centos 7安装完成后需要做的事情</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/51656707" target="_blank" rel="noopener">linux下man手册的安装和使用</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CaseZheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CaseZheng</p>
  <div class="site-description" itemprop="description">CaseZheng的博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CaseZheng" title="GitHub → https://github.com/CaseZheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:764307915@qq.com" title="E-Mail → mailto:764307915@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CaseZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">717k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  


</body>
</html>
