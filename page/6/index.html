<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F14AAB2D4C842CB9F200D0A80DA8CB2F">
  <meta name="baidu-site-verification" content="GNlbaIvRtqlfiBfg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.casezheng.date","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CaseZheng的博客网站">
<meta property="og:type" content="website">
<meta property="og:title" content="CaseZheng">
<meta property="og:url" content="http://www.casezheng.date/page/6/index.html">
<meta property="og:site_name" content="CaseZheng">
<meta property="og:description" content="CaseZheng的博客网站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CaseZheng">
<meta name="twitter:description" content="CaseZheng的博客网站">

<link rel="canonical" href="http://www.casezheng.date/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CaseZheng</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f1686055a927fa7bf1a09bc1143b57c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CaseZheng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CaseZheng Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/23/command-line-arguments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/23/command-line-arguments/" class="post-title-link" itemprop="url">命令行参数的处理 gflags getopt getopt_long</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-23 00:38:00" itemprop="dateCreated datePublished" datetime="2017-09-23T00:38:00+08:00">2017-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>命令行参数的处理 gflags getopt getopt_long的简单使用与对比</p>
<h1 id="getopt-getopt-long"><a href="#getopt-getopt-long" class="headerlink" title="getopt getopt_long"></a>getopt getopt_long</h1><p>getopt是简单的命令行处理函数。而getopt_long则复杂一些，功能也更加强大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind, opterr, optopt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long_only</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>函数说明 getopt()用来分析命令行参数。参数argc和argv分别代表参数个数和内容，跟main（）函数的命令行参数是一样的。参数 optstring为选项字符串， 告知 getopt()可以处理哪个选项以及哪个选项需要参数，如果选项字符串里的字母后接着冒号“:”，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果在处理期间遇到了不符合optstring指定的其他选项getopt()将显示一个错误消息，并将全域变量optarg设为”?“字符，如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。<br>optarg 指向当前选项参数（如果有）的指针。<br>optind 再次调用getopt()时的下一个argv指针的索引。<br>opterr 是否将错误信息输出到stderr的标志，置为0表示不输出。默认输出。<br>optopt 最后一个未知选项。<br>getopt optstring参数详解：</p>
<ol>
<li>单个字符，表示选项。</li>
<li>单个字符后接一个冒号:表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</li>
<li>单个字符后跟两个冒号::表示该选项后可以跟一个参数。也可以不跟。如果跟一个参数，参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。</li>
</ol>
<p>getopt调用返回的是解析出的字符的选项。返回-1表示解析完毕。<br>简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"argv "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"optind:"</span>&lt;&lt;optind&lt;&lt;<span class="string">" opterr:"</span>&lt;&lt;opterr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getopt(argc, argv, <span class="string">"a:bcde::g"</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"optind:"</span>&lt;&lt;optind&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option a "</span>&lt;&lt;optarg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option b "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"optarg is NULL :"</span>&lt;&lt;(<span class="literal">NULL</span>==optarg)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option c "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option d "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option e "</span>&lt;&lt;optarg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"unkown option "</span>&lt;&lt;optarg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error option"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"after argv "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Other]$ ./run -aef gege -ehaha -b gaga -cd</span><br><span class="line">argv 0 ./run</span><br><span class="line">argv 1 -aef</span><br><span class="line">argv 2 gege</span><br><span class="line">argv 3 -ehaha</span><br><span class="line">argv 4 -b</span><br><span class="line">argv 5 gaga</span><br><span class="line">argv 6 -cd</span><br><span class="line">optind:1 opterr:1</span><br><span class="line">optind:2</span><br><span class="line">option a ef</span><br><span class="line">optind:4</span><br><span class="line">option e haha</span><br><span class="line">optind:5</span><br><span class="line">option b</span><br><span class="line">optarg is NULL :1</span><br><span class="line">optind:6</span><br><span class="line">option c</span><br><span class="line">optind:7</span><br><span class="line">option d</span><br><span class="line">after argv 0 ./run</span><br><span class="line">after argv 1 -aef</span><br><span class="line">after argv 2 -ehaha</span><br><span class="line">after argv 3 -b</span><br><span class="line">after argv 4 -cd</span><br><span class="line">after argv 5 gege</span><br><span class="line">after argv 6 gaga</span><br></pre></td></tr></table></figure>
<p>optind初始值为1, 因为argv[0]存储的时程序名。所以从argv[1]开始解析。而optind表示的是下一次开始解析的位置，所以optind初始值为1。<br>解析a选项，解析出紧跟着的选项参数ef。-a和ef可以紧跟着也可以用空格分割。如果选项参数中有空格需要用” “或’’括起来。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./run -a &quot;ef ef&quot;</span><br><span class="line">./run -a&quot;ef ef&quot;</span><br></pre></td></tr></table></figure>
<p>解析e选项，解析e选项的参数haha。e选项使用了::，所以选项和选项参数必须紧跟在一起，不能用空格分割。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./run -e&apos;fefe&apos;</span><br><span class="line">./run -efefe</span><br></pre></td></tr></table></figure>
<p>而<code>./run -e fefe</code> 的写法是错误的，fefe无法解析出来。<br>再解析b c d选项，如果选项后不跟参数可以写在一起，例如<code>-cd</code>。<br>解析途中碰到的gege gaga 则不解析，并将其移动到argv参数尾部。即<code>argv[]</code>中的选项和选项的参数会被放置在数组前面，而optind 会指向第一个非选项和参数的位置。</p>
<h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h2><p>getopt_long和getopt都是解析命令行参数，但getopt_long支持长选项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">//长选项名字</span></span><br><span class="line">    <span class="keyword">int</span>         has_arg;    <span class="comment">//no_argument（或0）：选项不携带参数；required_argument（或1）：选项需要参数；optional_argument（或2）：选项携带可选参数</span></span><br><span class="line">    <span class="keyword">int</span>        *flag;       <span class="comment">//指定该长选项的返回值。如果flag是NULL，getopt_long会返回val。否则，getopt_long会返回0，且flag指向的值设置为val的值，前提是该选项成功找到了</span></span><br><span class="line">    <span class="keyword">int</span>         val;        <span class="comment">//当做返回值，或把值加载进flag所指的内存中。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>longopts用来支持长选项。longopts指向数组的最后一个元素值都设置为0。</p>
<ol>
<li>注意相比getopt，使用getopt_long需要加头文件<code>&lt;getopt.h&gt;</code></li>
<li>getopt_long除了会接受长选项，其他概念和getopt是一样的</li>
<li>如果使用getopt_long想只接受短选项，设置longopts为NULL即可；如果只想接受长选项，相应地设置optstring为NULL即可</li>
<li>长选项名是可以使用缩写方式，比如：选项有<code>--file--create</code>,那么输入<code>--c</code>/<code>--cr</code>/<code>--cre</code>等均会被正确识别为create选项</li>
<li>对于带参数的长选项格式是：<code>--arg=param</code>或<code>--arg param</code></li>
<li>longopts是指向struct option数组的第一个元素的指针，struct option定义在<code>&lt;getopt.h&gt;</code>中</li>
<li>longindex如果非NULL，则是返回识别到struct option数组中元素的位置指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//getopt_long示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"argv "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"optind:"</span>&lt;&lt;optind&lt;&lt;<span class="string">" opterr:"</span>&lt;&lt;opterr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = &#123;</span></span><br><span class="line">            &#123;  <span class="string">"append"</span>,    <span class="number">1</span>,   <span class="literal">NULL</span>,   <span class="string">'a'</span> &#125;,</span><br><span class="line">            &#123;  <span class="string">"help"</span>,      <span class="number">0</span>,   <span class="literal">NULL</span>,   <span class="string">'h'</span> &#125;,</span><br><span class="line">            &#123;  <span class="string">"verbose"</span>,   <span class="number">0</span>,   <span class="literal">NULL</span>,   <span class="string">'v'</span>  &#125;,</span><br><span class="line">            &#123;  <span class="string">"output"</span>,    <span class="number">1</span>,   &amp;flag,  <span class="string">'o'</span>   &#125;,</span><br><span class="line">            &#123;  <span class="literal">NULL</span>,        <span class="number">0</span>,   <span class="literal">NULL</span>,   <span class="number">0</span>  &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">int</span> longindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getopt_long(argc, argv, <span class="string">"a:hvb:cde::g"</span>, long_options, &amp;longindex)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"optind:"</span>&lt;&lt;optind&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ch:"</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"long option "</span>&lt;&lt;longindex&lt;&lt;<span class="string">" "</span>&lt;&lt;long_options[longindex].name;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != optarg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">" arg "</span>&lt;&lt;optarg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"ch "</span>&lt;&lt;(<span class="keyword">char</span>)ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != optarg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arg "</span>&lt;&lt;optarg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option b "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"optarg is NULL :"</span>&lt;&lt;(<span class="literal">NULL</span>==optarg)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option c "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option d "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option e "</span>&lt;&lt;optarg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"option ? "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != optarg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"unkown option "</span>&lt;&lt;optarg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"unkown longindex "</span>&lt;&lt;longindex&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error option"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"after argv "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Other]$ ./run -a fe -hv -cd -b ff -append --output fe</span><br><span class="line">argv 0 ./run</span><br><span class="line">argv 1 -a</span><br><span class="line">argv 2 fe</span><br><span class="line">argv 3 -hv</span><br><span class="line">argv 4 -cd</span><br><span class="line">argv 5 -b</span><br><span class="line">argv 6 ff</span><br><span class="line">argv 7 -append</span><br><span class="line">argv 8 --output</span><br><span class="line">argv 9 fe</span><br><span class="line">optind:1 opterr:1</span><br><span class="line">optind:3</span><br><span class="line">ch:97</span><br><span class="line">ch a</span><br><span class="line">arg fe</span><br><span class="line">optind:3</span><br><span class="line">ch:104</span><br><span class="line">ch h</span><br><span class="line"></span><br><span class="line">optind:4</span><br><span class="line">ch:118</span><br><span class="line">ch v</span><br><span class="line"></span><br><span class="line">optind:4</span><br><span class="line">ch:99</span><br><span class="line">option c</span><br><span class="line">optind:5</span><br><span class="line">ch:100</span><br><span class="line">option d</span><br><span class="line">optind:7</span><br><span class="line">ch:98</span><br><span class="line">option b</span><br><span class="line">optarg is NULL :0</span><br><span class="line">optind:8</span><br><span class="line">ch:97</span><br><span class="line">ch a</span><br><span class="line">arg ppend</span><br><span class="line">optind:10</span><br><span class="line">ch:0</span><br><span class="line">long option 3 output arg fe</span><br><span class="line">after argv 0 ./run</span><br><span class="line">after argv 1 -a</span><br><span class="line">after argv 2 fe</span><br><span class="line">after argv 3 -hv</span><br><span class="line">after argv 4 -cd</span><br><span class="line">after argv 5 -b</span><br><span class="line">after argv 6 ff</span><br><span class="line">after argv 7 -append</span><br><span class="line">after argv 8 --output</span><br><span class="line">after argv 9 fe</span><br></pre></td></tr></table></figure>
<h1 id="gflags"><a href="#gflags" class="headerlink" title="gflags"></a>gflags</h1><p>gflags 是 google 开源的用于处理命令行参数的项目。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">DEFINE_bool(daemon, <span class="literal">true</span>, <span class="string">"run daemon mode"</span>);</span><br><span class="line">DEFINE_int32(port, <span class="number">9000</span>, <span class="string">"program listen port"</span>);</span><br><span class="line">DEFINE_string(confpath, <span class="string">"./config.ini"</span>, <span class="string">"program config path"</span>);</span><br><span class="line">DEFINE_double(dou, <span class="number">0</span>, <span class="string">"double"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义对 FLAGS_port 的检查函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ValidatePort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int32_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span> &amp;&amp; value &lt; <span class="number">32768</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Invalid value for --%s: %d\n"</span>, name, (<span class="keyword">int</span>)value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用,确保参数检查在main函数进入时已经注册。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> port_dummy = gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort);</span></span><br><span class="line">    gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"daemon: "</span>&lt;&lt;FLAGS_daemon&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"port: "</span>&lt;&lt;FLAGS_port&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"configpath: "</span>&lt;&lt;FLAGS_confpath&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"dou: "</span>&lt;&lt;FLAGS_dou&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    FLAGS_dou = <span class="number">9999.8</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after dou: "</span>&lt;&lt;FLAGS_dou&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SetCommandLineOption 函数对参数进行设置才会调用检查函数</span></span><br><span class="line">    gflags::SetCommandLineOption(<span class="string">"port"</span>, <span class="string">"-2"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after port: "</span>&lt;&lt;FLAGS_port&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    FLAGS_port = <span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after2 port: "</span>&lt;&lt;FLAGS_port&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Other]$ g++ -o run CommandLine.cpp -g -lgflags</span><br><span class="line">[CaseZheng@localhost Other]$ ./run -confpath   &quot;./config.txt&quot; -daemon=&quot;true&quot; --port=111 -dou 1.001</span><br><span class="line">1</span><br><span class="line">111</span><br><span class="line">./config.txt</span><br><span class="line">1.001</span><br></pre></td></tr></table></figure></p>
<p>gflags支持的类型：</p>
<ul>
<li>DEFINE_bool: boolean</li>
<li>DEFINE_int32: 32-bit integer</li>
<li>DEFINE_int64: 64-bit integer</li>
<li>DEFINE_uint64: unsigned 64-bit integer</li>
<li>DEFINE_double: double</li>
<li>DEFINE_string: C++ string</li>
</ul>
<p>如定义: <code>DEFINE_bool(daemon, true, &quot;run daemon mode&quot;);</code><br>在命令行可以这样访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./run -daemon</span><br><span class="line">./run -daemon=true</span><br><span class="line">./run -daemon=1</span><br><span class="line">./run -daemon=false</span><br><span class="line">./run --daemon true</span><br><span class="line">./run --daemon &quot;true&quot;</span><br></pre></td></tr></table></figure></p>
<p>在程序中可加前缀<code>FLAGS_</code>来访问，例如: <code>cout&lt;&lt;FLAGS_daemon&lt;&lt;endl;</code><br>gflags变量可以被修改 <code>FLAGS_daemon = true;</code></p>
<p>gflags支持从文件中读取命令行参数。<br>config.flags文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-confpath   &quot;./config.txt&quot; -daemon=&quot;true&quot; --port=111 -dou 1.001</span><br></pre></td></tr></table></figure></p>
<p>命令行使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Other]$ ./run --flagfile config.flags</span><br><span class="line">1</span><br><span class="line">9000</span><br><span class="line">./config.ini</span><br><span class="line">dou: 0</span><br><span class="line">after dou: 9999.8</span><br></pre></td></tr></table></figure></p>
<h2 id="外部引用"><a href="#外部引用" class="headerlink" title="外部引用"></a>外部引用</h2><p>如果希望在别的文件中使用gflags变量，可以使用<code>DECLARE_type</code>（type为变量类型 int string double等）来声明变量。相当与extern声明变量 例如： <code>DECLARE_bool(daemon);</code></p>
<h2 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h2><p>可以注册检查函数值的检查函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Other]$ ./run -port=99</span><br><span class="line">[CaseZheng@localhost Other]$ ./run -port=-1</span><br><span class="line">Invalid value for --port: -1</span><br><span class="line">ERROR: failed validation of new value &apos;-1&apos; for flag &apos;port&apos;</span><br><span class="line">daemon: 1</span><br><span class="line">port: 99</span><br><span class="line">configpath: ./config.ini</span><br><span class="line">dou: 0</span><br><span class="line">after dou: 9999.8</span><br><span class="line">Invalid value for --port: -2</span><br><span class="line">after port: 99</span><br><span class="line">after2 port: -2</span><br></pre></td></tr></table></figure>
<p>可以看到命令行输入错误，程序会直接退出。<br>使用SetCommandLineOption修改参数也会触发参数检测，但如果不合法，程序不退出。如果直接修改参数的值则不会触发参数检测函数。</p>
<h2 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h2><ul>
<li><code>--help</code> 打印定义过的所有参数的帮助信息</li>
<li><code>--version</code> 打印版本信息 通过google::SetVersionString()指定</li>
<li><code>--nodefok</code> 但命令行中出现没有定义的参数时，并不退出（error-exit）</li>
<li><code>--fromenv</code> 从环境变量读取参数值 <code>--fromenv=foo,bar</code>表明要从环境变量读取foo，bar两个参数的值。通过<code>export FLAGS_foo=xxx; export FLAGS_bar=yyy</code> 程序就可读到foo，bar的值分别为xxx，yyy。</li>
<li><code>--tryfromenv</code>与<code>--fromenv</code>类似，当参数的没有在环境变量定义时，不退出（fatal-exit）</li>
<li><code>--flagfile</code> 从文件读取参数值，<code>--flagfile=my.conf</code>表明要从<code>my.conf</code>文件读取参数的值。在配置文件中指定参数值与在命令行方式类似，另外在flagfile里可进一步通过<code>--flagfile</code>来包含其他的文件。</li>
</ul>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol>
<li>getopt <code>getopt_long</code>是Linux标准库中的，可以直接使用，而gflags需要安装。</li>
<li>getopt只支持短选项，<code>getopt_long</code>支持短选项和长选项，<code>getopt_long</code>支持长选项缩写，gflags不支持长选项缩写。</li>
<li>getopt、<code>getopt_long</code>是C函数，通用性强，而gflags使用C++编写，C无法直接使用。</li>
<li>getopt、<code>getopt_long</code>使用不便，gflags使用方便，清晰。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/21/io-5-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/21/io-5-epoll/" class="post-title-link" itemprop="url">Linux I/O 复用 epoll源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-21 11:51:00" itemprop="dateCreated datePublished" datetime="2017-09-21T11:51:00+08:00">2017-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux I/O epoll 源码分析</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll_create">epoll_create</a></li>
<li><a href="#epoll_ctl">epoll_ctl</a></li>
<li><a href="#epoll中的递归死循环和深度检查">epoll中的递归死循环和深度检查</a></li>
<li><a href="#循环检测">循环检测</a></li>
<li><a href="#唤醒风暴">唤醒风暴</a></li>
<li><a href="#epoll_create和epoll_ctl函数调用过程">epoll_create和epoll_ctl函数调用过程</a></li>
<li><a href="#epoll_wait函数调用主要过程">epoll_wait函数调用主要过程</a></li>
<li><a href="#epoll结构体间关系">epoll结构体间关系</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll的简单原理</p>
<ol>
<li>执行epoll_create时，创建了红黑树和就绪list链表。</li>
<li>执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。</li>
<li>执行epoll_wait时立刻返回准备就绪链表里的数据即可。</li>
</ol>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>epoll_create主要做两件事</p>
<ol>
<li>创建并初始化一个eventpoll结构体变量</li>
<li>创建epoll的file结构，并指定file的private_data指针指向刚创建的eventpoll变量，这样，只要根据epoll文件描述符epfd就可以拿到file进而就拿到了eventpoll变量了，该eventpoll就是epoll_ctl和epoll_wait工作的场所</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll文件系统的相关实现</span></span><br><span class="line"><span class="comment">//epoll文件系统初始化，在系统启动时会调用  .init段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">eventpoll_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">si</span>;</span></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    <span class="comment">//限制可添加到epoll的最多的描述符数量</span></span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / <span class="number">25</span>) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    <span class="comment">//检查递归检查队列</span></span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);</span><br><span class="line">    ep_nested_calls_init(&amp;poll_readywalk_ncalls);</span><br><span class="line">    <span class="comment">//在内核创建内存池</span></span><br><span class="line">    <span class="comment">//epoll用kmem_cache_create（slab分配器）分别用来分配epitem和eppoll_entry</span></span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, <span class="keyword">sizeof</span>(struct epitem),</span><br><span class="line">            <span class="number">0</span>, SLAB_HWCACHE_ALIGN | SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct eppoll_entry), <span class="number">0</span>, SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    error = ep_alloc(&amp;ep);        <span class="comment">//为ep在堆上申请空间并初始化    eventpoll</span></span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));<span class="comment">//会调用alloc_fd()分配文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建与eventpoll结构体相对应的file结构体，匿名文件，ep保存在file-&gt;private_data结构体中</span></span><br><span class="line">    <span class="comment">//static const struct file_operations eventpoll_fops = &#123;</span></span><br><span class="line">    <span class="comment">//    .release    = ep_eventpoll_release,</span></span><br><span class="line">    <span class="comment">//    .poll        = ep_eventpoll_poll</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立文件描述符和file之间的联系</span></span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);        <span class="comment">//释放ep  eventpoll</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epfd    epoll内核事件表的文件描述符</span></span><br><span class="line"><span class="comment">//op        要进行的操作类型</span></span><br><span class="line"><span class="comment">//fd        要监测的文件描述符</span></span><br><span class="line"><span class="comment">//event    要监测的事件</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> did_lock_epmutex = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="comment">//判断参数的合法性，将event从用户空间复制到内核空间</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);    <span class="comment">//根据文件描述符得到相应的文件对象，内核事件表</span></span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    tfile = fget(fd);        <span class="comment">//要监测的文件</span></span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">        error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)    <span class="comment">//要监测文件设备poll方法的检查</span></span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    ep = file-&gt;private_data;            <span class="comment">//获取epoll对应的eventpoll结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) &#123;</span><br><span class="line">        mutex_lock(&amp;epmutex);</span><br><span class="line">        did_lock_epmutex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(tfile)) &#123;</span><br><span class="line">            error = -ELOOP;</span><br><span class="line">            <span class="keyword">if</span> (ep_loop_check(ep, tfile) != <span class="number">0</span>) &#123;        <span class="comment">//循环检测</span></span><br><span class="line">                clear_tfile_check_list();</span><br><span class="line">                <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            list_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);        <span class="comment">//互斥锁加锁</span></span><br><span class="line">    <span class="comment">//防止重复添加（在ep的红黑树中查找是否存在这个fd），存在返回epitem，不存在返回NULL</span></span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;            <span class="comment">//不同的操作</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;    <span class="comment">//红黑树上不存在这个节点</span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;    <span class="comment">//确保“出错，连接挂起”被当作感兴趣的事件</span></span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);    <span class="comment">//添加</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        clear_tfile_check_list();        <span class="comment">//清空需要监测的文件的检查列表</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)    <span class="comment">//红黑树上存在这个节点</span></span><br><span class="line">            error = ep_remove(ep, epi);        <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);        <span class="comment">//互斥锁，解锁</span></span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">    <span class="keyword">if</span> (did_lock_epmutex)</span><br><span class="line">        mutex_unlock(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">    fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct file *tfile, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">    <span class="comment">//struct ep_pqueue &#123;        poll_table pt;        struct epitem *epi;        &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_read(&amp;ep-&gt;user-&gt;epoll_watches) &gt;=</span><br><span class="line">             max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    <span class="comment">//初始化分配epi     epitem</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epi初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);        <span class="comment">//就绪的事件链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);        <span class="comment">//连接被监听的文件</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);        <span class="comment">//poll等待队列</span></span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化的epq</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">//epq.pt-&gt;qproc = ep_ptable_queue_proc    回调函数的设置</span></span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部会调用ep_ptable_queue_proc, 在文件对应的wait queue head 上注册回调函数</span></span><br><span class="line">    <span class="comment">//并返回当前文件的状态 </span></span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)        <span class="comment">//f_op-&gt;poll过程出错</span></span><br><span class="line">        <span class="keyword">goto</span> error_unregister;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//添加当前的epitem到要监测文件的tfile-&gt;f_ep_links链表</span></span><br><span class="line">    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//插入epi到红黑树</span></span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (reverse_path_check())                <span class="comment">//唤醒风暴检查</span></span><br><span class="line">        <span class="keyword">goto</span> error_remove_epi;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//文件已经就绪，插入到epitem的就绪链表rdllist</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">    <span class="comment">//通知epoll_wait,调用回调函数唤醒epoll_wait上的进程</span></span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))        <span class="comment">//先不通知调用eventpoll_poll的进程</span></span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    atomic_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);        <span class="comment">//安全通知调用eventpoll_poll的进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_remove_epi:</span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//删除文件上的epi</span></span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;fllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//从红黑树中删除</span></span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">error_unregister:</span><br><span class="line">    <span class="comment">//从文件的wait_queue中删除，释放epitem关联的所有epoll_entry</span></span><br><span class="line">    ep_unregister_pollwait(ep, epi);</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//释放epi</span></span><br><span class="line">    kmem_cache_free(epi_cache, epi);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt)   -&gt;   poll_wait()    -&gt;   ep_ptable_queue_proc()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">                 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        <span class="comment">//pwq初始化，pwq-&gt;wait.func = ep_poll_callback;    //唤醒回调函数</span></span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;    <span class="comment">//监测文件的等待队列头</span></span><br><span class="line">        pwq-&gt;base = epi;        <span class="comment">//指向epitem</span></span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);        <span class="comment">//将等待队列项，加入到等待队列中去</span></span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);    <span class="comment">//将等待队列项保存到epi-&gt;pwqlist链表中</span></span><br><span class="line">        epi-&gt;nwait++;            <span class="comment">//poll操作中事件的个数加1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;        <span class="comment">//标识调用出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_remove</span><span class="params">(struct eventpoll *ep, struct epitem *epi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">epi</span>-&gt;<span class="title">ffd</span>.<span class="title">file</span>;</span>        <span class="comment">//获得要删除文件描述符的文件结构</span></span><br><span class="line"></span><br><span class="line">    ep_unregister_pollwait(ep, epi);    <span class="comment">//删除被监听文件的等待队列项</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;file-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;fllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);    <span class="comment">//从epitem.fllink中删除</span></span><br><span class="line">    spin_unlock(&amp;file-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);    <span class="comment">//从红黑树中删除</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);    <span class="comment">//从epitem.rdllink中删除（就绪队列）</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    kmem_cache_free(epi_cache, epi);        <span class="comment">//释放空间</span></span><br><span class="line"></span><br><span class="line">    atomic_dec(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_modify</span><span class="params">(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line"></span><br><span class="line">    epi-&gt;event.events = event-&gt;events;</span><br><span class="line">    epi-&gt;event.data = event-&gt;data;</span><br><span class="line"></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>);    <span class="comment">//获得事件掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents &amp; event-&gt;events) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">            <span class="comment">//将已就绪的等待队列项，加入到ep-&gt;rdllist链表</span></span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">                wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">                pwake++;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">        <span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="comment">//检查输入数据有效性</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    ep = file-&gt;private_data;        <span class="comment">//获得eventpoll结构</span></span><br><span class="line"></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res, eavail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> jtimeout;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line">    <span class="comment">//timeout &lt; 0 或者timeout &gt;=  EP_MAX_MSTIMEO</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;        <span class="comment">//事件就绪队列为空</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);    <span class="comment">//对当前进程设置等待项</span></span><br><span class="line">        <span class="comment">//static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    q-&gt;flags = 0;</span></span><br><span class="line">        <span class="comment">//    q-&gt;private = p;</span></span><br><span class="line">        <span class="comment">//    q-&gt;func = default_wake_function;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;    <span class="comment">//标记等待的进程是互斥进程</span></span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);    <span class="comment">//加入ep_wait()等待队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//进程状态的设置，TASK_INTERRUPTIBLE表示进程可以被信号和wake_up()唤醒</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">//就绪队列为不空  或者  睡眠时间为0</span></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;        <span class="comment">//收到信号</span></span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">//进入睡眠等待ep_poll_callback()将当前进程唤醒或超时，返回值是剩余的时间。</span></span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125; <span class="comment">//end for( ; ; )</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);    <span class="comment">//将等待队列项从ep_wait()等待队列中移除</span></span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);        <span class="comment">//表示TASK_RUNNING运行或就绪状态</span></span><br><span class="line">    &#125;  <span class="comment">//end if</span></span><br><span class="line">    <span class="comment">//ep-&gt;rdllist不空    或者  ep-&gt;ovflist不空   eavail为true</span></span><br><span class="line">    eavail = ! list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//如果没有被信号中断，并且有事件就绪，但发送成功的文件描述符为0，并且没有超时</span></span><br><span class="line">    <span class="comment">//则跳转到retry标签处，重新等待文件状态就绪</span></span><br><span class="line">    <span class="keyword">if</span> ( !res &amp;&amp; eavail &amp;&amp;  !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    <span class="keyword">return</span> res;    <span class="comment">//返回获取的事件的个数或者错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送结果到用户空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line">    esed.maxevents = maxevents;        <span class="comment">//需要检测的文件描述符个数</span></span><br><span class="line">    esed.events = events;</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *, struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//将ep-&gt;rdllist链表添加到txlist链表中去，使ep-&gt;rdllist链表为空</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">//标记ep_scan_ready_list()准备向用户空间传递事件，当有唤醒函数ep_poll_callback()调用时</span></span><br><span class="line">    <span class="comment">//将就绪的文件描述符的epitem实例加入到ovflist链表中。</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);        <span class="comment">//ep_send_events_proc</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//在执行上面代码期间，又有可能有就绪事件，这样就进入ep-&gt;ovflist队列，</span></span><br><span class="line">    <span class="comment">//将ovflist链表中的就绪文件描述符加入到rdllist    #define EP_UNACTIVE_PTR ((void *) -1L)</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist;   (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">//如果epi-&gt;rdllink为空，将epi加入到ep-&gt;rdllist中</span></span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))        <span class="comment">//list_empty(&amp;epi-&gt;rdllink)</span></span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;        <span class="comment">//标记向用户空间传递事件结束</span></span><br><span class="line"></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);        <span class="comment">//如果txlist不为空，将txlist链表加入到rdllist链表中</span></span><br><span class="line">    <span class="keyword">if</span> ( ! list_empty(&amp;ep-&gt;rdllist)) &#123;        <span class="comment">//如果文件描述符就绪链表ep-&gt;rdllist不为空</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//如果ep-&gt;wq不空，唤醒ep-&gt;wq上的进程</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;                    <span class="comment">//如果ep-&gt;poll_wait不空</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);    <span class="comment">//通知调用了poll的进程</span></span><br><span class="line">    <span class="keyword">return</span> error;        <span class="comment">//返回发送的就绪的文件描述符个数或错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head, <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> eventcnt;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;  ) &#123;</span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);        <span class="comment">//得到epitem结构体</span></span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);        <span class="comment">//从就绪链表中删除该epitem</span></span><br><span class="line"><span class="comment">//立即返回当前文件的就绪事件</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line"><span class="comment">//将就绪事件的poll_event发送至用户空间</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);        <span class="comment">//发送失败，将epi重新加入head</span></span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line"><span class="comment">//#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET)</span></span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)  <span class="comment">//如果文件描述符检测EPOLLONESHOT</span></span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line"><span class="comment">//未设置为ET(非边缘触发)模式，就将epi-&gt;rdllink加入到ep-&gt;rdllist链表中</span></span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    <span class="comment">//end if revents</span></span><br><span class="line">    &#125;    <span class="comment">//end for</span></span><br><span class="line">    <span class="keyword">return</span> eventcnt;    <span class="comment">//返回发送的就绪的文件描述符个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ep_poll_callback唤醒回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span>    <span class="comment">//得到epitem</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span>                <span class="comment">//得到eventpoll</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; POLLFREE) &#123;            <span class="comment">//有错误发生</span></span><br><span class="line">        ep_pwq_from_wait(wait)-&gt;whead = <span class="literal">NULL</span>;    <span class="comment">//等待队列头置为NULL</span></span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);        <span class="comment">//从等待队列中删除等待队列项</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET)</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))<span class="comment">//有非EPOLLONESHOT | EPOLLET不懂！！！</span></span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>) key &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;                        <span class="comment">//没有事件发生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ep-&gt;ovflist != EP_UNACTIVE_PTR成立时，ep_scan_ready_list()正在向用户空间传递事件。</span></span><br><span class="line">    <span class="comment">//如果当前进程正在向用户空间传递事件，则将当前的事件对应的epitem实例加入到ovflist链表中。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="comment">//如果epi-&gt;next不等于EP_UNACTIVE_PTR，</span></span><br><span class="line">        <span class="comment">//则说明已经添加到ovflist链表中，就不用再添加了</span></span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;            <span class="comment">//把epi放到ovflist链表中</span></span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); <span class="comment">//把epitem放到strcut eventpoll的rdllist中去</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//唤醒调用epoll_wait()函数时睡眠的进程</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于epoll自身也是文件系统，其描述符也可以被poll/select/epoll监视，因此需要实现poll方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ep_eventpoll_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pollflags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">//把等待队列项插入到ep-&gt;poll_wait</span></span><br><span class="line">    poll_wait(file, &amp;ep-&gt;poll_wait, wait);</span><br><span class="line">    <span class="comment">//扫描就绪的文件列表，调用每个文件上的poll检查是否真的就绪，然后复制到用户空间，</span></span><br><span class="line">    <span class="comment">//文件列表中有可能有epoll文件，调用poll的时候有可能产生递归，</span></span><br><span class="line">    <span class="comment">//调用所以用ep_call_nested包装一下，防止死循环和过深的调用</span></span><br><span class="line">    pollflags = ep_call_nested(&amp;poll_readywalk_ncalls, EP_MAX_NESTS,</span><br><span class="line">                   ep_poll_readyevents_proc, ep, ep, current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pollflags != <span class="number">-1</span> ? pollflags : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_readyevents_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(priv, ep_read_events_proc, <span class="literal">NULL</span>, call_nests + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//移动ep-&gt;rdllist到新的链表txlist</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;        <span class="comment">//改变ovflist的状态</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);        <span class="comment">//ep_read_events_proc</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//调用ep_read_events_proc时可能出现了新的事件，遍历这些新的事件将其插入到rdllink</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">//epi不在rdllink,插入</span></span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;        <span class="comment">//还原ep-&gt;ovflist的状态</span></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);        <span class="comment">//将处理后的txlist链接到rdllist</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//唤醒epoll_wait</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);    <span class="comment">//安全唤醒外部的事件通知机制</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_read_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events)</span><br><span class="line"><span class="comment">//只要有一个文件描述符就绪返回可读 或 普通数据可写</span></span><br><span class="line">            <span class="keyword">return</span> POLLIN | POLLRDNORM;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//文件描述符未就绪，但在就绪队列中，将其移除</span></span><br><span class="line">            list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_poll_safewake</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> this_cpu = get_cpu();</span><br><span class="line"></span><br><span class="line">    ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS,</span><br><span class="line">               ep_poll_wakeup_proc, <span class="literal">NULL</span>, wq, (<span class="keyword">void</span> *) (<span class="keyword">long</span>) this_cpu);</span><br><span class="line"></span><br><span class="line">    put_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_wakeup_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ep_wake_up_nested((<span class="keyword">wait_queue_head_t</span> *) cookie, POLLIN,</span><br><span class="line">              <span class="number">1</span> + call_nests);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ep_wake_up_nested</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wqueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> events, <span class="keyword">int</span> subclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//唤醒所有正在等待此epfd的select/epoll/poll等</span></span><br><span class="line"><span class="comment">//如果唤醒的是epoll就可能唤醒所有其他的epoll，产生连锁反应</span></span><br><span class="line">    wake_up_poll(wqueue, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll中的递归死循环和深度检查"><a href="#epoll中的递归死循环和深度检查" class="headerlink" title="epoll中的递归死循环和深度检查"></a>epoll中的递归死循环和深度检查</h2><p>如果epoll之间相互监视就有可能导致死循环。epoll的实现中，所有可能产生递归调用的函数都由函函数ep_call_nested进行包裹，递归调用过程中出现死循环或递归过深就会打破死循环和递归调用直接返回。该函数的实现依赖于一个外部的全局链表nested_call_node(不同的函数调用使用不同的节点)，每次调用可能发生递归的函数(nproc)就向链表中添加一个包含当前函数调用上下文ctx(进程，CPU，或epoll文件)和处理的对象标识cookie的节点，通过检测是否有相同的节点就可以知道是否发生了死循环，检查链表中同一上下文包含的节点个数就可以知道递归的深度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制epoll中直接或间接递归调用的深度并防止死循环</span></span><br><span class="line"><span class="comment">//ctx:任务运行上下文（进程，CPU等）</span></span><br><span class="line"><span class="comment">//cokie:每个任务的标识</span></span><br><span class="line"><span class="comment">//priv:任务运行需要的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_call_nested</span><span class="params">(struct nested_calls *ncalls, <span class="keyword">int</span> max_nests,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (*nproc)(<span class="keyword">void</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>), <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *cookie, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, call_nests = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lsthead</span> = &amp;<span class="title">ncalls</span>-&gt;<span class="title">tasks_call_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> *<span class="title">tncur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> <span class="title">tnode</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//检查原有的嵌套调用链表ncalls，查看是否有深度超过限制的情况</span></span><br><span class="line">    list_for_each_entry(tncur, lsthead, llink) &#123;</span><br><span class="line">        <span class="comment">//同一上下文（ctx）中有相同的任务（cookie）说明产生了死循环</span></span><br><span class="line">        <span class="comment">//同一上下文的递归深度call_nests超过限制</span></span><br><span class="line">        <span class="keyword">if</span> (tncur-&gt;ctx == ctx &amp;&amp;</span><br><span class="line">            (tncur-&gt;cookie == cookie || ++call_nests &gt; max_nests)) &#123;</span><br><span class="line">            error = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的任务请求添加到调用列表</span></span><br><span class="line">    tnode.ctx = ctx;</span><br><span class="line">    tnode.cookie = cookie;</span><br><span class="line">    list_add(&amp;tnode.llink, lsthead);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//nproc 可能会导致递归调用(直接或间接)ep_call_nested ，如果发生递归调用, 那么在此函数返回之前, ncalls 又会被加入额外的节点, 这样通过前面的检测就可以知道递归调用的深度 </span></span><br><span class="line">    error = (*nproc)(priv, cookie, call_nests);</span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//从链表中删除当前任务</span></span><br><span class="line">    list_del(&amp;tnode.llink);</span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环检测"><a href="#循环检测" class="headerlink" title="循环检测"></a>循环检测</h2><p>循环检查(ep_loop_check)，该函数递归调用ep_loop_check_proc利用ep_call_nested来实现epoll之间相互监视的死循环。因为ep_call_nested中已经对死循环和过深的递归做了检查，实际的ep_loop_check_proc的实现只是递归调用自己。其中的visited_list和visited标记完全是为了优化处理速度，如果没有visited_list和visited标记函数也是能够工作的。该函数中得上下文就是当前的进程，cookie就是正在遍历的epoll结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_loop_check</span><span class="params">(struct eventpoll *ep, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep_cur</span>, *<span class="title">ep_next</span>;</span></span><br><span class="line"></span><br><span class="line">    ret = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                  ep_loop_check_proc, file, ep, current);</span><br><span class="line"><span class="comment">//清除链表和标志</span></span><br><span class="line">    list_for_each_entry_safe(ep_cur, ep_next, &amp;visited_list,</span><br><span class="line">                            visited_list_link) &#123;</span><br><span class="line">        ep_cur-&gt;visited = <span class="number">0</span>;</span><br><span class="line">        list_del(&amp;ep_cur-&gt;visited_list_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_loop_check_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep_tovisit</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, call_nests + <span class="number">1</span>);</span><br><span class="line">    ep-&gt;visited = <span class="number">1</span>;    <span class="comment">//标志当前为已遍历</span></span><br><span class="line">    list_add(&amp;ep-&gt;visited_list_link, &amp;visited_list);</span><br><span class="line">    <span class="comment">//遍历所有ep监视的文件</span></span><br><span class="line">    <span class="keyword">for</span> (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) &#123;</span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(is_file_epoll(epi-&gt;ffd.file))) &#123;</span><br><span class="line">            ep_tovisit = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">            <span class="keyword">if</span> (ep_tovisit-&gt;visited)    <span class="comment">//跳过先前已遍历的，避免循环检查</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//所有ep监视的未遍历的epoll</span></span><br><span class="line">            error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                    ep_loop_check_proc, epi-&gt;ffd.file,</span><br><span class="line">                    ep_tovisit, current);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//文件不在file-&gt;tfile_check_list中，添加</span></span><br><span class="line">            <span class="comment">//最外层的epoll需要检查epoll监视的文件</span></span><br><span class="line">            <span class="keyword">if</span> (list_empty(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink))</span><br><span class="line">                list_add(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink,</span><br><span class="line">                     &amp;tfile_check_list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="唤醒风暴"><a href="#唤醒风暴" class="headerlink" title="唤醒风暴"></a>唤醒风暴</h2><p>当文件状态发生改变时，会唤醒监听在其上的epoll文件，而这个epoll文件还可能唤醒其他的epoll文件，这种连续的唤醒就形成了一个唤醒路径，所有的唤醒路径就形成了一个有向图。如果文件对应的epoll唤醒有向图的节点过多，那么文件状态的改变就会唤醒所有的这些epoll(可能会唤醒很多进程，这样的开销是很大的)，而实际上一个文件经过少数epoll处理以后就可能从就绪转到未就绪，剩余的epoll虽然认为文件已就绪而实际上经过某些处理后已不可用。epoll的实现中考虑到了此问题，在每次添加新文件到epoll中时，就会首先检查是否会出现这样的唤醒风暴。<br>该函数的实现逻辑是这样的，递归调用reverse_path_check_proc遍历监听在当前文件上的epoll文件，在reverse_pach_check_proc中统计并检查不同路径深度上epoll的个数，从而避免产生唤醒风暴。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">current_file</span>;</span></span><br><span class="line">    <span class="comment">//遍历全局tfile_chack_list中的文件，第一级</span></span><br><span class="line">    list_for_each_entry(current_file, &amp;tfile_check_list, f_tfile_llink) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        path_count_init();</span><br><span class="line">        <span class="comment">//限制递归的深度，并检查每个深度上唤醒的epoll数量</span></span><br><span class="line">        error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                    reverse_path_check_proc, current_file,</span><br><span class="line">                    current_file, current);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">child_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    list_for_each_entry(epi, &amp;file-&gt;f_ep_links, fllink) &#123;</span><br><span class="line">        <span class="comment">//遍历监视file的epoll</span></span><br><span class="line">        child_file = epi-&gt;ep-&gt;file;</span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(child_file)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list_empty(&amp;child_file-&gt;f_ep_links)) &#123;</span><br><span class="line">                <span class="comment">//没有其他的epoll监视当前的这个epoll，已经是叶子了</span></span><br><span class="line">                <span class="keyword">if</span> (path_count_inc(call_nests)) &#123;</span><br><span class="line">                    error = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历监视这个epoll文件的epoll，递归调用</span></span><br><span class="line">                error = ep_call_nested(&amp;poll_loop_ncalls,</span><br><span class="line">                            EP_MAX_NESTS,</span><br><span class="line">                            reverse_path_check_proc,</span><br><span class="line">                            child_file, child_file,</span><br><span class="line">                            current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">"reverse_path_check_proc: "</span></span><br><span class="line">                <span class="string">"file is not an ep!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_ARR_SIZE 5</span></span><br><span class="line"><span class="comment">//深度限制</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> path_limits[PATH_ARR_SIZE] = &#123; <span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算出来的深度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> path_count[PATH_ARR_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">path_count_inc</span><span class="params">(<span class="keyword">int</span> nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nests == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (++path_count[nests] &gt; path_limits[nests])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path_count_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PATH_ARR_SIZE; i++)</span><br><span class="line">        path_count[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-create和epoll-ctl函数调用过程"><a href="#epoll-create和epoll-ctl函数调用过程" class="headerlink" title="epoll_create和epoll_ctl函数调用过程"></a>epoll_create和epoll_ctl函数调用过程</h2><p><img src="/Picture/epoll_create和epoll_ctl函数调用过程.png" alt></p>
<h2 id="epoll-wait函数调用主要过程"><a href="#epoll-wait函数调用主要过程" class="headerlink" title="epoll_wait函数调用主要过程"></a>epoll_wait函数调用主要过程</h2><p><img src="/Picture/epoll_wait函数调用主要过程.png" alt></p>
<h2 id="epoll结构体间关系"><a href="#epoll结构体间关系" class="headerlink" title="epoll结构体间关系"></a>epoll结构体间关系</h2><p><img src="/Picture/epoll结构体间关系.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/21/io-4-poll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/21/io-4-poll/" class="post-title-link" itemprop="url">Linux I/O 复用 poll源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-21 09:15:00" itemprop="dateCreated datePublished" datetime="2017-09-21T09:15:00+08:00">2017-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux I/O poll 源码分析</p>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#poll">poll</a><ul>
<li><a href="#poll系统调用的函数调用过程">poll系统调用的函数调用过程</a></li>
<li><a href="#poll系统调用图解">poll系统调用图解</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll函数系统调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct polled* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    short events;</span><br><span class="line">    short revents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds,</span><br><span class="line">        <span class="keyword">long</span>, timeout_msecs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算timespec类型的超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</span><br><span class="line">            NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);        <span class="comment">//重要函数，返回就绪的文件描述符的总数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do_sys_poll 被信号中断, 重新调用, 对使用者来说 poll 是不会被信号中断的.</span></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span></span><br><span class="line">        restart_block = &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;        <span class="comment">//设置重启的函数</span></span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;</span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;</span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ERESTART_RESTARTBLOCK 不会返回给用户进程,  而是会被系统捕获, 然后调用 do_restart_poll</span></span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_restart_poll</span><span class="params">(struct restart_block *restart_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> __<span class="title">user</span> *<span class="title">ufds</span> = <span class="title">restart_block</span>-&gt;<span class="title">poll</span>.<span class="title">ufds</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nfds = restart_block-&gt;poll.nfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">to</span> = <span class="title">NULL</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (restart_block-&gt;poll.has_timeout) &#123;</span><br><span class="line">        end_time.tv_sec = restart_block-&gt;poll.tv_sec;</span><br><span class="line">        end_time.tv_nsec = restart_block-&gt;poll.tv_nsec;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;</span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">     <span class="keyword">int</span> err = -EFAULT, fdcount, len, <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//首先使用栈上的空间，加速访问</span></span><br><span class="line">    <span class="keyword">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];    <span class="comment">//long stack_pps[64];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct poll_list &#123;</span></span><br><span class="line"><span class="comment">        struct poll_list *next;</span></span><br><span class="line"><span class="comment">        int len;                //本poll_list的entries长度</span></span><br><span class="line"><span class="comment">        struct pollfd entries[0];</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> = (<span class="title">struct</span> <span class="title">poll_list</span> *)<span class="title">stack_pps</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds &gt; current-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;    <span class="comment">// 文件描述符数量超过当前进程限制</span></span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds, N_STACK_PPS);        <span class="comment">//计算链表头结点的entries数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;        <span class="comment">//将用户空间的pollfd全部拷贝到内核空间</span></span><br><span class="line">        walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        walk-&gt;len = len;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//当用户传入的fd很多时，由于poll系统调用每次都要把所有struct pollfd拷进内核，所以参数传递和页分配此时就成了poll系统调用的性能瓶颈。</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))        <span class="comment">//拷贝前walk-&gt;len个</span></span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">        todo -= walk-&gt;len;    <span class="comment">//计算未拷贝的pollfd个数</span></span><br><span class="line">        <span class="keyword">if</span> (!todo)</span><br><span class="line">            <span class="keyword">break</span>;        <span class="comment">//全部已拷贝，退出</span></span><br><span class="line"></span><br><span class="line">        len = <span class="built_in">min</span>(todo, POLLFD_PER_PAGE);    <span class="comment">//计算个数</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct poll_list) + <span class="keyword">sizeof</span>(struct pollfd) * len;    <span class="comment">//计算申请空间的大小</span></span><br><span class="line">        walk = walk-&gt;next = kmalloc(<span class="built_in">size</span>, GFP_KERNEL);        <span class="comment">//在堆上申请空间</span></span><br><span class="line">        <span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">            err = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化table，设置函数指针table.pt.qproc为__pollwait</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);</span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> = <span class="title">walk</span>-&gt;<span class="title">entries</span>;</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; walk-&gt;len; j++, ufds++)</span><br><span class="line">            <span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents))</span><br><span class="line">                <span class="keyword">goto</span> out_fds;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">    walk = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (walk) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> = <span class="title">walk</span>;</span></span><br><span class="line">        walk = walk-&gt;next;</span><br><span class="line">        kfree(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">    pwq-&gt;polling_task = current;</span><br><span class="line">    pwq-&gt;triggered = <span class="number">0</span>;</span><br><span class="line">    pwq-&gt;error = <span class="number">0</span>;</span><br><span class="line">    pwq-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pt-&gt;qproc = qproc;        <span class="comment">//__pollwait</span></span><br><span class="line">    pt-&gt;key   = ~<span class="number">0U</span>L; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  struct poll_list *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct poll_wqueues *wait, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;    <span class="comment">//已超时</span></span><br><span class="line">        pt = <span class="literal">NULL</span>;        <span class="comment">//不执行__pollwait</span></span><br><span class="line">        timed_out = <span class="number">1</span>;    <span class="comment">//不睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)        <span class="comment">//计算睡眠时间，纳秒</span></span><br><span class="line">        slack = estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;    <span class="comment">//遍历整个链表</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span></span><br><span class="line"></span><br><span class="line">            pfd = walk-&gt;entries;</span><br><span class="line">            pfd_end = pfd + walk-&gt;len;</span><br><span class="line">            <span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;    <span class="comment">//遍历一个节点中的entries数组</span></span><br><span class="line">                <span class="comment">//当用户传入的fd很多时，对do_pollfd就会调用很多次，poll效率瓶颈的另一原因就在这里。</span></span><br><span class="line">                <span class="keyword">if</span> (do_pollfd(pfd, pt)) &#123;</span><br><span class="line">                    count++;            <span class="comment">//就绪文件描述符个数加1</span></span><br><span class="line">                    pt = <span class="literal">NULL</span>;          <span class="comment">//有文件描述符就绪，进程不需要再睡眠了，所以不需要再给后面文件的wait queue中添加唤醒函数了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pt = <span class="literal">NULL</span>;          <span class="comment">//所有的文件描述符都已执行__pollwait，以后不再执行</span></span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;       <span class="comment">//若count为0（表示无文件描述符就绪）</span></span><br><span class="line">            count = wait-&gt;error;    <span class="comment">//count = 0；</span></span><br><span class="line">            <span class="comment">//当用户程序在调用poll后挂起时，发信号可以让程序迅速退出poll调用，而通常的系统调用是不会被信号打断的。</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current))    <span class="comment">//判断是否为信号唤醒</span></span><br><span class="line">                count = -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count || timed_out)    <span class="comment">//有文件描述符就绪 或者 进程不再睡眠</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;    <span class="comment">//仅首次循环时执行，超时时间转换，转换为内核时间</span></span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前进程从这里进入睡眠，等待直到超时，或由回调函数唤醒，喊醒后文件等待队列中的等待    //队列项并不清除，到后边统一清除</span></span><br><span class="line">        <span class="comment">//超时，返回0；被唤醒，返回-EINTR</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">do_pollfd</span><span class="params">(struct pollfd *pollfd, poll_table *pwait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    mask = <span class="number">0</span>;</span><br><span class="line">    fd = pollfd-&gt;fd;    <span class="comment">//得到要检测文件的文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;        <span class="comment">//检测fd的正确性</span></span><br><span class="line">        <span class="keyword">int</span> fput_needed;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从当前进程描述符中取得文件结构，并增加引用计数</span></span><br><span class="line">        file = fget_light(fd, &amp;fput_needed);</span><br><span class="line">        mask = POLLNVAL;        <span class="comment">//初始化，文件描述符没有打开</span></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)</span></span><br><span class="line">            mask = DEFAULT_POLLMASK;</span><br><span class="line">            <span class="keyword">if</span> (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;poll) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pwait)        <span class="comment">//设置当前fd待检测的事件掩码</span></span><br><span class="line">                    pwait-&gt;key = pollfd-&gt;events | POLLERR | POLLHUP;</span><br><span class="line">                <span class="comment">//获取当前的就绪状态，并添加进程到文件的对应等待队列中</span></span><br><span class="line">                mask = file-&gt;f_op-&gt;poll(file, pwait);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去除不关心的状态掩码</span></span><br><span class="line">            mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP;</span><br><span class="line">            <span class="comment">//释放通过fget_light得到的file指针，实际就是减少引用计数</span></span><br><span class="line">            fput_light(file, fput_needed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录当前fd的就绪状态</span></span><br><span class="line">    pollfd-&gt;revents = mask;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>select用位图组织文件描述符和事件掩码，而poll用链表+数组的形式</li>
<li>要检测的文件描述符多的情况下，select全部用堆上的空间，poll用栈空间和堆空间</li>
<li>select可以被信号终止，poll不能被信号终止，会重新启动</li>
</ol>
<h2 id="poll系统调用的函数调用过程"><a href="#poll系统调用的函数调用过程" class="headerlink" title="poll系统调用的函数调用过程"></a>poll系统调用的函数调用过程</h2><p><img src="/Picture/poll系统调用的函数调用过程.png" alt></p>
<h2 id="poll系统调用图解"><a href="#poll系统调用图解" class="headerlink" title="poll系统调用图解"></a>poll系统调用图解</h2><p><img src="/Picture/poll系统调用图解.jpg" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/20/io-3-select/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/20/io-3-select/" class="post-title-link" itemprop="url">Linux I/O 复用 select源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-20 13:19:00" itemprop="dateCreated datePublished" datetime="2017-09-20T13:19:00+08:00">2017-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux I/O select 源码分析</p>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#select">select</a><ul>
<li><a href="#select系统调用的具体实现过程图解">select系统调用的具体实现过程图解：</a></li>
<li><a href="#select结构体依赖关系">select结构体依赖关系</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select系统调用原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;    <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;    <span class="comment">//微秒 10E-6秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;    <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span>    tv_nsec;    <span class="comment">//纳秒 10E-9秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits [<span class="number">1024</span>/(<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>))]; <span class="comment">//unsigned long fds_bits[32]</span></span><br><span class="line">    <span class="comment">//32*4*8 = 1024</span></span><br><span class="line">&#125;fd_set;</span><br></pre></td></tr></table></figure></p>
<p>select实现在fs/select.c中，源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//select主流程函数</span></span><br><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;    <span class="comment">//超时时间非空</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))        <span class="comment">//把超时时间从用户空间复制到内核空间</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="comment">//计算timespec类型的超时时间</span></span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);       <span class="comment">//select实现的核心函数</span></span><br><span class="line">    <span class="comment">//复制剩余的超时时间拷贝到用户空间</span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;    <span class="comment">//返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>core_sys_select实现select事件监听的主要功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    typedef struct &#123;</span></span><br><span class="line"><span class="comment">        unsigned long *in, *out, *ex;</span></span><br><span class="line"><span class="comment">        unsigned long *res_in, *res_out, *res_ex;</span></span><br><span class="line"><span class="comment">    &#125; fd_set_bits;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct fdtable &#123;    //进程的文件描述符表</span></span><br><span class="line"><span class="comment">        unsigned int max_fds;</span></span><br><span class="line"><span class="comment">        struct file ** fd;     //文件对象指针数组,长度放在max_fds中</span></span><br><span class="line"><span class="comment">        fd_set *close_on_exec;</span></span><br><span class="line"><span class="comment">        fd_set *open_fds;</span></span><br><span class="line"><span class="comment">        struct rcu_head rcu;</span></span><br><span class="line"><span class="comment">        struct fdtable *next;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];    <span class="comment">//long stack_fds[64];</span></span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();    <span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">//取得进程中的fdtable(文件描述符表)</span></span><br><span class="line">    fdt = files_fdtable(current-&gt;files);</span><br><span class="line">    max_fds = fdt-&gt;max_fds;        <span class="comment">//取得系统当前允许的最大文件描述符</span></span><br><span class="line">    rcu_read_unlock();    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds)    <span class="comment">//如果传入的n大于当前进程最大的文件描述符，修改n</span></span><br><span class="line">        n =     max_fds;</span><br><span class="line">    <span class="built_in">size</span> = FDS_BYTES(n);    <span class="comment">//按一个文件描述符一个bit位计算一个字段所需字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define FDS_BITPERLONG    (8*sizeof(long))</span></span><br><span class="line"><span class="comment">    #define FDS_LONGS(nr)    (((nr)+FDS_BITPERLONG-1)/FDS_BITPERLONG)</span></span><br><span class="line"><span class="comment">    #define FDS_BYTES(nr)    (FDS_LONGS(nr)*sizeof(long))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    bits = stack_fds;                <span class="comment">//bits先指向栈上空间，小对象使用栈上空间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;    <span class="comment">//栈上空间不足，全部使用堆上空间，使用kmalloc申请空间</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * <span class="built_in">size</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   <span class="built_in">size</span>;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*<span class="built_in">size</span>;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*<span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//从用户空间拷贝fd_set到内核空间，调用copy_from_user()</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//将存放返回状态的字段清0</span></span><br><span class="line">    zero_fd_set(n, fds.res_in);</span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);     <span class="comment">//核心函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)    <span class="comment">//有错误</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;        <span class="comment">//ret == 0，没有设备就绪</span></span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果从内核空间拷贝到用户空间，调用__copy_to_user()</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">//如果申请了空间kmalloc，释放空间</span></span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret;    <span class="comment">//返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些select内核实现需要了解的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span>    <span class="comment">//非常重要，一个调用select()的应用程序只存在一个poll_wqueues结构体，                    //用来统一辅佐实现这个进程中所有待检测的fd的轮询工作</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span>        <span class="comment">//动态申请的物理页挂在它上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span>    <span class="comment">//保存当前调用select的用户进程struct task_struct结构体</span></span><br><span class="line">    <span class="comment">//struct task_struct即进程控制块PCB结构</span></span><br><span class="line">    <span class="keyword">int</span> triggered;    <span class="comment">// 当前用户进程被唤醒后置成1，以免该进程接着进睡眠</span></span><br><span class="line">    <span class="keyword">int</span> error;        <span class="comment">//错误码</span></span><br><span class="line">    <span class="keyword">int</span> inline_index;    <span class="comment">//数组inline_entries的引用下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    poll_queue_proc qproc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span>        <span class="comment">//申请的物理页都会将起始地址强制转换成该结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">next</span>;</span>        <span class="comment">//指向下一个申请的物理页</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span>    <span class="comment">//指向entries[]中首个待分配(空的)poll_table_entry结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span>    <span class="comment">//该page页后边都是待分配的poll_table_entry结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span>        <span class="comment">//每个fd的都有一个该结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span>            <span class="comment">//指向特定fd对应的file结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key;        <span class="comment">//等待特定fd对应硬件设备的事件掩码</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;        <span class="comment">//代表调用select()的应用进程，等待在fd对应设备的特定事件（读或                        //写）的等待队列头上的等待队列项</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *wait_address;        <span class="comment">//设备驱动程序中特定事件的等待队列头</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span>        <span class="comment">//等待队列项</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;        <span class="comment">//标记该等待的进程是互斥进程还是非互斥进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE    0x01        <span class="comment">//互斥进程</span></span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;                <span class="comment">//指向poll_wqueues</span></span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;        <span class="comment">//等待队列的回调函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span>        <span class="comment">//链表的前向和后向指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span>    <span class="comment">//等待队列头</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;        <span class="comment">//锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack      = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">//检查fds中fd的有效性（要求fd必须打开），并获取当前最大的fd</span></span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line">    <span class="comment">//初始化table，设置函数指针table.pt.qproc为__pollwait</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line"></span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">//超时时间设为0时</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait = <span class="literal">NULL</span>;        <span class="comment">//不执行__pollwait</span></span><br><span class="line">        timed_out = <span class="number">1</span>;        <span class="comment">//timed_out设置为1，表示已超时。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)    <span class="comment">//设置的超时时间不为0</span></span><br><span class="line">        <span class="comment">//超时时间转换</span></span><br><span class="line">        slack = estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line">        <span class="comment">//遍历所有的描述符（n个），i文件描述符  从这里可以看出select使用了遍历的方式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, <span class="built_in">bit</span> = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//file_operations定义了一系列对字符设备的操作方法</span></span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="comment">//检查当前的位置中的描述符</span></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;    <span class="comment">//组合要监测的事件</span></span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;        <span class="comment">//没有需要监测的描述符，下一个位置</span></span><br><span class="line">                <span class="comment">// #define __NFDBITS    (8 * sizeof(unsigned long))</span></span><br><span class="line">                i += __NFDBITS;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次循环32次  4字节 32个位 使用位图的方式</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, <span class="built_in">bit</span> &lt;&lt;= <span class="number">1</span>) &#123;    <span class="comment">//第一次bit==1</span></span><br><span class="line">                <span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)        <span class="comment">//是否超出了最大待检测的fd</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//不需要监听描述符i，直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">bit</span> &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//根据i指定的索引，从当前进程描述符中取得文件结构，并增加引用计数</span></span><br><span class="line">                file = fget_light(i, &amp;fput_needed);</span><br><span class="line">                <span class="keyword">if</span> (file) &#123;    <span class="comment">//file存在</span></span><br><span class="line">                    f_op = file-&gt;f_op;</span><br><span class="line">                    <span class="comment">//#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)</span></span><br><span class="line">                    mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                    <span class="comment">//设置当前fd待检测的事件掩码，wait-&gt;key</span></span><br><span class="line">                        wait_key_set(wait, in, out, <span class="built_in">bit</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//获取当前的就绪状态，并添加进程到文件的对应等待队列中</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, wait);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//释放通过fget_light得到的file指针，实际就是减少引用计数</span></span><br><span class="line">                    fput_light(file, fput_needed);</span><br><span class="line">                    <span class="comment">//检测文件i是否已有事件就绪</span></span><br><span class="line">                    <span class="comment">//mask是每一个 (*f_op-&gt;poll)()程序返回的设备状态掩码</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        <span class="comment">//mask&amp;POLLIN_SET该文件是否可写，in&amp;bit应用程序是否关心该文件可写</span></span><br><span class="line">                        res_in |= <span class="built_in">bit</span>;    <span class="comment">//fd对应的设备可写</span></span><br><span class="line">                        retval++;        <span class="comment">//就绪的文件描述符个数加1</span></span><br><span class="line">                        <span class="comment">//如果已有就绪事件就不再向其他文件的等待队列中添加回调函数。</span></span><br><span class="line">                        <span class="comment">//避免重复执行__pollwait()</span></span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_out |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_ex |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据poll()的结果，写回到输出字段里面</span></span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait = <span class="literal">NULL</span>;    <span class="comment">//避免重复执行__pollwait()</span></span><br><span class="line">        <span class="comment">//有设备就绪或有异常 || 超时 || 有终止信号出现</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一轮循环，时间的转换timespec到ktime</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前进程从这里进入睡眠，等待直到超时，或由注册的函数唤醒超时，返回0；被唤醒，返回-EINTR</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;   <span class="comment">//超时后，将timed_out设为1，再遍历一次文件描述符后，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除等待队列</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line">    <span class="keyword">return</span> retval;        <span class="comment">//返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">    pwq-&gt;polling_task = current;</span><br><span class="line">    pwq-&gt;triggered    = <span class="number">0</span>;</span><br><span class="line">    pwq-&gt;error        = <span class="number">0</span>;</span><br><span class="line">    pwq-&gt;table        = <span class="literal">NULL</span>;</span><br><span class="line">    pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pt-&gt;qproc = qproc;        <span class="comment">//__pollwait</span></span><br><span class="line">    pt-&gt;key   = ~<span class="number">0U</span>L; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLEX_SET (POLLPRI)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wait_key_set</span><span class="params">(poll_table *wait, <span class="keyword">unsigned</span> <span class="keyword">long</span> in,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> out, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">bit</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wait) &#123;</span><br><span class="line">        wait-&gt;key = POLLEX_SET;</span><br><span class="line">        <span class="keyword">if</span> (in &amp; <span class="built_in">bit</span>)</span><br><span class="line">            wait-&gt;key |= POLLIN_SET;</span><br><span class="line">        <span class="keyword">if</span> (out &amp; <span class="built_in">bit</span>)</span><br><span class="line">            wait-&gt;key |= POLLOUT_SET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll 方法是3 个系统调用的后端:poll, epoll, 和select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞.poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的,并且,可能地,提供给内核信息用来使调用进程睡眠直到I/O 变为可能.如果一个驱动的poll 方法为NULL, 设备假定为不阻塞地可读可写.<br>首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后，返回表示是否能对设备进行无阻塞读写访问的掩码。把当前进程添加到wait_address参数指定的等待列表中。需要注意的是这个函数是不会引起阻塞的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;        <span class="comment">//设备驱动</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">evdev_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>         = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    poll_wait(file, &amp;evdev-&gt;wait, wait);</span><br><span class="line">    <span class="keyword">return</span> ((client-&gt;head == client-&gt;tail) ? <span class="number">0</span> : (POLLIN | POLLRDNORM)) |</span><br><span class="line">        (evdev-&gt;exist ? <span class="number">0</span> : (POLLHUP | POLLERR));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);    <span class="comment">//__pollwait</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//filp特定fd对应的file结构体指针</span></span><br><span class="line"><span class="comment">//wait 特定fd对应的硬件驱动程序中的等待队列头指针</span></span><br><span class="line"><span class="comment">//p 调用select()的应用程序中poll_wqueues结构体的poll_table项</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过container_of宏得到结构体poll_wqueues的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">container_of</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">poll_wqueues</span>, <span class="title">pt</span>);</span></span><br><span class="line">    <span class="comment">//调用poll_get_entry()得到一个poll_table_entry结构体</span></span><br><span class="line">    <span class="comment">//空间不足，动态申请物理内存页，以链表的形式挂在poll_wqueues.table上统一管理。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">pwq</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!entry)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    get_file(filp);</span><br><span class="line">    entry-&gt;filp         = filp;         <span class="comment">// 保存对应的file结构体</span></span><br><span class="line">    entry-&gt;wait_address = wait_address; <span class="comment">// 保存来自设备驱动程序的等待队列头</span></span><br><span class="line">    entry-&gt;key          = p-&gt;key;       <span class="comment">// 保存对该fd关心的事件掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化等待队列项，pollwake是唤醒该等待队列项时候调用的函数</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line"></span><br><span class="line"><span class="comment">//static inline void init_waitqueue_func_entry(wait_queue_t *q,wait_queue_func_t func)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    q-&gt;flags = 0;            //设为非互斥进程</span></span><br><span class="line"><span class="comment">//    q-&gt;private = NULL;</span></span><br><span class="line"><span class="comment">//    q-&gt;func = func;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待队列项private指向poll_wqueues</span></span><br><span class="line">    entry-&gt;wait.<span class="keyword">private</span> = pwq;</span><br><span class="line">    <span class="comment">//将该等待队列项添加到从驱动程序中传递过来的等待队列头中去</span></span><br><span class="line">    <span class="comment">//即：设置等待的进程为非互斥进程，并将其添加进等待队列头的队头中</span></span><br><span class="line">    add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_freewait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">p</span> = <span class="title">pwq</span>-&gt;<span class="title">table</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pwq-&gt;inline_index; i++)</span><br><span class="line">        free_poll_entry(pwq-&gt;inline_entries + i);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">old</span>;</span></span><br><span class="line">        entry = p-&gt;entry;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            entry--;</span><br><span class="line">            free_poll_entry(entry);</span><br><span class="line">        &#125; <span class="keyword">while</span> (entry &gt; p-&gt;entries);</span><br><span class="line">        old = p;</span><br><span class="line">        p   = p-&gt;next;</span><br><span class="line">        free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(struct poll_wqueues *pwq, <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">ktime_t</span> *expires, <span class="keyword">unsigned</span> <span class="keyword">long</span> slack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = -EINTR;</span><br><span class="line"></span><br><span class="line">    set_current_state(state);        <span class="comment">//设置当前进程的状态state = TASK_INTERRUPTIBLE,有可能在尚                            //未到期时由其它信号唤醒进程从而导致函数返回</span></span><br><span class="line">    <span class="keyword">if</span> (!pwq-&gt;triggered)    <span class="comment">//只要有一个fd对应的设备将当前进程唤醒，将会把triggered设置为1</span></span><br><span class="line">        rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    set_mb(pwq-&gt;triggered, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//唤醒的时候调用pollwake</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pollwake</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="comment">//取得文件对应的poll_table_entry</span></span><br><span class="line">    entry = container_of(wait, struct poll_table_entry, wait);</span><br><span class="line">    <span class="comment">//过滤不关心的事件,防止应用进程被误唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; entry-&gt;key))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//唤醒</span></span><br><span class="line">    <span class="keyword">return</span> __pollwake(wait, mode, sync, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">wait</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">    <span class="comment">//定义一个wait_queue_t类型的变量dummy_wait，并初始化</span></span><br><span class="line">    DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line">    <span class="comment">//    .private   = tsk,                        \</span></span><br><span class="line">    <span class="comment">//    .func      = default_wake_function,            \</span></span><br><span class="line">    <span class="comment">//    .task_list = &#123; NULL, NULL &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define DECLARE_WAITQUEUE(name, tsk)                    \</span></span><br><span class="line">    <span class="comment">//    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br><span class="line"></span><br><span class="line">    smp_wmb();</span><br><span class="line">    pwq-&gt;triggered = <span class="number">1</span>;    <span class="comment">//标记为已触发</span></span><br><span class="line">    <span class="comment">//唤醒函数</span></span><br><span class="line">    <span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select系统调用的具体实现过程图解："><a href="#select系统调用的具体实现过程图解：" class="headerlink" title="select系统调用的具体实现过程图解："></a>select系统调用的具体实现过程图解：</h2><p><img src="/Picture/select系统调用的具体实现过程.png" alt></p>
<h2 id="select结构体依赖关系"><a href="#select结构体依赖关系" class="headerlink" title="select结构体依赖关系"></a>select结构体依赖关系</h2><p><img src="/Picture/select结构体依赖关系.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/18/io-2-multiplexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/18/io-2-multiplexing/" class="post-title-link" itemprop="url">Linux I/O select、poll、epoll的使用方式和优缺点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-18 22:55:00" itemprop="dateCreated datePublished" datetime="2017-09-18T22:55:00+08:00">2017-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux I/O select、poll、epoll的使用方式和优缺点</p>
<h1 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h1><p>I/O复用使得程序可以<strong>同时监听多个文件描述符</strong>，对提升程序性能至关重要。<br>I/O复用虽然能同时监听多个文件描述符，但它<strong>本身是阻塞的</strong>。多个文件描述符同时就绪，如果不采取措施，程序只能顺序以此处理其中的每个文件描述符，使得服务器看起来像是串行工作。如果要实现并发，只能使用多进程或多线程等编程手段。</p>
<p><img src="/Picture/IO复用.png" alt></p>
<p>Linux下实现I/O复用的系统调用主要有select、poll和epoll。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 系统调用的用途：在一段时间内，监听用户感兴趣的文件描述符的可读、可写和异常等事件。<br>select系统调用的原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>nfds通常被设置为selcet监听的所有文件描述符中的<strong>最大值加1</strong>，因为文件描述符是从0开始计数的。</li>
<li><p>readfds、writefds、exceptfds分别指向可读、可写、异常等事件对应的文件描述符集合。<code>fd_set</code>结构体仅包含一个整数数组，数组中每个元素的每一个位标记一个文件描述符。<code>fd_set</code>能容纳的文件描述符数量由FD_SETSIZE指定，限制了select能同时处理的文件描述符的总量。linux定义了一系列的宏来访问<code>fd_set</code>结构体中的位。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timeout用来设置select函数的超时时间。是timeval结构体类型的指针。内核修改它告诉应用程序select等待了多长时间，这个timeval的返回指不能完全信任，比如调用失败时timeval值是不确定的。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由定义可见，select提供了微秒级的定时方式，如果给timeout变量的<code>tv_sec</code>成员和<code>tv_usec</code>成员都传递0，select将立即返回。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1,并设置errno为EINTR。</p>
<p>网络编程中socket可读的情况：</p>
<ol>
<li>socket内核接收缓冲区中的字节数大于或等于其低水位标记SO_REVLOWAT。此时可以无阻塞地读socket，并且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时对该socket的读操作返回0。</li>
<li>监听socket上有新的连接请求。</li>
<li>socket上有未处理的错误。可用getsockopt来读取和清除错误。</li>
</ol>
<p>网络编程中socket可写的情况：</p>
<ol>
<li>socket内核发送缓存区中的可用字节数大于或等于其最低水位标记SO_SNDLOWAT。此时可以无阻塞的写该socket，并且写操作返回的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或失败（超时）之后。</li>
<li>socket上由未处理的错误。可使用getsockopt来读取和清楚该错误。</li>
</ol>
<p>网络编程中异常情况只有一种：socket上接收到带外数据。</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fds是pollfd结构类型的数组，指定所有感兴趣的文件描述符上发生的可读、可写和异常等时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">   short events;     <span class="comment">/* requested events */</span></span><br><span class="line">   short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>fd成员指定文件描述符</li>
<li>events告诉poll监听fd的哪些事件</li>
<li>revents由内核修改，通知引用程序fd上实际发生了哪些事件</li>
</ol>
<p>poll支持的事件：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否可作为输入</th>
<th style="text-align:center">是否可作为输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td style="text-align:center">数据（包括普通数据和优先数据）可读</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td style="text-align:center">普通数据可读</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td style="text-align:center">优先级带数据可读（Linux）不支持</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLPRI</td>
<td style="text-align:center">高优先级数据可读，比如TCP带外数据</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLOUT</td>
<td style="text-align:center">数据（包括普通数据和优先数据）可写</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td style="text-align:center">普通数据可写</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td style="text-align:center">优先级带数据可写</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td style="text-align:center">TCP连接被对方关闭，或者对方关闭了写操作，由GNU引入</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLERR</td>
<td style="text-align:center">错误</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLHUP</td>
<td style="text-align:center">挂起。比如通道的写端被关闭后，读端描述符将收到POLLHUP事件</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td style="text-align:center">文件描述符没有打开</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
</div>
<p>nfds参数指定被监听事件集合fds的大小。<br>timeout参数指定poll的超时时间，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。<br>poll系统调用的返回值含义与select相同。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll维持一个内核事件表。<br>epoll是Linux特有的I/O复用函数。<br>epoll使用一组函数来完成任务。epoll将用户关心的文件描述符上的事件放在内核的一个事件表里。不需要像select和poll每次调用都重复传入文件描述符集或事件集。但epool需要一个额外的文件描述符，来唯一标识内核中的事件表。<br>内核事件表使用epoll_create函数创建。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>size并不起作用，只是给内核一个提示，告诉其内核事件表的期望大小。<br>操作内核事件表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fd参数是要操作的文件描述符，op参数则指定操作类型。操作类型有如下3种：</p>
<ol>
<li>EPOLL_CTL_ADD 往事件表注册fd上的事件</li>
<li>EPOLL_CTL_MOD 修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL 删除fd上的注册事件</li>
</ol>
<p>event参数指定事件，是epoll_event结构指针类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events epoll事件*/</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable 用户数据*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>epoll支持的事件类型和poll基本相同，表示epoll类型的宏是在poll对应的宏前加上”E”。epoll两个额外的事件类型——EPOLLET和EPOLLONESHOT。<br>epoll_ctl成功返回0,失败返回-1并设置errno。<br>epoll_wait函数在一段时间内等待一组文件描述符上的事件。该函数返回就绪的文件描述符的个数，失败返回-1并设置errno。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>maxevents指定最多监听多少个事件，必须大于0。<br>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表复制到events所指的数组中。</p>
<p>poll和epoll如何索引就绪文件描述符：<br><strong>poll必须遍历所有已注册文件描述符并找到其中的就绪者</strong>。<br><strong>epoll仅遍历就绪的ret个文件描述符</strong>。</p>
<p>epoll对文件描述符的操作有两种模式：<strong>LT（电平触发）模式和ET（边沿触发）模式</strong>。<strong>LT是默认的工作模式</strong>，错误率比较小。LT模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的<strong>EPOLLET</strong>事件时，epoll将以ET模式来操作文件描述符。<strong>ET是epoll的高效工作模式</strong>，错误率较大。<br>LT模式下，epoll_wait检测到事件发生并将此事件通知应用程序后，<strong>应用程序可以不立即处理该事件</strong>，下次调用epoll_wait时，epoll_wait还会再次通知该应用程序事件，直到事件被处理。<br>ET模式下，epoll_wait检测到事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件</strong>。<br>每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作就会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。因为ET模式只通知以此，所以需要循环读、循环写，如果时阻塞模式当不能读写的时候会阻塞，所以要设置非阻塞模式。<br>epoll的EPOLLONESHOT事件，注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上的注册的一个可读、可写或者异常事件，且只触发一次。</p>
<h1 id="select、poll、epoll的对比"><a href="#select、poll、epoll的对比" class="headerlink" title="select、poll、epoll的对比"></a>select、poll、epoll的对比</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">系统调用</th>
<th style="text-align:center">select</th>
<th style="text-align:center">poll</th>
<th style="text-align:center">epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">事件集合</td>
<td style="text-align:center">用户通过3个参数分别出入感兴趣的可读、可写、异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。使得用户每次调用select都要重置这3个参数。</td>
<td style="text-align:center">统一处理所有事件类型，因此只需要一个事件参数集合。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件</td>
<td style="text-align:center">内核通过一个事件表直接管理用户感兴趣的所有事件。每次调用epoll_wait时，无须重复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件。</td>
</tr>
<tr>
<td style="text-align:center">应用程序索引就绪文件描述符的时间复杂度</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">最大支持文件描述符数</td>
<td style="text-align:center">一般由最大值限制</td>
<td style="text-align:center">65535</td>
<td style="text-align:center">65535</td>
</tr>
<tr>
<td style="text-align:center">工作模式</td>
<td style="text-align:center">LT</td>
<td style="text-align:center">LT</td>
<td style="text-align:center">支持ET高效模式</td>
</tr>
<tr>
<td style="text-align:center">内核实现和工作效率</td>
<td style="text-align:center">采用轮询方式来检测就绪事件，算法复杂度O(n)</td>
<td style="text-align:center">采用轮询方式来检测就绪事件，算法时间复杂度O(n）</td>
<td style="text-align:center">采用回调方式来检测就绪事件，算法时间复杂度为O(1)</td>
</tr>
</tbody>
</table>
</div>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clisock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(clisock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"connect error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"connect succ "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    fd_set rfds;</span><br><span class="line">    fd_set wfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> input;           <span class="comment">//命令行输入</span></span><br><span class="line">    <span class="built_in">string</span> serinput;        <span class="comment">//服务器返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        FD_ZERO(&amp;wfds);</span><br><span class="line"></span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line">        FD_SET(<span class="number">1</span>, &amp;wfds);</span><br><span class="line">        FD_SET(clisock, &amp;rfds);</span><br><span class="line">        FD_SET(clisock, &amp;wfds);</span><br><span class="line"></span><br><span class="line">        retval = select(clisock+<span class="number">1</span>, &amp;rfds, &amp;wfds, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">        <span class="keyword">if</span>(retval == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"select error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(<span class="number">0</span>, &amp;rfds))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"可读"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;input;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(<span class="number">1</span>, &amp;wfds) &amp;&amp; !serinput.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"server return: "</span>&lt;&lt;serinput&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                serinput.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(clisock, &amp;rfds))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span>(recv(clisock, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    close(clisock);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"close "</span>&lt;&lt;clisock&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                serinput = <span class="built_in">string</span>(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(clisock, &amp;wfds) &amp;&amp; !input.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(send(clisock, input.c_str(), input.size(), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"send "</span>&lt;&lt;input&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    close(clisock);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"close "</span>&lt;&lt;clisock&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                input.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-server"><a href="#select-server" class="headerlink" title="select_server"></a>select_server</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sersock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sersock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bind error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sersock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"listen error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set rfds;</span><br><span class="line">    fd_set wfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; clisock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxfd = sersock;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        FD_ZERO(&amp;wfds);</span><br><span class="line"></span><br><span class="line">        FD_SET(sersock, &amp;rfds);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> pairs : clisock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = pairs.first;</span><br><span class="line">            <span class="built_in">string</span> s = pairs.second;</span><br><span class="line">            FD_SET(c, &amp;rfds);</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"s info: "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                FD_SET(c, &amp;wfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"set fd: "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            maxfd = c&gt;maxfd ? c : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">        retval = select(maxfd+<span class="number">1</span>, &amp;rfds, &amp;wfds, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">        <span class="keyword">if</span>(retval &lt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"select error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(sersock, &amp;rfds))</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in clientaddr;</span><br><span class="line">                <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="keyword">int</span> c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length);</span><br><span class="line">                clisock[c] = <span class="built_in">string</span>(<span class="string">""</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"new conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">auto</span> &amp;pairs : clisock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = pairs.first;</span><br><span class="line">                <span class="built_in">string</span> &amp;s = pairs.second;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(c, &amp;rfds))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(recv(c, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock[c] = <span class="built_in">string</span>(buffer);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv: "</span>&lt;&lt;clisock[c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        close(c);</span><br><span class="line">                        FD_CLR(c, &amp;wfds);</span><br><span class="line">                        FD_CLR(c, &amp;rfds);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(c, &amp;wfds))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(send(c, s.c_str(), s.size(), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send succ: "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll-server"><a href="#poll-server" class="headerlink" title="poll_server"></a>poll_server</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sersock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sersock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bind error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sersock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"listen error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024] = &#123;</span><span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    fds[<span class="number">0</span>].fd = sersock;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; clisock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        retval = poll(fds, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(retval &lt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"poll error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(POLLRDNORM == (fds[<span class="number">0</span>].revents &amp; POLLRDNORM))</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in clientaddr;</span><br><span class="line">                <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">                <span class="keyword">int</span> c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length);</span><br><span class="line">                clisock[c] = <span class="built_in">string</span>(<span class="string">""</span>);</span><br><span class="line">                fds[++maxi].fd = c;</span><br><span class="line">                fds[maxi].events = POLLRDNORM;</span><br><span class="line">                fds[maxi].revents = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"new conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> &amp;c = fds[i].fd;</span><br><span class="line">                <span class="keyword">auto</span> &amp;s = clisock[fds[i].fd];</span><br><span class="line">                <span class="keyword">if</span>(POLLRDNORM == (fds[i].revents &amp; POLLRDNORM))</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].revents &amp;= ~POLLRDNORM;</span><br><span class="line">                    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(recv(c, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock[c] = <span class="built_in">string</span>(buffer);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv: "</span>&lt;&lt;clisock[c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        fds[i].events |= POLLWRNORM;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        close(c);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                        fds[i].events = <span class="number">0</span>;</span><br><span class="line">                        fds[i].revents = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(POLLWRNORM == (fds[i].revents &amp; POLLWRNORM))</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].revents &amp;= ~POLLWRNORM;</span><br><span class="line">                    <span class="keyword">if</span>(send(c, s.c_str(), s.size(), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send succ: "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        close(c);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fds[i].events &amp;= ~POLLWRNORM;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                fds[i].revents = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-server"><a href="#epoll-server" class="headerlink" title="epoll_server"></a>epoll_server</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sersock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sersock, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sersock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bind error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sersock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"listen error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span>(epollfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"epoll_create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tmpfds</span>;</span></span><br><span class="line">    tmpfds.events = EPOLLRDNORM;</span><br><span class="line">    tmpfds.data.fd = sersock;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, sersock, &amp;tmpfds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; clisock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">        retval = epoll_wait(epollfd, fds, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(retval &lt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"epoll_wait error "</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;retval; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].data.fd == sersock &amp;&amp; (fds[i].events &amp; EPOLLRDNORM) == EPOLLRDNORM)</span><br><span class="line">                &#123;</span><br><span class="line">                    struct sockaddr_in clientaddr;</span><br><span class="line">                    <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">                    <span class="keyword">int</span> c = accept(sersock, (struct sockaddr*)&amp;clientaddr, &amp;length);</span><br><span class="line">                    clisock[c] = <span class="built_in">string</span>(<span class="string">""</span>);</span><br><span class="line">                    tmpfds.data.fd = c;</span><br><span class="line">                    tmpfds.events = EPOLLRDNORM;</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_ADD, c, &amp;tmpfds);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"new conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = fds[i].data.fd;</span><br><span class="line">                <span class="keyword">auto</span> &amp;s = clisock[c];</span><br><span class="line">                <span class="keyword">if</span>(fds[i].data.fd != sersock &amp;&amp;  (fds[i].events &amp; EPOLLRDNORM) == EPOLLRDNORM)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    tmpfds.data.fd = c;</span><br><span class="line">                    tmpfds.events = EPOLLWRNORM | EPOLLRDNORM;</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_MOD, c, &amp;tmpfds);</span><br><span class="line">                    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(recv(c, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock[c] = <span class="built_in">string</span>(buffer);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv: "</span>&lt;&lt;clisock[c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        close(c);</span><br><span class="line">                        epoll_ctl(epollfd, EPOLL_CTL_DEL, c, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"recv close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((fds[i].events &amp; EPOLLWRNORM) == EPOLLWRNORM)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmpfds.data.fd = c;</span><br><span class="line">                    tmpfds.events = EPOLLRDNORM;</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_MOD, c, &amp;tmpfds);</span><br><span class="line">                    <span class="keyword">if</span>(send(c, s.c_str(), s.size(), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send succ: "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        clisock.erase(c);</span><br><span class="line">                        close(c);</span><br><span class="line">                        epoll_ctl(epollfd, EPOLL_CTL_DEL, c, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send close conn "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/18/io-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/18/io-1/" class="post-title-link" itemprop="url">Linux I/O 阻塞、非阻塞、同步、异步的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-18 21:12:00" itemprop="dateCreated datePublished" datetime="2017-09-18T21:12:00+08:00">2017-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux I/O 阻塞、非阻塞、同步、异步的理解</p>
<p>在进行网络编程时，常见到<strong>同步、异步、阻塞、非阻塞</strong>四种调用方式。<br>同步、异步关注的时<strong>消息通信机制</strong>。</p>
<ol>
<li>同步：发出一个调用时，在没有得到结果时，该调用不返回，一旦调用返回，就得到返回值。</li>
<li>异步：调用发出后，该调用直接返回，没有返回结果，被调用者通过状态、通知来通知调用者，或通过回调函数处理该调用。</li>
</ol>
<p>阻塞、非阻塞关注的是<strong>等待调用结果（消息、返回值）的状态</strong>。</p>
<ol>
<li>阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才返回。</li>
<li>非阻塞：调用不能立即得到结果之前，该调用不会阻塞当前线程。</li>
</ol>
<p>在处理IO的时候，<strong>阻塞和非阻塞都是同步IO</strong>。只有特殊的API才是异步IO。<br>对于unix而言：<strong>阻塞式I/O（默认）、非阻塞式I/O（nonblock）、I/O复用（select/poll/epoll）都属于同步I/O</strong>，因为在数据由内核空间复制回进程缓冲区时都是阻塞的。只有<strong>异步I/O模型（AIO）时符合异步I/O操作含义</strong>的，即在数据准备完成，由内核空间拷贝回缓冲区后通知进程的。</p>
<p>阻塞和非阻塞的区别：如果因为各种原因不能马上进行IO操作，继续等待则是阻塞IO，否则则为非阻塞IO。<br>同步和异步的区别：等待一次IO操作完成再返回则是同步，否则为异步。</p>
<p>阻塞式IO<br><img src="/Picture/阻塞式IO.png" alt></p>
<p>非阻塞式IO<br><img src="/Picture/非阻塞式IO.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/16/network-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/16/network-review/" class="post-title-link" itemprop="url">网络相关知识复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-16 12:06:00" itemprop="dateCreated datePublished" datetime="2017-09-16T12:06:00+08:00">2017-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>复习下网络相关知识，包括TCP/IP协议族题解结构和主要协议介绍、封装、复用、ARP协议、IP协议、TCP协议、IP模块工作流程、TCP网络连接的建立和状态转移、DNS服务、HTTP服务的介绍。</p>
<h1 id="浏览器网页访问的过程简介"><a href="#浏览器网页访问的过程简介" class="headerlink" title="浏览器网页访问的过程简介"></a>浏览器网页访问的过程简介</h1><ol>
<li>浏览器分析链接指向的URL</li>
<li>浏览器向DNS请求解析域名的IP地址(DNS协议基于UDP协议)<ol>
<li>UDP(用户数据报)协议 不可靠、无连接、基于数据报</li>
<li>IP协议 不可靠(不保证IP数据报准确到达接收端)、无连接、无状态(简单、高效)</li>
<li>封装 DNS报文 + UDP头部 -&gt; UDP数据报 + IP头部 -&gt; IP数据报 + 以太网头部 + 以太网尾部 -&gt; 以太网帧</li>
<li>传输<ol>
<li>传输层端对端</li>
<li>网络层 选路和转发 使用IP地址寻址</li>
<li>数据链路层 网络驱动程序 使用物理地址寻址 (ARP协议 IP地址转为物理地址) (RARP协议 物理地址转化为IP地址)</li>
<li>分片:帧的最大传输单元(MTU),受到网络类型的限制,以太网帧的MTU1500字节,过长的IP数据报可能会被分片传输.分片只有在最终目标机器上才会被内核IP模块重新组装.</li>
</ol>
</li>
<li>分用 以太网帧到目的主机后,根据各层协议头,将报文逐层解析,最终将处理后的数据交给目标应用程序</li>
</ol>
</li>
<li>DNS获取域名的IP地址,并返回解析到的IP地址<ol>
<li>递归查询(一般采用方式) 主机 -&gt; 本地域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器 -&gt; 顶级域名服务器 -&gt; 本地域名服务器 -&gt; 权限域名服务器 -&gt; 本地域名服务器 -&gt; 主机</li>
<li>迭代查询 主机 -&gt; 本地域名服务器 -&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权限域名服务器 -&gt; 顶级域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器 -&gt; 主机</li>
</ol>
</li>
<li>浏览器和服务器建立TCP链接(TCP三次握手)<ol>
<li>TCP(传输控制)协议 可靠(发送应答机制,超时重传机制,乱序/重复IP报文重排/整理机制)、面向连接(保存状态占用内核资源,全双工)、基于流(数据的发送和接收没有边界限制)</li>
<li>浏览器(CLOSED-&gt;SYN_SENT)发送SYN到服务器</li>
<li>服务器(LISTEN-&gt;SYN_RECV)接收SYN并发送SYN和ACK到浏览器</li>
<li>浏览器(SYN_SENT-&gt;ESTABLISHED)接收ACK并发送ACK到服务器(SYN_RECV-&gt;ESTABLISHED)</li>
</ol>
</li>
<li>浏览器发出命令<ol>
<li>HTTP协议 无连接,无状态</li>
<li>封装</li>
<li>传输<ol>
<li>拥塞窗口</li>
<li>慢开始</li>
<li>拥塞避免</li>
<li>慢开始门限(拥塞窗口)</li>
<li>快重传</li>
<li>快恢复</li>
<li>发送窗口(拥塞窗口和对方给出接收窗口中较小的那一个)</li>
<li>路由器的尾部丢弃和随机丢弃策略</li>
<li>糊涂窗口综合症</li>
<li>滑动窗口</li>
</ol>
</li>
<li>分用</li>
</ol>
</li>
<li>服务器给出响应</li>
<li>浏览器关闭释放TCP连接(TCP四次挥手)<ol>
<li>浏览器(ESTABLISHED-&gt;FIN_WAIT_1)发送FIN到服务器</li>
<li>服务器(ESTABLISHED-&gt;CLOSE_WAIT)接收FIN并发送ACK到浏览器,浏览器(FIN_WAIT_1-&gt;FIN_WAIT_2)接收ACK</li>
<li>服务器(CLOSE_WAIT-&gt;LAST_ACK)发送FIN到浏览器</li>
<li>浏览器(FIN_WAIT_2-&gt;TIME_WAIT)接收FIN,并发送ACK到服务器,服务器(LAST_ACK-&gt;CLOSED)接收ACK 先关闭链接的一方进入TIME_WAIT状态,TIME_WAIT状态需要等待2MSL(TCP报文段最大生存时间):<ol>
<li>可靠的终止链接(重发ACK)</li>
<li>保证让迟来的TCP报文段有足够时间被识别并丢弃</li>
</ol>
</li>
</ol>
</li>
<li>浏览器显示返回结果</li>
</ol>
<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h1><p>Internet（因特网）主流协议族是TCP/IP协议族。<br>TCP/IP协议族是一个<strong>多层、多协议</strong>的通信协议。</p>
<h2 id="TCP-IP协议族体系结构和主要结构"><a href="#TCP-IP协议族体系结构和主要结构" class="headerlink" title="TCP/IP协议族体系结构和主要结构"></a>TCP/IP协议族体系结构和主要结构</h2><p>TCP/IP协议是<strong>四层</strong>协议系统，从底到上分别是<strong>数据链路层、传输层、网络层、应用层</strong>。<br>每层完成不同的功能，通过若干协议来实现，<strong>上层协议使用下层协议提供的服务</strong>。<br><img src="/Picture/TCP-IP协议族体系结构及主要协议.png" alt="TCP/IP协议族体系结构和主要结构"></p>
<h3 id="网络链路层"><a href="#网络链路层" class="headerlink" title="网络链路层"></a>网络链路层</h3><p>网络链路层实现网卡接口的<strong>网络驱动程序</strong>，处理数据在物理媒介（比如以太网、令牌环等）上的传输。<strong>不同的物理网络具有不同的电气特性</strong>，网络驱动程序隐藏了这些细节，为上层协议提供了一个统一的接口。<br>数据链路层主要协议：</p>
<ol>
<li><strong>ARP协议（地址解析协议）  将IP地址转换为物理地址</strong>（通常为MAC地址，以太网、令牌环、802.11无线网络都是用MAC地址）。</li>
<li><strong>RARP协议（逆地址解析协议）  将物理地址转化为IP地址</strong>，利用网卡上的物理地址向网络管理者（服务器或网络管理软件）查询自身的IP地址，RARP协议仅用于网络上的某些无盘工作站,无盘工作站缺乏存储设备，所以无法记住自身的地址。运行RARP服务的网络管理者通常存有该网路上所有及其的物理地址到IP地址的映射。</li>
</ol>
<p><strong>数据链路层使用物理地址来寻址一台机器，而网络层使用IP地址寻找一台机器。</strong></p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层实现数据包的<strong>选路和转发</strong>。WAN（广域网）通常使用众多分级的路由器来连接分散的主机或LAN（局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）相连，<strong>网络层的任务就是选择这些中间节点，以确认主机之间的通信路径</strong>。<br>网络层对上层协议<strong>隐藏网络拓扑连接的细节</strong>，使得在传输层和网络应用程序看来，通信的双方是直接相连的。</p>
<p><strong>网络层核心协议：IP协议（因特网协议）</strong><br>IP协议通过数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目的主机，那么IP协议就为它寻找一个和合适的下一跳路由器，并将数据包交付给该路由器来转发。多次重复该过程，数据包最终到达目标主机，或者因为发送失败而被丢弃。<br>IP协议使用<strong>逐跳</strong>的方式确定通信路径。<br>网络层重要协议<strong>ICMP协议（因特网控制报文协议），IP协议的重要补充，主要用来检测网络连接</strong>。</p>
<p><strong>ICMP协议并不是严格意义上的网络层协议</strong>，因为它使用处于同一层的IP协议提供的服务。<br><img src="/Picture/ICMP报文格式.png" alt="ICMP报文格式"><br>8位类型，用来区分报文类型</p>
<ol>
<li><strong>差错报文</strong>，主要用来回应网络错误，比如目标不可达（类型值为3）和重定向（类型值为5）。</li>
<li><strong>查询报文</strong>，主要用来查询网络信息，比如ping程序使用ICMP报文查看目标是否可达（类型值为8）。</li>
</ol>
<p>8位代码，进一步区分不同的条件，比如重定向报文使用代码值0表示对网络重定向，用代码值1标识对主机重定向。<br>16位校验和，对<strong>整个报文（包括头部和内容部分）进行循环冗余检验（CRC）</strong>，以检验报文在传输过程中是否损坏，不同的ICMP报文类型具有不同的正文内容。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为两台主机上的应用程序提供<strong>端到端的通信</strong>，传输层只关心通信的<strong>起始端和目的端</strong>，而<strong>不关心数据包的中转过程</strong>。<br>传输层协议主要有三个：<strong>TCP协议，UDP协议和SCTP协议</strong>。</p>
<ol>
<li><strong>TCP协议（传输控制协议）</strong>为应用层提供<strong>可靠的、面向连接的和基于流的</strong>服务。</li>
<li><strong>UDP协议（用户数据报协议）</strong>为应用层提供<strong>不可靠的、无连接的和基于数据报的</strong>服务。</li>
<li>SCTP协议（流控制传输协议）相对较新的传输层协议，为了在因特网上传输电话信号而设计。<br><img src="/Picture/传输层和网络层的区别.png" alt="传输层和网络层的区别"><br>图中垂直实线箭头表示TCP/IP协议族之间的实体通信（数据包确实沿着这些线路传递），水平虚线箭头表示逻辑通信线路。<br>数据链路层（驱动程序）封装了物理网路的电气细节；网络层封装了网络连接的细节；传输层为应用程序封装了一条端到端的逻辑通信链路，负责数据的收发、链路的超时重连等。</li>
</ol>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层负责处理应用程序的<strong>逻辑</strong>。数据链路层、网络层、传输层负责处理<strong>网络通信细节</strong>，这些部分必须<strong>既稳定又高效</strong>，因此它们都在<strong>内核空间</strong>中实现。应用层在用户空间实现，因为它处理众多逻辑，比如文件传输、名称查询、网络管理等。如果应用层实现在内核中，内核会变得非常庞大。应用层实现在内核中，内存不用在用户空间和内核空间中来回切换（主要是数据复制），可以提高工作效率，但实现复杂、不够灵活、不方便移植。<br>应用层协议众多：</p>
<ol>
<li>ping是应用程序，而是不协议，<strong>利用ICMP报文检测网络连接</strong>，是调试网络环境的必备工具。</li>
<li>telent协议是一种远程登陆协议，使我们能在本地完成远程任务。</li>
<li>OSPF（开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间通信，以告知对方各自的路由信息。</li>
<li><strong>DNS（域名服务）协议提供及其域名到IP地址的转换</strong>。</li>
</ol>
<p>应用层协议（或程序）可以跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。<br>应用层协议（或程序）通常<strong>既可以使用TCP服务，又可以使用UDP协议</strong>，比如DNS协议。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>应用程序数据在发送到物理网络上之前，先沿着协议栈从上向下传递，<strong>每层协议都在上层数据的基础上加上自己的头部信息（有时还包括尾部信息）</strong>，以实现该层的功能，这个过程叫做<strong>封装</strong>。<br><img src="/Picture/封装.png" alt="封装"><br>经过TCP封装获得数据成为<strong>TCP报文段</strong>（TCP段）。<br>TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中TCP模块首先将这些数据复制到与该连接相对应的TCP内核发送缓存区中，然后TCP模块调用IP模块提供的服务，传递的参数包括<strong>TCP头部信息和TCP内核缓存区（发送缓存区或接收缓存区）数据一起构成TCP报文段</strong>。<br><img src="/Picture/TCP报文段封装过程.png" alt="TCP报文段封装过程"><br>经过UDP封装后的数据称为<strong>UDP数据报</strong>。UDP对应用程序数据的封装与TCP类似。UDP无须为应用层数据保存副本，提供不可靠的服务。当一个UDP数据报被成功发送后，UDP内核缓存区中的该数据报就被丢弃了。如果应用程序检测到该数据报未被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓存区。<br>经过IP封装后的数据称为<strong>IP数据报</strong>，IP数据报也包括<strong>头部信息和数据部分</strong>，其中数据部分就是一个TCP报文段、UDP数据报或着ICMP报文。<br>经过数据链路层封装的数据成为<strong>帧</strong>，传输媒介不同，帧的类型也不同。比如，以太网上是以太网帧，令牌环网络为令牌环帧。<br>以太网帧如下图所示：<br><img src="/Picture/以太网帧.png" alt="以太网帧"><br>以太网帧使用6字节的目的物理地址和6字节的源物理地址来表示通信的双方。<br>2字节类型字段用来标识上层协议。<br>4字节CRC字段对帧的其他部分提供循环冗余教研。<br>帧的最大传输单元（MTU），集帧最多携带多少上层协议数据，通常受到网络类型的限制，<strong>以太网帧的MTU是1500字节</strong>，过长的IP数据报可能需要被<strong>分片</strong>传输。<br><strong>帧才是最终在物理网络上传输的字节序列</strong>。</p>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当帧到达目的主机后，将沿着协议栈自底向上依次传递，各层协议以此处理帧中本层负责的头部信息获取所需的信息，并最终将处理后的数据交给目标应用程序，这个过程叫做分用。<br><img src="/Picture/以太网分用过程.png" alt="以太网分用过程"><br>分用是依靠<strong>头部信息中的类型字段</strong>来实现的。<br>帧中用2字节类型字段区分上层协议，即IP协议、ARP协议或RARP协议。<br>类型字段为0x800，即帧的数据部分为IP数据报。<br>类型字段为0x806，即帧的数据部分为ARP请求或应答报文。<br>类型字段为0x835，即帧的数据部分为RARP请求或应答报文。<br>IP数据报的头部采用16位的协议字段来区分ICMP协议、TCP协议和UDP协议。<br>TCP报文段和UDP报文段则通过其头部中的16位端口号字段来区分上层应用程序。</p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><strong>ARP协议实现任意网络层地址到物理层地址的转换</strong>。<br>IP地址到以太网地址（MAC）的转换。<br>工作原理：主机向自己所在的网络<strong>广播</strong>一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但<strong>只有被请求的目标机器会回应一个ARP应答</strong>，其中包含自己的物理地址。<br><img src="/Picture/以太网ARP请求或应答报文.png" alt="以太网ARP请求或应答报文"><br>硬件类型：定义物理地址的类型，值为1表示MAC地址。<br>协议类型：表示要映射的协议地址类型，值为0x800表示IP地址。<br>硬件地址长度和协议地址长度：单位为字节。MAC地址长度为6,IP(v4)地址长度为4。<br>操作类型：4种操作类型。ARP请求（1）、ARP应答（2）、RARP请求（3）、RARP应答（4）。<br>最后四个字段指定通信双方的以太网地址（MAC）和IP地址。<br>发送端填充除了目的端以太网地址之外的其他3个字段，以构建ARP请求并发送。<br>接收端发送请求的目的端IP地址是自己，就把自己的以太网地址填充进取，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回。<br>ARP请求/应答报文长度为28字节，加上以太网头部和尾部的18字节，一个携带ARP请求/应答的以太网帧帧长度为46字节，有的实现要求以太网数据长度至少为46字节，此时ARP请求/应答报文会增加一些填充字节，满足该要求，这样携带ARP请求/应答报文的以太网帧为64字节。<br><strong>ARP维护一个高速缓存</strong>，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。<strong>避免了重复的ARP请求，提高了发送数据报的速度</strong>。ARP高速缓存是<strong>动态变化</strong>的。<br><strong>每个ARP广播中都包含发送方的IP地址到物理地址的绑定，接收方在处理ARP分组前，先更新缓存中IP到物理地址的绑定信息</strong>。<br><img src="/Picture/ARP通信过程.png" alt="ARP通信过程"></p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议是TCP/IP协议的动力，为上层提供<strong>无状态、无连接、不可靠的服务</strong>。<br>无状态：IP通信双方<strong>不同步传输数据的状态信息</strong>。  优点：<strong>简单、高效</strong>。<br>无连接：IP通信双方<strong>不长久地维持双方的任何信息</strong>。上层协议每次发送数据的时候，都必须明确制定对方的IP地址。<br>不可靠：Ip协议<strong>不保证IP数据报准确地到达接收端</strong>。<br><img src="/Picture/IP报文.png" alt="IP报文"></p>
<p>选项：</p>
<ol>
<li>记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，用于跟踪数据报的传递路径。</li>
<li>时间戳，告诉每个路由器都将数据报转发的时间填入IP头部的选项部分，测量途径路由之间的数据报传输时间。</li>
<li>松散源路由选择，指定一个路由器IP地址列表，数据报发送过程中必须经过所有的路由器。</li>
<li>严格源路由选择，和松散源路由选择类似，不过数据报只能经过被指定的路由器。</li>
</ol>
<p>当IP数据报的长度超过帧的MTU时，将被分片传输。分片可以发送在发送端，也可以发生在中转路由器上，而且在传输过程中可能被多次分片，但只有在最终的目的机器上，这些分片才会被内核中IP模块重新组装。<br>IP头部中的数据报标识、标志和片偏移三个字段给IP的分片和组装提供了足够的信息，一个IP数据报的每个分片都具有自己的IP头部，具有相同的标识符，但具有不同的片偏移。并且除了最后一个分片外，每个分片都将设置MF标志，每个分片的IP头部的总长度字段将被设置为该分片的长度。<br><img src="/Picture/IP头部信息结构体格式.png" alt="IP头部信息结构体格式"></p>
<h2 id="IP模块工作流程"><a href="#IP模块工作流程" class="headerlink" title="IP模块工作流程"></a>IP模块工作流程</h2><p><img src="/Picture/IP模块工作流程.png" alt><br>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括本机上层数据（ICMP报文、TCP报文段和UDP报文段）的IP数据报。<br>从IP输入队列中取出一个IP数据报：</p>
<ol>
<li>对该IP数据报的头部做CRC校验，确认无误后分析其头部的具体信息。</li>
<li>如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理该数据报。</li>
<li>如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者广播地址，即该数据报是发送给本机的，则IP模块根据数据报头部的协议字段来句町将它分派给那个上层应用（分用）。否则该数据报不是发送给本机的，将其交给转发子模块来处理。</li>
<li>数据报转发子模块将首先检测系统是否允许转发，如果不允许，IP模块就丢弃该数据报。如果允许，数据报转发子模块就对该数据报执行一些操作，然后将其交给IP数据报输出子模块。</li>
</ol>
<p><strong>IP数据报应该发送至下一跳路由（或者目标机器），以及经过哪个网卡来发送，就是IP路由过程</strong>。<br><strong>IP模块实现数据报路由的核心数据结构是路由表</strong>，这个表按照数据报的目标IP分类，同一类型的IP数据报就被发往相同的下一跳路由器（或目标机器）。<br>虚线箭头显示路由表更新的过程，这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，成为IP路由测策略。<br><img src="/Picture/路由表.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[CaseZheng@localhost Picture]$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 enp2s0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     100    0        0 enp2s0</span><br><span class="line">192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0</span><br></pre></td></tr></table></figure></p>
<p>IP路由机制：</p>
<ol>
<li>查找路由表中和数据报中的目的IP地址完全匹配的主机IP地址，如果找到，就是用该路由项，没找到则转步骤2。</li>
<li>查找路由表中和数据报中目标IP地址具有相同网路ID的网络IP地址。如果找到，就是用该路由项，没找到则转步骤3。</li>
<li>选择默认路由，通常表示网关。</li>
</ol>
<p>路由器更新：<br>路由器必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。</p>
<ol>
<li>通过route命令或者其他工具手动修改路由表，是静态的路由更新方式。</li>
<li>对大型路由器，通过BGP（边际网关协议）、RIP（路由信息协议）、OSFP等协议来发现路径，并更新自己的路由表。这种方式是动态的、自动的。</li>
<li>ICMP重定向报文。</li>
</ol>
<p>IP转发：</p>
<ol>
<li>检测数据报头部的TTL值，如果TTL值已经为0,则丢弃该数据报。</li>
<li>查看数据报头部的严格源路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站路由失败报文给发送端。</li>
<li>如果有必要，则给源端发送一个ICMP重定向报文，告诉它一个更合理的下一跳路由器。</li>
<li>将TTL值减1。</li>
<li>处理IP头部选项。</li>
<li>如果有必要，则执行IP分片。</li>
</ol>
<p>一般来说，主机只接收ICMP重定向报文，路由器只能发送ICMP重定向报文。<br>ICMP重定向报文的类型值为5，代码字段有4个可选值，用来区分不同的重定向类型。<br>主机重定向代码值为1。<br>更新路由表通常是更新路由表缓存，而不是直接更改路由表。<br><img src="/Picture/ICMP重定向报文.png" alt></p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><strong>TCP服务：面向连接、字节流和可靠传输</strong>。<br>面向连接：使用TCP通信的双方必须先<strong>建立连接</strong>，然后才可以开始数据的读写。双方必须为该连接分配必要的<strong>内核资源</strong>，以管理连接的状态和连接上的传输。TCP连接是<strong>全双工</strong>的，即双方的数据读写可以通过一个连接进行，完成数据交换后，通信双方必须断开连接以释放系统资源。TCP连接是<strong>一对一</strong>的，所以基于广播和多播的应用程序不能使用TCP连接。而无连接协议UDP协议则非常适合于广播和多播。<br>字节流：发送端执行的写操作次数和接收端执行的读操作次数没有任何数量关系，应用程序对<strong>数据的发送和接受没有边界限制</strong>。<br>可靠连接：</p>
<ol>
<li><strong>发送应答机制</strong>，发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。</li>
<li><strong>超时重传机制</strong>，发送端在发送一个TCP报文后启动定时器，如果定时器时间内未收到应答，将重新发送该报文段。</li>
<li>TCP报文段最终以IP数据报发送，而IP数据报到达接收端可能是<strong>乱序、重复</strong>的，所以TCP协议会对接收到的IP报文<strong>重排、整理</strong>，再交给应用层。</li>
</ol>
<p>由于TCP使用两个端点来标识连接，一个机器上的某个TCP端口可以被多个连接所共享。<br><img src="/Picture/TCP-UDP发送接收.png" alt></p>
<p>TCP头部结构如下图所示<br><img src="/Picture/TCP头部结构.png" alt><br>16位端口号，告知主机该数据报来自哪个（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行TCP通信时，客户端使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。<br>32位序列号，一次TCP通信（从TCP连接建立到断开）过程中某个传输方向上的字节流的每个字节的编号。<br>32位确认号，对于另一方发送来的TCP报文段的响应，其值是收到的TCP报文段的序号家1。<br>4位头部长度，表示该TCP头部有多少个32bit（4字节）。<br>6位标志位：</p>
<ol>
<li>URG，紧急指针是否有效。</li>
<li>ACK，表示确认号是否有效，携带ACK标志的TCP报文段为确认报文段。</li>
<li>PSH，提示接收端应用程序应该立即从TCP接收缓存区读走数据，为后续数据腾出空间。</li>
<li>RST，要求对方重新建立连接，携带RST标志的TCP报文段位复位报文段。</li>
<li>SYN，要求建立一个连接，携带SYN标志的TCP报文段位同步报文段。</li>
<li>FIN，通知对方本端要关闭了，携带FIN标志的TCP的报文段为结束报文段。</li>
</ol>
<p>16位窗口大小，是TCP流量控制的一个手段，指接收通告窗口，告诉对方本端的TCP接收缓存区还能容纳多少字节的数据，对方据此控制发送数据的速度。<br>16位校验和，由发送端填充，接收端对TCP报文段执行CRC算法以校验TCP报文段在传输过程中是否损坏，注意：检验<strong>包括头部和数据部分</strong>。是TCP可靠传输的一个保障。<br>16位紧急指针，一个正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。该字段，实际是紧急指针相对当前序号的偏移，紧急偏移。TCP的紧急指针的发送端向接收端发送紧急数据的方法。<br>紧急指针指出紧急数据在报文段中的结束位置。</p>
<p><img src="/Picture/TCP头部选项的一般结构.png" alt><br>TCP头部的最后一个字段选项是可变长的可选信息，最多包含40个字节。<br>kind说明选项类型，常见的TCP选项有7种。<br>length说明该选项的长度。<br>info是选项的具体信息。<br><img src="/Picture/7种TCP选项.png" alt><br>kind=0,选项表结束选项。<br>kind=1,空操作选项，没有特殊含义，一般用于将TCP选项的长度填充为4字节的整数倍。<br>kind=2,最大报文段长度选项。<br>kind=3,窗口扩大引子选项。<br>kind=4,选择性确认（SACK）选项。<br>kind=5,SACK实际工作的选项。<br>kind=8,时间戳选项。</p>
<p>TCP报文段伪首部，用于TCP校验和计算。<br><img src="/Picture/TCP报文段伪首部.png" alt><br>TCP确认信息指出了接收方期望收到的下一个报文组的序号。<br><strong>拥塞窗口</strong>:拥塞窗口发送方使用,用来控制发送速率,避免发的过多.<br><strong>慢开始</strong>：在启动新连接的传输或者在拥塞之后增加通信量时，仅以一个报文段作为拥塞窗口的初始值，而每收到一个确认后，将拥塞窗口大小加1,使用慢开始算法后，每经过一个往返时间RTT，拥塞窗口的值就加倍。<br><strong>拥塞避免算法</strong>：让拥塞窗口缓慢增加，每经过一个往返时间RTT就把发送窗口的拥塞窗口加1,而不是加倍。<br><strong>慢开始门限</strong>：</p>
<ol>
<li>拥塞窗口小于慢开始门限，使用慢开始算法。</li>
<li>拥塞窗口大于慢开始门限，使用拥塞避免算法。</li>
<li>拥塞窗口等于慢开始门限，即可使用慢开始算法，也可使用拥塞避免算法。<br><strong>滑动窗口</strong>:控制接收和同步数据,通知接收方目前接收的数据范围,用于流量控制,接收端使用.<br><strong>快重传</strong>：接收方每收到一个失序的报文段就立即发出重复确认，而不是等待自己发送数据时才进行捎带确认。当发送方一次收到3个重复确认就应立即重传对方尚未收到的报文段。<br><strong>快恢复</strong>:当发送方连续收到三个重复确认时，就执行“乘法减小算法”，把快启动门限减半，把拥塞窗口设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法。<br>发送方的发送窗口一定不能超过对方给出的接收窗口值。<strong>发送窗口</strong>的取值为<strong>拥塞窗口和对方给出的接收窗口中较小的那一个</strong>。<br><strong>路由器的尾部丢弃策略</strong>：如果数据报到达时输入队列已被填满，则丢弃该数据报。<br>可能会丢弃来自多个TCP连接的一个数据报，而不是来自一个连接的多个数据报，造成全局性的同步，丢失数据报的多个TCP连接同时进入慢开始状态。<br><strong>路由器的随机丢弃策略（RED）</strong>：当数据报到达时，如果输入队列已满，则丢弃这个数据报，如果输入队列未满，但大小超过了上限阀值，则通过按概率p丢弃数据报来避免同步。<br><strong>糊涂窗口综合症</strong>：发送方应用进程产生数据很慢或者接收端应用程序处理接收缓冲区数据很慢，或者二者皆有；就会导致应用进程间传送的报文很小；极端情况下，有效载荷可能只有1个字节，传输开销有40个字节（20个字节的IP头和20字节的TCP头）这种现象。<br>接收方避免糊涂窗口综合症的策略：通告0窗口后，要等缓冲区可用空间至少达到宗空间的一半或达到最大报文段长度后才发送更新的窗口通告。<br>实现接收方避免糊涂窗口综合症的策略可使用两种手段：</li>
<li>TCP对收到的报文段进行确认，但要等到窗口空间达到启发式策略所指定的限度之后才发出窗口增大的通告。</li>
<li>在窗口大小不足以避免该症的策略所指定的限度时，则延迟发送确认。TCP标准推荐延迟发送确认。<ol>
<li>延迟确认技术优点：降低通信量并提高吞吐量</li>
<li>延迟确认技术缺点：当接收方的确认延迟太大时，发送方会进行报文段的重传（浪费网络宽带，降低了吞吐量，加重了收发双方的计算负载）。推迟确认造成了估算值的混乱并增大了重传时间。TCP实现确认推迟时间最多推迟500ms，TCP标准推荐接收方按照至少每隔一个报文段使用正常的方式对报文段进行确认。<br>发送方避免糊涂窗口综合症的策略：在一个连接上已经传输的数据还未收到确认的情况下，发送方的应用程序又生成了后续数据，并照常将数据送到输出缓冲区中，但这时并不发送后续报文段，而是等数据足以填满一个达最大长度的报文段之后再把缓冲区的数据发送出去，该策略适用于任何情况，包括推操作在内。<br>现行的TCP要求收发双方实现避免糊涂窗口综合症的启发式策略。<strong>接收方要避免小窗口通告，而接收方要使用自适应机制来推迟传送，以便将数据组块形成较长的大报文段</strong>。</li>
</ol>
</li>
</ol>
<h2 id="TCP网络连接"><a href="#TCP网络连接" class="headerlink" title="TCP网络连接"></a>TCP网络连接</h2><p>TCP通信双方建立TCP连接的一般过程。如下图：<br><img src="/Picture/TCP三次握手四次挥手.png" alt></p>
<p>TCP通信双方的各种状态变化如下图所示：<br><img src="/Picture/TCP状态转移过程.png" alt></p>
<h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>DNS是一套分布式的域名服务系统，每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且时动态更新的。众多网络客户端程序使用DNS协议来向服务器查询目标主机的IP地址。<br>DNS报文格式如下：<br><img src="/Picture/DNS查询和应答报文.png" alt><br>16位标识：用来标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。<br>16位标志：用来协商具体的通信方式和反馈通信状态<br><img src="/Picture/DNS报文头部的标志字段.png" alt><br>16位问题个数、16位应答资源记录个数、16位授权资源记录数目和16位额外的资源记录数目分别指出DNS报文的最后四个字段的资源记录数目。<br>对查询报文，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<br>对应答报文，应答资源记录数则至少为1,而授权资源记录数和额外资源记录数可为0或非0。<br><img src="/Picture/DNS查询问题格式和资源记录格式.png" alt></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="/Picture/HTTP.png" alt></p>
<h1 id="HTTP协议-1"><a href="#HTTP协议-1" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>HTTPS是以安全为目标的HTTP通道,是HTTP的安全版本,即HTTP+SSL层,HTTPS的安全基础是SSL.<br>HTTPS协议的主要作用:</p>
<ol>
<li>建立一个信息安全通道,确保数据传输安全</li>
<li>确保网站真实性</li>
</ol>
<p>HTTP以明文方式发送内容,不提供任何方式的数据加密</p>
<h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ol>
<li>HTTP是明文传输,HTTPS具有安全性的SSL加密传输协议</li>
<li>HTTPS需要CA申请证书,免费证书少,需要一定费用,HTTP则不需要</li>
<li>HTTP和HTTPS使用完全不同的连接方式,HTTP默认80端口,HTTPS默认443端口</li>
<li>HTTP连接无状态,HTTPS协议由HTTP+SSL协议构建,可进行加密传输、身份认证的网络协议,安全性高于HTTP</li>
</ol>
<h2 id="HTTPS优缺点"><a href="#HTTPS优缺点" class="headerlink" title="HTTPS优缺点"></a>HTTPS优缺点</h2><ol>
<li>优点:<ol>
<li>使用HTTPS协议认证用户的服务器,确保数据发送到正确的客户机和服务器</li>
<li>HTTPS有SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,比HTTP协议安全,可防止数据在传输过程中不被窃取、改变,确保数据的安全和完整.</li>
</ol>
</li>
<li>缺点:<ol>
<li>HTTPS握手阶段耗时多</li>
<li>SSL证书需要钱</li>
<li>HTTPS的协议加密范围有限,</li>
</ol>
</li>
</ol>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="TCP三次握手-客户端发送的最后确认的ACK丢失-服务端会怎么样-服务器在没有收到第二个ACK时-客户端发送数据-被服务端接收到-服务端怎么处理-客户端在回复ACK的同时携带数据服务器会怎么处理"><a href="#TCP三次握手-客户端发送的最后确认的ACK丢失-服务端会怎么样-服务器在没有收到第二个ACK时-客户端发送数据-被服务端接收到-服务端怎么处理-客户端在回复ACK的同时携带数据服务器会怎么处理" class="headerlink" title="TCP三次握手,客户端发送的最后确认的ACK丢失,服务端会怎么样? 服务器在没有收到第二个ACK时,客户端发送数据,被服务端接收到,服务端怎么处理? 客户端在回复ACK的同时携带数据服务器会怎么处理?"></a>TCP三次握手,客户端发送的最后确认的ACK丢失,服务端会怎么样? 服务器在没有收到第二个ACK时,客户端发送数据,被服务端接收到,服务端怎么处理? 客户端在回复ACK的同时携带数据服务器会怎么处理?</h2><ol>
<li>TCP三次握手,如果第2个ACK丢失,此时服务端状态为SYN_RECV,等段时间后会触发超时重传,依次等待时间为3s,6s,12s,24s,48s,之后重发SYN+ACK包(服务端重发SYN+ACK包的次数可通过<code>/proc/sys/net/ipv4/tcp_synack_retries</code>修改,默认为5次),让客户端重发ACK.如果重发指定次数的SYN+ACK后仍然未收到ACK应答,过一段时间,Server将自动关闭这个连接.</li>
<li>虽然第二个ACK丢失,但客户端在发出ACK后即确认连接建立,此时发送数据到服务端,服务端将发送RST,让客户端断开这个异常连接.</li>
<li>客户端在第二个ACK携带数据,服务端会正常建立连接,并处理数据</li>
</ol>
<h2 id="主动关闭TCP连接的一方进入TIME-WAIT状态-还是被动关闭的一方进入-TIME-WAIT状态有何特殊之处-为什么"><a href="#主动关闭TCP连接的一方进入TIME-WAIT状态-还是被动关闭的一方进入-TIME-WAIT状态有何特殊之处-为什么" class="headerlink" title="主动关闭TCP连接的一方进入TIME_WAIT状态,还是被动关闭的一方进入?TIME_WAIT状态有何特殊之处,为什么?"></a>主动关闭TCP连接的一方进入TIME_WAIT状态,还是被动关闭的一方进入?TIME_WAIT状态有何特殊之处,为什么?</h2><ol>
<li>主动关闭的一方进入TIME_WAIT状态</li>
<li>TIME_WAIT状态需要等待2MSL(TCP报文段最大生存时间),才会完全关闭<ol>
<li>可靠地终止TCP连接,当被动关闭的一方发出FIN,在等待一段时间后未收到ACK,此时会重发FIN,令主动关闭的一方重发ACK.</li>
<li>保证来迟的TCP报文段有足够的时间被识别并丢弃</li>
</ol>
</li>
</ol>
<h2 id="关闭TCP连接时-如果通信双方同时发出了FIN会怎么样"><a href="#关闭TCP连接时-如果通信双方同时发出了FIN会怎么样" class="headerlink" title="关闭TCP连接时,如果通信双方同时发出了FIN会怎么样?"></a>关闭TCP连接时,如果通信双方同时发出了FIN会怎么样?</h2><ul>
<li>同时发出FIN则都先进入FIN_WAIT_1状态,在收到对方的FIN后进入CLOSING状态,并发出自己的ACK,等收到对方的ACK后,再进入TIME_WAIT状态</li>
</ul>
<h2 id="被动关闭一方在LAST-ACK收不到ACK如何关闭"><a href="#被动关闭一方在LAST-ACK收不到ACK如何关闭" class="headerlink" title="被动关闭一方在LAST_ACK收不到ACK如何关闭?"></a>被动关闭一方在LAST_ACK收不到ACK如何关闭?</h2><p>如果超时未收到ACK则会重发FIN,此时:</p>
<ol>
<li>主动关闭一方仍处于TIME_WAIT状态,则会发送ACK,被动关闭方收到ACK则顺利从LAST_ACK进入CLOSED.</li>
<li>主动断开的一方经过2MSL已经进入了CLOSED状态,此时会返回RST给被动关闭方,被断开方收到后从LAST_ACK进入CLOSED.</li>
</ol>
<h2 id="四次挥手可能变成三次挥手吗"><a href="#四次挥手可能变成三次挥手吗" class="headerlink" title="四次挥手可能变成三次挥手吗?"></a>四次挥手可能变成三次挥手吗?</h2><ul>
<li>当被动关闭方在收到FIN后,回复ACK的时候,可能由于TCP延迟确认,延迟发送这个ACK,此时被动关闭一方也关闭了连接,被动关闭一方将同时发送FIN和ACK给主动关闭一方,被动关闭方由CLOSE_WAIT状态直接到LAST_ACK状态,而主动关闭一方由FIN_WAIT_1状态直接进入TIME_WAIT状态.此时TCP四次挥手,变为三次挥手</li>
</ul>
<h2 id="四次挥手-被动关闭一方何时发送FIN"><a href="#四次挥手-被动关闭一方何时发送FIN" class="headerlink" title="四次挥手,被动关闭一方何时发送FIN?"></a>四次挥手,被动关闭一方何时发送FIN?</h2><ul>
<li>被动关闭一方收到FIN并回复ACK后不会理解发送FIN,需要等待应用层关闭连接后才会发送FIN</li>
</ul>
<h2 id="为什么是三次握手-四次挥手"><a href="#为什么是三次握手-四次挥手" class="headerlink" title="为什么是三次握手,四次挥手?"></a>为什么是三次握手,四次挥手?</h2><ol>
<li><strong>三次握手,为了防止已经失效的连接请求报文段突然又传到服务端,因而产生错误.</strong> 例如:客户端发送一个连接请求给服务端,这个请求并没有丢失,但由于未知原因在某个网络节点,导致延迟到连接释放的某个时间点到达服务端,这是一个本已失效的报文段,但服务端再收到报文后,会误以为A再次发出了一个新的连接请求,服务端向客户端发送确认报文,确认连接成功,但客户端并没有发出建立连接的请求,服务端等不到客户端的消息,也不会结束连接,白白浪费服务器资源</li>
<li><strong>四次挥手是因为TCP连接是全双工的</strong>,允许同时通信的双方同时进行数据的收发,也运行收发的两个方向的连接被独立关闭,避免客户端数据发送完毕,向服务端发送FIN关闭连接,而服务端还有发送到客户端的数据没有发送完毕的情况.所以关闭TCP连接需要四次,每次关闭一个方向上的连接需要FIN和ACK两次.</li>
</ol>
<h2 id="什么是半打开、半关闭、半连接"><a href="#什么是半打开、半关闭、半连接" class="headerlink" title="什么是半打开、半关闭、半连接?"></a>什么是半打开、半关闭、半连接?</h2><ol>
<li>半打开,一方已经关闭或者异常终止连接,而另一方却不知道,这样的连接称为半打开</li>
<li>半关闭,TCP是全双工的,其在关闭写后,仍然可以读取对方发送的数据称为半关闭</li>
<li>半连接,客户端向服务端发起TCP连接发送SYN,服务端正常回复SYN和ACK,但客户端未回复ACK</li>
</ol>
<h2 id="close和shutdown的区别"><a href="#close和shutdown的区别" class="headerlink" title="close和shutdown的区别"></a>close和shutdown的区别</h2><ul>
<li>单进程、单线程、多线程在使用close时行为是一致的,都会真正的关闭连接,而多进程下调用close函数只是对其引用计数减一,只有当引用计数为0时才会真正的关闭连接,如果多进程共享同一个socket则需要都调用close才会真正关闭连接</li>
<li>shutdown则和多进程、多线程无关,只要调用shutdown都会去真正的关闭连接.shutdown可以通过标志位选择关闭读(对端发送过来的消息丢弃掉)、关闭写(发送FIN)、关闭读写</li>
</ul>
<h2 id="listen函数的第二个参数的含义是什么"><a href="#listen函数的第二个参数的含义是什么" class="headerlink" title="listen函数的第二个参数的含义是什么?"></a>listen函数的第二个参数的含义是什么?</h2><ul>
<li>TCP在三次握手时,服务端维护了两个队列,一个是连接尚未建立完成的队列(SYN队列,即收到SYN,回复SYN+ACK后,尚未收到ACK),一个是连接建立完成的队列(ACCEPT队列,即收到SYN,回复SYN+ACK后,收到ACK),listen函数第二个参数的含义即为连接建立完成的队列的长度,一般设置为5-10,因为服务器处理能力优先,而且维护队列需要消耗资源</li>
</ul>
<h2 id="TCP的定时器有哪些"><a href="#TCP的定时器有哪些" class="headerlink" title="TCP的定时器有哪些?"></a>TCP的定时器有哪些?</h2><ol>
<li>建立连接定时器 TCP建立连接客户端发送第一个SYN后,起一个定时器(默认3s),如果SYN丢失,定时器到后会重发SYN,配置<code>/proc/sys/net/ipv4/tcp_syn_retries</code>查看重传次数,时间倍数递增</li>
<li>重传定时器 TCP发出数据时设定,超时未收到ACK则重传</li>
<li>延迟应答定时器 延迟应答时使用,延迟应答是为了提高网络传输的效率(糊涂窗口综合症)</li>
<li>坚持定时器 专门为对付零窗口通告而设立,发送端收到零窗口通告则启动,发送探测报文段</li>
<li>保活定时器 收到消息则重置保活定时器,如果超时(通常是2小时),则每75s(发送10次)发送一个探测报文段,若收不到响应则终止连接</li>
<li>FIN_WAIT_2定时器 主动断开连接一方发送FIN收到ACK后进入FIN_WAIT_2状态,此时启动该定时器,当对端一直不发送数据,超时后终止连接</li>
<li>TIME_WAIT定时器 2MSL定时器,主动关闭方进入TIME_WAIT状态时启动,定时器设定为1分钟,TCP控制块被删除,端口号可重用</li>
</ol>
<h2 id="大端和小端的区别"><a href="#大端和小端的区别" class="headerlink" title="大端和小端的区别"></a>大端和小端的区别</h2><ul>
<li>大端和小端都是指主机字节序,网络字节序采用大端的方式</li>
<li>小端将低位字节存放在内存的低地址端,高位字节存放在内存的高地址端</li>
<li>大端将低地字节存放在内存的高地址端,高位字节存放在内存的低地址段<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">栈  由高地址向低地址增长 <span class="number">1</span>的<span class="number">16</span>进制为 <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span></span><br><span class="line">|----|          高地址</span><br><span class="line">|<span class="number">0x00</span>|</span><br><span class="line">|----|</span><br><span class="line">|<span class="number">0x00</span>|</span><br><span class="line">|----|</span><br><span class="line">|<span class="number">0x00</span>|</span><br><span class="line">|----|</span><br><span class="line">|<span class="number">0x01</span>|&lt;---&amp;x p  低地址</span><br><span class="line">|----|</span><br><span class="line">|    |</span><br><span class="line">|----|</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)(&amp;x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (((<span class="keyword">int</span>)(*p) == <span class="number">1</span>) ? <span class="string">"小端"</span> : <span class="string">"大端"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> i;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((un.c == <span class="number">1</span>) ? <span class="string">"小端"</span> : <span class="string">"大端"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Linux高性能服务器编程</li>
<li><a href="https://blog.csdn.net/zerooffdate/article/details/79359726" target="_blank" rel="noopener">TCP三次握手的第二个ack丢了会怎样</a></li>
<li><a href="https://yq.aliyun.com/articles/15118/" target="_blank" rel="noopener">TCP连接建立的三次握手过程可以携带数据吗？</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/12/design-pattern-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/12/design-pattern-27/" class="post-title-link" itemprop="url">设计模式探秘-27-比较总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-12 21:42:00" itemprop="dateCreated datePublished" datetime="2017-09-12T21:42:00+08:00">2017-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>创建类模式包括工厂方法模式、建造者模式、抽象工厂模式、单例模式和原型模式，都能够提供对象的创建和管理职责。单例模式要求在内存中只有一个对象，原型模式要求通过复制的方法产生一个新的对象。</p>
<h1 id="工厂方法模式和建造者模式"><a href="#工厂方法模式和建造者模式" class="headerlink" title="工厂方法模式和建造者模式"></a>工厂方法模式和建造者模式</h1><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步的精准构造创建出一个复杂的对象。<br><strong>工厂方法模式和建造者模式都属于对象创建类模式</strong>，都用来创建类的对象，但区别还是比较明显的：</p>
<ol>
<li><strong>意图不同</strong>，工厂方法模式中，关注产品整体，无须关心产品的各部分是如何创建出来的；在建造者模式中，一个具体产品的产生依赖各个部件的产生以及装配顺序，关注的是“由零件一步一步地组装出产品对象”。简单说：工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注产品组成部分的创建过程。</li>
<li><strong>产品复杂度不同</strong>，工厂方法模式创建的产品一般都是单一性质产品，而建造者模式创建的都是复合产品，由哥哥不见复合而成，不见不同产品对象也不相同。工厂方法模式的对象粒度比较粗，而建造者模式的对象粒度比较粗。</li>
</ol>
<h1 id="抽象工厂模式和建造者模式"><a href="#抽象工厂模式和建造者模式" class="headerlink" title="抽象工厂模式和建造者模式"></a>抽象工厂模式和建造者模式</h1><p>抽象工厂模式实现对产品家族的创建，一个产品家族是一系列的产品：具有不同分类维度的产品组合，采用抽象工厂模式则不需要关心构建过程，只关心什么产品由什么工厂生产即可，而建造者模式则是要求按照指定蓝图建造产品，主要目的是通过组装零部件而产生一个新产品。<br><strong>抽象工厂模式比建造者模式的尺度要大，关注产品整体，建造者模式关注建造过程</strong>，因此建造者模式可以很容易构建出一个崭新产品。<br>抽象工厂模式适用于希望屏蔽对象的创建过程，只提供一个封装良好的对象，而建造者模式可以用在构建的装配方面，通过不同装配方案产生新对象，其可产生一个非常灵活的架构，方便地扩展和维护系统。</p>
<p>结构类模式包括适配器模式、桥梁模式、组合模式、装饰模式、门面模式、享元模式、代理模式。结构类模式：通过组合类或对象产生更大结构以适应更高层次的逻辑需求。</p>
<h1 id="代理模式和装饰模式"><a href="#代理模式和装饰模式" class="headerlink" title="代理模式和装饰模式"></a>代理模式和装饰模式</h1><p><strong>装饰模式是代理模式的一种特殊应用</strong>。共同点：具有相同的接口。不同点：代理模式着重代理过程的控制，装饰模式则是对类的功能进行加强和减弱，着重类的功能变化。<br>代理模式把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真是角色的消息进行变形处理，不对被主题角色（被代理类）的功能做任何处理，保证原汁原味的调用。<br>装饰模式在保证接口不变的情况下加强类功能，保证被修饰对象功能比原始对象丰富，但不做准入条件判断和准入参数过滤。</p>
<h1 id="装饰模式和适配器模式"><a href="#装饰模式和适配器模式" class="headerlink" title="装饰模式和适配器模式"></a>装饰模式和适配器模式</h1><p>装饰模式和适配器模式在功能上相似，都是包装作用，通过委托方式实现其功能，不同点是，装饰模式包装的是自己的兄弟类，隶属同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，其本质还是非相同接口的对象。</p>
<p>不同点：</p>
<ol>
<li>意图不同<ol>
<li>装饰模式的意图是加强对象的功能。</li>
<li>适配器模式关注的是转化，主要意图是两个对象间的转化。</li>
</ol>
</li>
<li>施与对象不同<ol>
<li>装饰模式装饰对象必须是自己的同宗，即有相同的接口或父类</li>
<li>适配器模式必须是两个不同的对象</li>
</ol>
</li>
<li>场景不同<ol>
<li>装饰模式在任何时候都可以用，只是相增强类的功能</li>
<li>适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的羡慕中。</li>
</ol>
</li>
<li>扩展性不同<ol>
<li>装饰器模式易于扩展</li>
<li>适配器模式建立容易，想去掉就不容易拉</li>
</ol>
</li>
</ol>
<p>行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模版方法模式、访问者模式。</p>
<h1 id="命令模式和策略模式"><a href="#命令模式和策略模式" class="headerlink" title="命令模式和策略模式"></a>命令模式和策略模式</h1><p>策略模式的意图是封装算法，让算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户。命令模式是对动作的解耦，把一个动作的执行分为执行对象（接受者角色）、执行行为（命令角色）、让两者相互独立而不相互影响。</p>
<p>不同：</p>
<ol>
<li>关注点不同，策略模式关注算法的替换，而命令模式关注的是解耦问题。</li>
<li>角色功能不同，策略模式中的具体算法是负责一个完整算法逻辑，是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。命令模式关注命令的实现，也就是功能的实现。</li>
<li>使用场景不同，策略模式适用于算法要求变换的场景，命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。</li>
</ol>
<h1 id="策略模式和状态模式"><a href="#策略模式和状态模式" class="headerlink" title="策略模式和状态模式"></a>策略模式和状态模式</h1><p>策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的，而状态模式封装的是不同的状态，已到达状态切换行为随之发生改变的目的。虽然都有变换的行为，但两者目标不同。</p>
<p>不同：</p>
<ol>
<li>环境角色的职责不同 策略模式的环境角色只是一个委托作用，负责算法的替换，而状态模式的环境角色不仅仅是委托行为，还具有登记状态变化的功能，与具体状态类协作，共同完成状态切换行为随之切换的任务。</li>
<li>解决问题的重点不同 策略模式旨在解决内部算法如何改变的问题，将内部算法的改变对外界的影响降低到最小程度，保证的是算法可以自由地切换，状态模式旨在解决内在状态变化而引起行为改变的问题，出发点是事物的状态，封装状态而暴露行为，一个对象的状态改变，从外界看好像行为改变。</li>
<li>解决问题的方法不同 策略模式只是确保算法可以自由切换，什么时候用什么算法它不能决定，而状态模式对外暴露的是行为，状态的变化由环境角色和具体状态共同完成，状态模式封装了状态的变化而暴露了不同行为或行为结果。</li>
<li>应用场景不同 策略模式的算法必须是平行的，状态模式要求一系列状态发生变化的场景，要求是有状态且有行为的场景，一个对象必须具有二维（状态和行为）描述才能采用状态模式，如果只有状态而没有行为，则状态的变化就失去了意义。</li>
<li>复杂度不同 策略模式较简单（结构简单，扩展容易，代码容易阅读）。状态模式较复杂，要从两个角色看出对象状态和行为的改变，即封装的是变化。</li>
</ol>
<h1 id="观察者模式和责任链模式"><a href="#观察者模式和责任链模式" class="headerlink" title="观察者模式和责任链模式"></a>观察者模式和责任链模式</h1><p>触发链和责任链虽然都是链结构，但有所区别</p>
<ol>
<li>链中的消息对象不同 从首节点开始到最终的尾节点，两个链中传递的消息对象是不同的。责任链模式基本不改变消息对象的结构，虽然每个节点都可以参与消费（一般不参与消费），但结构不会发生变化。触发链模式中链中对象可以自由变化，上下级之间传递对象了解即可，不要求链中消息对象不变化，只要求链中相邻两个节点的消息对象固定。</li>
<li>上下节点的关系不同 责任链模式中，上下节点没有关系，都接受相同的对象，所有传递的对象都是从链首传递过来，上一节点是没有什么关系，按照自己的逻辑处理即可。触发链模式上下级关系亲密，链中任意两个相邻节点都是一个牢固的独立团体。</li>
<li>消息分销渠道不同 责任链模式中，一个消息从链首传递进来后，沿着链条向链尾移动，方向是单一、固定的。触发链模式不同，采用观察者模式，非常灵活，一个消息传递到链首后，具体怎么传递不固定，可以广播方式传递，也可跳跃方式传递，取决于处理消息的逻辑。</li>
</ol>
<p>创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式着重如何建立软件结构。</p>
<h1 id="策略模式和桥梁模式"><a href="#策略模式和桥梁模式" class="headerlink" title="策略模式和桥梁模式"></a>策略模式和桥梁模式</h1><p>策略模式是行为模式，旨在封装一系列的行为。桥梁模式解决在不破坏封装的情况下抽取出抽象部分和实现部分，前提是不破坏封装，让抽象部分和实现部分都可以独立的变化。策略模式使用继承和多态建立一套可以自由切换算法的模式，桥梁模式在不破坏封装性的前提下解决抽象和实现都可以独立扩展的模式。</p>
<h1 id="门面模式和中介者模式"><a href="#门面模式和中介者模式" class="headerlink" title="门面模式和中介者模式"></a>门面模式和中介者模式</h1><p>门面模式为复杂系统提供统一的访问界面，定义的是一个高层接口，该接口使子系统更加容易使用，避免外部模块深入到子系统内部，而产生与子系统内部细节耦合的问题。<br>中介者模式使用中介对象封装一系列同事对象的交互行为，使各个对象之间不再显式地引用，从而使其耦合松散，建立可扩展的应用架构。</p>
<p>不同：</p>
<ol>
<li>功能区别 门面模式只是增加了一个门面，对子系统没有增加任何功能，子系统脱离门面模式完全可以独立运行，中介者模式增加了业务功能，把各个同事类中的原有耦合关系移植到中介者，同事类不可能脱离中介者而独立存在。</li>
<li>知晓状态不同 门面模式中子系统不知道门面的存在，对中介者来说，每个同事类都知道中介者存在，因为要依靠中介者调和同事间关系。</li>
<li>封装程度不同 门面模式是简单封装，所有请求处理都委托给子系统完成，中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，术语更进一步的业务功能封装。</li>
</ol>
<h1 id="包装模式比较"><a href="#包装模式比较" class="headerlink" title="包装模式比较"></a>包装模式比较</h1><p>包装模式包括：装饰模式、适配器模式、门面模式、代理模式、桥梁模式。<br>包装模式都通过委托的方式对一个对象或一系列对象施行包装，使设计的系统更加灵活、稳定、具有扩展性。从实现角度看，都是代理的一种表现形式。</p>
<ol>
<li>代理模式：主要用在不希望展示一个对象内部细节的场景中。</li>
<li>装饰模式：特殊的代理模式，倡导不改变接口的前提下为对象增强功能，或动态添加额外职责，就扩展性而言，比子类更加灵活。</li>
<li>适配器模式：主要意图是接口转换，把一个对象的接口转换成系统希望的另一种接口，避免外界深入系统内部，提高系统的稳定性和可靠性。</li>
<li>桥梁模式：在抽象层产生耦合，解决自行扩展的问题，使两个耦合关系的对象互不影响的扩展。</li>
<li>门面模式：一个粗粒度的封装，提供一个方便访问子系统的接口，不具有任何业务逻辑，仅仅是一个访问复杂系统的快速通道，没有门面，子系统也可正常运行。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>设计模式之禅</li>
<li>GoF+23种设计模式解析</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/08/design-pattern-26-bridge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/design-pattern-26-bridge/" class="post-title-link" itemprop="url">设计模式探秘-26-桥梁模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-08 23:41:00" itemprop="dateCreated datePublished" datetime="2017-09-08T23:41:00+08:00">2017-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>桥梁模式的学习与实践</p>
<h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><p>桥梁模式也叫桥接模式，其定义：将抽象和实现解耦，使得两者可以独立地变化。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKhEIImkLd1CAYufIamkoSpFKwZcKW02RV-2rA94a8269bSj5rHTK6fQPbvg2Zxbdha5o3g0t9pKtDIyalmYe5Aui7D-Nd9HQaagXZGM6tHB2tHhx93To8LDErGPaX0NiYbQkaMPwHabkYWkibBGpimju798pKi11WO0"></p>
<ol>
<li>Abstraction 抽象化角色 主要职责是定义该角色的行为，同时保存一个对实现化角色的引用，该角色是一般为抽象类。</li>
<li>Implementor 实现化角色 接口或者抽象类，定义角色必须的行为和属性。</li>
<li>RefinedAbstraction 修正抽象化角色 引用实现化角色对抽象化角色进行修正。</li>
<li>ConcreteImplementor 具体具现化角色 实现接口或者抽象类定义的方法和属性。</li>
</ol>
<p>抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。<br>桥梁模式使用类间的聚合关系、继承、覆写等常用功能提供了非常清晰、稳定的架构。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象和实现分离 完全是为了解决继承的缺点而提出的设计模式。该模式下实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。</li>
<li>优秀的扩充能力。</li>
<li>实现细节对用户透明 客户不关心细节的实现，已经由抽象层通过聚合关系完成了封装。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>不希望或不适用使用继承的场景</li>
<li>接口或抽象类不稳定的场景</li>
<li>重用性要求高的场景</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用桥梁模式主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。当系统设计时发现类的继承有N层时，可以考虑使用桥梁模式。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>Bridge是设计模式中比较复杂和难理解的模式之一，在ＯＯ开发中经常会使用到．使用组合（委托）的方式将抽象和实现彻底地解耦，抽象和实现分别独立的变化，系统的耦合性得到了下降。  　　<br>桥梁模式要抽象和实现分离，这里的实现不是指抽象基类中虚函数（接口）的实现，而是指如何去实现用户的需求，通过组合（委托）方式去实现，并不是指通过继承基类、实现基类接口，而是指通过对象组合实现用户的需求。</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桥梁模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractionImp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Abstraction() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Abstraction() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractionImp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractionImp() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractionImp() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AbstractionImp::Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMP"</span>&lt;&lt;__FUNCTION__&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> :</span> <span class="keyword">public</span> Abstraction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RefinedAbstraction(AbstractionImp *imp)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pImp = imp;</span><br><span class="line">    &#125;</span><br><span class="line">    ~RefinedAbstraction() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pImp-&gt;Operation();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractionImp *m_pImp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAbstractionImpA</span> :</span> <span class="keyword">public</span> AbstractionImp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteAbstractionImpA() &#123;&#125;</span><br><span class="line">    ~ConcreteAbstractionImpA() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;__FUNCTION__&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAbstractionImpB</span> :</span> <span class="keyword">public</span> AbstractionImp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteAbstractionImpB() &#123;&#125;</span><br><span class="line">    ~ConcreteAbstractionImpB() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B"</span>&lt;&lt;__FUNCTION__&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractionImp *impa = <span class="keyword">new</span> ConcreteAbstractionImpA();</span><br><span class="line">    Abstraction *absa = <span class="keyword">new</span> RefinedAbstraction(impa);</span><br><span class="line">    absa-&gt;Operation();</span><br><span class="line"></span><br><span class="line">    AbstractionImp *impb = <span class="keyword">new</span> ConcreteAbstractionImpB();</span><br><span class="line">    Abstraction *absb = <span class="keyword">new</span> RefinedAbstraction(impb);</span><br><span class="line">    absb-&gt;Operation();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>设计模式之禅</li>
<li>GoF+23种设计模式解析</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/08/design-pattern-25-flyweight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/design-pattern-25-flyweight/" class="post-title-link" itemprop="url">设计模式探秘-25-享元模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-08 13:30:00" itemprop="dateCreated datePublished" datetime="2017-09-08T13:30:00+08:00">2017-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>享元模式的学习与实践</p>
<h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><p>享元模式是池技术的重要实现方式，使用享元对象可有效支持大量的细粒度的对象。</p>
<p>享元模式的定义提出了两点要求：细粒度的对象和共享对象。<br>细粒度对象使得对象数量多且性质相近，将对象的信息分为两部分：内部状态和外部状态。</p>
<ol>
<li>内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而变化，可以作为对象的动态附加信息，不必直接储存在具体某个对象中，属于可以共享的部分。</li>
<li>外部状态是对象得以依赖的一个标记，随环境改变而变化、不可以共享的状态。</li>
</ol>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://www.plantuml.com/plantuml/svg/VP512iCW44NtSmgNAS4BT142WNJPCuYPD5AhGKUAjBrxKqXIKqbdf_yvyxzJUnAEmas3rC9xrkfuHtKPg1MIh8li0MogyeIqIiKLum5UyFjaOSyZEa7AcYAX6ckaGyAKNiLW_20STd-XHYiqyqqEyZ3oP_Kr0_izCpGBpJNsn6qIxSZAVZbucAry6bNPbstLRFnMtdK9DPfksiiR"></p>
<ol>
<li>Flyweight 抽象享元角色 简单来说就是产品的抽象类，同时定义出对象的内部状态和外部状态的接口或实现。</li>
<li>ConcreteFlyweight 具体享元角色 具体的产品类，实现抽象角色定义的业务，该角色中需要注意内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，又改变了外部状态。</li>
<li>unsharedConcreteFlyweight 不可共享的享元角色 不存在外部状态或者安全要求不能使用共享计数的对象。</li>
<li>FlyweightFactory 享元工厂 职责非常简单 就是构造一个池容器，同时提供从池中获得对象的方法。</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>大大减少应用程序创建的对象，降低程序内存的占用，增强程序性能。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固话特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中有大量的相似对象</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，即对象没有特定身份</li>
<li>需要缓冲池的场景</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>线程安全问题</li>
<li>性能平衡</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>对象池着重在系统的复用上，池中对象可相互替换，从同一池中获取的对象对于客户端来说完全相同。享元模式主要解决对象的共享问题，如何建立多个可共享的细粒度对象是其关注的重点。</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Flyweight()</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;extrinsicState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetIntrinsicState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_sIntrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Flyweight(<span class="built_in">string</span> intrinsicState)</span><br><span class="line">    &#123;</span><br><span class="line">        m_sIntrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_sIntrinsicState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> :</span> <span class="keyword">public</span> Flyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteFlyweight(<span class="built_in">string</span> intrinsicState) : Flyweight(intrinsicState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ConcreteFlyweight Build ...."</span>&lt;&lt;intrinsicState&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ConcreteFlyweight()</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;extrinsicState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ConcreteFlyweight:内"</span>&lt;&lt;GetIntrinsicState()&lt;&lt;<span class="string">"外"</span>&lt;&lt;extrinsicState&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FlyweightFactory()</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    ~FlyweightFactory()</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Flyweight *<span class="title">GetFlywgight</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//auto it = m_vFly.begin();</span></span><br><span class="line">        <span class="comment">//for(; it!=m_vFly.end(); ++it)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//if((*it)-&gt;GetIntrinsicState() == key)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;"already creteed by users ..."&lt;&lt;key&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">//return *it;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:m_vFly)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;GetIntrinsicState() == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"already creteed by users ..."</span>&lt;&lt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Flyweight *fn = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">        m_vFly.push_back(fn);</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Flyweight*&gt; m_vFly;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FlyweightFactory fc;</span><br><span class="line">    Flyweight *fw1 = fc.GetFlywgight(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fw1-&gt;GetIntrinsicState()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Flyweight *fw2 = fc.GetFlywgight(<span class="string">"world"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fw2-&gt;GetIntrinsicState()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Flyweight *fw3 = fc.GetFlywgight(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fw3-&gt;GetIntrinsicState()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>设计模式之禅</li>
<li>GoF+23种设计模式解析</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CaseZheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CaseZheng</p>
  <div class="site-description" itemprop="description">CaseZheng的博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CaseZheng" title="GitHub → https://github.com/CaseZheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:764307915@qq.com" title="E-Mail → mailto:764307915@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CaseZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">717k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  


</body>
</html>
