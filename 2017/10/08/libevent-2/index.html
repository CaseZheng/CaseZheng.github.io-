<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F14AAB2D4C842CB9F200D0A80DA8CB2F">
  <meta name="baidu-site-verification" content="GNlbaIvRtqlfiBfg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.casezheng.date","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable，本篇主要是Libevent event_base的设置、Libevent 事件循环的启动和停止、Libevent事件的创建和处理、Libevent http服务相关API的介绍 基础API日志打印回调设置API event_set_log_callbackLibevent记录内">
<meta name="keywords" content="cpp,网络,libevent">
<meta property="og:type" content="article">
<meta property="og:title" content="Libevent源码阅读——API简介">
<meta property="og:url" content="http://www.casezheng.date/2017/10/08/libevent-2/index.html">
<meta property="og:site_name" content="CaseZheng">
<meta property="og:description" content="重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable，本篇主要是Libevent event_base的设置、Libevent 事件循环的启动和停止、Libevent事件的创建和处理、Libevent http服务相关API的介绍 基础API日志打印回调设置API event_set_log_callbackLibevent记录内">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-12T04:56:36.131Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Libevent源码阅读——API简介">
<meta name="twitter:description" content="重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable，本篇主要是Libevent event_base的设置、Libevent 事件循环的启动和停止、Libevent事件的创建和处理、Libevent http服务相关API的介绍 基础API日志打印回调设置API event_set_log_callbackLibevent记录内">

<link rel="canonical" href="http://www.casezheng.date/2017/10/08/libevent-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Libevent源码阅读——API简介 | CaseZheng</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f1686055a927fa7bf1a09bc1143b57c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CaseZheng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CaseZheng Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/10/08/libevent-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Libevent源码阅读——API简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-08 00:41:00" itemprop="dateCreated datePublished" datetime="2017-10-08T00:41:00+08:00">2017-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络库/" itemprop="url" rel="index"><span itemprop="name">网络库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>重新读下Libevent的源码，使用最新的Libevent版本libevent-release-2.1.8-stable，本篇主要是Libevent event_base的设置、Libevent 事件循环的启动和停止、Libevent事件的创建和处理、Libevent http服务相关API的介绍</p>
<h1 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h1><h2 id="日志打印回调设置API-event-set-log-callback"><a href="#日志打印回调设置API-event-set-log-callback" class="headerlink" title="日志打印回调设置API event_set_log_callback"></a>日志打印回调设置API event_set_log_callback</h2><p>Libevent记录内部的错误和警告日志，如果编译了日志支持功能，也会记录调试信息，<strong>日志信息默认输出到stderr</strong>，可以通过提供自己的日志函数的方法来覆盖该行为。调用event_set_log_callback()传入event_log_cb类型的函数改变默认行为，传入NULL置为默认行为。默认调试日志是禁止的，可以通过event_enable_debug_logging()函数打开调试(DEBUG)日志，EVENT_DBG_NONE为默认行为，EVENT_DBG_ALL打开所有支持的调试日志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Libevent日志登记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LOG_DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LOG_MSG   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LOG_WARN  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LOG_ERR   3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//severity libevent日志等级</span></span><br><span class="line"><span class="comment">//msg libevent日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_log_cb)</span><span class="params">(<span class="keyword">int</span> severity, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log_fn libevent默认的日志回调函数</span></span><br><span class="line"><span class="keyword">static</span> event_log_cb log_fn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置libevent新的日志回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	log_fn = cb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_DBG_ALL 0xffffffffu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_DBG_NONE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_logging</span><span class="params">(<span class="keyword">ev_uint32_t</span> which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	event_debug_logging_mask_ = which;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/CaseZheng/Study/blob/master/Libevent/libevent_server.cpp" target="_blank" rel="noopener">Github示例代码</a></p>
<h2 id="致命错误退出回调设置API-event-set-fatal-callback"><a href="#致命错误退出回调设置API-event-set-fatal-callback" class="headerlink" title="致命错误退出回调设置API event_set_fatal_callback"></a>致命错误退出回调设置API event_set_fatal_callback</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_fatal_cb)</span><span class="params">(<span class="keyword">int</span> err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> event_fatal_cb fatal_fn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fatal_fn = cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Libevent在遇到致命错误时默认调用exit()或abort()退出当前进程，Libevent提供接口在其退出前会调用一次。</p>
<h2 id="更换内存管理函数的API-event-set-mem-functions"><a href="#更换内存管理函数的API-event-set-mem-functions" class="headerlink" title="更换内存管理函数的API event_set_mem_functions"></a>更换内存管理函数的API event_set_mem_functions</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*mm_malloc_fn_)(<span class="keyword">size_t</span> sz) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*mm_realloc_fn_)(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> sz) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*mm_free_fn_)</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(<span class="keyword">void</span> *(*malloc_fn)(<span class="keyword">size_t</span> sz),</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mm_malloc_fn_ = malloc_fn;</span><br><span class="line">	mm_realloc_fn_ = realloc_fn;</span><br><span class="line">	mm_free_fn_ = free_fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下Libevent会使用原生的malloc、calloc、realloc、free。<br>注意:更换内存管理函数将会影响LibEvent后续所有调用allocate、resize和free内存的函数.因此你需要确保在LibEvent调用其它函数之前替换掉这些函数.否则LibEvent将会调用你提供的free函数来释放从C语言库版本的malloc分配的内存.</p>
<ul>
<li>你的malloc和realloc函数需要返回和C语言库相同的内存对齐.</li>
<li>你的realloc函数需要正确处理realloc(NULL,sz),也就是说当做(malloc(sz)处理).</li>
<li>你的realloc函数需要正确处理realloc(ptr,0),也就是说当做free(ptr)处理.</li>
<li>你的free函数不必去处理free(NULL).</li>
<li>你的malloc函数不必去处理malloc(0).</li>
<li>如果你不止一个线程使用LibEvent,那么你提供的的内存管理替代函数必须是线程安全的.</li>
</ul>
<p><a href="https://github.com/CaseZheng/Study/blob/master/Libevent/libevent_server.cpp" target="_blank" rel="noopener">Github示例代码</a></p>
<h2 id="释放LibEvent全局结构体-libevent-global-shutdown"><a href="#释放LibEvent全局结构体-libevent-global-shutdown" class="headerlink" title="释放LibEvent全局结构体 libevent_global_shutdown"></a>释放LibEvent全局结构体 libevent_global_shutdown</h2><p>当进程退出时所有内存都会被释放，但残留的结构体会导致某些调试工具认为Libevent存在内存泄露，使用libevent_global_shutdown可以释放所有库内部的全局数据结构。但libevent_global_shutdown不会释放返回到Libevent外部的结构体，如events、event_base、bufferevents等。<br>调用libevent_global_shutdown()函数将会使得别的LibEvent的函数产生不可预知的行为.除了程序调用了最后一个LibEvent的函数否则不要调用它。<br><a href="https://github.com/CaseZheng/Study/blob/master/Libevent/libevent_timer_signal.cpp" target="_blank" rel="noopener">Github示例代码</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下设置请看官方文档或<a href="http://blog.csdn.net/zhouyongku/article/details/53431597" target="_blank" rel="noopener">Libevent中文帮助手册</a></p>
<ol>
<li>线程和锁</li>
<li>调试锁的使用</li>
<li>调试事件的使用</li>
<li>Libevent版本的检查</li>
</ol>
<h1 id="event-base创建"><a href="#event-base创建" class="headerlink" title="event_base创建"></a>event_base创建</h1><h2 id="默认的event-base"><a href="#默认的event-base" class="headerlink" title="默认的event_base"></a>默认的event_base</h2><p>event_base_new()函数分配和返回一个默认参数的event_base，event_base_new()函数检查环境变量，然后分配一个指向新的event_base的指针，如果错误，返回NULL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="复杂的event-base"><a href="#复杂的event-base" class="headerlink" title="复杂的event_base"></a>复杂的event_base</h2><p>创建复杂的event_base需要传入event_config。event_config通过event_config_new获得。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>获得event_config后对其进行设置，然后调用event_base_new_with_config()创建event_base。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用完event_config后需要调用event_config_free()释放event_config。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>event_config的设置需要调用别的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg, <span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> event_method_feature &#123;</span><br><span class="line">    EV_FEATURE_ET = <span class="number">0x01</span>,</span><br><span class="line">    EV_FEATURE_O1 = <span class="number">0x02</span>,</span><br><span class="line">    EV_FEATURE_FDS = <span class="number">0x04</span>,</span><br><span class="line">    EV_FEATURE_EARLY_CLOSE = <span class="number">0x08</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> features)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> event_base_config_flag &#123;</span><br><span class="line">	EVENT_BASE_FLAG_NOLOCK = <span class="number">0x01</span>,</span><br><span class="line">	EVENT_BASE_FLAG_IGNORE_ENV = <span class="number">0x02</span>,</span><br><span class="line">	EVENT_BASE_FLAG_STARTUP_IOCP = <span class="number">0x04</span>,</span><br><span class="line">	EVENT_BASE_FLAG_NO_CACHE_TIME = <span class="number">0x08</span>,</span><br><span class="line">	EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = <span class="number">0x10</span>,</span><br><span class="line">	EVENT_BASE_FLAG_PRECISE_TIMER = <span class="number">0x20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>event_config_avoid_method()可通过名字让libevent避免使用特定的可用后端。<br>event_config_require_features()可让libevent不使用不能提供所有指定特征的后端。<br>event_config_set_flag()让libevent在创建event_base时设置一个或多个运行时标志。</p>
<h3 id="event-config-require-features"><a href="#event-config-require-features" class="headerlink" title="event_config_require_features()"></a>event_config_require_features()</h3><p>可识别的选项值有：</p>
<ol>
<li>EV_FEATURE_ET 要求支持ET模式的后端（边沿触发）</li>
<li>EV_FEATURE_O1 要求添加、删除单个事件，或者确定哪个事件激活的操作时O(1)复杂度的后端</li>
<li>EV_FEATURE_FDS 要求支持任意文件描述符，而不仅仅是套接字的后端</li>
<li>EV_FEATURE_EARLY_CLOSE 要求后台方法可以使用EV_CLOSED检测链接关闭，而不需要读完所有未决数据才能判断 支持EV_CLOSED的后台方法不是所有OS内核都支持的</li>
</ol>
<p>设置成功返回0，失败返回-1</p>
<h3 id="event-config-set-flag"><a href="#event-config-set-flag" class="headerlink" title="event_config_set_flag()"></a>event_config_set_flag()</h3><p>可识别的选项值有：</p>
<ol>
<li>EVENT_BASE_FLAG_NOLOCK 不要为 event_base分配锁.设置这个选项可以为event_base节省一点用于锁定和解锁的时间,但是让在多个线程中访问 event_base成为不安全的</li>
<li>EVENT<em>BASE_FLAG_IGNORE_ENV 选择使用的后端时,不要检测``EVENT</em>*``环境变量.</li>
<li>EVENT_BASE_FLAG_STARTUP_IOCP 仅用于 Windows,让 libevent在启动时就启用任何必需的IOCP分发逻辑,而不是按需启用</li>
<li>EVENT_BASE_FLAG_NO_CACHE_TIME 不是在事件循环每次准备执行超时回调时检测当前时间,而是在每次超时回调后进行检测.注意:这会消耗更多的CPU时间</li>
<li>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST 如果决定使用epoll后端,可以安全地使用更快的基于 changelist的后端.epoll-changelist后端可以在后端的分发函数调用之间,同样的fd多次修改其状态的情况下,避免不必要的系统调用.但是如果传递任何使用 dup ()或者其变体克隆的 fd给libevent, epoll-changelist后端会触发一个内核bug,导致不正确的结果.在不使用epoll后端的情况下,这个标志是没有效果的.也可以通过设置 EVENT_EPOLL_USE_CHANGELIST:环境变量来打开epoll-changelist选项.</li>
<li>EVENT_BASE_FLAG_PRECISE_TIMER 使用更加精确的定时机制</li>
</ol>
<p>设置成功返回0，失败返回-1</p>
<h3 id="获得特定event-base的配置信息"><a href="#获得特定event-base的配置信息" class="headerlink" title="获得特定event_base的配置信息"></a>获得特定event_base的配置信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_features</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event_base_get_method返回一个指针,指向event_base所选择的后端的名称<br>event_base_get_features返回event_base所选后端支持的特征值的比特掩码</p>
<p><a href="https://github.com/CaseZheng/Study/blob/master/Libevent/libevent_timer_signal.cpp" target="_blank" rel="noopener">示例代码</a></p>
<h1 id="运行循环"><a href="#运行循环" class="headerlink" title="运行循环"></a>运行循环</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_ONCE	0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK	0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span> <span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event_base_loop会运行一个event_base直到没有event注册进来，循环运行，不断重复判断是否有注册的event触发。<br>flags标记可改变event_base_loop的行为：</p>
<ol>
<li>EVLOOP_ONCE 循环将等待某些事件成为激活的，执行激活的事件直到没有更多的事件可以执行，然会返回</li>
<li>EVLOOP_NONBLOCK：循环不等待事件被触发，循环将仅仅检测是否有事件已经就绪，可以立即触发，如果有，则执行事件的回调。</li>
<li>EVLOOP_NO_EXIT_ON_EMPTY：没有事件仍不退出，而是由其他函数触发退出</li>
</ol>
<p>event_base_dispatch采用默认的配置调用event_base_loop();<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *event_base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (event_base_loop(event_base, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="停止循环"><a href="#停止循环" class="headerlink" title="停止循环"></a>停止循环</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *event_base, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *event_base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *event_base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *event_base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="event-base-loopexit"><a href="#event-base-loopexit" class="headerlink" title="event_base_loopexit()"></a>event_base_loopexit()</h2><p>要求event_base在指定时间后停止，如果tv为NULL，则立即停止。但该函数实际会使部分event_base在执行完全部的callback之后才返回。</p>
<h2 id="event-base-loopbreak"><a href="#event-base-loopbreak" class="headerlink" title="event_base_loopbreak()"></a>event_base_loopbreak()</h2><p>要求event_base立即停止，无视其他的active事件而停止。如果当前没有callback，则会导致event_base等到执行完下一个callback之后才退出。</p>
<h2 id="event-base-got-break-和-event-base-got-exit"><a href="#event-base-got-break-和-event-base-got-exit" class="headerlink" title="event_base_got_break() 和 event_base_got_exit()"></a>event_base_got_break() 和 event_base_got_exit()</h2><p>event_base_got_break 如果循环因为event_base_loopbreak()退出，event_base_got_break返回true，否则返回false<br>event_base_got_exit 如果循环因为event_base_loopexit()退出，event_base_got_exit返回true，否则返回false</p>
<p><a href="https://github.com/CaseZheng/Study/blob/master/Libevent/libevent_timer_signal.cpp" target="_blank" rel="noopener">示例代码</a></p>
<h1 id="event"><a href="#event" class="headerlink" title="event"></a>event</h1><h2 id="event简介"><a href="#event简介" class="headerlink" title="event简介"></a>event简介</h2><p>libevent的基本操作单元是事件event，每个事件代表一组条件：</p>
<ol>
<li>文件描述符已经就绪，可以读取或者写入</li>
<li>文件描述符变为就绪状态，可以读取或者写入（仅对于边沿触发IO）</li>
<li>超时事件</li>
<li>信号</li>
<li>用户手动触发</li>
</ol>
<p>当一个event被设置好，并且关联到一个event_base里面时，它被称为“initialized”。此时你可以执行add，这使得它进入pending(等待、未决的)状态。当event被触发或超时时，它的状态称为active，这个情况下对应的callback会被调用。如果event被配置为persist，那么它在callback执行前后都会保持pending的状态。可以通过delete来使得一个event从pending状态重新变成nonpending。</p>
<h2 id="event-API-介绍"><a href="#event-API-介绍" class="headerlink" title="event API 介绍"></a>event API 介绍</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span>, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event * <span class="title">event_new</span><span class="params">(struct event_base *base, \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd, \</span></span></span><br><span class="line"><span class="function"><span class="params">    short events, \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*cb)(<span class="keyword">evutil_socket_t</span>, short, <span class="keyword">void</span> *), \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="event创建-event-new"><a href="#event创建-event-new" class="headerlink" title="event创建 event_new"></a>event创建 event_new</h3><p>event_new 创建一个新的event。其中fd是文件描述符，需要自行初始化之后再作为参数传入。event_free()释放event的资源。如果event是active或者是pending状态，则函数会将event先变成非active且非pending的状态，然后再释放它。<br>参数events表示event的需要关注绑定该fd上的哪些事件。</p>
<ol>
<li>EV_TIMEOUT：超时</li>
<li>EV_READ：有数据可读</li>
<li>EV_WRITE：数据可写</li>
<li>EV_SIGNAL：系统发出的信号（signal）</li>
<li>EV_PERSIST：持续事件</li>
<li>EV_ET：边沿触发</li>
</ol>
<p>cb是event被触发后调用的回调函数，cb的类型为event_callback_fn。<br>arg为用户数据在调用回调函数时传给回调函数。</p>
<h3 id="EV-PERSIST-事件持久化"><a href="#EV-PERSIST-事件持久化" class="headerlink" title="EV_PERSIST 事件持久化"></a>EV_PERSIST 事件持久化</h3><p>默认情况下，每当未决事件成为激活的(因为fd已经准备好读取或者写入,或者因为超时),事件将在其回调被执行前成为非未决的。如果想让事件再次成为未决的,可以在回调函数中再次对其调用event_add()。<br>如果设置了EV_PERSIST标志,事件就是持久的。这意味着即使其回调被激活,事件还是会保持为未决状态。如果想在回调中让事件成为非未决的,可以对其调用event_del()。每次执行事件回调的时候,持久事件的超时值会被复位。</p>
<h3 id="超时事件的创建"><a href="#超时事件的创建" class="headerlink" title="超时事件的创建"></a>超时事件的创建</h3><p>纯超时事件不需要fd（传-1即可）。libevent定义了创建超时事件的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(ev, b, cb, arg) \</span></span><br><span class="line">	event_assign((ev), (b), <span class="number">-1</span>, <span class="number">0</span>, (cb), (arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b, cb, arg)	       event_new((b), -1, 0, (cb), (arg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv)		event_add((ev), (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev)			event_del(ev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_initialized(ev)		event_initialized(ev)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="信号事件的创建"><a href="#信号事件的创建" class="headerlink" title="信号事件的创建"></a>信号事件的创建</h3><p>信号事件不需要传入fd，而是传入signum。libevent定义了创建信号事件的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv)		event_add((ev), (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(ev, b, x, cb, arg)			\</span></span><br><span class="line">	event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(b, x, cb, arg)				\</span></span><br><span class="line">	event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev)		event_del(ev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, tv)	event_pending((ev), EV_SIGNAL, (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev)	event_initialized(ev)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="事件的初始化"><a href="#事件的初始化" class="headerlink" title="事件的初始化"></a>事件的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *, struct event_base *, <span class="keyword">evutil_socket_t</span>, short, event_callback_fn, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以使用event_new在创建event时初始化event，也可以使用event_assign初始化未初始化的event，event_assign的参数与event_new的参数意义相同。<br>不要对已经在event_base中未决的事件调用event_assign(),这可能会导致难以诊断的错误。如果已经初始化和成为未决的,调用event_assign()之前需要调用event_del()。libevent提供了方便的宏将event_assign()用于仅超时事件或者信号事件。</p>
<h3 id="event添加监听与取消监听"><a href="#event添加监听与取消监听" class="headerlink" title="event添加监听与取消监听"></a>event添加监听与取消监听</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv)		event_add((ev), (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv)		event_add((ev), (tv))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev)			event_del(ev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev)		event_del(ev)</span></span><br></pre></td></tr></table></figure>
<p>event_add 添加事件监听, tv为指定的超时值，如果为NULL表示不超时。event_del 取消事件监听。</p>
<h3 id="event设置优先级"><a href="#event设置优先级" class="headerlink" title="event设置优先级"></a>event设置优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_init</span><span class="params">(<span class="keyword">int</span> npriorities)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event_priority_init()初始化优先级等级。即设置event_base的优先级数目<br>event_priority_set()设置ev的优先级。pri是[0, npriorities)的一个值。</p>
<h3 id="event状态检测"><a href="#event状态检测" class="headerlink" title="event状态检测"></a>event状态检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, short event, struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">evutil_socket_t</span> <span class="title">event_get_fd</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function">short <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event, struct event_base **base_out, <span class="keyword">evutil_socket_t</span> *fd_out, short *events_out, event_callback_fn *callback_out, <span class="keyword">void</span> **arg_out)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="event-pending"><a href="#event-pending" class="headerlink" title="event_pending"></a>event_pending</h4><p>event_pending函数确定给出的event是未决的还是活动的.如果EV_READ、EV_WRITE、EV_SIGNAL、EV_TIMEOUT被设置为event参数,函数会返回event是未决的或者活动的所有标志.如果提供了tv_out并且设置了EV_TIMEOUT标志给event参数,当前event是未决的或者活跃在超时上,tv_out设置为保存event超时后的时间。</p>
<h4 id="event-get-fd"><a href="#event-get-fd" class="headerlink" title="event_get_fd"></a>event_get_fd</h4><p>函数返回了event配置的文件描述符或者信号值。</p>
<h4 id="event-get-base"><a href="#event-get-base" class="headerlink" title="event_get_base"></a>event_get_base</h4><p>返回event配置的event_base。</p>
<h4 id="event-get-events"><a href="#event-get-events" class="headerlink" title="event_get_events"></a>event_get_events</h4><p>返回事件的标志(EV_READ、EV_WRITE等)</p>
<h4 id="event-get-callback-和-event-get-callback-arg"><a href="#event-get-callback-和-event-get-callback-arg" class="headerlink" title="event_get_callback 和 event_get_callback_arg"></a>event_get_callback 和 event_get_callback_arg</h4><p>event_get_callback()和event_get_callback_arg()函数返回了event的回掉函数和它的参数指针</p>
<h4 id="event-get-priority"><a href="#event-get-priority" class="headerlink" title="event_get_priority"></a>event_get_priority</h4><p>返回了事件当前分配的优先级</p>
<h4 id="event-get-assignment"><a href="#event-get-assignment" class="headerlink" title="event_get_assignment"></a>event_get_assignment</h4><p>拷贝了event分配的所有字段到提供的指针。如果指针为空,则忽略。</p>
<h2 id="手动激活事件"><a href="#手动激活事件" class="headerlink" title="手动激活事件"></a>手动激活事件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> res, short ncalls)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使ev以标志res(EV_READ、EV_WRITE、EV_TIMEOUT的组合)激活,ev不需要预先的被未决,激活event也不需要使其未决。</p>
<h1 id="evbuffer"><a href="#evbuffer" class="headerlink" title="evbuffer"></a>evbuffer</h1><p>evbuffer 用于处理缓冲网络 IO 的”缓冲”部分.</p>
<h2 id="创建和释放evbuffer"><a href="#创建和释放evbuffer" class="headerlink" title="创建和释放evbuffer"></a>创建和释放evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer * <span class="title">evbuffer_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_free</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_new() 分配和返回一个新的空evbuffer;而evbuffer_free()释放evbuffer和其内容</p>
<h2 id="evbuffer与线程安全"><a href="#evbuffer与线程安全" class="headerlink" title="evbuffer与线程安全"></a>evbuffer与线程安全</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_enable_locking</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_lock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_unlock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下，在多个线程中同时访问 evbuffer 是不安全的。如果需要这样的访问，可以调用 evbuffer_enable_locking() 。 如果lock参数为NULL,libevent会使用evthread_set_lock_creation_callback 提供的锁创建函数创建一个锁.否则,libevent将lock参数用作锁。evbuffer_lock()和 evbuffer_unlock()函数分别请求和释放 evbuffer 上的锁。可以使用这两个函数让一系列操作是原子的。如果 evbuffer 没有启用锁，这两个函数不做任何操作。<br>注意：对于单个操作，不需要调用evbuffer_lock()和evbuffer_unlock()：如果evbuffer启用了锁，单个操作就已经是原子的。只有在需要多个操作连续执行，不让其他线程介入的时候，才需要手动锁定evbuffer</p>
<h2 id="检查evbuffer"><a href="#检查evbuffer" class="headerlink" title="检查evbuffer"></a>检查evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">evbuffer_get_length</span><span class="params">(<span class="keyword">const</span> struct evbuffer *<span class="built_in">buffer</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回evbuffer存储的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">evbuffer_get_contiguous_space</span><span class="params">(<span class="keyword">const</span> struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回连续地存储在 evbuffer 前面的字节数。evbuffer 中的数据可能存储在多个分隔开的内存块中，这个函数返回当前第一个块中的字节数</p>
<h2 id="向evbuffer添加数据"><a href="#向evbuffer添加数据" class="headerlink" title="向evbuffer添加数据"></a>向evbuffer添加数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data_in, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_printf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_vprintf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_expand</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_add()添加data处的datlen字节到buf的末尾.<br>evbuffer_add_printf()和evbuffer_add_vprintf()添加格式化的数据到buf末尾.<br>evbuffer_expand()修改缓冲区最后一块,或者添加一个新的块,使缓冲区足以容纳datlen字节,而不需要更多的内存分配</p>
<h2 id="将数据从一个evbuffer移动到另一个"><a href="#将数据从一个evbuffer移动到另一个" class="headerlink" title="将数据从一个evbuffer移动到另一个"></a>将数据从一个evbuffer移动到另一个</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer</span><span class="params">(struct evbuffer *outbuf, struct evbuffer *inbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_buffer</span><span class="params">(struct evbuffer *src, struct evbuffer *dst, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_add_buffer()将inbuf的所有数据移动到outbuf末尾.<br>evbuffer_remove_buffer()从src中移动datlen字节到dst末尾,尽量少进行复制.如果字节数小于datlen,所有字节被移动.</p>
<h2 id="添加数据到evbuffer前面"><a href="#添加数据到evbuffer前面" class="headerlink" title="添加数据到evbuffer前面"></a>添加数据到evbuffer前面</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend_buffer</span><span class="params">(struct evbuffer *outbuf, struct evbuffer *inbuf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将数据移动到目标缓冲区前面</p>
<h2 id="从evbuffer中移除数据"><a href="#从evbuffer中移除数据" class="headerlink" title="从evbuffer中移除数据"></a>从evbuffer中移除数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_drain</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_drain()函数从buf前面移除len字节内存<br>evbuffer_remove()函数从buf前面复制和移除datlen字节到data_out处的内存中.如果可用字节少于datlen,复制所有字节.</p>
<h2 id="从evbuffer中复制出数据"><a href="#从evbuffer中复制出数据" class="headerlink" title="从evbuffer中复制出数据"></a>从evbuffer中复制出数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ev_ssize_t</span> <span class="title">evbuffer_copyout</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前面复制 datlen 字节到 data_out 处的内存中。如果可用字节少于 datlen，函数会复制所有字节。失败时返回-1，否则返回复制的字节数。</p>
<h2 id="面向行的输入"><a href="#面向行的输入" class="headerlink" title="面向行的输入"></a>面向行的输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> evbuffer_eol_style &#123;</span><br><span class="line">	EVBUFFER_EOL_ANY,</span><br><span class="line">	EVBUFFER_EOL_CRLF,</span><br><span class="line">	EVBUFFER_EOL_CRLF_STRICT,</span><br><span class="line">	EVBUFFER_EOL_LF,</span><br><span class="line">	EVBUFFER_EOL_NUL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">evbuffer_readln</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> *n_read_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_readln()函数从 evbuffer 前面取出一行，用一个新分配的空字符结束的字符串返回这一行。如果 n_read_out 不是 NULL，则它被设置为返回的字符串的字节数。如果没有整行供读取，函数返回空。返回的字符串不包括行结束符。evbuffer_readln()理解4种行结束格式</p>
<ol>
<li>EVBUFFER_EOL_ANY,行尾是单个换行符</li>
<li>EVBUFFER_EOL_CRLF,行尾是一个回车符，后随一个换行符</li>
<li>EVBUFFER_EOL_CRLF_STRICT,行尾是一个可选的回车，后随一个换行符</li>
<li>EVBUFFER_EOL_LF,行尾是任意数量、任意次序的回车和换行符。</li>
</ol>
<h2 id="在evbuffer中搜索"><a href="#在evbuffer中搜索" class="headerlink" title="在evbuffer中搜索"></a>在evbuffer中搜索</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_ptr</span> &#123;</span></span><br><span class="line">	<span class="keyword">ev_ssize_t</span> pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">void</span> *chain;</span><br><span class="line">		<span class="keyword">size_t</span> pos_in_chain;</span><br><span class="line">	&#125; internal_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start)</span></span>;</span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_range</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start, <span class="keyword">const</span> struct evbuffer_ptr *<span class="built_in">end</span>)</span></span>;</span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_eol</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, struct evbuffer_ptr *start, <span class="keyword">size_t</span> *eol_len_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_search()函数在缓冲区中查找含有 len 个字符的字符串 what。函数返回包含字符串位置，或者在没有找到字符串时包含-1的 evbuffer_ptr 结构体。如果提供了 start 参数，则从指定的位置开始搜索；否则，从开始处进行搜索。<br>evbuffer_search_range()函数和 evbuffer_search 行为相同，只是它只考虑在 end 之前出现 的 what。<br>evbuffer_search_eol()函数像 evbuffer_readln()一样检测行结束，但是不复制行，而是返回指向行结束符的 evbuffer_ptr。如果 eol_len_out 非空，则它被设置为 EOL 字符串长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> evbuffer_ptr_how &#123;</span><br><span class="line">	EVBUFFER_PTR_SET,</span><br><span class="line">	EVBUFFER_PTR_ADD</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_ptr_set</span><span class="params">(struct evbuffer *buf, struct evbuffer_ptr *pos, <span class="keyword">size_t</span> <span class="built_in">position</span>, <span class="keyword">enum</span> evbuffer_ptr_how how)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_ptr_set 函数操作 buffer 中的位置 pos。如果 how 等于 EVBUFFER_PTR_SET,指针被移动到缓冲区中的绝对位置 position；如果等于 EVBUFFER_PTR_ADD，则向前移动 position 字节。成功时函数返回0，失败时返回-1。<br>任何修改 evbuffer 或者其布局的调用都会使得 evbuffer_ptr 失效，不能再安全地使用。</p>
<h2 id="检测数据而不复制"><a href="#检测数据而不复制" class="headerlink" title="检测数据而不复制"></a>检测数据而不复制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_iovec</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *iov_base;</span><br><span class="line">	<span class="keyword">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_peek</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">ev_ssize_t</span> len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vec)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用 evbuffer_peek()的时候，通过 vec_out 给定一个 evbuffer_iovec 数组，数组的长度是n_vec。函数会让每个结构体包含指向 evbuffer 内部内存块的指针（iov_base)和块中数据长度。如果 len 小于0，evbuffer_peek()会试图填充所有 evbuffer_iovec 结构体。否则，函数会进行填充，直到使用了所有结构体，或者见到 len 字节为止。如果函数可以给出所有请求的数据，则返回实际使用的结构体个数；否则，函数返回给出所有请求数据所需的结构体个数。如果 ptr 为 NULL，函数从缓冲区开始处进行搜索。否则，从 ptr 处开始搜索。</p>
<ol>
<li>修改 evbuffer_iovec 所指的数据会导致不确定的行为</li>
<li>如果任何函数修改了 evbuffer，则 evbuffer_peek()返回的指针会失效</li>
<li>如果在多个线程中使用evbuffer，确保在调用evbuffer_peek()之前使用evbuffer_lock()，在使用完evbuffer_peek()给出的内容之后进行解锁.</li>
</ol>
<h2 id="直接向evbuffer添加数据"><a href="#直接向evbuffer添加数据" class="headerlink" title="直接向evbuffer添加数据"></a>直接向evbuffer添加数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_reserve_space</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> <span class="built_in">size</span>, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_commit_space</span><span class="params">(struct evbuffer *buf, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evbuffer_reserve_space()函数给出 evbuffer 内部空间的指针。函数会扩展缓冲区以至少提供 size 字节的空间。到扩展空间的指针，以及其长度，会存储在通过 vec 传递的向量数组中，n_vec 是数组的长度。n_vec 的值必须至少是1。如果只提供一个向量，libevent 会确保请求的所有连续空间都在单个扩展区中，但是这可能要求重新排列缓冲区，或者浪费内存。为取得更好的性能，应该至少提供2个向量。函数返回提供请求的空间所需的向量数。<br>写入到向量中的数据不会是缓冲区的一部分，直到调用 evbuffer_commit_space()，使得写入的数据进入缓冲区。如果需要提交少于请求的空间，可以减小任何 evbuffer_iovec 结构体的 iov_len 字段，也可以提供较少的向量。函数成功时返回0，失败时返回-1。</p>
<ol>
<li>调用任何重新排列evbuffer或者向其添加数据的函数都将使从 evbuffer_reserve_space()获取的指针失效。</li>
<li>当前实现中，不论用户提供多少个向量，evbuffer_reserve_space()从不使用多于两个。未来版本可能会改变这一点。</li>
<li>如果在多个线程中使用evbuffer，确保在调用evbuffer_reserve_space()之前使用 evbuffer_lock()进行锁定，然后在提交后解除锁定</li>
</ol>
<h2 id="使用evbuffer的网络IO"><a href="#使用evbuffer的网络IO" class="headerlink" title="使用evbuffer的网络IO"></a>使用evbuffer的网络IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write_atmost</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">ev_ssize_t</span> howmuch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_read</span><span class="params">(struct evbuffer *buf, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> howmuch)</span></span>;</span><br></pre></td></tr></table></figure>
<p>vbuffer_read()函数从套接字 fd 读取至多 howmuch 字节到 buffer 末尾。成功时函数返回读取的字节数，0表示 EOF，失败时返回-1。注意，错误码可能指示非阻塞操作不能立即成功，应该检查错误码 EAGAIN（或者 Windows 中的 WSAWOULDBLOCK）。如果 howmuch 为负，evbuffer_read()试图猜测要读取多少数据。evbuffer_write_atmost()函数试图将 buffer 前面至多 howmuch 字节写入到套接字 fd 中。成功时函数返回写入的字节数，失败时返回-1。跟 evbuffer_read()一样，应该检查错误码，看是真的错误，还是仅仅指示非阻塞 IO 不能立即完成。如果为 howmuch 给出负值，函数会试图写入 buffer 的所有内容。调用 evbuffer_write()与使用负的 howmuch 参数调用 evbuffer_write_atmost()一样：函数会试图尽量清空 buffer 的内容。在 Unix 中，这些函数应该可以在任何支持 read 和 write 的文件描述符上正确工作。在 Windows 中，仅仅支持套接字.</p>
<h2 id="evbuffer和回调"><a href="#evbuffer和回调" class="headerlink" title="evbuffer和回调"></a>evbuffer和回调</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> orig_size;</span><br><span class="line">	<span class="keyword">size_t</span> n_added;</span><br><span class="line">	<span class="keyword">size_t</span> n_deleted;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_cb_func)</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, <span class="keyword">const</span> struct evbuffer_cb_info *info, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_entry</span> &#123;</span></span><br><span class="line">	LIST_ENTRY(evbuffer_cb_entry) next;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		evbuffer_cb_func cb_func;</span><br><span class="line">		evbuffer_cb cb_obsolete;</span><br><span class="line">	&#125; cb;</span><br><span class="line">	<span class="keyword">void</span> *cbarg;</span><br><span class="line">	<span class="keyword">ev_uint32_t</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct evbuffer_cb_entry * <span class="title">evbuffer_add_cb</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>向 evbuffer 添加数据，或者从中移除数据的时候，回调函数会被调用。函数收到缓冲区指针、一个 evbuffer_cb_info 结构体指针，和用户提供的参数。evbuffer_cb_info 结构体的 orig_size 字段指示缓冲区改变大小前的字节数，n_added 字段指示向缓冲区添加了多少字节；n_deleted 字段指示移除了多少字节。</p>
<p>evbuffer_add_cb()函数为 evbuffer 添加一个回调函数，返回一个不透明的指针，随后可用于代表这个特定的回调实例。cb 参数是将被调用的函数，cbarg 是用户提供的将传给这个函数的指针。可以为单个 evbuffer 设置多个回调，添加新的回调不会移除原来的回调<br>注意：释放非空 evbuffer 不会清空其数据，释放 evbuffer 也不会为回调释放用户提供的数据指针。如果不想让缓冲区上的回调永远激活，可以移除或者禁用回调：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb_entry</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, struct evbuffer_cb_entry *ent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVBUFFER_CB_ENABLED 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_set_flags</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_clear_flags</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以通过添加回调时候的 evbuffer_cb_entry 来移除回调，也可以通过回调函数和参数指针来移除。成功时函数返回0，失败时返回-1。evbuffer_cb_set_flags()和 evbuffer_cb_clear_flags()函数分别为回调函数设置或者清除给定的标志。当前只有一个标志是用户可见的：EVBUFFER_CB_ENABLED。这个标志默认是打开的。如果清除这个标志，对 evbuffer 的修改不会调用回调函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_defer_callbacks</span><span class="params">(struct evbuffer *<span class="built_in">buffer</span>, struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>跟 bufferevent 回调一样，可以让 evbuffer 回调不在 evbuffer 被修改时立即运行，而是延迟到某 event_base 的事件循环中执行。如果有多个 evbuffer，它们的回调潜在地让数据添加到 evbuffer 中，或者从中移除，又要避免栈崩溃，延迟回调是很有用的。如果回调被延迟，则最终执行时，它可能是多个操作结果的总和。与 bufferevent 一样，evbuffer 具有内部引用计数的，所以即使还有未执行的延迟回调，释放 evbuffer 也是安全的。</p>
<h2 id="为基于evbuffer的IO避免数据复制"><a href="#为基于evbuffer的IO避免数据复制" class="headerlink" title="为基于evbuffer的IO避免数据复制"></a>为基于evbuffer的IO避免数据复制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_ref_cleanup_cb)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datalen, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_reference</span><span class="params">(struct evbuffer *outbuf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen, evbuffer_ref_cleanup_cb cleanupfn, <span class="keyword">void</span> *extra)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过引用向 evbuffer 末尾添加一段数据。不会进行复制：evbuffer 只会存储一个到data 处的 datlen 字节的指针。因此，在 evbuffer 使用这个指针期间，必须保持指针是有效的。evbuffer 会在不再需要这部分数据的时候调用用户提供的 cleanupfn 函数，带有提供的data 指针、datlen 值和 extra 指针参数。函数成功时返回0，失败时返回-1</p>
<h1 id="接受TCP连接"><a href="#接受TCP连接" class="headerlink" title="接受TCP连接"></a>接受TCP连接</h1><p>evconnlistener机制提供了监听和接受TCP连接的方法.</p>
<h2 id="创建和释放evconnlistener"><a href="#创建和释放evconnlistener" class="headerlink" title="创建和释放evconnlistener"></a>创建和释放evconnlistener</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>两个 evconnlistener_new*()函数都分配和返回一个新的连接监听器对象。连接监听器使用 event_base 来得知什么时候在给定的监听套接字上有新的 TCP 连接。新连接到达时，监听器调用你给出的回调函数。两个函数中，base 参数都是监听器用于监听连接的 event_base。cb 是收到新连接时要调用的回调函数；如果 cb 为 NULL，则监听器是禁用的，直到设置了回调函数为止。ptr 指针将传递给回调函数。flags 参数控制回调函数的行为，下面会更详细论述。backlog 是任何时刻网络栈允许处于还未接受状态的最大未决连接数。更多细节请查看系统的 listen()函数文档。如果 backlog 是负的，libevent 会试图挑选一个较好的值；如果为0，libevent 认为已经对提供的套接字调用了 listen()。<br>两个函数的不同在于如何建立监听套接字。evconnlistener_new()函数假定已经将套接字绑定到要监听的端口，然后通过 fd 传入这个套接字。如果要 libevent 分配和绑定套接字，可以调用 evconnlistener_new_bind()，传输要绑定到的地址和地址长度。<br>要释放连接监听器，调用 evconnlistener_free()</p>
<p>可标识的标志<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下，连接监听器接收新套接字后，会将其设置为非阻塞的，以便将其用于 libevent。如果不想要这种行为，可以设置这个标志。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_LEAVE_SOCKETS_BLOCKING	(1u&lt;&lt;0)</span></span><br><span class="line"><span class="comment">//如果设置了这个选项，释放连接监听器会关闭底层套接字。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_CLOSE_ON_FREE		(1u&lt;&lt;1)</span></span><br><span class="line"><span class="comment">//如果设置了这个选项，连接监听器会为底层套接字设置 close-on-exec 标志。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_CLOSE_ON_EXEC		(1u&lt;&lt;2)</span></span><br><span class="line"><span class="comment">//某些平台在默认情况下，关闭某监听套接字后，要过一会儿其他套接字才可以绑定到同一个端口。设置这个标志会让 libevent 标记套接字是可重用的，这样一旦关闭，可以立即打开其他套接字，在相同端口进行监听。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_REUSEABLE		(1u&lt;&lt;3)</span></span><br><span class="line"><span class="comment">//为监听器分配锁，这样就可以在多个线程中安全地使用了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_THREADSAFE		(1u&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_DISABLED		(1u&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_DEFERRED_ACCEPT		(1u&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEV_OPT_REUSEABLE_PORT		(1u&lt;&lt;7)</span></span><br></pre></td></tr></table></figure></p>
<p>连接监听器回调<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(struct evconnlistener *, <span class="keyword">evutil_socket_t</span>, struct sockaddr *, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>stener参数是接收连接的连接监听器。sock参数是新接收的套接字。addr和len参数是接收连接的地址和地址长度。ptr是调用evconnlistener_new()时用户提供的指针。</p>
<h2 id="禁用和启用evconnlistener"><a href="#禁用和启用evconnlistener" class="headerlink" title="禁用和启用evconnlistener"></a>禁用和启用evconnlistener</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_disable</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_enable</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>暂时禁止或者重新允许监听新连接</p>
<h2 id="设置evconnlistener的回调函数"><a href="#设置evconnlistener的回调函数" class="headerlink" title="设置evconnlistener的回调函数"></a>设置evconnlistener的回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数调整 evconnlistener 的回调函数和其参数。</p>
<h2 id="检测evconnlistener"><a href="#检测evconnlistener" class="headerlink" title="检测evconnlistener"></a>检测evconnlistener</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">evutil_socket_t</span> <span class="title">evconnlistener_get_fd</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="function">struct event_base *<span class="title">evconnlistener_get_base</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>分别返回监听器关联的套接字和 event_base</p>
<h2 id="侦测错误"><a href="#侦测错误" class="headerlink" title="侦测错误"></a>侦测错误</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_errorcb)</span><span class="params">(struct evconnlistener *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_error_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_errorcb errorcb)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果使用 evconnlistener_set_error_cb()为监听器设置了错误回调函数，则监听器发生错误时回调函数就会被调用。第一个参数是监听器，第二个参数是调用 evconnlistener_new() 时传入的 ptr。</p>
<h1 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h1><h2 id="bufferevent-和-evbuffer"><a href="#bufferevent-和-evbuffer" class="headerlink" title="bufferevent 和 evbuffer"></a>bufferevent 和 evbuffer</h2><p>每个bufferevent都有一个输出缓冲区和一个输入缓冲区,类型都是”struct evbuffer”,有数据要写入到bufferevent时,添加数据到输出缓冲区;bufferevent中有数据供读取的时候,从输入缓冲区抽取数据.</p>
<h2 id="回调和水位"><a href="#回调和水位" class="headerlink" title="回调和水位"></a>回调和水位</h2><p>每个bufferevent有两个数据相关的回调:读取回调和写入回调.默认情况下,从底层传输端口读取任意量的数据后会调用读取回调;输出去有足够的数据被清空到底层传输端口后写入回调会被调用.</p>
<p>每个bufferevent有四个水位:</p>
<ol>
<li>读取低水位:读取操作使得输入缓冲区的数据量在此级别或者更高时，读取回调将被调用。默认值为0，所以每个读取操作都会导致读取回调被调用。</li>
<li>读取高水位:输入缓冲区中的数据量达到此级别后，bufferevent 将停止读取，直到输入缓冲区中足够量的数据被抽取，使得数据量低于此级别。默认值是无限，所以永远不会因为输入缓冲区的大小而停止读取。</li>
<li>写入低水位:写入操作使得输出缓冲区的数据量达到或者低于此级别时，写入回调将被调用。默认值是0，所以只有输出缓冲区空的时候才会调用写入回调。</li>
<li>写入高水位:bufferevent 没有直接使用这个水位。它在 bufferevent 用作另外一个bufferevent 的底层传输端口时有特殊意义。</li>
</ol>
<p>错误或事件回调(向应用通知非面向数据的事件)</p>
<ol>
<li>BEV_EVENT_READING:读取操作时发生某事件</li>
<li>BEV_EVENT_WRITING:写入操作时发生某事件</li>
<li>BEV_EVENT_EOF:遇到文件结束指示</li>
<li>BEV_EVENT_ERROR:操作时发生错误,调用EVUTIL_SOCKET_ERROR()获取更错错误信息</li>
<li>BEV_EVENT_TIMEOUT:发生超时</li>
<li>BEV_EVENT_CONNECTED:请求的连接过程已经完成</li>
</ol>
<h2 id="延迟回调"><a href="#延迟回调" class="headerlink" title="延迟回调"></a>延迟回调</h2><p>默认情况下,bufferevent的回调在相应的条件发生时立即被执行.在依赖关系复杂的情况下,立即调用会产生问题.要解决该问题,可以请求bufferevent延迟其回调.条件满足时,延迟回调不会立即被调用,而是在event_loop()调用中被排队.然后在通常的事件回调后执行.</p>
<h2 id="buffervent的选项标记bufferevent-options"><a href="#buffervent的选项标记bufferevent-options" class="headerlink" title="buffervent的选项标记bufferevent_options"></a>buffervent的选项标记bufferevent_options</h2><ol>
<li>BEV_OPT_CLOSE_ON_FREE:释放bufferevent时关闭底层传输端口.将关闭底层套接字,释放底层bufferevent等.</li>
<li>BEV_OPT_THREADSAFE:自动为bufferevent分配锁,可以安全的在多个线程中使用bufferevent</li>
<li>BEV_OPT_DEFER_CALLBACKS:设置该标记,bufferevent延迟所有回调</li>
<li>BEV_OPT_UNLOCK_CALLBACKS:默认情况下,如果设置bufferevent为线程安全的,则bufferevent会在调用用户提供的回调时进行锁定.设置该选项让Libevent在执行回调时不锁定.</li>
</ol>
<h2 id="基于套接字的bufferevent"><a href="#基于套接字的bufferevent" class="headerlink" title="基于套接字的bufferevent"></a>基于套接字的bufferevent</h2><h2 id="创建基于套接字的bufferevent"><a href="#创建基于套接字的bufferevent" class="headerlink" title="创建基于套接字的bufferevent"></a>创建基于套接字的bufferevent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *</span></span><br><span class="line"><span class="class"><span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>, <span class="title">evutil_socket_t</span> <span class="title">fd</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">options</span>);</span></span><br></pre></td></tr></table></figure>
<p>base时event_base反应堆 fd是套接字的文件描述符 options是bufferevent选项</p>
<h2 id="在基于套接字的bufferevent上启动连接"><a href="#在基于套接字的bufferevent上启动连接" class="headerlink" title="在基于套接字的bufferevent上启动连接"></a>在基于套接字的bufferevent上启动连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果还没有为 bufferevent 设置套接字，调用函数将为其分配一个新的流套接字，并且设置为非阻塞的。如果已经为 bufferevent 设置套接字，调用 bufferevent_socket_connect()将告知 libevent 套接字还未连接，直到连接成功之前不应该对其进行读取或者写入操作。连接完成之前可以向输出缓冲区添加数据。如果连接成功启动，函数返回0；如果发生错误则返回-1。<br>注意:如果使用bufferevent_socket_connect() 发起连接,将只会收到 BEV_EVENT_CONNECTED 事件。如果自己调用 connect()，则连接上将被报告为写入事件</p>
<h2 id="通过主机名启动连接"><a href="#通过主机名启动连接" class="headerlink" title="通过主机名启动连接"></a>通过主机名启动连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect_hostname</span><span class="params">(struct bufferevent *bev, struct evdns_base *evdns_base, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_get_dns_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_socket_connect_hostnam解析hostname,通过其family类型地址(允许的地址族类型有AF_INET,IF_INET6和AF_UNSPEC).如果名字解析失败,函数将调用事件回调,报告错误事件.如果解析成功,函数将启动连接请求.<br>dns_base参数可选:如果为NULL,等待名字查找完成期间调用线程将被阻塞.如果提供dns_base参数,libevent将使用它异步查询主机名.<br>函数返回的错误可能是DNS主机名查询错误，可以调用bufferevent_socket_get_dns_error() 来获取最近的错误。返回值0表示没有检测到 DNS 错误。</p>
<h2 id="操作回调、水位和启用-禁用"><a href="#操作回调、水位和启用-禁用" class="headerlink" title="操作回调、水位和启用/禁用"></a>操作回调、水位和启用/禁用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev, short what, <span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_setcb()函数修改bufferevent的一个或多个回调.readcb、writecb、eventcb函数分别在读取到足够的数据、写入足够的数据、发生错误时被调用.每个回调的第一个参数都是发生了事件的bufferevent,最后一个参数都是调用bufferevent_setcb()时用户提供的cbarg参数(通过cbarg参数向回调函数传递参数).事件回调的events参数是一个表示事件标志的位掩码.<br>要禁用回调,传递NULL而不是回调函数.注意:<strong>bufferevent的所有回调函数共享单个cbarg,修改它需要特别小心</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, short event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev, short event)</span></span>;</span><br><span class="line"><span class="function">short <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_enable()函数开启bufferevent的EV_READ、EV_WRITE事件<br>bufferevent_disable()函数禁用bufferevent的EV_READ、EV_WRITE事件<br>没有启用读取或写入事件时,bufferevent将不会试图进行数据的读取和写入</p>
<p>没有必要在输出缓冲区空时禁用写入事件：bufferevent 将自动停止写入，然后在有数据等待写入时重新开始<br>没有必要在输入缓冲区高于高水位时禁用读取事件：bufferevent 将自动停止读取，然后在有空间用于读取时重新开始读取<br>默认情况下，新创建的 bufferevent 的写入是启用的，但是读取没有启用<br>bufferevent_get_enabled()可以确定bufferevent上当前开启的事件.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setwatermark</span><span class="params">(struct bufferevent *bufev, short events, <span class="keyword">size_t</span> lowmark, <span class="keyword">size_t</span> highmark)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_setwatermark()函数设置单个bufferevent的读取水位、写入水位.如果events设置为EV_READ调整读取水位,events设置为EV_WARITE调整写入水位.<br>对于高水位,0表示”无限”</p>
<h2 id="bufferevent中数据的操作"><a href="#bufferevent中数据的操作" class="headerlink" title="bufferevent中数据的操作"></a>bufferevent中数据的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct evbuffer * bufferevent_get_input(struct bufferevent *bufev);</span><br><span class="line">struct evbuffer * bufferevent_get_output(struct bufferevent *bufev);</span><br></pre></td></tr></table></figure>
<p>bufferevent_get_input()返回输入缓冲区<br>bufferevent_get_output()返回输出缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_write()将内从从data处开始的size字节数据添加到输出缓冲区末尾.<br>bufferevent_write_buffer()移除buf的所有内容,将其放置到输出缓冲区末尾.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent *bufev, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_read_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_read()至多从输入缓冲区移除size字节的数据,将其存储到内存中data处,返回实际移除的字节数<br>bufferevent_read_buffer()抽空输入缓冲区的所有内容,将其放置到buf中,成功返回0,失败返回-1</p>
<h2 id="读写超时"><a href="#读写超时" class="headerlink" title="读写超时"></a>读写超时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> struct timeval *tv_read,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> struct timeval *tv_write)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bufferevent_set_timeouts()设置超时时间为NULL会移除超时回调<br>试图读取数据的时候，如果至少等待了 timeout_read 秒，则读取超时事件将被触发。试图写入数据的时候，如果至少等待了 timeout_write 秒，则写入超时事件将被触发。<br>注意，只有在读取或者写入的时候才会计算超时。即如果 bufferevent 的读取被禁止，或者输入缓冲区满（达到其高水位），则读取超时被禁止。如果写入被禁止，或者没有数据待写入，则写入超时被禁止。读取或者写入超时发生时，相应的读取或者写入操作被禁止，然后超时事件回调被调用，带有标志BEV_EVENT_TIMEOUT | BEV_EVENT_READING或者BEV_EVENT_TIMEOUT | BEV_EVENT_WRITING。</p>
<h2 id="清空bufferevent"><a href="#清空bufferevent" class="headerlink" title="清空bufferevent"></a>清空bufferevent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_flush</span><span class="params">(struct bufferevent *bufev,</span></span></span><br><span class="line"><span class="function"><span class="params">    short iotype,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> bufferevent_flush_mode mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>清空 bufferevent 要求 bufferevent 强制从底层传输端口读取或者写入尽可能多的数据，而忽略其他可能保持数据不被写入的限制条件。函数的细节功能依赖于 bufferevent 的具体类型。iotype 参数应该是 EV_READ、EV_WRITE 或者 EV_READ | EV_WRITE，用于指示应该处理读取、写入，还是二者都处理。state 参数可以是 BEV_NORMAL、BEV_FLUSH 或者BEV_FINISHED。BEV_FINISHED 指示应该告知另一端，没有更多数据需要发送了； 而 BEV_NORMAL 和 BEV_FLUSH 的区别依赖于具体的 bufferevent 类型。<br>失败时 bufferevent_flush()返回-1，如果没有数据被清空则返回0，有数据被清空则返回1</p>
<h2 id="类型特定的bufferevent函数"><a href="#类型特定的bufferevent函数" class="headerlink" title="类型特定的bufferevent函数"></a>类型特定的bufferevent函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_priority_set</span><span class="params">(struct bufferevent *bufev, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调整bufev的优先级为priority.成功返回0,失败返回-1,该函数仅作用域基于套接字的bufferevent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_setfd</span><span class="params">(struct bufferevent *bev, <span class="keyword">evutil_socket_t</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">evutil_socket_t</span> <span class="title">bufferevent_getfd</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置或返回基于fd的事件的文件描述符.只有基于套接字的bufferevent支持bufferevent_setfd.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base * <span class="title">bufferevent_get_base</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回bufferevent的event_base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_get_underlying</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回作为 bufferevent 底层传输端口的另一个 bufferevent。</p>
<h2 id="手动锁定和解锁"><a href="#手动锁定和解锁" class="headerlink" title="手动锁定和解锁"></a>手动锁定和解锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_lock</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_unlock</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意:如果创建 bufferevent 时没有指定 BEV_OPT_THREADSAFE 标志,或者没有激活 libevent 的线程支持，则锁定操作是没有效果的.用这个函数锁定 bufferevent 将自动同时锁定相关联的 evbuffer.这些函数是递归的:锁定已经持有锁的 bufferevent 是安全的.当然,对于每次锁定都必须进行一次解锁.</p>
<h1 id="http服务相关"><a href="#http服务相关" class="headerlink" title="http服务相关"></a>http服务相关</h1><h2 id="http-Server的创建与开始"><a href="#http-Server的创建与开始" class="headerlink" title="http Server的创建与开始"></a>http Server的创建与开始</h2><p>首先需要使用event_base_new或event_base_new_with_config创建一个event_base，然后使用evhttp_new创建evhttp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evhttp *<span class="title">evhttp_new</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在需要释放evhttp时需要调用evhttp_free来释放。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evhttp_free</span><span class="params">(struct evhttp* http)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>再为evhttp设置回调函数，evhttp_set_cb为特定URL指定回调函数，evhttp_set_gencb注册通用回调函数，在没有指定URL回调函数的情况下该回调函数被调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uri 特定的uri</span></span><br><span class="line"><span class="comment">//cb 回调函数</span></span><br><span class="line"><span class="comment">//cbarg 传入回调函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evhttp_set_cb</span><span class="params">(struct evhttp *http, <span class="keyword">const</span> <span class="keyword">char</span> *uri, \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*cb)(struct evhttp_request *, <span class="keyword">void</span> *), <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cb 回调函数</span></span><br><span class="line"><span class="comment">//cbarg 传入回调函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evhttp_set_gencb</span><span class="params">(struct evhttp *http,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*cb)(struct evhttp_request *, <span class="keyword">void</span> *), <span class="keyword">void</span> *cbarg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>再为evhttp绑定需要监听的ip和port。使用evhttp_bind_socket_with_handle函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evhttp_bound_socket *<span class="title">evhttp_bind_socket_with_handle</span><span class="params">(struct evhttp *http, <span class="keyword">const</span> <span class="keyword">char</span> *address, <span class="keyword">ev_uint16_t</span> port)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以使用libevent提供的相关函数打印监听端口信息。<br>最后使用event_base_dispatch进入事件循环。</p>
<h2 id="http请求的处理"><a href="#http请求的处理" class="headerlink" title="http请求的处理"></a>http请求的处理</h2><p>evhttp_request_get_uri得到当前请求的uri地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">evhttp_request_get_uri</span><span class="params">(<span class="keyword">const</span> struct evhttp_request *req)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>evhttp_request_get_command得到当前请求的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> evhttp_cmd_type &#123;</span><br><span class="line">	EVHTTP_REQ_GET     = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	EVHTTP_REQ_POST    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	EVHTTP_REQ_HEAD    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	EVHTTP_REQ_PUT     = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">	EVHTTP_REQ_DELETE  = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">	EVHTTP_REQ_OPTIONS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">	EVHTTP_REQ_TRACE   = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">	EVHTTP_REQ_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">	EVHTTP_REQ_PATCH   = <span class="number">1</span> &lt;&lt; <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">enum</span> evhttp_cmd_type <span class="title">evhttp_request_get_command</span><span class="params">(<span class="keyword">const</span> struct evhttp_request *req)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>evhttp_uri_parse URI解析，得到evhttp_uri。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evhttp_uri *<span class="title">evhttp_uri_parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source_uri)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>evhttp_parse_query对uri参数进行解析，结果保存在struct evkeyvalq结构体中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evhttp_parse_query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *uri, struct evkeyvalq *args)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>evhttp<em>decode_uri URL解码，得到UTF编码的字符，得到数据所占内存需要自己释放。<br>evhttp_encode_uri URL编码，对所有非alphanumeric及-\</em>的字符都被类似于%和一个2位16进制字符替换(其中空格被+号替换)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evhttp_encode_uri</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evhttp_decode_uri</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *uri)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="http://blog.csdn.net/column/details/libevent-src.html" target="_blank" rel="noopener">libevent专栏</a></li>
<li><a href="http://blog.csdn.net/zhouyongku/article/details/53431597" target="_blank" rel="noopener">Libevent中文帮助手册</a></li>
<li><a href="https://segmentfault.com/a/1190000005594871" target="_blank" rel="noopener">Libevent 官方文档学习笔记</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
              <a href="/tags/网络/" rel="tag"># 网络</a>
              <a href="/tags/libevent/" rel="tag"># libevent</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/10/02/libevent-1/" rel="prev" title="Libevent源码阅读——概述、实践">
      <i class="fa fa-chevron-left"></i> Libevent源码阅读——概述、实践
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/10/19/vim-youcompleteme/" rel="next" title="vim的自动补全插件的安装YouCompleteMe">
      vim的自动补全插件的安装YouCompleteMe <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础API"><span class="nav-number">1.</span> <span class="nav-text">基础API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#日志打印回调设置API-event-set-log-callback"><span class="nav-number">1.1.</span> <span class="nav-text">日志打印回调设置API event_set_log_callback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#致命错误退出回调设置API-event-set-fatal-callback"><span class="nav-number">1.2.</span> <span class="nav-text">致命错误退出回调设置API event_set_fatal_callback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更换内存管理函数的API-event-set-mem-functions"><span class="nav-number">1.3.</span> <span class="nav-text">更换内存管理函数的API event_set_mem_functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放LibEvent全局结构体-libevent-global-shutdown"><span class="nav-number">1.4.</span> <span class="nav-text">释放LibEvent全局结构体 libevent_global_shutdown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#event-base创建"><span class="nav-number">2.</span> <span class="nav-text">event_base创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认的event-base"><span class="nav-number">2.1.</span> <span class="nav-text">默认的event_base</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂的event-base"><span class="nav-number">2.2.</span> <span class="nav-text">复杂的event_base</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#event-config-require-features"><span class="nav-number">2.2.1.</span> <span class="nav-text">event_config_require_features()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event-config-set-flag"><span class="nav-number">2.2.2.</span> <span class="nav-text">event_config_set_flag()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获得特定event-base的配置信息"><span class="nav-number">2.2.3.</span> <span class="nav-text">获得特定event_base的配置信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行循环"><span class="nav-number">3.</span> <span class="nav-text">运行循环</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#停止循环"><span class="nav-number">4.</span> <span class="nav-text">停止循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#event-base-loopexit"><span class="nav-number">4.1.</span> <span class="nav-text">event_base_loopexit()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#event-base-loopbreak"><span class="nav-number">4.2.</span> <span class="nav-text">event_base_loopbreak()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#event-base-got-break-和-event-base-got-exit"><span class="nav-number">4.3.</span> <span class="nav-text">event_base_got_break() 和 event_base_got_exit()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#event"><span class="nav-number">5.</span> <span class="nav-text">event</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#event简介"><span class="nav-number">5.1.</span> <span class="nav-text">event简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#event-API-介绍"><span class="nav-number">5.2.</span> <span class="nav-text">event API 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#event创建-event-new"><span class="nav-number">5.2.1.</span> <span class="nav-text">event创建 event_new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EV-PERSIST-事件持久化"><span class="nav-number">5.2.2.</span> <span class="nav-text">EV_PERSIST 事件持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超时事件的创建"><span class="nav-number">5.2.3.</span> <span class="nav-text">超时事件的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号事件的创建"><span class="nav-number">5.2.4.</span> <span class="nav-text">信号事件的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件的初始化"><span class="nav-number">5.2.5.</span> <span class="nav-text">事件的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event添加监听与取消监听"><span class="nav-number">5.2.6.</span> <span class="nav-text">event添加监听与取消监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event设置优先级"><span class="nav-number">5.2.7.</span> <span class="nav-text">event设置优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event状态检测"><span class="nav-number">5.2.8.</span> <span class="nav-text">event状态检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#event-pending"><span class="nav-number">5.2.8.1.</span> <span class="nav-text">event_pending</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-fd"><span class="nav-number">5.2.8.2.</span> <span class="nav-text">event_get_fd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-base"><span class="nav-number">5.2.8.3.</span> <span class="nav-text">event_get_base</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-events"><span class="nav-number">5.2.8.4.</span> <span class="nav-text">event_get_events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-callback-和-event-get-callback-arg"><span class="nav-number">5.2.8.5.</span> <span class="nav-text">event_get_callback 和 event_get_callback_arg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-priority"><span class="nav-number">5.2.8.6.</span> <span class="nav-text">event_get_priority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-get-assignment"><span class="nav-number">5.2.8.7.</span> <span class="nav-text">event_get_assignment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手动激活事件"><span class="nav-number">5.3.</span> <span class="nav-text">手动激活事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#evbuffer"><span class="nav-number">6.</span> <span class="nav-text">evbuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建和释放evbuffer"><span class="nav-number">6.1.</span> <span class="nav-text">创建和释放evbuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#evbuffer与线程安全"><span class="nav-number">6.2.</span> <span class="nav-text">evbuffer与线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查evbuffer"><span class="nav-number">6.3.</span> <span class="nav-text">检查evbuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向evbuffer添加数据"><span class="nav-number">6.4.</span> <span class="nav-text">向evbuffer添加数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将数据从一个evbuffer移动到另一个"><span class="nav-number">6.5.</span> <span class="nav-text">将数据从一个evbuffer移动到另一个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加数据到evbuffer前面"><span class="nav-number">6.6.</span> <span class="nav-text">添加数据到evbuffer前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从evbuffer中移除数据"><span class="nav-number">6.7.</span> <span class="nav-text">从evbuffer中移除数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从evbuffer中复制出数据"><span class="nav-number">6.8.</span> <span class="nav-text">从evbuffer中复制出数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向行的输入"><span class="nav-number">6.9.</span> <span class="nav-text">面向行的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在evbuffer中搜索"><span class="nav-number">6.10.</span> <span class="nav-text">在evbuffer中搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测数据而不复制"><span class="nav-number">6.11.</span> <span class="nav-text">检测数据而不复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接向evbuffer添加数据"><span class="nav-number">6.12.</span> <span class="nav-text">直接向evbuffer添加数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用evbuffer的网络IO"><span class="nav-number">6.13.</span> <span class="nav-text">使用evbuffer的网络IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#evbuffer和回调"><span class="nav-number">6.14.</span> <span class="nav-text">evbuffer和回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为基于evbuffer的IO避免数据复制"><span class="nav-number">6.15.</span> <span class="nav-text">为基于evbuffer的IO避免数据复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接受TCP连接"><span class="nav-number">7.</span> <span class="nav-text">接受TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建和释放evconnlistener"><span class="nav-number">7.1.</span> <span class="nav-text">创建和释放evconnlistener</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#禁用和启用evconnlistener"><span class="nav-number">7.2.</span> <span class="nav-text">禁用和启用evconnlistener</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置evconnlistener的回调函数"><span class="nav-number">7.3.</span> <span class="nav-text">设置evconnlistener的回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测evconnlistener"><span class="nav-number">7.4.</span> <span class="nav-text">检测evconnlistener</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#侦测错误"><span class="nav-number">7.5.</span> <span class="nav-text">侦测错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bufferevent"><span class="nav-number">8.</span> <span class="nav-text">bufferevent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bufferevent-和-evbuffer"><span class="nav-number">8.1.</span> <span class="nav-text">bufferevent 和 evbuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回调和水位"><span class="nav-number">8.2.</span> <span class="nav-text">回调和水位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟回调"><span class="nav-number">8.3.</span> <span class="nav-text">延迟回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buffervent的选项标记bufferevent-options"><span class="nav-number">8.4.</span> <span class="nav-text">buffervent的选项标记bufferevent_options</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于套接字的bufferevent"><span class="nav-number">8.5.</span> <span class="nav-text">基于套接字的bufferevent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建基于套接字的bufferevent"><span class="nav-number">8.6.</span> <span class="nav-text">创建基于套接字的bufferevent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在基于套接字的bufferevent上启动连接"><span class="nav-number">8.7.</span> <span class="nav-text">在基于套接字的bufferevent上启动连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过主机名启动连接"><span class="nav-number">8.8.</span> <span class="nav-text">通过主机名启动连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作回调、水位和启用-禁用"><span class="nav-number">8.9.</span> <span class="nav-text">操作回调、水位和启用/禁用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bufferevent中数据的操作"><span class="nav-number">8.10.</span> <span class="nav-text">bufferevent中数据的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写超时"><span class="nav-number">8.11.</span> <span class="nav-text">读写超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清空bufferevent"><span class="nav-number">8.12.</span> <span class="nav-text">清空bufferevent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型特定的bufferevent函数"><span class="nav-number">8.13.</span> <span class="nav-text">类型特定的bufferevent函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手动锁定和解锁"><span class="nav-number">8.14.</span> <span class="nav-text">手动锁定和解锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http服务相关"><span class="nav-number">9.</span> <span class="nav-text">http服务相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http-Server的创建与开始"><span class="nav-number">9.1.</span> <span class="nav-text">http Server的创建与开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http请求的处理"><span class="nav-number">9.2.</span> <span class="nav-text">http请求的处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">10.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CaseZheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CaseZheng</p>
  <div class="site-description" itemprop="description">CaseZheng的博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CaseZheng" title="GitHub → https://github.com/CaseZheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:764307915@qq.com" title="E-Mail → mailto:764307915@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CaseZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">717k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
