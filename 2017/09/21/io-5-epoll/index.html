<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F14AAB2D4C842CB9F200D0A80DA8CB2F">
  <meta name="baidu-site-verification" content="GNlbaIvRtqlfiBfg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.casezheng.date","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Linux I/O epoll 源码分析 目录  epoll epoll_create epoll_ctl epoll中的递归死循环和深度检查 循环检测 唤醒风暴 epoll_create和epoll_ctl函数调用过程 epoll_wait函数调用主要过程 epoll结构体间关系     epollepoll的简单原理  执行epoll_create时，创建了红黑树和就绪list链表。 执行ep">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux I&#x2F;O 复用 epoll源码解析">
<meta property="og:url" content="http://www.casezheng.date/2017/09/21/io-5-epoll/index.html">
<meta property="og:site_name" content="CaseZheng">
<meta property="og:description" content="Linux I/O epoll 源码分析 目录  epoll epoll_create epoll_ctl epoll中的递归死循环和深度检查 循环检测 唤醒风暴 epoll_create和epoll_ctl函数调用过程 epoll_wait函数调用主要过程 epoll结构体间关系     epollepoll的简单原理  执行epoll_create时，创建了红黑树和就绪list链表。 执行ep">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.casezheng.date/Picture/epoll_create和epoll_ctl函数调用过程.png">
<meta property="og:image" content="http://www.casezheng.date/Picture/epoll_wait函数调用主要过程.png">
<meta property="og:image" content="http://www.casezheng.date/Picture/epoll结构体间关系.png">
<meta property="og:updated_time" content="2020-04-12T04:56:36.123Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux I&#x2F;O 复用 epoll源码解析">
<meta name="twitter:description" content="Linux I/O epoll 源码分析 目录  epoll epoll_create epoll_ctl epoll中的递归死循环和深度检查 循环检测 唤醒风暴 epoll_create和epoll_ctl函数调用过程 epoll_wait函数调用主要过程 epoll结构体间关系     epollepoll的简单原理  执行epoll_create时，创建了红黑树和就绪list链表。 执行ep">
<meta name="twitter:image" content="http://www.casezheng.date/Picture/epoll_create和epoll_ctl函数调用过程.png">

<link rel="canonical" href="http://www.casezheng.date/2017/09/21/io-5-epoll/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux I/O 复用 epoll源码解析 | CaseZheng</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4f1686055a927fa7bf1a09bc1143b57c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CaseZheng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CaseZheng Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.casezheng.date/2017/09/21/io-5-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CaseZheng">
      <meta itemprop="description" content="CaseZheng的博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaseZheng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux I/O 复用 epoll源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-21 11:51:00" itemprop="dateCreated datePublished" datetime="2017-09-21T11:51:00+08:00">2017-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 12:56:36" itemprop="dateModified" datetime="2020-04-12T12:56:36+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Linux I/O epoll 源码分析</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll_create">epoll_create</a></li>
<li><a href="#epoll_ctl">epoll_ctl</a></li>
<li><a href="#epoll中的递归死循环和深度检查">epoll中的递归死循环和深度检查</a></li>
<li><a href="#循环检测">循环检测</a></li>
<li><a href="#唤醒风暴">唤醒风暴</a></li>
<li><a href="#epoll_create和epoll_ctl函数调用过程">epoll_create和epoll_ctl函数调用过程</a></li>
<li><a href="#epoll_wait函数调用主要过程">epoll_wait函数调用主要过程</a></li>
<li><a href="#epoll结构体间关系">epoll结构体间关系</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll的简单原理</p>
<ol>
<li>执行epoll_create时，创建了红黑树和就绪list链表。</li>
<li>执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。</li>
<li>执行epoll_wait时立刻返回准备就绪链表里的数据即可。</li>
</ol>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>epoll_create主要做两件事</p>
<ol>
<li>创建并初始化一个eventpoll结构体变量</li>
<li>创建epoll的file结构，并指定file的private_data指针指向刚创建的eventpoll变量，这样，只要根据epoll文件描述符epfd就可以拿到file进而就拿到了eventpoll变量了，该eventpoll就是epoll_ctl和epoll_wait工作的场所</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll文件系统的相关实现</span></span><br><span class="line"><span class="comment">//epoll文件系统初始化，在系统启动时会调用  .init段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">eventpoll_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">si</span>;</span></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    <span class="comment">//限制可添加到epoll的最多的描述符数量</span></span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / <span class="number">25</span>) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    <span class="comment">//检查递归检查队列</span></span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);</span><br><span class="line">    ep_nested_calls_init(&amp;poll_readywalk_ncalls);</span><br><span class="line">    <span class="comment">//在内核创建内存池</span></span><br><span class="line">    <span class="comment">//epoll用kmem_cache_create（slab分配器）分别用来分配epitem和eppoll_entry</span></span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, <span class="keyword">sizeof</span>(struct epitem),</span><br><span class="line">            <span class="number">0</span>, SLAB_HWCACHE_ALIGN | SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct eppoll_entry), <span class="number">0</span>, SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    error = ep_alloc(&amp;ep);        <span class="comment">//为ep在堆上申请空间并初始化    eventpoll</span></span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));<span class="comment">//会调用alloc_fd()分配文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建与eventpoll结构体相对应的file结构体，匿名文件，ep保存在file-&gt;private_data结构体中</span></span><br><span class="line">    <span class="comment">//static const struct file_operations eventpoll_fops = &#123;</span></span><br><span class="line">    <span class="comment">//    .release    = ep_eventpoll_release,</span></span><br><span class="line">    <span class="comment">//    .poll        = ep_eventpoll_poll</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立文件描述符和file之间的联系</span></span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);        <span class="comment">//释放ep  eventpoll</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epfd    epoll内核事件表的文件描述符</span></span><br><span class="line"><span class="comment">//op        要进行的操作类型</span></span><br><span class="line"><span class="comment">//fd        要监测的文件描述符</span></span><br><span class="line"><span class="comment">//event    要监测的事件</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> did_lock_epmutex = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="comment">//判断参数的合法性，将event从用户空间复制到内核空间</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);    <span class="comment">//根据文件描述符得到相应的文件对象，内核事件表</span></span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    tfile = fget(fd);        <span class="comment">//要监测的文件</span></span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">        error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)    <span class="comment">//要监测文件设备poll方法的检查</span></span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    ep = file-&gt;private_data;            <span class="comment">//获取epoll对应的eventpoll结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) &#123;</span><br><span class="line">        mutex_lock(&amp;epmutex);</span><br><span class="line">        did_lock_epmutex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(tfile)) &#123;</span><br><span class="line">            error = -ELOOP;</span><br><span class="line">            <span class="keyword">if</span> (ep_loop_check(ep, tfile) != <span class="number">0</span>) &#123;        <span class="comment">//循环检测</span></span><br><span class="line">                clear_tfile_check_list();</span><br><span class="line">                <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            list_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);        <span class="comment">//互斥锁加锁</span></span><br><span class="line">    <span class="comment">//防止重复添加（在ep的红黑树中查找是否存在这个fd），存在返回epitem，不存在返回NULL</span></span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;            <span class="comment">//不同的操作</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;    <span class="comment">//红黑树上不存在这个节点</span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;    <span class="comment">//确保“出错，连接挂起”被当作感兴趣的事件</span></span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);    <span class="comment">//添加</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        clear_tfile_check_list();        <span class="comment">//清空需要监测的文件的检查列表</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)    <span class="comment">//红黑树上存在这个节点</span></span><br><span class="line">            error = ep_remove(ep, epi);        <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);        <span class="comment">//互斥锁，解锁</span></span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">    <span class="keyword">if</span> (did_lock_epmutex)</span><br><span class="line">        mutex_unlock(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">    fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct file *tfile, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">    <span class="comment">//struct ep_pqueue &#123;        poll_table pt;        struct epitem *epi;        &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_read(&amp;ep-&gt;user-&gt;epoll_watches) &gt;=</span><br><span class="line">             max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    <span class="comment">//初始化分配epi     epitem</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epi初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);        <span class="comment">//就绪的事件链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);        <span class="comment">//连接被监听的文件</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);        <span class="comment">//poll等待队列</span></span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化的epq</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">//epq.pt-&gt;qproc = ep_ptable_queue_proc    回调函数的设置</span></span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部会调用ep_ptable_queue_proc, 在文件对应的wait queue head 上注册回调函数</span></span><br><span class="line">    <span class="comment">//并返回当前文件的状态 </span></span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)        <span class="comment">//f_op-&gt;poll过程出错</span></span><br><span class="line">        <span class="keyword">goto</span> error_unregister;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//添加当前的epitem到要监测文件的tfile-&gt;f_ep_links链表</span></span><br><span class="line">    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//插入epi到红黑树</span></span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (reverse_path_check())                <span class="comment">//唤醒风暴检查</span></span><br><span class="line">        <span class="keyword">goto</span> error_remove_epi;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//文件已经就绪，插入到epitem的就绪链表rdllist</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">    <span class="comment">//通知epoll_wait,调用回调函数唤醒epoll_wait上的进程</span></span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))        <span class="comment">//先不通知调用eventpoll_poll的进程</span></span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    atomic_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);        <span class="comment">//安全通知调用eventpoll_poll的进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_remove_epi:</span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//删除文件上的epi</span></span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;fllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">//从红黑树中删除</span></span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">error_unregister:</span><br><span class="line">    <span class="comment">//从文件的wait_queue中删除，释放epitem关联的所有epoll_entry</span></span><br><span class="line">    ep_unregister_pollwait(ep, epi);</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//释放epi</span></span><br><span class="line">    kmem_cache_free(epi_cache, epi);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt)   -&gt;   poll_wait()    -&gt;   ep_ptable_queue_proc()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">                 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        <span class="comment">//pwq初始化，pwq-&gt;wait.func = ep_poll_callback;    //唤醒回调函数</span></span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;    <span class="comment">//监测文件的等待队列头</span></span><br><span class="line">        pwq-&gt;base = epi;        <span class="comment">//指向epitem</span></span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);        <span class="comment">//将等待队列项，加入到等待队列中去</span></span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);    <span class="comment">//将等待队列项保存到epi-&gt;pwqlist链表中</span></span><br><span class="line">        epi-&gt;nwait++;            <span class="comment">//poll操作中事件的个数加1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;        <span class="comment">//标识调用出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_remove</span><span class="params">(struct eventpoll *ep, struct epitem *epi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">epi</span>-&gt;<span class="title">ffd</span>.<span class="title">file</span>;</span>        <span class="comment">//获得要删除文件描述符的文件结构</span></span><br><span class="line"></span><br><span class="line">    ep_unregister_pollwait(ep, epi);    <span class="comment">//删除被监听文件的等待队列项</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;file-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;fllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);    <span class="comment">//从epitem.fllink中删除</span></span><br><span class="line">    spin_unlock(&amp;file-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);    <span class="comment">//从红黑树中删除</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);    <span class="comment">//从epitem.rdllink中删除（就绪队列）</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    kmem_cache_free(epi_cache, epi);        <span class="comment">//释放空间</span></span><br><span class="line"></span><br><span class="line">    atomic_dec(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_modify</span><span class="params">(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line"></span><br><span class="line">    epi-&gt;event.events = event-&gt;events;</span><br><span class="line">    epi-&gt;event.data = event-&gt;data;</span><br><span class="line"></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>);    <span class="comment">//获得事件掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents &amp; event-&gt;events) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">            <span class="comment">//将已就绪的等待队列项，加入到ep-&gt;rdllist链表</span></span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">                wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">                pwake++;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">        <span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="comment">//检查输入数据有效性</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    ep = file-&gt;private_data;        <span class="comment">//获得eventpoll结构</span></span><br><span class="line"></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res, eavail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> jtimeout;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line">    <span class="comment">//timeout &lt; 0 或者timeout &gt;=  EP_MAX_MSTIMEO</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;        <span class="comment">//事件就绪队列为空</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);    <span class="comment">//对当前进程设置等待项</span></span><br><span class="line">        <span class="comment">//static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    q-&gt;flags = 0;</span></span><br><span class="line">        <span class="comment">//    q-&gt;private = p;</span></span><br><span class="line">        <span class="comment">//    q-&gt;func = default_wake_function;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;    <span class="comment">//标记等待的进程是互斥进程</span></span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);    <span class="comment">//加入ep_wait()等待队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//进程状态的设置，TASK_INTERRUPTIBLE表示进程可以被信号和wake_up()唤醒</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">//就绪队列为不空  或者  睡眠时间为0</span></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;        <span class="comment">//收到信号</span></span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">//进入睡眠等待ep_poll_callback()将当前进程唤醒或超时，返回值是剩余的时间。</span></span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125; <span class="comment">//end for( ; ; )</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);    <span class="comment">//将等待队列项从ep_wait()等待队列中移除</span></span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);        <span class="comment">//表示TASK_RUNNING运行或就绪状态</span></span><br><span class="line">    &#125;  <span class="comment">//end if</span></span><br><span class="line">    <span class="comment">//ep-&gt;rdllist不空    或者  ep-&gt;ovflist不空   eavail为true</span></span><br><span class="line">    eavail = ! list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//如果没有被信号中断，并且有事件就绪，但发送成功的文件描述符为0，并且没有超时</span></span><br><span class="line">    <span class="comment">//则跳转到retry标签处，重新等待文件状态就绪</span></span><br><span class="line">    <span class="keyword">if</span> ( !res &amp;&amp; eavail &amp;&amp;  !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    <span class="keyword">return</span> res;    <span class="comment">//返回获取的事件的个数或者错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送结果到用户空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line">    esed.maxevents = maxevents;        <span class="comment">//需要检测的文件描述符个数</span></span><br><span class="line">    esed.events = events;</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *, struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//将ep-&gt;rdllist链表添加到txlist链表中去，使ep-&gt;rdllist链表为空</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">//标记ep_scan_ready_list()准备向用户空间传递事件，当有唤醒函数ep_poll_callback()调用时</span></span><br><span class="line">    <span class="comment">//将就绪的文件描述符的epitem实例加入到ovflist链表中。</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);        <span class="comment">//ep_send_events_proc</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//在执行上面代码期间，又有可能有就绪事件，这样就进入ep-&gt;ovflist队列，</span></span><br><span class="line">    <span class="comment">//将ovflist链表中的就绪文件描述符加入到rdllist    #define EP_UNACTIVE_PTR ((void *) -1L)</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist;   (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">//如果epi-&gt;rdllink为空，将epi加入到ep-&gt;rdllist中</span></span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))        <span class="comment">//list_empty(&amp;epi-&gt;rdllink)</span></span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;        <span class="comment">//标记向用户空间传递事件结束</span></span><br><span class="line"></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);        <span class="comment">//如果txlist不为空，将txlist链表加入到rdllist链表中</span></span><br><span class="line">    <span class="keyword">if</span> ( ! list_empty(&amp;ep-&gt;rdllist)) &#123;        <span class="comment">//如果文件描述符就绪链表ep-&gt;rdllist不为空</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//如果ep-&gt;wq不空，唤醒ep-&gt;wq上的进程</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;                    <span class="comment">//如果ep-&gt;poll_wait不空</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);    <span class="comment">//通知调用了poll的进程</span></span><br><span class="line">    <span class="keyword">return</span> error;        <span class="comment">//返回发送的就绪的文件描述符个数或错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head, <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> eventcnt;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;  ) &#123;</span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);        <span class="comment">//得到epitem结构体</span></span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);        <span class="comment">//从就绪链表中删除该epitem</span></span><br><span class="line"><span class="comment">//立即返回当前文件的就绪事件</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line"><span class="comment">//将就绪事件的poll_event发送至用户空间</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);        <span class="comment">//发送失败，将epi重新加入head</span></span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line"><span class="comment">//#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET)</span></span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)  <span class="comment">//如果文件描述符检测EPOLLONESHOT</span></span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line"><span class="comment">//未设置为ET(非边缘触发)模式，就将epi-&gt;rdllink加入到ep-&gt;rdllist链表中</span></span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    <span class="comment">//end if revents</span></span><br><span class="line">    &#125;    <span class="comment">//end for</span></span><br><span class="line">    <span class="keyword">return</span> eventcnt;    <span class="comment">//返回发送的就绪的文件描述符个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ep_poll_callback唤醒回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span>    <span class="comment">//得到epitem</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span>                <span class="comment">//得到eventpoll</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; POLLFREE) &#123;            <span class="comment">//有错误发生</span></span><br><span class="line">        ep_pwq_from_wait(wait)-&gt;whead = <span class="literal">NULL</span>;    <span class="comment">//等待队列头置为NULL</span></span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);        <span class="comment">//从等待队列中删除等待队列项</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET)</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))<span class="comment">//有非EPOLLONESHOT | EPOLLET不懂！！！</span></span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>) key &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;                        <span class="comment">//没有事件发生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ep-&gt;ovflist != EP_UNACTIVE_PTR成立时，ep_scan_ready_list()正在向用户空间传递事件。</span></span><br><span class="line">    <span class="comment">//如果当前进程正在向用户空间传递事件，则将当前的事件对应的epitem实例加入到ovflist链表中。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="comment">//如果epi-&gt;next不等于EP_UNACTIVE_PTR，</span></span><br><span class="line">        <span class="comment">//则说明已经添加到ovflist链表中，就不用再添加了</span></span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;            <span class="comment">//把epi放到ovflist链表中</span></span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist); <span class="comment">//把epitem放到strcut eventpoll的rdllist中去</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//唤醒调用epoll_wait()函数时睡眠的进程</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于epoll自身也是文件系统，其描述符也可以被poll/select/epoll监视，因此需要实现poll方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ep_eventpoll_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pollflags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">//把等待队列项插入到ep-&gt;poll_wait</span></span><br><span class="line">    poll_wait(file, &amp;ep-&gt;poll_wait, wait);</span><br><span class="line">    <span class="comment">//扫描就绪的文件列表，调用每个文件上的poll检查是否真的就绪，然后复制到用户空间，</span></span><br><span class="line">    <span class="comment">//文件列表中有可能有epoll文件，调用poll的时候有可能产生递归，</span></span><br><span class="line">    <span class="comment">//调用所以用ep_call_nested包装一下，防止死循环和过深的调用</span></span><br><span class="line">    pollflags = ep_call_nested(&amp;poll_readywalk_ncalls, EP_MAX_NESTS,</span><br><span class="line">                   ep_poll_readyevents_proc, ep, ep, current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pollflags != <span class="number">-1</span> ? pollflags : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_readyevents_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(priv, ep_read_events_proc, <span class="literal">NULL</span>, call_nests + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//移动ep-&gt;rdllist到新的链表txlist</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;        <span class="comment">//改变ovflist的状态</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);        <span class="comment">//ep_read_events_proc</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//调用ep_read_events_proc时可能出现了新的事件，遍历这些新的事件将其插入到rdllink</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">//epi不在rdllink,插入</span></span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;        <span class="comment">//还原ep-&gt;ovflist的状态</span></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);        <span class="comment">//将处理后的txlist链接到rdllist</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);        <span class="comment">//唤醒epoll_wait</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);    <span class="comment">//安全唤醒外部的事件通知机制</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_read_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events)</span><br><span class="line"><span class="comment">//只要有一个文件描述符就绪返回可读 或 普通数据可写</span></span><br><span class="line">            <span class="keyword">return</span> POLLIN | POLLRDNORM;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//文件描述符未就绪，但在就绪队列中，将其移除</span></span><br><span class="line">            list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_poll_safewake</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> this_cpu = get_cpu();</span><br><span class="line"></span><br><span class="line">    ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS,</span><br><span class="line">               ep_poll_wakeup_proc, <span class="literal">NULL</span>, wq, (<span class="keyword">void</span> *) (<span class="keyword">long</span>) this_cpu);</span><br><span class="line"></span><br><span class="line">    put_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_wakeup_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ep_wake_up_nested((<span class="keyword">wait_queue_head_t</span> *) cookie, POLLIN,</span><br><span class="line">              <span class="number">1</span> + call_nests);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ep_wake_up_nested</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wqueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> events, <span class="keyword">int</span> subclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//唤醒所有正在等待此epfd的select/epoll/poll等</span></span><br><span class="line"><span class="comment">//如果唤醒的是epoll就可能唤醒所有其他的epoll，产生连锁反应</span></span><br><span class="line">    wake_up_poll(wqueue, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll中的递归死循环和深度检查"><a href="#epoll中的递归死循环和深度检查" class="headerlink" title="epoll中的递归死循环和深度检查"></a>epoll中的递归死循环和深度检查</h2><p>如果epoll之间相互监视就有可能导致死循环。epoll的实现中，所有可能产生递归调用的函数都由函函数ep_call_nested进行包裹，递归调用过程中出现死循环或递归过深就会打破死循环和递归调用直接返回。该函数的实现依赖于一个外部的全局链表nested_call_node(不同的函数调用使用不同的节点)，每次调用可能发生递归的函数(nproc)就向链表中添加一个包含当前函数调用上下文ctx(进程，CPU，或epoll文件)和处理的对象标识cookie的节点，通过检测是否有相同的节点就可以知道是否发生了死循环，检查链表中同一上下文包含的节点个数就可以知道递归的深度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制epoll中直接或间接递归调用的深度并防止死循环</span></span><br><span class="line"><span class="comment">//ctx:任务运行上下文（进程，CPU等）</span></span><br><span class="line"><span class="comment">//cokie:每个任务的标识</span></span><br><span class="line"><span class="comment">//priv:任务运行需要的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_call_nested</span><span class="params">(struct nested_calls *ncalls, <span class="keyword">int</span> max_nests,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (*nproc)(<span class="keyword">void</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>), <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *cookie, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, call_nests = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lsthead</span> = &amp;<span class="title">ncalls</span>-&gt;<span class="title">tasks_call_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> *<span class="title">tncur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> <span class="title">tnode</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//检查原有的嵌套调用链表ncalls，查看是否有深度超过限制的情况</span></span><br><span class="line">    list_for_each_entry(tncur, lsthead, llink) &#123;</span><br><span class="line">        <span class="comment">//同一上下文（ctx）中有相同的任务（cookie）说明产生了死循环</span></span><br><span class="line">        <span class="comment">//同一上下文的递归深度call_nests超过限制</span></span><br><span class="line">        <span class="keyword">if</span> (tncur-&gt;ctx == ctx &amp;&amp;</span><br><span class="line">            (tncur-&gt;cookie == cookie || ++call_nests &gt; max_nests)) &#123;</span><br><span class="line">            error = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的任务请求添加到调用列表</span></span><br><span class="line">    tnode.ctx = ctx;</span><br><span class="line">    tnode.cookie = cookie;</span><br><span class="line">    list_add(&amp;tnode.llink, lsthead);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//nproc 可能会导致递归调用(直接或间接)ep_call_nested ，如果发生递归调用, 那么在此函数返回之前, ncalls 又会被加入额外的节点, 这样通过前面的检测就可以知道递归调用的深度 </span></span><br><span class="line">    error = (*nproc)(priv, cookie, call_nests);</span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);</span><br><span class="line">    <span class="comment">//从链表中删除当前任务</span></span><br><span class="line">    list_del(&amp;tnode.llink);</span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环检测"><a href="#循环检测" class="headerlink" title="循环检测"></a>循环检测</h2><p>循环检查(ep_loop_check)，该函数递归调用ep_loop_check_proc利用ep_call_nested来实现epoll之间相互监视的死循环。因为ep_call_nested中已经对死循环和过深的递归做了检查，实际的ep_loop_check_proc的实现只是递归调用自己。其中的visited_list和visited标记完全是为了优化处理速度，如果没有visited_list和visited标记函数也是能够工作的。该函数中得上下文就是当前的进程，cookie就是正在遍历的epoll结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_loop_check</span><span class="params">(struct eventpoll *ep, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep_cur</span>, *<span class="title">ep_next</span>;</span></span><br><span class="line"></span><br><span class="line">    ret = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                  ep_loop_check_proc, file, ep, current);</span><br><span class="line"><span class="comment">//清除链表和标志</span></span><br><span class="line">    list_for_each_entry_safe(ep_cur, ep_next, &amp;visited_list,</span><br><span class="line">                            visited_list_link) &#123;</span><br><span class="line">        ep_cur-&gt;visited = <span class="number">0</span>;</span><br><span class="line">        list_del(&amp;ep_cur-&gt;visited_list_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_loop_check_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep_tovisit</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, call_nests + <span class="number">1</span>);</span><br><span class="line">    ep-&gt;visited = <span class="number">1</span>;    <span class="comment">//标志当前为已遍历</span></span><br><span class="line">    list_add(&amp;ep-&gt;visited_list_link, &amp;visited_list);</span><br><span class="line">    <span class="comment">//遍历所有ep监视的文件</span></span><br><span class="line">    <span class="keyword">for</span> (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) &#123;</span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(is_file_epoll(epi-&gt;ffd.file))) &#123;</span><br><span class="line">            ep_tovisit = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">            <span class="keyword">if</span> (ep_tovisit-&gt;visited)    <span class="comment">//跳过先前已遍历的，避免循环检查</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//所有ep监视的未遍历的epoll</span></span><br><span class="line">            error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                    ep_loop_check_proc, epi-&gt;ffd.file,</span><br><span class="line">                    ep_tovisit, current);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//文件不在file-&gt;tfile_check_list中，添加</span></span><br><span class="line">            <span class="comment">//最外层的epoll需要检查epoll监视的文件</span></span><br><span class="line">            <span class="keyword">if</span> (list_empty(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink))</span><br><span class="line">                list_add(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink,</span><br><span class="line">                     &amp;tfile_check_list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="唤醒风暴"><a href="#唤醒风暴" class="headerlink" title="唤醒风暴"></a>唤醒风暴</h2><p>当文件状态发生改变时，会唤醒监听在其上的epoll文件，而这个epoll文件还可能唤醒其他的epoll文件，这种连续的唤醒就形成了一个唤醒路径，所有的唤醒路径就形成了一个有向图。如果文件对应的epoll唤醒有向图的节点过多，那么文件状态的改变就会唤醒所有的这些epoll(可能会唤醒很多进程，这样的开销是很大的)，而实际上一个文件经过少数epoll处理以后就可能从就绪转到未就绪，剩余的epoll虽然认为文件已就绪而实际上经过某些处理后已不可用。epoll的实现中考虑到了此问题，在每次添加新文件到epoll中时，就会首先检查是否会出现这样的唤醒风暴。<br>该函数的实现逻辑是这样的，递归调用reverse_path_check_proc遍历监听在当前文件上的epoll文件，在reverse_pach_check_proc中统计并检查不同路径深度上epoll的个数，从而避免产生唤醒风暴。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">current_file</span>;</span></span><br><span class="line">    <span class="comment">//遍历全局tfile_chack_list中的文件，第一级</span></span><br><span class="line">    list_for_each_entry(current_file, &amp;tfile_check_list, f_tfile_llink) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        path_count_init();</span><br><span class="line">        <span class="comment">//限制递归的深度，并检查每个深度上唤醒的epoll数量</span></span><br><span class="line">        error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,</span><br><span class="line">                    reverse_path_check_proc, current_file,</span><br><span class="line">                    current_file, current);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">child_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    list_for_each_entry(epi, &amp;file-&gt;f_ep_links, fllink) &#123;</span><br><span class="line">        <span class="comment">//遍历监视file的epoll</span></span><br><span class="line">        child_file = epi-&gt;ep-&gt;file;</span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(child_file)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list_empty(&amp;child_file-&gt;f_ep_links)) &#123;</span><br><span class="line">                <span class="comment">//没有其他的epoll监视当前的这个epoll，已经是叶子了</span></span><br><span class="line">                <span class="keyword">if</span> (path_count_inc(call_nests)) &#123;</span><br><span class="line">                    error = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历监视这个epoll文件的epoll，递归调用</span></span><br><span class="line">                error = ep_call_nested(&amp;poll_loop_ncalls,</span><br><span class="line">                            EP_MAX_NESTS,</span><br><span class="line">                            reverse_path_check_proc,</span><br><span class="line">                            child_file, child_file,</span><br><span class="line">                            current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">"reverse_path_check_proc: "</span></span><br><span class="line">                <span class="string">"file is not an ep!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_ARR_SIZE 5</span></span><br><span class="line"><span class="comment">//深度限制</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> path_limits[PATH_ARR_SIZE] = &#123; <span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算出来的深度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> path_count[PATH_ARR_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">path_count_inc</span><span class="params">(<span class="keyword">int</span> nests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nests == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (++path_count[nests] &gt; path_limits[nests])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path_count_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PATH_ARR_SIZE; i++)</span><br><span class="line">        path_count[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-create和epoll-ctl函数调用过程"><a href="#epoll-create和epoll-ctl函数调用过程" class="headerlink" title="epoll_create和epoll_ctl函数调用过程"></a>epoll_create和epoll_ctl函数调用过程</h2><p><img src="/Picture/epoll_create和epoll_ctl函数调用过程.png" alt></p>
<h2 id="epoll-wait函数调用主要过程"><a href="#epoll-wait函数调用主要过程" class="headerlink" title="epoll_wait函数调用主要过程"></a>epoll_wait函数调用主要过程</h2><p><img src="/Picture/epoll_wait函数调用主要过程.png" alt></p>
<h2 id="epoll结构体间关系"><a href="#epoll结构体间关系" class="headerlink" title="epoll结构体间关系"></a>epoll结构体间关系</h2><p><img src="/Picture/epoll结构体间关系.png" alt></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/09/21/io-4-poll/" rel="prev" title="Linux I/O 复用 poll源码解析">
      <i class="fa fa-chevron-left"></i> Linux I/O 复用 poll源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/09/23/command-line-arguments/" rel="next" title="命令行参数的处理 gflags getopt getopt_long">
      命令行参数的处理 gflags getopt getopt_long <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#epoll"><span class="nav-number">2.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-create"><span class="nav-number">2.1.</span> <span class="nav-text">epoll_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">2.2.</span> <span class="nav-text">epoll_ctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll中的递归死循环和深度检查"><span class="nav-number">2.3.</span> <span class="nav-text">epoll中的递归死循环和深度检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环检测"><span class="nav-number">2.4.</span> <span class="nav-text">循环检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#唤醒风暴"><span class="nav-number">2.5.</span> <span class="nav-text">唤醒风暴</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-create和epoll-ctl函数调用过程"><span class="nav-number">2.6.</span> <span class="nav-text">epoll_create和epoll_ctl函数调用过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait函数调用主要过程"><span class="nav-number">2.7.</span> <span class="nav-text">epoll_wait函数调用主要过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll结构体间关系"><span class="nav-number">2.8.</span> <span class="nav-text">epoll结构体间关系</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CaseZheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CaseZheng</p>
  <div class="site-description" itemprop="description">CaseZheng的博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CaseZheng" title="GitHub → https://github.com/CaseZheng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:764307915@qq.com" title="E-Mail → mailto:764307915@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CaseZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">717k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
